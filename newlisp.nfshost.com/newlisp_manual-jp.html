<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="js-jp">
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <meta name="author" content="Lutz Mueller"/>
   <meta name="keywords" content="newLISP Lisp SCHEME programming language 
   manual reference Artificial Intelligence AI NUEVATEC"/>
   <meta name="description" content="newLISP User Manual and Reference"/>
   <title>newLISP v.10.7.5 Manual and Reference</title>

<style type="text/css" media="screen">

.divider {
	margin-top: 2em; 
	margin-bottom: 1em;
	font-family: Times New Roman, Times, serif;
	color: #ffAA28;
	}

.title {
	font-family:Optima, Georgia, Times New Roman, Times, serif; 
	font-size: 500%;
	color: #404040;
	}

span.arw {
	color:#303030;
	font-size: 100%;
	font-weight: bold;
	}
	
span.err {
	color:#cc0000;
	}

span.function {
	font-family: Verdana, Lucida Sans, Helvetica,  sans-serif;
	color:#dd0000;
	}

span.gnu {
	font-family: Verdana, Lucida Sans, Helvetica,  sans-serif;
	color:#dd0000;
	}

h4	{
	font-family: Verdana, Lucida Sans, Helvetica,  sans-serif;
    color: #404040;
	}

b	{
	font-family: Verdana, Lucida Sans, Helvetica,  sans-serif;
    color: #606060;
	font-weight: 600;
	}


body, h1, h2, h3 {
	font-family: Helvetica, sans-serif;
	color: #404040;
	line-height: 120%;
 	}

h1, h2, h3 {
	font-family: Helvetica,  sans-serif;
	color: #101010;
	line-height: 120%;
    font-weight: 100;
 	}

p {
	font-family: Helvetica Neue, Verdana, Lucida Sans, sans-serif;
	color: #404040;
	line-height: 120%;
 	}

table {
	margin: 0px;
	margin-left: 10px;
	border-style: solid;
	border-color: #888888;
	border-width: 0px;
	padding: 0px;
	background: #f8ffff;
	font-size: 95%;
    }
    
th {
	border-style: solid;
	border-width: 1px;
	border-color: #888888;
	padding: 3px;
	background: #eeeeee;
    font-size: 100%;
    }
    
td {
	border-style: solid;
	border-width: 1px;
	border-color: #888888;
	padding: 3px;
	background: #f8ffff;
    font-size: 100%;
    }
    

pre {
	margin: 0px;
	margin-left: 10px;
	margin-right: 10px;
	border-style: dashed;
	border-width: 1px;
	border-color: #888888;
	padding: 4px;
    font-family: Andale Mono, "Bitstream Vera Sans Mono", Monaco, "Courier New";
    font-size: 90%;
	background: #f8ffff;
    }


tt {
	font-family: Andale Mono, "Bitstream Vera Sans Mono", Monaco, "Courier New";
	font-size: 100%;
	}

.license {
	margin: 30px;
	}
	
</style>

</head>
<body text="#000000" bgcolor="#FFFFFF" link="#376590" vlink="#551A8B" alink="#ffAA28">

<br/><br/><br/><br/><br/><br/><br/><br/><br/>


<center>
<span class="title">newLISP<font size='3'>&#174;</font></span>
</center>

<br/>

<center>
<b>For macOS, GNU Linux, Unix and Windows</b>
</center>

<center>
<h2>ユーザー マニュアルとリファレンス v.10.7.5<br />
<h2>User Manual and Reference v.10.7.5</h2>
</center>

<br/><br/><br/><br/>
<center>
<span style="line-height:80%;">
<font size='1'>
<br/>Copyright &copy; 2019 Lutz Mueller&nbsp;<a href="http://www.nuevatec.com">www.nuevatec.com</a>. 
All rights reserved.<br/>
Japanese translations copyright &copy; 2019 <a href=http://johu02.spaces.live.com/?_c11_BlogPart_Blo gPart=blogview&_c=BlogPart&partqs=cat%3dLISP>short story &#12414;&#12383;&#12399; &#26228;&#32789;&#38632;&#35501;&#12394;&#26085;&#12293;</a>
<br/><br/>
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License,<br/> Version 1.2 or any later version 
published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts,<br/> 
and no Back-Cover Texts. A copy of the license is included in the section entitled 
<a href="#GNUFDL">GNU Free Documentation License</a>.<br/>
The accompanying software is protected by the 
<a href="#GNUGPL">GNU General Public License</a> V.3, June 2007.<br/>
newLISP is a registered trademark of Lutz Mueller.

</font>
</span>
</center>
<br/><br/><br/>

<center><h1>Contents（目次）</h1></center>

<h3><a href="#users_manual">Users Manual（ユーザー マニュアル）</a></h3>

<ol>
<li><a href="#introduction">Introduction（イントロダクション）</a></li>
<li><a href="#deprecated">Deprecated functions and future changes（廃止される関数と将来の変更）</a></li>
<li><a href="#REPL">Interactive Lisp mode（インターラクティブ Lisp モード）</a></li>
<li><a href="#options">Command line options（コマンド ライン オプション）</a>
  <ul>
  <li><a href="#cmd_help">Command line help summary（コマンド ライン ヘルプ要約）</a></li>
  <li><a href="#url_files">Specifying files as URLs（URL としてのファイル指定）</a></li>
  <li><a href="#no_init">No loading of init.lsp（init.lsp のロード無し）</a></li>
  <li><a href="#stack_size">Stack size（スタック・サイズ）</a></li>
  <li><a href="#max_mem">Maximum memory usage（最大メモリ使用量）</a></li>
  <li><a href="#direct_exec">Direct execution mode（直接実行モード）</a></li>
  <li><a href="#logging">Logging I/O（I/O のログ出力化）</a></li>
  <li><a href="#working_dir">Specifying the working directory（作業ディレクトリの指定）</a></li>  <li><a href="#prompt">Suppressing the prompt and HTTP processing（プロンプトの抑制と HTTP 処理）</a></li>
  <li><a href="#forcing_prompt">Forcing prompts in pipe I/O mode（パイプ I/O モードでの強制プロンプト）</a></li>
  <li><a href="#tcpip_server">newLISP as a TCP/IP server（TCP/IP サーバーとして newLISP）</a></li>
  <li><a href="#daemon">TCP/IP daemon mode（TCP/IP デーモン モード）</a></li>

  <li><a href="#http_mode">HTTP only server mode（HTTP のみのサーバー モード）</a></li>
  <li><a href="#local_domain_server">Local domain Unix socket server（ローカル ドメイン Unix ソケット サーバー）</a></li>
  <li><a href="#conn_timeout">Connection timeout（接続のタイムアウト）</a></li>
  <li><a href="#inetd_daemon"><tt>inetd</tt> daemon mode（<tt>inetd</tt> デーモン モード）</a></li>
  <li><a href="#link">Linking a source file with newLISP for a new executable（newLISP 新実行部とソースとの統合）</a></li>
  </ul>
</li>

<li><a href="#startup">Startup, directories, environment（スタートアップ、ディレクトリ、環境）</a>
  <ul>
  <li><a href="#environment">Environment variable NEWLISPDIR（環境変数 NEWLISPDIR）</a></li>
  <li><a href="#initialization">The initialization file <tt>init.lsp</tt>（初期化ファイル <tt>init.lsp</tt>）</a></li>
  <li><a href="#directories_unix">Directories on Linux, BSD, macOS（Linux, BSD, macOS の ディレクトリ）</a></li>
  <li><a href="#directories_win">Directories on MS Windows（MS Windows のディレクトリ）</a></li>
  </ul>
</li>

<li><a href="#shared-lib">Extending newLISP with shared libraries（共有ライブラリによる newLISP の拡張）</a></li>
<li><a href="#newlisp-lib">newLISP as a shared library（共有ライブラリとしての newLISP）</a></li>
  <ul>
  <li><a href="#newlisp-lib">newLISP as a C library（C ライブラリとしての newLISP）</a></li>
  <li><a href="#newlisp-js-lib">newLISP as a JavaScript library（JavaScript ライブラリとしての newLISP）</a></li>
  </ul>
<li><a href="#expressions">Evaluating newLISP expressions（newLISP 式の評価）</a>
  <ul>
  <li><a href="#multiline">Interactive multiline expressions（インターラクティブ時の複数行の式）</a></li>
  <li><a href="#int_float">Integer, floating point data and operators（整数、浮動小数点データと演算子）</a></li>
  <li><a href="#big_int">Big integer, unlimited precision arithmetic（算術精度に制限のない大整数）</a></li>
  <li><a href="#eval_rules">Evaluation rules and data types（評価ルールとデータ型）</a></li>
  </ul>
</li>

<li><a href="#lambda_expressions">Lambda expressions in newLISP（newLISP におけるラムダ式）</a></li>
<li><a href="#nil_and_true"><tt>nil</tt>, <tt>true</tt>, <tt>cons</tt> and <tt>()</tt> in newLISP（newLISP の <tt>nil</tt>、<tt>true</tt>、<tt>cons</tt> と <tt>()</tt>）</a></li>
<li><a href="#arrays">Arrays（アレイ）</a></li>
<li><a href="#indexing">Indexing elements of strings, lists and arrays（文字列、リスト、アレイの要素指定）</a>
  <ul>
  <li><a href="#implicit_indexing">Implicit indexing for <tt>nth</tt>（<tt>nth</tt> 的な暗黙の要素指定）</a></li>
  <li><a href="#implicit_default">Implicit indexing and the default functor（暗黙の要素指定とデフォルト ファンクタ）</a></li>
  <li><a href="#implicit_rest_slice">Implicit indexing for <tt>rest</tt> and <tt>slice</tt>（<tt>rest</tt> や <tt>slice</tt> 的な暗黙の要素指定）</a></li>
  <li><a href="#implicit_modify">Modify references in lists, arrays and strings（文字列、リスト、アレイの参照変更）</a></li>
  </ul>
</li>  

<li><a href="#destructive">Destructive versus non-destructive functions（破壊的 対 非破壊的関数）</a>
<ul>
	<li><a href="#make_nondestructive">Make a destructive function non-destructive（破壊的関数の非破壊的関数化）</a></li>
</ul>
</li>

<li><a href="#return">Early return from functions, loops, blocks（関数、ループ、ブロックからの早期脱出）</a>
  <ul>
  <li><a href="#flow_catch_throw">Using <tt>catch</tt> and <tt>throw</tt>（<tt>catch</tt> と <tt>throw</tt> の使用）</a></li>
  <li><a href="#flow_and_or">Using <tt>and</tt> and <tt>or</tt>（<tt>and</tt> と <tt>or</tt> の使用）</a></li>
  </ul>
</li>
<li><a href="#scoping">Dynamic and lexical scoping（ダイナミック・スコープとレキシカル・スコープ）</a></li>

<li><a href="#contexts">Contexts（コンテキスト）</a>
  <ul>
  <li><a href="#context_rules">Symbol creation in contexts（コンテキストでのシンボル生成）</a></li>
  <li><a href="#creating_contexts">Creating contexts（コンテキスト生成）</a></li>
  <li><a href="#scope_global">Global scope（グローバル スコープ）</a></li>
  <li><a href="#protection">Symbol protection（シンボル保護）</a></li>
  <li><a href="#overwrite">Overwriting global symbols and built-ins（グローバル・シンボルと組込の上書き）</a></li>
  <li><a href="#context_vars">Variables holding contexts（コンテキストを含む変数）</a></li>
  <li><a href="#sequence_creating">Sequence of creating contexts（コンテキストの生成手順）</a></li>
  <li><a href="#context_modules">Contexts as programming modules（プログラミング・モジュールとしてのコンテキスト）</a></li>
  <li><a href="#context_data">Contexts as data containers（データ・コンテナとしてのコンテキスト）</a></li>
  <li><a href="#loading_contexts">Loading and declaring contexts（コンテキストのロードと宣言）</a></li>
  <li><a href="#serializing">Serializing context objects（コンテキスト・オブジェクトの<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby> ）</a></li>
  </ul>
</li>

<li><a href="#default_function">The context default functor（コンテキスト・デフォルト・ファンクタ）</a>
  <ul>
  <li><a href="#func_memory">Functions with memory（メモリとしての関数）</a></li>
  <li><a href="#hash">Hash functions and dictionaries（ハッシュ機能と辞書）</a></li>
  <li><a href="#pass_big">Passing data by reference（参照によるデータの受け渡し）</a></li>
  </ul>
</li>

<li><a href="#foop">Functional object-oriented programming（関数的オブジェクト指向プログラミング）</a>
  <ul>
  <li><a href="#newlisp_classes">FOOP classes and constructors（FOOP クラスとコンストラクタ）</a></li>
  <li><a href="#newlisp_objects">Objects（オブジェクト）</a></li>
  <li><a href="#colon_operator">The colon <tt>:</tt> operator and polymorphism（コロン <tt>:</tt> 演算子と多態性）</a></li>
  <li><a href="#structure_foop">Structuring a larger FOOP program（大規模 FOOP プログラムの構造化）</a></li>
  </ul>
</li>

<li><a href="#multi_processing">Concurrent processing and distributed computing（並列処理と分散コンピューティング）</a>
	<ul>
	<li><a href="#cilk">The Cilk API（Cilk API）</a></li>
	<li><a href="#distributed">Distributed network computing（分散ネットワーク コンピューティング）</a></li>
	</ul>
</li>

<li><a href="#JSON_XML">JSON, XML, SXML and XML-RPC（JSON、XML、SXML と XML-RPC）</a></li>
<li><a href="#internationalization">Customization, localization and UTF-8（カスタマイズ、ローカライズと UTF-8）</a>
  <ul>
  <li><a href="#naming">Customizing function names（関数名のカスタマイズ）</a></li>
  <li><a href="#switching">Switching the locale（ロケールの切り替え）</a></li>
  <li><a href="#decimal_point">Decimal point and decimal comma（十進点と十進カンマ）</a></li>
  <li><a href="#unicode_utf8">Unicode and UTF-8 encoding（Unicode と UTF-8 エンコーディング）</a></li>
  <li><a href="#utf8_capable">Functions working on UTF-8 characters（UTF-8 文字で動作する関数）</a></li>
  <li><a href="#utf8_version">Functions only available on UTF-8 enabled versions（UTF-8 バージョンでのみ利用できる関数）</a></li>
  </ul>
</li>

<li><a href="#commas">Commas in parameter lists（パラメータ リストのカンマ）</a></li>
</ol>

<h3><a href="#function_ref">Function Reference（関数リファレンス）</a></h3>
<ol>
<li><a href="#symbol_names">Syntax of symbol variables and numbers（シンボル変数と数値の構文）</a></li>
<li><a href="#type_ids">Data types and names in the reference（リファレンスでのデータ型と名前）</a></li>
<li><a href="#functions">Functions in groups（グループ毎の関数）</a>
  <ul>
  <li><a href="#list_processing">List processing, flow control, and integer arithmetic（リスト処理、フロー制御と整数演算）</a></li>
  <li><a href="#string_operators">String and conversion functions（文字列と変換関数）</a></li>
  <li><a href="#floating_point">Floating point math and special functions（浮動小数点数学と特殊関数）</a></li>
  <li><a href="#matrices">Matrix functions（行列関数）</a></li>
  <li><a href="#array-funcs">Array functions（アレイ関数）</a></li>
  <li><a href="#bit_operators">Bit operators（ビット演算子）</a></li>
  <li><a href="#predicates">Predicates（述語）</a></li>
  <li><a href="#timedate">Date and time functions（日付と時刻の関数）</a></li>
  <li><a href="#montecarlo">Statistics, simulation and modeling functions（統計、シミュレーション、モデル化関数）</a></li>
  <li><a href="#pattern">Pattern matching（パターン マッチング）</a></li>
  <li><a href="#financial">Financial math functions（財務関数）</a></li>
  <li><a href="#input_output">File and I/O operations（ファイルと I/O の操作）</a></li>
  <li><a href="#processes">Processes and the Cilk API（プロセスと CilK API）</a></li>
  <li><a href="#directory_management">File and directory management（ファイルとディレクトリの管理）</a></li>
  <li><a href="#http_api">HTTP networking API（HTTP ネットワーキング API）</a></li>
  <li><a href="#socket_tcpip">Socket TCP/IP, UDP and ICMP network API（ソケット TCP/IP、UDP と ICMP ネットワーク API）</a></li>
  <li><a href="#JS">API for newLISP in a web browser（ウェブ・ブラウザ用 newLISP の API）</a></li>
  <li><a href="#reflection">Reflection and customization（リフレクションとカスタマイズ）</a></li>
  <li><a href="#system_functions">System functions（システム関数）</a></li>
  <li><a href="#importing_libraries">Importing libraries（ライブラリのインポート）</a></li>
  <li><a href="#internals">newLISP internals API（newLISP 内部 API）</a></li>
  </ul>
</li>

<li><a href="#functions_alphabetical">Functions in alphabetical order（アルファベット順の関数）</a>
<p>
<b>
<a href="#shell">!</a>&nbsp;
<a href="#arithmetic">+-*/%</a>&nbsp;
<a href="#abort">Ab</a>&nbsp;
<a href="#append">Ap</a>&nbsp;
<a href="#asin">As</a>&nbsp;
<a href="#base64-dec">Ba</a>&nbsp;
<a href="#callback">Ca</a>&nbsp;
<a href="#clean">Cl</a>&nbsp;
<a href="#command-event">Co</a>&nbsp;
<a href="#current-line">Cu</a>&nbsp;
<a href="#dec">De</a>&nbsp;
<a href="#difference">Di</a>&nbsp;
<a href="#do-until">Do</a>&nbsp;
<a href="#encrypt">En</a>&nbsp;
<br/>
<a href="#exec">Ex</a>&nbsp;
<a href="#file-info">Fi</a>&nbsp;
<a href="#flat">Fl</a>&nbsp;
<a href="#gammaln">Ga</a>&nbsp;
<a href="#global">Gl</a>&nbsp;
<a href="#inc">In</a>&nbsp;
<a href="#lambdap">La</a>&nbsp;
<a href="#listp">Li</a>&nbsp;
<a href="#macrop">Ma</a>&nbsp;
<a href="#mul">Mu</a>&nbsp;
<a href="#net-accept">Net</a>&nbsp;
<a href="#new">New</a>&nbsp;
<a href="#nth">Nt</a>&nbsp;
<a href="#pack">Pa</a>&nbsp;
<br/>
<a href="#pretty-print">Pr</a>&nbsp;
<a href="#randomize">Ra</a>&nbsp;
<a href="#read">Rea</a>&nbsp;
<a href="#regex">Reg</a>&nbsp;
<a href="#search">Sea</a>&nbsp;
<a href="#sequence">Seq</a>&nbsp;
<a href="#sleep">Sl</a>&nbsp;
<a href="#starts-with">St</a>&nbsp;
<a href="#sync">Sy</a>&nbsp;
<a href="#time-of-day">Ti</a>&nbsp;
<a href="#truep">Tr</a>&nbsp;
<a href="#utf8">Ut</a>&nbsp;
<a href="#write-file">Wr</a>&nbsp;
</b>
</p>
</li>  
</ol>

<h3><a href="#appendix">Appendix（付録）</a></h3>

<ul>
<li><a href="#error_codes">Error Codes（エラー コード）</a></li>
<li><a href="#system_symbols">System Symbols（システム シンボル）</a></li>
<li><a href="#GNUFDL">GNU Free Documentation License</a></li>
<li><a href="#GNUGPL">GNU General Public License</a></li>
</ul>

<br/>
<a name="introduction"></a>

<center style="font-size: 150%">
<span class="divider">(&nbsp;<font color="#7ba9d4">&part;</font>&nbsp;)</span>
</center>

<br/><br/>

<a name="users_manual"></a>
<center><h1>newLISP User Manual</h1></center>


<h2>1. Introduction（イントロダクション）</h2>

<p>newLISP は、Lisp の主要構成要素：<em>リスト</em>、<em>シンボル</em>、<em>ラムダ式</em> に焦点を合わせています。
これらに newLISP は<em>アレイ</em> とリストやアレイ上の <em>暗黙の要素指定</em> と <em>ダイナミック（訳注：動的ともいう）</em> 及び <em>レキシカル（訳注：静的または構文的ともいう）スコープ</em> を追加しています。
レキシカル・スコープは、<em>コンテキスト</em> と呼ばれる独立した名前空間を使って実装しています。（訳注：名前空間 <em>コンテキスト</em> は、ダイナミック・スコープで <em>fexpr</em> を使う時の安全性を提供します。<a href="http://en.wikipedia.org/wiki/Fexpr">fexpr</a> とは、引数が評価されずに渡される関数のこと。newlLISP では <a href="#define-macro">define-macro</a> を使って定義します）<br />
newLISP focuses on the core components of Lisp: <em>lists</em>, <em>symbols</em>, 
and <em>lambda expressions</em>. To these, newLISP adds <em>arrays</em>,
<em>implicit indexing</em> on lists and arrays, and <em>dynamic</em> and 
<em>lexical scoping</em>. Lexical scoping is implemented using separate namespaces 
called <em>contexts</em>. </p>

<p>その結果、ほとんどの Scheme 実装よりも小さくありながら、約 350個 の組込関数を持つという学びやすい Lisp となっています。
newLISP のサイズは BSD システムで 200k 強でありながら、最も一般的な Unix システム C ライブラリのみを使い、高いポータビリティを持って構築されています。
ロードも素早く、メモリ消費もわずかです。
newLISP は他の一般的なスクリプト用言語と同等かそれ以上に早く、リソースも少ししか使いません。<br />
The result is an easier-to-learn Lisp that is even smaller than most Scheme 
implementations, but which still has about 350 built-in functions.
Not much over 200k in size on BSD systems, newLISP is built for high portability
using only the most common Unix system C-libraries. It loads quickly and has 
a small memory footprint. newLISP is as fast or faster than other popular 
scripting languages and uses very few resources.</p>


<p>組込とユーザ定義関数の両方とも、変数と一緒に、同じグローバル・シンボル木を共有し、同じ関数として扱われます。
また、ラムダ式とユーザ定義関数は、他のリスト式と同じように処理できます。<br />
Both built-in and user-defined functions, along with variables, share the 
same global symbol tree and are manipulated by the same functions. Lambda expressions 
and user-defined functions can be handled like any other list expression.</p>

<p>newLISP は、レキシカルに分離されたコンテキスト（名前空間）を内部に持つダイナミック・スコープです。
newLISP のコンテキストは、様々な用途で使われます。
(1) プログラムのモジュール分割、
(2) FOOP (Functional Object Oriented Programming) での <em>クラス</em> 定義、
(3) 状態を持つ関数の定義（訳注：いわゆる<a href="http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3">クロージャ</a>）
(4) 連想キー &rarr; 値保存のためのハッシュ木生成等を可能にします。<br />
newLISP is dynamically scoped inside lexically separated contexts (namespaces). 
Contexts in newLISP are used for multiple purposes. They allow (1) partioning of 
programs into modules, (2) the definition of <em>Classes</em> in FOOP 
(Functional Object Oriented Programming), (3) the definition of functions with 
state and (4) the creation of Hash trees for associative key &rarr; value storage.</p>

<p>newLISP の効率的な<em><a href="http://ja.wikipedia.org/wiki/%E8%B5%A4%E9%BB%92%E6%9C%A8">赤黒木</a></em>（訳注：英語版は、<a href="http://en.wikipedia.org/wiki/Red-black_tree">こちら</a>）の実装は、性能劣化なしに数百万のシンボルを処理できます。<br />
newLISP's efficient <em>red-black</em> tree implementation can handle millions 
of symbols in namespaces or hashes without degrading performance.</p>

<p>newLISP は、伝統的な非同期<a href="http://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3">ガベージコレクション</a>を使用せずに、メモリの割当と回収を自動的に行ないます（エラー条件下を除いて）。
全てのオブジェクトは&mdash;&mdash;コンテキスト、組込プリミティブ、シンボルを除いて&mdash;&mdash;値として渡され、一度だけ参照されます。
オブジェクトは、生成において遅延削除が予定されており、Lisp セルを新規オブジェクト生成用に再利用します。
これらの結果として、伝統的なガベージコレクションに見られる休止は起こらず、予測可能な処理時間をもたらします。
newLISP の独創的な自動メモリ管理は、最も早いインターラクティブ Lisp をもたらします。
それは、他の Lisp 以上に、<em>データ ＝ プログラム</em> パラダイムと完全な自己<a href="http://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6)">リフレクション</a>実装をもたらします。<br />
newLISP allocates and reclaims memory automatically, without using traditional 
asynchronous garbage collection.
All objects &mdash; except for contexts, built-in primitives, and symbols &mdash;
are passed by value and are referenced only once. Upon creation objects are scheduled
for delayed deletion and Lisp cells are recycled for newly created objects.
This results in predictable processing times without the pauses found in traditional 
garbage collection. newLISP's unique automatic memory management makes it the fastest 
interactive Lisp available. More than any other Lisp, it implements the 
<em>data equals program</em> paradigm and full self reflection.</p>

<p>newLISP の組込関数は、様々な形態を持ち、多様なデータ型とオプション・パラメータを受け入れます。
これは学習や実装に必要な関数と構文形態の数を劇的に減らします。
高級関数が多数用意されており、分布計算、並行プロセス、財務数学、統計、人工知能アプリケーションに利用できます。<br />
Many of newLISP's built-in functions are polymorphic and accept a variety 
of data types and optional parameters. This greatly reduces the number of 
functions and syntactic forms necessary to learn and implement.
High-level functions are available for string and list processing, financial math, 
statistics, and Artificial Intelligence applications.</p>

<p>newLISP は複雑な<em>入れ子</em> リストや<em>多次元</em> アレイ構造内の要素を変更・挿入・削除する関数を多数持っています。<br />
newLISP has functions to modify, insert, or delete elements inside 
complex <em>nested</em> lists or <em>multi-dimensional</em> array structures.</p>

<p>newLISP では文字列に null 文字を含ませることができ、バイナリ・データ処理にほとんどの文字列操作関数を使えます。<br />
Because strings can contain null characters in newLISP, they can be used to 
process binary data with most string manipulating functions.</p>

<p>newLISP は共有ライブラリ・インターフェースによる拡張も可能で、外部バイナリ・データ構造のデータをアクセスする関数を導入することができます。
配布物には、一般的なデータベース API 群を導入するためのモジュール群が入っています。<br />
newLISP can also be extended with a shared library interface
to import functions that access data in foreign binary data structures.
The distribution contains modules for importing popular C-library APIs.</p>

<p>newLISP の HTTP、TCP/IP、UDP ソケット・インターフェイスは、ネットワーク分散アプリケーションを書き易くします。
newLISP の組込 XML インターフェース は、テキスト処理機能&mdash;&mdash; Perl コンパチブル正規表現 (PCRE) とテキスト解析関数 &mdash;&mdash;と相まって、有用な CGI 処理ツールを提供します。
配布ソースに HTML フォーム処理例があります。
newLISP は、組込 http モード・オプションを使って、CGI 処理可能なウェブ・サーバーになります。<br />
newLISP's HTTP, TCP/IP, and UDP socket interfaces make it easy to write 
distributed networked applications. Its built-in XML interface, along with 
its text-processing features &mdash; Perl Compatible Regular Expressions (PCRE) 
and text-parsing functions &mdash; make newLISP a useful tool for CGI processing.
The source distribution includes examples of HTML forms processing.
newLISP can be run a as a CGI capable web server using its built-in http mode option.</p>

<p>newLISP は、ネットワーク上の分散処理と一個以上のコアを持つ CPU 上の並列処理を支援する組込関数を持っています。<br />
newLISP has built-in support for distributed processing on networks and parallel,
concurrent processing on the same CPU with one or more processing cores.</p>

<p>配布ソースは、Linux, macOS/Darwin, BSD, 他の多くの Unix 類似品, MS Windows でコンパイル可能です。
newLISP は、完全な64ビット・メモリ・アドレッシング用の 64ビット <a href="http://ja.wikipedia.org/wiki/64%E3%83%93%E3%83%83%E3%83%88">LP64</a> アプリケーションとしてもコンパイルできます。<br />
The source distribution can be compiled for Linux, macOS/Darwin, BSDs, many 
other Unix flavors and MS Windows. newLISP can be compiled as a 64-bit LP64 application 
for full 64-bit memory addressing.</p>

<p>バージョン 10.5.7 から、newLISP は JavaScript にもコンパイルして、<a href="http://www.newlisp.org/newlisp-js/">ウェブ・ブラウザ（訳注：JavaScript 版 newLISP の簡易 IDE に飛びます）</a> で走らせることができます。<br />
Since version 10.5.7, newLISP also can be compiled to JavaScript and run in
a <a href="http://www.newlisp.org/newlisp-js/">web browser</a>.</p>

<br/>

<h3>Licensing</h3>

<p>newLISP は <a href="#GNUGPL">GPL (General Public License)</a> 第3版のもとでライセンスされます。
newLISP 文書は newLISP と一緒にパッケージされた他の文書と同様に <a href="#GNUFDL">GNU Free Documentation License</a> のもとでライセンスされます。 <br />
newLISP are licensed under version 3
of the <a href="#GNUGPL">GPL (General Public License)</a>.
The newLISP documentation as well as other documentation packaged with newLISP 
are licensed under the <a href="#GNUFDL">GNU Free Documentation License</a>. </p>

<br/>

<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>

<a name="deprecated"></a>
<h2>2. Deprecated functions since version 10.3.0（バージョン10.3.0 から廃止される関数）</h2>

<p>バージョン 10.3.0 以降の newLISP は、新規関数 <a href="#net-ipv">net-ipv</a> を使って、ランタイムに IPv4 モードと IPv6 モードを切り替えることができます。
IPv6 モードで newLISP を開始するのに、<tt>-6</tt> のコマンドライン・オプションが使えます。
IPv6 に移行後は、 <tt>-6</tt> コマンドライン・スイッチは、IPv4 モードで開始するための <tt>-4</tt> に変更されるでしょう。<br />
Since version 10.3.0 newLISP can switch between IPv4 and IPv6 modes during
run-time using the new <a href="#net-ipv">net-ipv</a> function. The 
<tt>-6</tt> commandline option can be used to start newLISP in IPv6 mode. 
After transition to IPv6 the <tt>-6</tt>
commandline switch will be changed to <tt>-4</tt> for starting up in IPv4
mode.</p>

<p><a href="#date-parse">date-parse</a> の古い書式 <tt>parse-date</tt> はまだ認識されますが、バージョン10.3.0 以降推奨されません。
古い書式は将来のバージョンで削除されます。<br />
The old writing <tt>parse-date</tt> of <a href="#date-parse">date-parse</a>
is still recognized but deprecated since version 10.3.0. The old writing will 
be removed in a future version.</p>

<p>バージョン  10.4.2 以降、<tt>if-not</tt> は推奨されていません。将来のバージョンで削除される可能性があります。<br />
Since version 10.4.2 <tt>if-not</tt> is deprecated and will be removed in a
future version.</p>

<p>バージョン 10.4.6 以降の newLISP には、 JSON データをＳ式に翻訳する組込関数 <a href="#json-parse">json-parse</a> があります。
そのため <tt>json.lsp</tt> モジュール・ファイルが配布から外されます。<br />
Since version 10.4.6 newLISP has a built-in function <a href="#json-parse">
json-parse</a> for translating JSON data into S-expressions. The module
file <tt>json.lsp</tt> is removed from the distribution.</p>

<p>バージョン 10.4.8 以降、桁数に制限のない整数がサポートされます。
これにより、GNU GMP モジュール である <tt>gmp.lsp</tt> は不要になります。<br />
Since version 10.4.8 newLISP has built-in support for unlimited precision
integers. This makes the GNU GMP module <tt>gmp.lsp</tt> obsolete.</p>

<br/>

<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>

<a name="REPL"></a>
<h2>3. Interactive Lisp mode（インターラクティブ Lisp モード）</h2>
<p>Lisp を体験し、それを試す最も良い方法は、ターミナル・ウィンドウか、オペレーティング・システムのコマンド・シェルにおいて、対話モードを使うことです。
バージョン 10.3 から、newLISP の read-eval-print-loop (REPL) は複数行を受け付けます。<br />
The best way to experience Lisp and experiment with it, is using interactive 
mode in a terminal window or operating system command shell. Since version 10.3, 
newLISP's read-eval-print-loop (REPL) accepts multi-line statements.</p>

<p>複数行の宣言文を入力するには、システム・プロンプトの後に空行で [enter] キーを打ちます。
複数行モードから出るには、再び、空行で [enter] キーを打ちます。
次の例では、コンピュータの出力が太文字で示されています：<br />
To enter a multi-line statement hit the [enter] key on an empty line after
the system prompt. To exit multi-line mode, hit the [enter] key again on an empty
line. In the following example computer output is shown in bold letters:</p>

<pre>
<b>></b> 
(define (foo x y)
    (+ x y))

<b>(lambda (x y) (+ x y))
></b> (foo 3 4)
<b>7
></b> 
</pre>

<p>複数行モードは、OSコマンド・ターミナル・ウィンドウかコマンド・シェルでのみ可能なことに注意してください。<br />
Note, that multi-line mode is only possible in an OS command terminal window
or command shell.</p>

<p>対話モードの Lisp はオペレーティング・システムのシェル・コマンドも受け付けます。
OS コマンドを入力するには、プロンプトの右直後に '!' 文字を入力し、シェル・コマンドを続けます：<br />
Interactive Lisp mode can accept operating system shell commands. To hit
an OS command enter the '<tt>!</tt>' character right after the prompt, immediately
followed by the shell command:</p>

<pre>
<b>> </b>!ls *.html
<b>CodePatterns.html		MemoryManagement.html	newLISPdoc.html
ExpressionEvaluation.html	manual_frame.html		newlisp_index.html
License.html			newLISP-10.3-Release.html	newlisp_manual.html
> </b>
</pre>

<p>この例では <tt>ls</tt> コマンドが入力され、現在のディレクトリの HTML ファイルが表示されています。
MS ウィンドウズ では、<tt>dir</tt> コマンドを同じ処理に使います。<br />
In the example a <tt>ls</tt> shell command is entered to show HTML files
in the current directory. On MS Windows a <tt>dir</tt> command could be used
in the same fashion.</p>

<p>このモードはエディタ等の他のプログラムを呼び出すのにも使えます：<br />
The mode can also be used to call an editor or any other program:</p>

<pre>
<b>> </b>!vi foo.lsp
</pre>

<p>この例では <tt>Vi</tt> エディタがプログラム "foo.lsp" を編集するために開いています。
エディタを離れた後のプログラムは load 宣言文を使って、走らせることができます。<br />
<p>The Vi editor will open to edit the program "foo.lsp". After leaving
the editor the program could be run using a load statement:</p>

<pre>
<b>> </b>(load "foo.lsp")
</pre>

<p>これでプログラム foo.lsp が走ります。<br />
The program <tt>foo.lsp</tt> is now run.</p>

<p>UNIX で端末やコマンド・シェルを使っている時は、tab を使って newLISP 組込関数を補完表示できます：<br />
When using a Unix terminal or command shell, tab-expansion for built-in newLISP
functions can be used:</p>

<pre>
<b>> </b>(pri
<b>print       println     primitive?  
> (pri</b>
</pre>

<p>このように、文字 <tt> (pri </tt> の入力後に [tab] キーを一回打てば、同じ文字で始まる組込関数が全て表示されます。
関数名の前に [tab] を二回打つと、全ての組込関数名が表示されます。<br />
After entering the characters <tt> (pri </tt>  hit the [tab] key once to
show all the built-in functions starting with the same characters. When hitting
[tab] twice before a function name has started, all built-in function names will
be displayed.</p>

<p>ほとんどの Unix では、ホーム・ディレクトリにある <tt>.inputrc</tt> ファイルに次の行を含めることで、コマンダラインにおける括弧の一致が可能になります：<br />
On most Unix, parenthesis matching can be enabled on the commandline by
including the following line in the file <tt>.inputrc</tt> in the home
directory:</p>

<pre>
set blink-matching-paren on
</pre>

<p>但し、全てのシステムの <tt>libreadline</tt> が、この動作の可能なバージョンになっているとは限りません。<br />
Not all systems have a version of <tt>libreadline</tt> advanced enough for 
this to work.</p>


<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="options"></a>
<h2>4. Command-line options, startup and directories（コマンド ライン オプション）</h2>

<a name="cmd_help"></a>
<h3>Command line help summary（コマンド ライン ヘルプ要約）</h3>

<p>コマンドラインから newLISP を開始する時、いくつかのスイッチとオプション及びソースを指定できます。
次の実行は：<br />
When starting newLISP from the command-line several switches and options and 
source files can be specified. Executing:</p>

<pre>
newlisp -h
</pre>

<p>コマンドシェルで、次のようにオプションとスイッチの要約を出します：<br />
in a command shell will produce the following summary of options and switches:</p>

<pre>
 -h this help (no init.lsp)
 -n no init.lsp (must be first)
 -x &lt;source&gt; &lt;target&gt; link (no init.lsp)
 -v version
 -s &lt;stacksize&gt;
 -m &lt;max-mem-MB&gt; cell memory
 -e &lt;quoted lisp expression&gt;
 -l &lt;path-file&gt; log connections
 -L &lt;path-file&gt; log all
 -w &lt;working dir&gt;
 -c no prompts, HTTP
 -C force prompts
 -t &lt;usec-server-timeout&gt;
 -p &lt;port-no&gt;
 -d &lt;port-no&gt; demon mode
 -http only
 -http-safe safe mode
 -6 IPv6 mode
</pre>

<p>コマンドラインのスイッチの前後で、ロードして実行するファイルを指定できます。
実行可能な newLISP プログラムが続くパラメータを利用するなら、
そのプログラムは <tt>(exit)</tt> 宣言文で終わっている必要があります。
そうでなければ、newLISP はコマンドラインのパラメータを、ロードして実行すべき追加の newLISP スクリプト（訳注：もしくは追加のコマンドライン・オプション）として解釈します。<br />
Before or after the command-line switches, files to load and execute can 
be specified. If a newLISP executable program is followed by parameters, 
the program must finish with and <tt>(exit)</tt> statement, else newLISP 
will take command-line parameters as additional newLISP scripts to be 
loaded and executed.</p>

<p>Linux や他の Unix システム上で、<tt>newlisp</tt> の <em>man ページ</em> が見つかります：<br />
On Linux and other Unix systems, a <tt>newlisp</tt> <em>man page</em> 
can be found:</p>

<pre>
man newlisp
</pre>		

<p>これは、Linux/Unix シェルで <a href="http://ja.wikipedia.org/wiki/Man%E3%83%9A%E3%83%BC%E3%82%B8">man ページ</a>を表示します。<br />
This will display a man page in the Linux/Unix shell.</p>

<br/>

<a name="url_files"></a>
<h3>Specifying files as URLs（URL としてのファイル指定）</h3>

<p>newLISP はコマンドラインで指定されたファイルを、ロードして実行します。
ファイルはローカル・ファイル上のパス名か <tt>file://</tt> URL のどちらか、
または HTTP サーバーが走っているリモート・ファイル・システム上の <tt>http://</tt> URL で指定されます。
HTTP サーバー・モードで走っている newLISP も HTTP サーバーになります。<br />
newLISP will load and execute files specified on the command-line. Files are 
specified with either their pathname or a <tt>file://</tt> URL on the local file 
system or with a <tt>http://</tt> URL on remote file systems running an HTTP
server. That HTTP server can be newLISP running in HTTP server mode.</p>

<pre>
newlisp aprog.lsp bprog.lsp prog.lsp
newlisp http://newlisp.org/example.lsp
newlisp file:///usr/home/newlisp/demo.lsp
</pre>

<br/>

<a name="no_init"></a>
<h3>No loading of init.lsp（init.lsp のロード無し）</h3>

<p>このオプションは、初期化ファイル <tt>init.lsp</tt> または <tt>.init.lsp</tt> のロードを抑制します。
これを動作させるには、第一オプションに指定されなければなりません：<br />
This option suppresses loading of any present initialization file <tt>init.lsp</tt> 
or <tt>.init.lsp</tt>. In order to work, this must be the first option specified:</p>

<pre>
newlisp -n
</pre>

<p>初期化ファイルの詳細は <a href="#initialization">The initialization file init.lsp（初期化ファイル init.lsp）</a> で。<br />
More about <a href="#initialization">initialization files.</a></p>

<br/>

<a name="stack_size"></a>
<h3>Stack size（スタック・サイズ）</h3>

<pre>
newlisp -s 4000
newlisp -s 100000 aprog bprog
newlisp -s 6000 myprog
newlisp -s 6000 http://asite.com/example.lsp
</pre>		

<p>上の例は、<tt>-s</tt> オプションを使って異なるスタック・サイズで newLISP を開始するのを示しているのと共に、
一つ以上の newLISP ソースファイルをロードする例と URL で指定されたファイルをロードする例を示しています。
スタック・サイズが指定されない時はデフォルトの 2048 になります。
一つのスタックにつき 80 バイトのメモリが予約されます。<br />
The above examples show starting newLISP with different stack sizes using 
the <tt>-s</tt> option, as well as loading one or more newLISP source files
and loading files specified by an URL. When no stack size is specified, 
the stack defaults to 2048. Per stack position about 80 bytes of memory are
preallocated.</p>

<br/>

<a name="max_mem"></a>
<h3>Maximum memory usage（最大メモリ使用量）</h3>

<pre>
newlisp -m 128
</pre>		

<p>この例では newLISP セル・メモリを 128 メガバイトに制限しています。
32 ビット newLISP では、各リスプ・セルは 16 バイト消費するので、
引数の <tt>128</tt> は最大 8,388,608 の newLISP セルを意味します。
この情報は <a href="#sys-info">sys-info</a> で返るリストの第二要素にあります。
リスプ・セル量が newLISP で消費する唯一のメモリではありませんが、
動的メモリ使用量全体の良い指標になります。<br />
This example limits newLISP cell memory to 128 megabytes. In 32-bit newLISP, 
each Lisp cell consumes 16 bytes, so the argument <tt>128</tt> would 
represent a maximum of 8,388,608 newLISP cells. This information is returned 
by <a href="#sys-info">sys-info</a> as the list's second element. Although 
Lisp cell memory is not the only memory consumed by newLISP, it is a good 
estimate of overall dynamic memory usage.</p>

<br/>

<a name="direct_exec"></a>
<h3>Direct execution mode（直接実行モード）</h3>

<p>newLISP 小品はコマンドラインから直接実行できます：<br />
Small pieces of newLISP code can be executed directly from the command-line:</p>

<pre>
newlisp -e "(+ 3 4)"  <span class="arw">&rarr;</span> 7 ; On MS Windows and Unix

newlisp -e '(append "abc" "def")'  <span class="arw">&rarr;</span> "abcdef" ; On Unix
</pre>		

<p>引用符で囲まれた式が評価され、結果は標準出力 (STDOUT) に出力されます。
ほとんどの Unix システム・シェルでは、コマンド文字列の区切りにシングル・クォートが使えます。
<tt>-e</tt> と引用コマンド文字列の間にスペースが有ることに注意してください。<br />
The expression enclosed in quotation marks is evaluated, and the result is 
printed to standard out (STDOUT). In most Unix system shells, single quotes 
can also be used as command string delimiters. Note that there is a space between 
<tt>-e</tt> and the quoted command string.</p>

<br/>

<a name="logging"></a>
<h3>Logging I/O（I/O のログ出力化）</h3>

<p>どのモードの newLISP でも <tt>-l</tt> か <tt>-L</tt> オプションで始めれば、ログの書き込みができます。
走っている newLISP のモードによって、ログ・ファイルに書き込まれる内容が変わります。
どちらのオプションでもログ・ファイルのパス指定が必要です。
パスには相対パスが使え、<tt>-l</tt> や <tt>-L</tt> オプションと、くっついていても離れていても構いません。
ファイルが存在していないなら、最初にログ出力を書き出す時点で生成されます。<br />
In any mode, newLISP can write a log when started with the <tt>-l</tt> or <tt>-L</tt> 
option. Depending on the mode newLISP is running, different output is written to the log 
file. Both options always must specify the  path of a log-file. The path may be a relative 
path and can be either attached or detached to the <tt>-l</tt> or <tt>-L</tt> option. 
If the file does not exist, it is created when the first logging output is written.</p>


<pre>
newlisp -l./logfile.txt -c

newlisp -L /usr/home/www/log.txt -http -w /usr/home/www/htpdocs
</pre>

<p>次の表に示されているのは、状況別のログ項目です：<br />
The following table shows the items logged in different situations:</p>

<table  width="98%" summary="logging formats">
<tr align="left"><th>logging mode</th><th>command-line and net-eval with 
<tt>-c</tt></th><th>HTTP server with <tt>-http</tt></th></tr>
<tr><td><tt>newlisp -l</tt></td>
    <td>log only input and network connections</td>
    <td>log only network connections</td></tr>
<tr><td><tt>newlisp -L</tt></td>
    <td>log also newLISP output (w/o prompts)</td>
    <td>log also HTTP requests</td></tr>
</table><br/>

<p><tt>-l</tt> か <tt>-L</tt>オプションの後に指定されたファイルに、ログ出力が全て書き込まれます。<br />
All logging output is written to the file specified after the <tt>-l</tt> 
or <tt>-L</tt> option.</p>

<br/>

<a name="working_dir"></a>
<h3>Specifying the working directory（作業ディレクトリの指定）</h3>

<p><tt>-w</tt> オプションは、newLISP のスタートアップ後の初期作業ディレクトリを指定します：<br />
The <tt>-w</tt> option specifies the initial working directory for newLISP 
after startup:
</p>

<pre>
newlisp -w /usr/home/newlisp
</pre>

<p>ディレクトリ・パスの付いていないファイルは全て、
<tt>-w</tt> オプションで指定されたパスに振り向けられます。<br />
All file requests without a directory path will now be directed to the path 
specified with the <tt>-w</tt> option.</p>

<br/>

<a name="prompt"></a>
<h3>Suppressing the prompt and HTTP processing（プロンプトの抑制と HTTP 処理）</h3>

<p>コマンドライン・プロンプトと最初に表示されるコピーライトが抑制されます：<br />
The command-line prompt and initial copyright banner can be suppressed:</p>

<pre>
newlisp -c
</pre>

<p>ログ状態でないなら、待ち受け（listen）と接続のメッセージも抑制されます。
<tt>-c</tt> オプションは他のプログラムから newLISP を制御する時に便利であり、
<a href="#net-eval">net-eval</a> サーバーとして設定する時は必須です。<br />
Listen and connection messages are suppressed if logging is not enabled. 
The <tt>-c</tt> option is useful when controlling newLISP 
from other programs; it is mandatory when setting it up 
as a <a href="#net-eval">net-eval</a> server.</p>

<p><tt>-c</tt> オプションは、
CGI プロセシングはもちろん、
<tt>HTTP GET</tt>、
<tt>PUT</tt>、
<tt>POST</tt>、
<tt>DELETE</tt> <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>に返答する newLISP サーバー・ノードも可能にします。
<tt>-w</tt> や <tt>-d</tt> と一緒に <tt>-c</tt> オプションを使うと、
newLISP はスタンドアローンの <tt>httpd</tt> ウェブ・サーバーになります：<br />
The <tt>-c</tt> option also enables newLISP server nodes to answer
<tt>HTTP GET</tt>, <tt>PUT</tt>, <tt>POST</tt> and <tt>DELETE</tt> requests, 
as well as perform CGI processing. Using the <tt>-c</tt> option,
together with the <tt>-w</tt> and <tt>-d</tt> options,
newLISP can serve as a standalone <tt>httpd</tt> webserver:</p>

<pre>
newlisp -c -d 8080 -w /usr/home/www
</pre>

<p>Unix 機において、newLISP を
<tt><a href="http://ja.wikipedia.org/wiki/Inetd">inetd</a></tt> や
<tt><a href="http://ja.wikipedia.org/wiki/Xinetd">xinetd</a></tt> が可能なサーバーとして走らせる時は、次のようにして使います：<br />
When running newLISP as a <tt>inetd</tt> or <tt>xinetd</tt> enabled
server on Unix machines, use:</p>

<pre>
newlisp -c -w /usr/home/www
</pre>

<p><tt>-c</tt> モードで、newLISP は HTTP と同様なコマンドライン<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>と <a href="#net-eval">net-eval</a> <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を処理します。
このモードで newLISP を走らせるのは、ファイアーウォールで守られたマシン上でのみ推奨されます。
インターネットに開放され、アクセスも可能なマシン上では、このモードで走らせるべきではありません。
<a href="#net-eval">net-eval</a> やコマンドラインのような<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>の処理を抑制するために、より安全な <tt>-http</tt> オプションを使ってください。<br />
In <tt>-c</tt> mode, newLISP processes command-line requests as well as
HTTP and <a href="#net-eval">net-eval</a> requests. Running
newLISP in this mode is only recommended on a machine behind
a firewall. This mode should not be run on machines open and accessible
through the Internet. To suppress the processing of <a href="#net-eval">net-eval</a> 
and command-line&ndash;like requests, use the safer <tt>-http</tt> option.</p>

<br/>

<a name="forcing_prompt"></a>
<h3>Forcing prompts in pipe I/O mode（パイプ I/O モードでの強制プロンプト）</h3>

<p>大文字 <tt>C</tt> は、
Emacs エディタ 内においてパイプ I/O モードで newLISP を走らせている時、プロンプトを強制します：<br />
A capital <tt>C</tt> forces prompts when running newLISP in pipe I/O mode
inside the Emacs editor:</p>

<pre>
newlisp -C
</pre>

<p>評価による戻り値のコンソール出力を抑制するには <a href="#silent">silent</a> を使ってください。<br />
To suppress console output from return values from evaluations, 
use <a href="#silent">silent</a>.</p>

<br/>

<a name="tcpip_server"></a>
<h3>newLISP as a TCP/IP server（TCP/IP サーバーとして newLISP）</h3>

<pre>
newlisp some.lsp -p 9090
</pre>		

<p>この例は newLISP が TCP/IP ソケット接続上でコマンドを待ち受け（listen）する方法を示しています。
この場合、標準 I/O は <tt>-p</tt> オプションで指定されるポートへリダイレクトされています。
<tt>some.lsp</tt> はオプション・ファイルで、
スタートアップ時、接続が開始し待ち受け（listen）する前にロードされます。<br />
This example shows how newLISP can listen for commands on a TCP/IP socket 
connection. In this case, standard I/O is redirected to the port specified with 
the <tt>-p</tt> option. <tt>some.lsp</tt> is an optional file loaded during 
startup, before listening for a connection begins.</p>

<p><tt>-p</tt> オプションは、主に別のアプリケーションから newLISP を制御する時に使われます。別のアプリケーションとは newLISP GUI フロントエンドや他の言語で書かれたプログラムのようなものです。
制御しているクライアントが接続を閉じると、newLISP は直ちに終了します。<br />
The <tt>-p</tt> option is mainly used to control newLISP from another 
application, such as a newLISP GUI front-end or a program written in another 
language. As soon as the controlling client closes the connection, newLISP 
will exit.</p>

<p>サーバーとして走っている newLISP のテストに telnet アプリケーションが使えます。
最初に次のように入力します：<br />
A telnet application can be used to test running newLISP as a server. First 
enter:</p>

<pre>
newlisp -p 4711 &amp;
</pre>		

<p>Unix シェルにおいて <tt>&amp;</tt> はプロセスをバックグラウンドで走らせることを意味します。
Windows では、<tt>&amp;</tt> 無しでサーバー・プロセスをフォアグラウンドで開始して、
telnet アプリケーション用に二つ目のコマンド・ウィンドウを開いてください。
telnet を接続します:<br />
The <tt>&amp;</tt> indicates to a Unix shell to run the process in the 
background. On Windows, start the server process without the <tt>&amp;</tt> 
in the foreground and open a second command window for the telnet application. 
Now connect with a telnet: </p>

<pre>
telnet localhost 4711
</pre>	

<p>接続すると、newLISP サインオン表示とプロンプトが現れます。
<tt>4711</tt> の代わりに、他のポート番号を使うこともできます。<br />
If connected, the newLISP sign-on banner and prompt appear. Instead of 
<tt>4711</tt>, any other port number could be used.</p>

<p>クライアント・アプリケーションが接続を閉じると newLISP も終了します。<br />
When the client application closes the connection, newLISP will exit, too.
</p>

<br/>

<a name="daemon"></a>
<h3>TCP/IP daemon mode（TCP/IP デーモン モード）</h3>

<p><tt>-p</tt> モードでは、クライアントへの接続を閉じると newLISP は終了します。
これを避けるためには、<tt>-p</tt> の代わりに <tt>-d</tt> オプションを使ってください：<br />
When the connection to the client is closed in <tt>-p</tt> mode, newLISP 
exits. To avoid this, use the <tt>-d</tt> option instead of the <tt>-p</tt> 
option:</p>

<pre>
newlisp -d 4711 &amp;
</pre>		

<p>これは <tt>-p</tt> オプションのように動作しますが、接続を閉じても newLISP は終了しません。
代わりにメモリにとどまり、新しい接続を待ち受け（listen）、その状態を維持します。
クライアント・アプリケーションから発行された <a href="#exit">exit</a> がネットワーク接続を閉じても、
newLISP デーモンは常駐を維持し、新しい接続を待ちます。
<tt>4711</tt> の代わりにどんなポート番号も使えます。<br />
This works like the <tt>-p</tt> option, but newLISP does not exit after a 
connection closes. Instead, it stays in memory, listening for a new connection 
and preserving its state. An <a href="#exit">exit</a> issued from a client 
application closes the network connection, and the newLISP daemon remains 
resident, waiting for a new connection. Any port number could be used in place 
of <tt>4711</tt>.</p>

<p>各処理が終わって接続を閉じる度に、newLISP はリセット処理を行ない、スタックとシグナルを初期化し、コンテキストを <tt>MAIN</tt> に戻します。
サーバー状態である間維持されるのは、プログラムと変数シンボルの内容のみです。<br />
After each transaction, when a connection closes, newLISP will go through a 
reset process, reinitialize stack and signals and go to the <tt>MAIN</tt> 
context. Only the contents of program and variable symbols will be preserved 
when running a stateful server.</p>

<p><tt>-p</tt> または <tt>-d</tt> モードで走っている時、複数行の宣言文を囲むために開始タグ <tt>[cmd]</tt> と終了タグ <tt>[/cmd]</tt> を使う必要があります。
それらは各々個別の行に現れなければなりません（訳注：<tt>[cmd]</tt> と <tt>[/cmd]</tt> を単独行にするということ）。
これにより、制御しているアプリケーションから長いコードを転送することが可能になります。<br />
When running in <tt>-p</tt> or <tt>-d</tt> mode, the opening and closing tags 
<tt>[cmd]</tt> and <tt>[/cmd]</tt> must be used to enclose multiline 
statements.  They must each appear on separate lines. This makes it possible 
to transfer larger portions of code from controlling applications. </p>

<p>次なる <tt>-d</tt> モードは、クライアント側で <a href="#net-eval">net-eval</a> を使う分散処理環境でよく使われます：<br />
The following variant of the <tt>-d</tt> mode is frequently used in a 
distributed computing environment, together with 
<a href="#net-eval">net-eval</a> on the client side:</p>

<pre>
newlisp -c -d 4711 &amp;
</pre>		

<p><tt>-c</tt> を指定することで、プロンプト表示を抑制し、
関数 <a href="#net-eval">net-eval</a> からの<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を受け取るのに適したモードにします。<br />
The <tt>-c</tt> spec suppresses prompts, making this mode suitable 
for receiving requests from the <a href="#net-eval">net-eval</a> function.</p>

<p>走っている newLISP サーバー・ノードは、
 <tt>HTTP</tt> の <tt>GET</tt>、<tt>PUT</tt>、<tt>DELETE</tt> <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>にも応えます。
<a href="#get-url">get-url</a>、
<a href="#put-url">put-url</a>、
<a href="#delete-url">delete-url</a>、
<a href="#read-file">read-file</a>、
<a href="#write-file">write-file</a>、
<a href="#append-file">append-file</a> を使ってのファイルの引き出しや保存ができ、
<a href="#load">load</a> と <a href="#save">save</a> を使ってのリモート・サーバー・ノードへのプログラムのロードとセーブができます。
詳細は  <tt>-c</tt> と <tt>-http</tt> オプションの章を見てください。<br />
newLISP server nodes running will also answer <tt>HTTP GET</tt>, 
<tt>PUT</tt> and <tt>DELETE</tt> requests. This can be used to retrieve and 
store files with <a href="#get-url">get-url</a>, <a href="#put-url">put-url</a>,
<a href="#delete-url">delete-url</a>, <a href="#read-file">read-file</a>, 
<a href="#write-file">write-file</a> and <a href="#append-file">append-file</a>,
or to load and save programs using <a href="#load">load</a> and 
<a href="#save">save</a> from and to remote server nodes. See the chapters for 
the <tt>-c</tt> and <tt>-http</tt> options for more details.</p>

<br/>

<a name="http_mode"></a>
<h3>HTTP-only server mode（HTTP のみのサーバー モード）</h3>
<p><tt>-http</tt> を使うことで、newLISP の処理を HTTP 処理に制限することができます。
このモードにより、セキュアな <tt>httpd</tt> ウェブ・サーバー・デーモンが構成されます：<br />
 newLISP can be limited to HTTP processing using the <tt>-http</tt> option.
With this mode, a secure <tt>httpd</tt> web server daemon can be configured:</p>

<pre>
newlisp -http -d 8080 -w /usr/home/www
</pre>

<p>Unix 機において、newLISP を
<tt><a href="http://ja.wikipedia.org/wiki/Inetd">inetd</a></tt> や
<tt><a href="http://ja.wikipedia.org/wiki/Xinetd">xinetd</a></tt> が可能なサーバーとして走らせる時は、次のようにして使います：<br />
 When running newLISP as an <tt>inetd</tt> or <tt>xinetd</tt>-enabled
server on Unix machines, use:</p>

<pre>
newlisp -http -w /usr/home/www
</pre>

<p>このモードを使って、よりセキュリティの高い HTTP 処理を行なうには、
スタートアップ時、次のようにプログラムをロードしてください：<br />
To further enhance security and HTTP processing, load a program during 
startup when using this mode:</p>

<pre>
newlisp httpd-conf.lsp -http -w /usr/home/www
</pre>

<p>ファイル <tt>httpd-conf.lsp</tt> では、関数<a href="#command-event">command-event</a> に、<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>の解析・フィルタ・翻訳用ユーザ定義関数を指定してあります。
動作例については、この関数（訳注：<a href="#command-event">command-event</a>）のリファレンスを見てください。<br />
The file <tt>httpd-conf.lsp</tt> contains a <a href="#command-event">command-event</a>
function configuring a user-defined function to analyze, filter and translate requests.
See the reference for this function for a working example.</p>

<p><tt>-c</tt> または <tt>-http</tt> どちらかの HTTP モードでも、次のファイル型が認識され、正しく整形された <tt>Content-Type:</tt> ヘッダーを返送します：<br />
In the HTTP modes enabled by either <tt>-c</tt> or <tt>-http</tt>, the 
following file types are recognized, and a correctly formatted 
<tt>Content-Type:</tt> header is sent back:</p>

<table  summary="media types">
<tr align="left"><th>file extension</th><th>media type</th></tr>
<tr><td>.avi</td><td>video/x-msvideo</td></tr>
<tr><td>.css</td><td>text/css</td></tr>
<tr><td>.gif</td><td>image/gif</td></tr>
<tr><td>.htm</td><td>text/htm</td></tr>
<tr><td>.html</td><td>text/html</td></tr>
<tr><td>.jpg</td><td>image/jpg</td></tr>
<tr><td>.js</td><td>application/javascript</td></tr>
<tr><td>.mov</td><td>video/quicktime</td></tr>
<tr><td>.mp3</td><td>audio/mpeg</td></tr>
<tr><td>.mpg</td><td>video/mpeg</td></tr>
<tr><td>.pdf</td><td>application/pdf</td></tr>
<tr><td>.png</td><td>image/png</td></tr>
<tr><td>.wav</td><td>audio/x-wav</td></tr>
<tr><td>.zip</td><td>application/zip</td></tr>
<tr><td><em>any other</em></td><td>text/plain</td></tr>
</table><br/>

<p>HTTP サーバー・モードは CGI を提供するために、
Unix ライク・プラットフォームでは <tt>/tmp</tt> ディレクトリを、
MS Windows では <tt>C:\tmp</tt> ディレクトリを必要とします。
newLISP は GET、PUT、POST、DELETE <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を処理し、カスタムの<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>ヘッダを生成します。
CGI ファイルは拡張子を <tt>.cgi</tt> にしておく必要があり、さらに UNIX では実行許可を持ってなければなりません。
newLISP サーバー・モード CGI 処理についての詳細情報は、<a href="http://www.newlisp.org/CodePatterns.html">Code Patterns in newLISP</a> ドキュメントで見ることができます。<br />
To serve CGI, HTTP server mode needs a <tt>/tmp</tt> directory on Unix-like
platforms or a <tt>C:\tmp</tt> directory on MS Windows. newLISP can process GET, PUT,
POST and DELETE requests and create custom response headers. CGI files must have
the extension <tt>.cgi</tt> and have executable permission on Unix. More 
information about CGI processing for newLISP server modes can be found in the 
document <a href="http://www.newlisp.org/CodePatterns.html">
Code Patterns in newLISP</a></p>

<p><tt>-c</tt> と <tt>-http</tt> の両サーバー・モードでは、環境変数 DOCUMENT_ROOT、REQUEST_METHOD、REQUEST_URI、SERVER_SOFTWARE、QUERY_STRING  が設定されます。
クライアントから送られた HTTP ヘッダに存在するなら、変数 CONTENT_TYPE、CONTENT_LENGTH、HTTP_HOST、HTTP_USER_AGENT、HTTP_COOKIE も設定されます。
環境変数は関数 <a href="#env">env</a> を使って読むことができます。 <br />
In both server modes <tt>-c</tt> and <tt>-http</tt> the environment 
variables DOCUMENT_ROOT, HTTP_HOST, REMOTE_ADDR, REQUEST_METHOD, REQUEST_URI, 
SERVER_SOFTWARE and QUERY_STRING are set. The variables CONTENT_TYPE, 
CONTENT_LENGTH, HTTP_HOST, HTTP_USER_AGENT and HTTP_COOKIE are also set, if 
present in the HTTP header sent by the client. Environment variables can be
read using the <a href="#env">env</a> function.</p>

<br/>
		
<a name="local_domain_server"></a>
<h3>Local domain Unix socket server（ローカル ドメイン Unix ソケット サーバー）</h3>

<p><tt>-d</tt> または <tt>-p</tt> サーバー・モードでは、ポートの代わりにローカル・ドメイン Unix ソケット・パスを指定できます。<br />
Instead of a port, a local domain Unix socket path can be specified in
the <tt>-d</tt> or <tt>-p</tt> server modes.</p>

<pre>
newlisp -c -d /tmp/mysocket &amp;
</pre>	

<p>別の newLISP プロセスを使ってサーバーをテストします：<br />
Test the server using another newLISP process:</p>

<pre>
newlisp -e '(net-eval "/tmp/mysocket" 0 "(symbols)")'
</pre>	

<p>これで、組込シンボルの全リストが端末に出力されます。<br />
A list of all built-in symbols will be printed to the terminal</p>

<p>このモードは <a href="#net-connect">net-connect</a>、
<a href="#net-listen">net-listen</a>、
<a href="#net-eval">net-eval</a> のローカル・デーモン・ソケット・モードと共に動作します。
<a href="#net-accept">net-accept</a>、
<a href="#net-receive">net-receive</a>、 
<a href="#net-send">net-send</a> を使って、
<tt>net-connect</tt> と <tt>net-listen</tt> で開くローカル・デーモン・ソケットを提供できます。
<a href="#net-peek">net-peek</a> と <a href="#net-select">net-select</a> を使って、ローカル・デーモン・ソケット接続を監視できます。<br />
This mode will work together with local domain socket modes of
<a href="#net-connect">net-connect</a>, <a href="#net-listen">net-listen</a>,
and <a href="#net-eval">net-eval</a>. Local domain sockets opened with 
<tt>net-connect</tt> and <tt>net-listen</tt> can be served using
<a href="#net-accept">net-accept</a>, <a href="#net-receive">net-receive</a>,
and <a href="#net-send">net-send</a>. Local domain socket connections
can be monitored using <a href="#net-peek">net-peek</a> and 
<a href="#net-select">net-select</a>.</p>

<p>ローカル・デーモン・ソケット接続は通常の TCP/IP ネットワーク接続よりも高速で、同じローカルファイルシステム上でアプリケーションを配布するプロセス間通信に向いています。
このモードは、MS Windows では利用できません。<br />
Local domain socket connections are much faster than normal TCP/IP network
connections and preferred for communications between processes on
the same local file system in distributed applications. This mode is not
available on MS Windows.</p>

<br/>

<a name="conn_timeout"></a>
<h3>Connection timeout（接続のタイムアウト）</h3>

<p><tt>-p</tt> または <tt>-d</tt> デーモン・モードで走っている時の接続タイムアウト時間を指定します。
newLISP サーバーはクライアント接続を受け入れ後、さらなる入力が無い時は接続を断ちます。
タイムアウト時間は μ秒で指定します：<br />
Specifies  a  connection timeout when running in <tt>-p</tt> or <tt>-d</tt> 
demon mode. A newLISP Server will disconnect when no further input is read 
after accepting a client connection. The timeout is specified in micro 
seconds:</p>

<pre>
newlisp -c -t 3000000 -d 4711 &amp;
</pre>

<p>この例は 3秒のタイムアウト時間を指定しています。<br />
The example specifies a timeout of three seconds.</p>

<br/>

<a name="inetd_daemon"></a>
<h3><tt>inetd</tt>	 daemon mode（<tt>inetd</tt> デーモン モード）</h3>

<p>事実上、全ての Linux/Unix OS 上で走っている <tt>inetd</tt> サーバーは、newLISP のプロキシとして機能します。
サーバーは、TCP/IP または UDP 接続を受け入れ、<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を標準 I/O を通して newLISP に渡します。
<tt>inetd</tt> は各クライアント接続用に newLISP プロセスを開始します。
クライアントが接続を断つと、接続が閉じられ、newLISP プロセスも終了します。<br />
The <tt>inetd</tt> server running on virtually all Linux/Unix OSes can function 
as a proxy for newLISP. The server accepts TCP/IP or UDP connections and passes 
on requests via standard I/O to newLISP. <tt>inetd</tt> starts a newLISP 
process for each client connection. When a client disconnects, the connection 
is closed and the newLISP process exits.</p>

<p>newLISP はメモリ使用量が少ない上に実行も早く、プログラムのロード時間も短いので、<tt>inetd</tt> と newLISP の組み合わせは複数の接続を効率良く処理します。
<a href="#net-eval">net-eval</a> を使って動作させる時、このモードが好まれるのは、分散処理環境で複数の<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を効率良く処理するためです。<br />
<tt>inetd</tt> and newLISP together can handle multiple connections efficiently 
because of newLISP's small memory footprint, fast executable, and short program 
load times. When working with <a href="#net-eval">net-eval</a>, this mode is 
preferred for efficiently handling multiple requests in a distributed computing 
environment.</p>

<p><tt>services</tt> と <tt>inetd.conf</tt> の二つのファイルを設定しておかなけばなりません。 
どちらも ASCII 編集が可能で、通常 <tt>/etc/services</tt> と <tt>/etc/inetd.conf</tt> で見つかります。<br />
Two files must be configured: <tt>services</tt> and <tt>inetd.conf</tt>. 
Both are ASCII-editable and can usually be found at <tt>/etc/services</tt> and 
<tt>/etc/inetd.conf</tt>.
</p>

<p>次の行のどちらかを <tt>inetd.conf</tt> に置いてください：<br />
Put one of the following lines into <tt>inetd.conf:</tt>
</p>

<pre>
net-eval  stream  tcp  nowait  root  /usr/local/bin/newlisp -c
											 
# as an alternative, a program can also be preloaded
											 
net-eval  stream  tcp  nowait  root  /usr/local/bin/newlisp -c myprog.lsp
</pre>

<p><tt>root</tt> の代わりに別のユーザとオプション・グループを指定できます。
詳細は、<tt>inetd</tt> の Unix <a href="http://ja.wikipedia.org/wiki/Man%E3%83%9A%E3%83%BC%E3%82%B8">man ページ</a>を見てください。<br />
Instead of <tt>root</tt>, another user and optional group can be specified. 
For details, see the Unix man page for <tt>inetd</tt>.
</p>

<p>ファイル <tt>services</tt> には次の行を置いてください：<br />
The following line is put into the <tt>services</tt> file:
</p>

<pre>
net-eval        4711/tcp     # newLISP net-eval requests
</pre>		

<p>macOS と Unix システムによっては、<tt>inetd</tt> の代わりに <tt>xinetd</tt> を使うことができます。
<tt>/etc/xinetd.d/</tt> ディレクトリに <tt>net-eval</tt> というファイル名で次の内容を保存します：<br />
On macOS and some Unix systems, <tt>xinetd</tt> can be used instead of 
<tt>inetd</tt>. Save the following to a file named <tt>net-eval</tt> in the 
<tt>/etc/xinetd.d/</tt> directory:
</p>

<pre>
service net-eval
{
    socket_type = stream
    wait = no
    user = root
    server = /usr/local/bin/newlisp
    port = 4711
    server_args = -c
    only_from = localhost
}
</pre>		
<p>セキュリティ上の理由から、<tt>root</tt> は別ユーザに変更すべきであり、
適切に調整された www ドキュメント・ディレクトリのファイル許可も同様です。
<tt>only_from</tt> 指定は、リモート・アクセスを許可するために取ることができます。<br />
For security reasons, <tt>root</tt> should be changed to a different user
and file permissions of the www document directory adjusted accordingly.
The <tt>only_from</tt> spec can be left out to permit remote access.
</p>

<p>他の構成オプションは <tt>xinetd</tt> と <tt>xinetd.conf</tt> の man ページを見てください。<br />
See the man pages for <tt>xinetd</tt> and <tt>xinetd.conf</tt> 
for other configuration options.
</p>

<p>デーモンを設定した後、新規または変更した構成ファイルを読み込ませるために、<tt>inetd</tt> あるいは <tt>xinetd</tt> を（訳注：次のようにして）再起動する必要があります：<br />
After configuring the daemon, <tt>inetd</tt> or 
<tt>xinetd</tt> must be restarted to 
allow the new or changed configuration files to be read:

</p>

<pre>
kill -HUP &lt;pid&gt;
</pre>	

<p>走っている <tt>xinetd</tt> プロセスのプロセスID で <tt>&lt;pid&gt;</tt> を置き換えてください。<br />
Replace <tt>&lt;pid&gt;</tt> with the process ID of the 
running <tt>xinetd</tt> process.</p>

<p>4711 以外の数値や TCP 以外のネットワーク・プロトコルを指定することもできます。<br />
A number or network protocol other than 4711 or TCP can be specified.</p>

<p>プロンプトなしの newLISP コマンドラインで入力されたかのように、
newLISP は全てを処理します。
inetd セットアップをテストするために telnetプログラムを使用できます：<br />
newLISP handles everything as if the input were being entered 
on a newLISP command-line without a prompt. To test the 
<tt>inetd</tt> setup, the <tt>telnet</tt> program can be used:
</p>

<pre>
telnet localhost 4711
</pre>		

<p>これで newLISP 式が入力でき、<tt>inetd</tt> は自動的に newLISP プロセスのスタートアップ通信を処理します。
複数行の式は、<tt>[cmd]</tt> と <tt>[/cmd]</tt> のタグで囲むことで、
各々個別の行として入力できます。<br />
newLISP expressions can now be entered, and <tt>inetd</tt> will 
automatically handle the startup and communications of a newLISP 
process. Multiline expressions can be entered by bracketing them 
with <tt>[cmd]</tt> and <tt>[/cmd]</tt> tags, each on separate lines.
</p>

<p>newLISP サーバ・ノード は、<tt>HTTP GET</tt> と <tt>PUT</tt> の<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>に返答します。
これは、
<a href="#get-url">get-url</a>、
<a href="#put-url">put-url</a>、
<a href="#read-file">read-file</a>、
<a href="#write-file">write-file</a>、
<a href="#append-file">append-file</a>
によるファイルの取り出しや保存、および、
<a href="#load">load</a> と
<a href="#save">save</a> を使っての
リモート・サーバ・ノードへのプログラムのロードとセーブを
可能にします。<br />
newLISP server nodes answer <tt>HTTP GET</tt> and <tt>PUT</tt> requests. 
This can be used to retrieve and store files 
with <a href="#get-url">get-url</a>, <a href="#put-url">put-url</a>,
<a href="#read-file">read-file</a>, <a href="#write-file">write-file</a>
and <a href="#append-file">append-file</a>,
or to load and save programs using <a href="#load">load</a> 
and <a href="#save">save</a> from and to remote server nodes.</p>
		
<br/>

<a name="link"></a>
<h3>Linking a source file with newLISP for a new executable（newLISP 新実行部とソースとの統合）</h3>

<p>コマンド・ライン・フラグ <tt>-x</tt> を使い、ソース・コードと newLISP 実行部を一緒にして、自己完結アプリケーションを構築できます。<br />
Source code and the newLISP executable can be linked together to build a 
self-contained application by using the <tt>-x</tt> command line flag.</p>

<pre>
;; uppercase.lsp - Link example
(println (upper-case (main-args 1)))
(exit)
</pre>		

<p>プログラム <tt>uppercase.lsp</tt> はコマンド・ライン上の最初の単語を取り、それを大文字に変換します。<br />
The program <tt>uppercase.lsp</tt> takes the first word on the command-line 
and converts it to uppercase.</p>

<p>次のようなステップで自己完結アプリケーションを構築します：<br />
To build this program as a self-contained executable,
follow these steps:</p>

<pre>
# on OSX, Linux and other UNIX

newlisp -x uppercase.lsp uppercase

chmod 755 uppercase # give executable permission

# on Windows the target needs .exe extension

newlisp -x uppercase.lsp uppercase.exe
</pre>		

<p>newLISP は実行環境のパスで newLISP 実行部を探し、ソース・コードのコピーとリンクします。<br />
newLISP will find a newLISP executable in the execution path of the
environment and link a copy of the source code.</p>

<pre>
uppercase "convert me to uppercase"
</pre>	

<p>Linux や 他の UNIX では、現ディレクトリが実行パスでない場合は：<br />
On Linux and other UNIX, if the current directory is not in the 
executable path:</p>

<pre>
./uppercase "convert me to uppercase"
</pre>	


<p>上記実行で、コンソールには次のような出力が現れます：<br />
The console should print:</p>

<pre>
CONVERT ME TO UPPERCASE
</pre>		

<p>リンクしたプログラムは、起動時に初期化ファイル <tt>init.lsp</tt> あるいは <tt>.init.lsp</tt> をロードしないので注意してください。<br />
Note that neither one of the initialization files <tt>init.lsp</tt> nor 
<tt>.init.lsp</tt> is loaded during startup of linked programs.</p>

<br/>


<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>


<a name="startup"></a>
<h2>5. Startup, directories, environment（スタートアップ、ディレクトリ、環境）</h2>

<a name="environment"></a>
<h3>Environment variable <tt>NEWLISPDIR</tt>（環境変数 NEWLISPDIR）</h3>
<p>newLISP は、スタートアップ時に環境変数 <tt>NEWLISPDIR</tt> が設定されていないなら、それを設定します。
Linux、BSDs、macOS 等のUnix 上では、その変数を <tt>/usr/local/share/newlisp</tt> に設定します。
MS Windows 上では、<tt>%PROGRAMFILES%/newlisp</tt> になります。
ほとんどの MS Windows システムの <tt>%PROGRAMFILES%</tt> は <tt>C:\Program Files (x86)\</tt> ディレクトリに設定されています。<br />
During startup, newLISP sets the environment variable <tt>NEWLISPDIR</tt>, 
if it is not set already. On Linux, BSDs, macOS and other Unixes the 
variable is set to <tt>/usr/local/share/newlisp</tt>. On MS Windows the variable is set 
to <tt>%PROGRAMFILES%/newlisp</tt>. On most MS Windows systems <tt>%PROGRAMFILES%</tt> evaluates to the <tt>C:\Program Files (x86)\</tt> directory.</p>

<p>環境変数 <tt>NEWLISPDIR</tt> が役立つのは、newLISP と一緒にインストールされるファイルを次のようにロードする時です：<br />
The environment variable <tt>NEWLISPDIR</tt> is useful when loading files 
installed with newLISP:</p>

<pre>
(load (append (env "NEWLISPDIR") "/modules/mysql.lsp"))
</pre>

<p>関数 <tt>module</tt> を使えば、<tt>modules/</tt> ディレクトリからロードする二番目の宣言文を短くできます：<br />
A predefined function <tt>module</tt> can be used to shorten
the second statement loading from the <tt>modules/</tt>
directory:</p> 

<pre>
(module "mysql.lsp")
</pre>

<br/>

<a name="initialization"></a>
<h3> The initialization file <tt>init.lsp</tt>（初期化ファイル <tt>init.lsp</tt>）</h3>
<p>コマンドラインで指定されたファイルをロードする前、そして、バナーやプロンプトが示される前に、
newLISP はホーム・ディレクトリから <tt>.init.lsp</tt> のロードを試みます。
macOS、Linux、その他 Unix では、ホーム・ディレクトリは <tt>HOME</tt> 環境変数で見つかります。
MS Windows では、このディレクトリ名は環境変数 <tt>USERPROFILE</tt> か <tt>DOCUMENT_ROOT</tt> に含まれています。<br />
Before loading any files specified on the command-line, and before the 
banner and prompt are shown. newLISP tries to load a file <tt>.init.lsp</tt> 
from the home directory of the user starting newLISP. On macOS, Linux and 
other Unix the home directory is found in the <tt>HOME</tt> environment 
variable.  On MS Windows the directory name is contained in the <tt>USERPROFILE</tt> 
or <tt>DOCUMENT_ROOT</tt> environment variable.</p>

<p>もし、ホーム・ディレクトリで <tt>.init.lsp</tt> を見つけられないなら、
newLISP は環境変数 <tt>NEWLISPDIR</tt> で見つかるディレクトリから <tt>init.lsp</tt> ファイルのロードを試みます。<br />
If a <tt>.init.lsp</tt> cannot be found in the home directory newLISP tries
to load the file <tt>init.lsp</tt> from the directory found in the 
environment variable <tt>NEWLISPDIR</tt>.</p>

<p>newLISP を<a href="#newlisp-lib">共有ライブラリとして起動する</a>と、環境変数 <tt>NEWLISPLIB_INIT</tt> にある初期化ファイルを探します。
初期化ファイルはフル・パス名で指定されていることが必要です。
<tt>NEWLISPLIB_INIT</tt> が定義されていなければ、このライブラリ・モジュールは初期化ファイルをロードしません。<br />
When newLISP is run as a shared library, an initialization file is looked 
for in the environment variable <tt>NEWLISPLIB_INIT</tt>. The full path-name 
of the initialization file must be specified. If <tt>NEWLISPLIB_INIT</tt> is 
not defined, no initialization file will be loaded by the library module.</p>

<p>newLISP が走るために <tt>init.lsp</tt> は必要ありませんが、関数やシステム共通変数を定義するのに便利です。<br />
 Although newLISP does not require <tt>init.lsp</tt> to run, it is 
convenient for defining functions and system-wide variables.</p>

<p><a href="#link">リンク・プログラム</a>のスタートアップ中は、初期化ファイル <tt>init.lsp</tt> または <tt>.init.lsp</tt> のどちらもロードされないので、注意してください。また、<tt>-n</tt>、<tt>-h</tt>、<tt>-x</tt> オプションの何れかでもロードされません。<br />
Note that neither one of the initialization files <tt>init.lsp</tt> nor 
<tt>.init.lsp</tt> is loaded during startup of linked programs or
when one of the options <tt>-n</tt>, <tt>-h</tt>, <tt>-x</tt> is
specified.</p>

<br/>

<a name="directories_unix"></a>
<h3> Directories on Linux, BSD, macOS and other Unix （Linux, BSD, macOS の ディレクトリ）</h3>
<p><tt>/usr/local/share/newlisp/modules</tt> ディレクトリには、POP3 mail 等の有用な関数群のモジュールが入っています。
<tt>/usr/local/share/doc/newlisp/</tt> ディレクトリには、HTML形式のドキュメントが入っています。<br />
The directory <tt>/usr/local/share/newlisp/modules</tt> contains modules with useful 
functions POP3 mail, etc. The directory <tt>/usr/local/share/doc/newlisp/</tt> 
contains documentation in HTML format.</p>

<br/>

<a name="directories_win"></a>
<h3>Directories on MS Windows（MS Windows のディレクトリ）</h3>

<p>MS Windows システムでは、全ファイルがデフォルトの <tt>%PROGRAMFILES%&yen;newlisp</tt> ディレクトリにインストールされます（訳注：インストール・プログラム実行時にインストール・ディレクトリを変更することもできます）。
<tt>PROGRAMFILES</tt> は MS Windows の環境変数で、日本語環境へのインストールでは結果として <tt>C:&yen;Program files&yen;newlisp&yen;</tt> になります。
<tt>%PROGRAMFILES%&yen;newlisp&yen;modules</tt> サブ・ディレクトリには、外部ライブラリへのインタフェース用モジュールやサンプル・プログラムが入っています。<br />
On MS Windows systems, all files are installed in the default directory 
<tt>%PROGRAMFILES%\newlisp</tt>.  <tt>PROGRAMFILES</tt> is a MS Windows environment 
variable that resolves to <tt>C:\Program files\newlisp\</tt> in English 
language installations. The subdirectory <tt>%PROGRAMFILES%\newlisp\modules</tt> 
contains modules for interfacing to external libraries and sample programs.</p>
<br/>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="shared-lib"></a>
<h2>6. Extending newLISP with shared libraries（共有ライブラリによる newLISP の拡張）</h2>
<p>Unix や MS Windows の多くの共有ライブラリは newLISP の機能を拡張するために使えます。
例えば、グラフィカル・ユーザ・インターフェイス用ライブラリや暗号・復号用ライブラリ、データベース・アクセス用などがあります。<br />
Many shared libraries on Unix and MS Windows systems can be used to
extend newLISP's functionality. Examples are libraries for writing graphical
user interfaces, libraries for encryption or decryption and libraries for 
accessing databases.</p>

<p>外部ライブラリから関数を導入するには、関数<a href="#import">import</a> を使います。
外部ライブラリからのコールバック関数を登録するには、関数<a href="#callback">callback</a> を使います。
導入したライブラリ関数への入出力用フォーマットを簡単に実現できる関数として、
<a href="#pack">pack</a>、<a href="#unpack">unpack</a>、
<a href="#get-char">get-char</a>、<a href="#get-string">get-string</a>、
<a href="#get-int">get-int</a>、<a href="#get-long">get-long</a> 等があります。
関数 <a href="#cpymem">cpymem</a> は指定したアドレスを直接メモリーからメモリへコピーします。<br />
The function <a href="#import">import</a> is used to import functions from 
external libraries. The function <a href="#callback">callback</a> is used to 
register callback functions in external libraries. 
Other functions like <a href="#pack">pack</a>,
<a href="#unpack">unpack</a>, <a href="#get-char">get-char</a>, <a href="#get-string">get-string</a>,
<a href="#get-int">get-int</a> and <a href="#get-long">get-long</a> exist
to facilitate formatting input and output to and from imported library 
functions. The fucntion <a href="#cpymem">cpymem</a> allows direct memory-to-memory
copy specifying addresses.</p>

<p>共有ライブラリ用 API を書くときに使う関数のほとんどが、正しく使わないとセグメンテーション違反を起こします。
このマニュアルの <a href="#shared-lib"><font size="+1">&#x26A0;</font></a> にリンクした章に、そのような関数が記してあります。 <br />。
Most of the functions used when writing APIs for share libraries can cause
newLISP to segfault when not used correctly. The reference documentation marks
these functions with a <a href="#shared-lib"><font size="+1">&#x26A0;</font></a> character linking
to this chapter.</p>

<p><a href="http://www.newlisp.org/CodePatterns-jp.html">
Code Patterns in newLISP</a> 文書の
<a href="http://www.newlisp.org/CodePatterns-jp.html#toc-23">
23. Extending newLISP</a> の章も見てください。<br />
See also the chapter 
<a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-23">
23. Extending newLISP</a> in the
<a href="http://www.newlisp.org/downloads/CodePatterns.html">
Code Patterns in newLISP</a> document.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="newlisp-lib"></a>
<h2>7. newLISP as a shared library（共有ライブラリとしての newLISP）</h2>

<h3>newLISP as C library（C ライブラリとしての newLISP）</h3>

<p>newLISP は共有ライブラリとしてもコンパイルできます。
Linux や BSD 等の Unix ではライブラリを <tt>newlisp.so</tt> から呼び出します。
Windows なら <tt>newlisp.dll</tt>、macOS では <tt>newlisp.dylib</tt> です。
newLISP 共有ライブラリは他の共有ライブラリと同じようにして使えます。
newLISP 共有ライブラリは他のプログラム言語に newLISP 機能を導入するために必要なものです。<br />
newLISP can be compiled as a shared library. On Linux, BSDs and other Unix 
flavors the library is called <tt>newlisp.so</tt>. On Windows it is called 
<tt>newlisp.dll</tt> and <tt>newlisp.dylib</tt> on macOS. A newLISP shared 
library is used like any other shared library. A newLISP shared library is
only required for importing newLISP functionality into other programming 
languages.</p>

<p>導入できる主な関数は <tt>newlispEvalStr</tt> です。
この関数は <a href="#eval-string">eval-string</a> のように newLISP の式からなる文字列を取り、結果を文字列のアドレスに保存します。
結果は <a href="#get-string">get-string</a> を使って取り出せます。
結果の文字列はコマンド・ライン・セッションの出力のように整形されます。
ライン・フィード終端文字は含まれますが、プロンプト記号は含みません。<br />
The main function to import is <tt>newlispEvalStr</tt>. Like 
<a href="#eval-string">eval-string</a>, this function takes a string containing 
a newLISP expression and stores the result in a string address. The result can 
be retrieved using <a href="#get-string">get-string</a>. The returned string 
is formatted like output from a command-line session. It contains terminating 
line-feed characters, but not the prompt string.</p>

<p>関数 newlispEvalStr の呼び出しで、コンソールに向けられる出力（例えば、戻り値や <a href="#print">print</a> 文）は、通常文字列ポインタの整数値で返されます。
このポインタを関数 <a href="#get-string">get-string</a> に渡すことで、出力にアクセスできます。（訳注: <tt>get-string</tt> ）戻り値の（訳注:コンソールへの）出力を止めるには <a href="#silent">silent</a> 命令を使ってください。<br />
When calling <tt>newlispEvalStr</tt>, output normally directed to the 
console (e.g. return values or <a href="#print">print</a> statements) is 
returned in the form of an integer string pointer. The output can be accessed 
by passing this pointer to the <tt>get-string</tt> function. To silence the 
output from return values, use the <a href="#silent">silent</a> function.</p>

<p>コンソール上で <em>stdio</em> を使えるようにするには、<tt>newlispLibConsole</tt> を導入し、<tt>1</tt> をパラメータにして呼び出します。そうすれば、コンソール上から <em>stdin</em> と <em>stdout</em> に I/O できます。<br />
To enable <em>stdio</em> on the console, import the function <tt>newlispLibConsole</tt>
and call it with a parameter of <tt>1</tt> for enabling I/O on the console
with <em>stdin</em> and <em>stdout</em>.</p>

<p>v.10.3.3 から <tt>newlispCallback</tt> を使って、コールバックを登録できるようになりました。
詳細は、<a href="http://www.newlisp.org/CodePatterns-jp.html">Code Patterns in newLISP</a> 文書の <a href="http://www.newlisp.org/CodePatterns-jp.html#toc-24">24. newLISP compiled as a shared library</a> の章を読んでください。<br />
Since v.10.3.3 callbacks can also be registered using 
<tt>newlispCallback</tt>. For more information read the chapter 
<a href="http://www.newlisp.org/downloads/CodePatterns.html#toc-24">
24. newLISP compiled as a shared library</a> in the 
<a href="http://www.newlisp.org/downloads/CodePatterns.html">
Code Patterns in newLISP</a> document.</p>


<a name="newlisp-js-lib"></a>
<h3>newLISP as a JavaScript library（JavaScript ライブラリとしての newLISP）</h3>

<p>バージョン 10.5.7 から、newLISP は <a href="http://ja.wikipedia.org/wiki/Emscripten">Emscripten</a> ツールを使って、JavaScript にもコンパイルできます。
このライブラリを使えば、ウェブ・ブラウザのクライアント側で JavaScript や HTML のように newLISP を走らせることができます。
HTML ページには newLISP コードと JavaScript コードを混在でき、両言語間で互いに呼び出し合うことができます。
詳細情報は、配布パッケージ中の <tt>newlisp-js-x.x.x.zip</tt> を見てください。<tt>newlisp-js-lib.js</tt> ライブラリやドキュメント、例題アプリケーションが入っています。
ブラウザ・ベースの簡単な newLISP 開発環境がここからアクセスできます：<a href="http://www.newlisp.org/newlisp-js/">newlisp-js</a>。
このアプリケーションには、ほかの例題アプリケーションやドキュメントへのリンクが含まれています。
ダウンロード・リンクには、全パッケージがリンクされています。<br />
Since version 10.5.7, newLISP can be compiled to JavaScript using the
<a href="https://github.com/kripken/emscripten/wiki">Emscripten</a>
toolset. The library can be used to run newLISP clientr-side in a web 
browser, just like JavaScript or HTML. An HTML page can host both,
newLISP code and JavaScript code together. Both languages can call
each other. For more information see the <tt>newlisp-js-x.x.x.zip</tt>
distribution package which contains the library <tt>newlisp-js-lib.js</tt>,
documentaion and example applications. A small newLISP development
environment hosted in a browser can also be accessed here:
<a href="http://www.newlisp.org/newlisp-js/">newlisp-js</a>
The application contains links to another example application,
documentation and a download link for the whole package.</p>

<p>JavaScript ライブラリとしてコンパイルされた newLISP には、<a href="#JS">ウェブ・ブラウザ用 newLISP の API</a> の新関数がつかされています。<br />
newLISP compiled as a JavaScript library adds new functions linked 
from <a href="newlisp_manual.html-jp#JS">API for newLISP in a web browser</a>.
</p>
 

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="expressions"></a>
<h2>8. Evaluating newLISP expressions（newLISP 式の評価）</h2>

<p>この章は、newLISP 宣言文の評価と newLISP における整数と浮動小数点数の規則に関する短い紹介です。<br />
The following is a short introduction to newLISP statement evaluation 
and the role of integer and floating point arithmetic in newLISP.</p>

<p><a href="#load"> load</a> 関数を使った時、もしくは、コマンド・ライン上のコンソールで式を入力した時、トップ・レベルの式が評価されます。<br />
Top-level expressions are evaluated when using the 
<a href="#load"> load</a> function or when entering expressions in console 
mode on the command-line. </p>

<br/>

<a name="multiline"></a>
<h3>Interactive Multiline expressions（インターラクティブ時の複数行の式）</h3>

<p>最初に空行を入力することで、複数行の式を入力できます。
一旦、複数行モードに入り、再び入力モードに戻るには、空行を入力します。
そうすると、入力して宣言文一式が評価されます（出力は太字）：<br />
Multiline expressions can be entered by entering an empty line first. 
Once in multiline mode, another empty line returns from entry mode 
and evaluates the statement(s) entered (ouput in boldface):</p>

<pre>
&gt;
(define (foo x y)
    (+ x y))

<b>(lambda (x y) (+ x y))</b>
&gt; (foo 3 4)
<b>7</b>
&gt; _
</pre>		

<p>空行で enter キーを打って複数行モードに入ると、プロンプト表示が抑制されます。
もう一度空行を入力することで複数行モードから離れ、式が評価されます。<br />
Entering multiline mode by hitting the enter key on an empty line 
suppresses the prompt. Entering another empty line will leave the multiline 
mode and evaluate expressions.</p>

<p>空行入力の代わりに、<tt>[cmd]</tt> と <tt>[/cmd]</tt> のタグも使え、
その際、各々別の行として入力します。
このモードは、いくつかの newLISP 制御インターラクティブ IDE でも使われますし、関数<a href="#net-eval">net-eval</a> でも内部的に使われます。<br />
As an alternativo to entering empty lines, the <tt>[cmd]</tt> and 
<tt>[/cmd]</tt> tags are used, each entered on separate lines. This mode is 
used by some interactive IDEs controlling newLISP and internally by the 
<a href="#net-eval">net-eval</a> function.</p>

<br/>

<a name="int_float"></a>
<h3>Integer, floating point data and operators（整数、浮動小数点データと演算子）</h3>

<p>newLISP の関数や演算子は、整数と浮動小数点数を受け入れ、
必要な形式に変換します。
例えば、ビット操作演算子は浮動小数点数の小数部分を省いて整数に変換します。
同様に、三角関数は計算を実行する前、内部的に整数を浮動小数点数に変換しています。
<br />
newLISP functions and operators accept integer and floating point numbers, 
converting them into the needed format. For example, a bit-manipulating 
operator converts a floating point number into an integer by omitting the 
fractional part. In the same fashion, a trigonometric function will 
internally convert an integer into a floating point number before performing 
its calculation.</p>

<p>シンボル演算子
(<tt>+</tt> <tt>-</tt> <tt>*</tt> <tt>/</tt> <tt>%</tt> 
<tt>$</tt> <tt>~</tt> <tt>|</tt> <tt>^</tt> <tt>&lt;&lt;</tt> 
<tt>&gt;&gt;</tt>) は整数型の値を返します。
シンボルの代わりに単語としての名前を持つ関数や演算子（例えば、<tt>+</tt> の代わりに <tt>add</tt> ）は浮動小数点数を返します。
整数演算子は浮動小数点数の小数を切り捨て、整数にします。<br />
The symbol operators 
(<tt>+</tt> <tt>-</tt> <tt>*</tt> <tt>/</tt> <tt>%</tt> 
<tt>$</tt> <tt>~</tt> <tt>|</tt> <tt>^</tt> <tt>&lt;&lt;</tt> 
<tt>&gt;&gt;</tt>) return values of type integer. Functions and operators named 
with a word instead of a symbol (e.g., <tt>add</tt> rather than <tt>+</tt>) 
return floating point numbers. Integer operators truncate floating point 
numbers to integers, discarding the fractional parts.</p>

<p>newLISP は、基本的な算術演算子として二つのタイプを持っています：
整数 (<tt>+</tt> <tt>-</tt> <tt>*</tt> <tt>/</tt>) 用と
浮動小数点 (<tt>add</tt> <tt>sub</tt> <tt>mul</tt> <tt>div</tt>)用です。
算術関数は関数自身の型と互換性のある型に引数を変換します：整数関数は引数を整数に、浮動小数点関数は引数を浮動小数点に。
newLISP を他のスクリプト言語のように動作させるために、
整数演算子 <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt> で
浮動小数点演算 <tt>add</tt>, <tt>sub</tt>, <tt>mul</tt>, <tt>div</tt> を
実行するよう再定義できます：<br />
newLISP has two types of basic arithmetic operators: integer (<tt>+</tt> 
<tt>-</tt> <tt>*</tt> <tt>/</tt>) and floating point (<tt>add</tt> <tt>sub</tt> 
<tt>mul</tt> <tt>div</tt>). The arithmetic functions convert their arguments into types compatible 
with the function's own type: integer function arguments into integers, 
floating point function arguments into floating points. To make newLISP 
behave more like other scripting languages, the integer operators 
<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, and <tt>/</tt> can be redefined to 
perform the floating point operators <tt>add</tt>, <tt>sub</tt>, 
<tt>mul</tt>, and <tt>div</tt>:</p>

<pre>
(constant '+ add)
(constant '- sub)
(constant '* mul)
(constant '/ div)
 
;; or all 4 operators at once
(constant '+ add '- sub '* mul '/ div)
</pre>		

<p>
これで共通算術演算子 <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt> は、整数と浮動小数点数を受け入れ、浮動小数点の結果を返します。<br />
Now the common arithmetic operators <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, 
and <tt>/</tt> accept both integer and floating point numbers and return 
floating point results. </p>

<p>この場合、<a href="#imoport">導入</a>したライブラリから整数を想定している関数を使う時は、注意を払わなければなりません。
 <tt>+, -, *</tt>, <tt>/</tt> を再定義した後では、整数の代わりに倍精度浮動小数点数を不用意に渡すことになるかもしれません。
このような時は、関数 <a href="#int">int</a> を使って、浮動小数点数を整数に変換できます。
同様に、<a href="#float">float</a> 関数を使って、整数を浮動小数点数に変換することもできます：<br />
Care must be taken when <a href="#import">importing</a> from libraries 
that use functions expecting integers. After redefining <tt>+, -, *</tt>, 
and <tt>/</tt>, a double floating point number may be unintentionally passed 
to an imported function instead of an integer. In this case, floating point 
numbers can be converted into integers by using the function 
<a href="#int">int</a>. Likewise, integers can be transformed into 
floating point numbers using the <a href="#float">float</a> function:</p>

<pre>
(import "mylib.dll" "foo")  ; importing int foo(int x) from C
(foo (int x))               ; passed argument as integer
(import "mylib.dll" "bar")  ; importing C int bar(double y)
(bar (float y))             ; force double float
</pre>		

<p>newLISP に搭載されているモジュールには、
<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt> のデフォルトの実装を想定して書かれているものがあります。
これは、導入されるライブラリ関数のアドレス計算実行時に、最大スピードを与えるためです。
<br />
Some of the modules shipping with newLISP are written assuming the 
default implementations of <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, and <tt>/</tt>. 
This gives imported library functions maximum speed when performing address 
calculations. </p>

<p>newLISP 好きなら、
整数演算子として定義された <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt> をそのままにして、
明らかに要求された時のみ、<tt>add</tt>, <tt>sub</tt>, <tt>mul</tt>, <tt>div</tt> を使うでしょう。
バージョン 8.9.7 から、newLISP の整数演算は 64 ビット演算ですが、64 ビット倍精度浮動小数点数が提供する整数部の精度は 52 ビットです。
<br />
The newLISP preference is to leave <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, and 
<tt>/</tt> defined as integer operators and use <tt>add</tt>, <tt>sub</tt>, 
<tt>mul</tt>, and <tt>div</tt> when explicitly required. Since version 8.9.7, 
integer operations in newLISP are 64 bit operations, whereas 64 bit double 
floating point numbers offer only 52 bits of resolution in the integer part 
of the number.</p>
		
<br/>
<a name="big_int"></a>
<h3>Big integer, multiple precision arithmetic（算術精度に制限のない大整数）</h3>

<p>次の演算子、関数、述語が大整数に対して動作します：<br />
The following operators, functions and predicates work on big integers:</p>

<table  summary="functions working on big integers">
<tr align="left"><th>function</th><th>description</th></tr>

<tr>
<td width="16%"><a href="#arithmetic">+ - * / ++ -- %</a></td>
<td width="80%">算術演算子<br />arithmetic operators</td>
</tr>

<tr>
<td><a href="#logical">&lt; &gt; = &lt;= &gt;= !=</a></td>
<td>論理演算子<br />logical operators</td>
</tr>

<tr>
<td><a href="#abs">abs</a></td>
<td>数値の絶対値を返す<br />returns the absolute value of a number</td>
</tr>

<tr>
<td><a href="#gcd">gcd</a></td>
<td>最大公約数を計算する<br />calculates the greatest common divisor of a group of integers</td>
</tr>

<tr>
<td><a href="#evenp">even?</a></td>
<td>整数の偶奇をチェック<br />checks the parity of an integer number</td>
</tr>

<tr>
<td><a href="#oddp">odd?</a></td>
<td>整数の奇数をチェック<br />checks the parity of an integer number</td>
</tr>

<tr>
<td><a href="#numberp">number?</a></td>
<td>数値のチェック<br />checks if an expression is a float or an integer</td>
</tr>

<tr>
<td><a href="#zerop">zero?</a></td>
<td>ゼロのチェック<br />checks if an expression is 0 or 0.0</td>
</tr>
</table>


<p>これらの演算子や関数の引数の一番目が大整数なら、大整数モードで計算を実行します。このマニュアルの<a href="#function_ref">関数リファレンス</a>節では、これらの関数に <a href="#bigint"><font size="-1">bigint</font></a> が記されています。<br />
If the first argument in any of these operators and functions is a big 
integer, the calculation performed will be in big integer mode. In the
<a href="#function_ref">Function Reference</a> section of this manual
these are marked with a <a href="#bigint"><font size="-1">bigint</font></a>
suffix.</p> 

<p>文字通り、9223372036854775807 より大きい数や -9223372036854775808 より小さい数、または末尾に L のつく数は、大整数に変化され、そのモードで処理されます。 
整数や浮動小数点や文字列形式からの変換には、関数 <a href="#bigint">bigint</a> が使えます。
<a href="#bigintp">bigint?</a> 述語は大変数型かどうかをチェックします。<br />
Literal integer values greater than 9223372036854775807
or smaller than -9223372036854775808, or integers with an appended letter L,
will be converted and processed in big integer mode. The function 
<a href="#bigint">bigint</a>  can be used to convert from integer, float or string 
format to big integer. The predicate <a href="#bigintp">bigint?</a> checks for 
big integer type.</p>

<pre>
; first argument triggers big integer mode because it's big enough

(+ 123456789012345678901234567890 12345) <span class='arw'>&rarr;</span> 123456789012345678901234580235L

; first small literal put in big integer format by 
; appending L to guarantee big integer mode

(+ 12345L 123456789012345678901234567890) <span class='arw'>&rarr;</span> 123456789012345678901234580235L

(setq x 1234567890123456789012345)
(* x x) <span class='arw'>&rarr;</span> 1524157875323883675049533479957338669120562399025L

; conversion from bigint to float introduces rounding errors

(bigint (float (* x x))) <span class='arw'>&rarr;</span> 1524157875323883725344000000000000000000000000000L


; sequence itself does not take big integers, before using
; apply, the sequence is converted with bigint

(apply * (map bigint (sequence 1 100))) ; calculate 100!
<span class='arw'>&rarr;</span> 93326215443944152681699238856266700490715968264381
  62146859296389521759999322991560894146397615651828
  62536979208272237582511852109168640000000000000000
  00000000L

; only the first operand needs to be bigint for apply
; to work. The following gives the same result

(apply * (cons 1L (sequence 2 100)))

; length on big integers returns the number of decimal digits
(length (apply * (map bigint (sequence 1 100)))) 
<span class='arw'>&rarr;</span> 158 ; decimal digits

; all fibonacci numbers up to 200, only the first number 
; needs to be formatted as big integer, the rest follows
; automatically - when executed from the command line in 
; a 120 char wide terminal, this shows a beautiful pattern

(let (x 1L) (series x (fn (y) (+ x (swap y x))) 200))

</pre>

<p>整数と大整数が混在する算術計算では、演算誤差を避けるために第一引数を大整数にすべきです。<br /> When doing mixed integer / big integer arithmetic, the first
argument should be a big integer to avoid erratic behaviour.</p>

<pre>
; because the first argument is 64-bit, no big integer arithmetic 
; will be done, although the second argument is big integer 

(+ 123 12345L)
<span class='arw'>&rarr;</span> 12468

; the second argument is recognized as a big integer
; and overflows the capacity of a 64-bit integer

(+ 123 123453456735645634565463563546)
<span class='arw'>&rarr;</span> <span class="err">ERR: number overflows in function +</span>

; now the first argument converts to big integer and the
; whole expression is evaluates in big integer mode

(+ 123L 123453456735645634565463563546)
<span class='arw'>&rarr;</span> 123453456735645634565463563669L
</pre>

<p>浮動小数点が混在するほとんどの場合、整数と大整数に違いはありません。
第二引数に必要な変換を関数が自動的に行います。
通常の整数や浮動小数点のみを使う場合のオーバーフローは、バージョン 10.5.0 以前の newLISP と変わっていません。<br />
Under most circumstances mixing float, integers and big integers is 
transparent. Functions automatically do conversions when needed on the 
second argument. The overflow behavior when using normal integers and 
floats only, has not changed from newLISP versions previous to 10.5.0.</p>

<br/>
<a name="eval_rules"></a>
<h3>Evaluation rules and data types（評価ルールとデータ型）</h3>

<p>コマンドラインで入力または編集された式を評価します。
複雑なプログラムは Emacs や VI のようなエディタを使って入力できます。
それらのエディタはタイプ中に対応する括弧を示すモードを持っています。
<a href="#load">load</a> 関数を使って、コンソール・セクションに保存したファイルを呼び戻せます<br />
Evaluate expressions by entering and editing them on the command-line. 
More complicated programs can be entered using editors like Emacs and VI, 
which have modes to show matching parentheses while typing. Load a saved 
file back into a console session by using the <a href="#load">load</a> function.
</p>
<p>一行コメントは、<tt>;</tt>（セミコロン）か <tt>#</tt>（<a href="http://ja.wikipedia.org/wiki/%E7%95%AA%E5%8F%B7%E8%A8%98%E5%8F%B7">番号記号</a>）で始まり、行の終わりまで及びます。

 Linux/Unix 環境でスクリプト言語として newLISP を使う時は <tt>#</tt> が便利です。 Linux/Unix ではスクリプトとシェルの一行コメントして <tt>#</tt> が共通に使えるからです。<br />
A line comment begins with a <tt>;</tt> (semicolon) or a <tt>#</tt> (number sign) 
and extends to the end of the line. newLISP ignores this line during evaluation. 
The <tt>#</tt> is useful when using newLISP as a scripting language in 
Linux/Unix environments, where the <tt>#</tt> is commonly used as a line comment 
in scripts and shells.</p>

<p>コマンドラインで評価が起こると、結果はコンソール・ウィンドウに出力されます。<br />
When evaluation occurs from the command-line, the result is printed to the 
console window.</p>

<p>続く例題は → シンボルの左側のコードをタイプしてコマンドラインに入力します。
次の行に現れる結果は → シンボルの右側のコードと一致するはずです。<br />
The following examples can be entered on the command-line by typing the code 
to the left of the &nbsp;&nbsp;<span class='arw'>&rarr;</span> symbol. The 
result that appears on the next line should match the code to the right of the 
&nbsp;&nbsp;<span class='arw'>&rarr;</span> symbol.</p>

<p><b>nil</b> と <b>true</b> は、それ自身に評価される<a href="http://ja.wikipedia.org/wiki/%E3%83%96%E3%83%BC%E3%83%AA%E3%82%A2%E3%83%B3%E5%9E%8B">論理データ型</a>です：<br />
<b>nil</b> and <b>true</b> are Boolean data types that 
evaluate to themselves:</p>

<pre>
nil    <span class='arw'>&rarr;</span> nil
true   <span class='arw'>&rarr;</span> true
</pre>		

<p><b>整数</b> と <b>大整数</b> と <b>浮動小数点</b> の数値は、それ自身に評価されます：<br />
<b>Integers</b>, <b>big integers</b> and <b>floating point</b> numbers evaluate to themselves:</p>

<pre>
123      <span class='arw'>&rarr;</span> 123    ; decimal integer
0xE8     <span class='arw'>&rarr;</span> 232    ; hexadecimal prefixed by 0x
055      <span class='arw'>&rarr;</span> 45     ; octal prefixed by 0 (zero)
0b101010 <span class='arw'>&rarr;</span> 42     ; binary prefixed by 0b
1.23     <span class='arw'>&rarr;</span> 1.23   ; float
123e-3   <span class='arw'>&rarr;</span> 0.123  ; float in scientific notation

123456789012345678901234567890
<span class='arw'>&rarr;</span> 123456789012345678901234567890L ; parses to big integer
</pre>		
<p>
整数は符号ビットを含む 64 ビット数値です。
有効整数は -9,223,372,036,854,775,808 と +9,223,372,036,854,775,807 の間です。
浮動小数点数から変換される最大数は、二つの制限の内の一つに丸められます。
newLISP の内部整数で 32 ビット数値で制限されるもの（訳注：例えば、<a href="#date-parse">date-parse</a>）は、+2,147,483,647 か -2,147,483,648 のどちらかでオーバーフローします。<br />
Integers are 64-bit numbers including the sign bit. Valid integers 
are numbers between -9,223,372,036,854,775,808 and
+9,223,372,036,854,775,807.  Larger numbers converted from floating point 
numbers are truncated to one of the two limits. Integers internal to newLISP, 
which are limited to 32-bit numbers, overflow to either +2,147,483,647 or
-2,147,483,648.</p>

<p>浮動小数点数は IEEE 754 の 64 ビット倍精度です。
<a href="#format">format</a>で特殊フォーマット文字を使えば、符号無しで 18,446,744,073,709,551,615 まで、表示可能です。<br />
Floating point numbers are IEEE 754 64-bit doubles.
Unsigned numbers up to 18,446,744,073,709,551,615 can be displayed
using special formatting characters for <a href="#format">format</a>.</p>

<p>大整数はメモリが許す限り、桁数に制限がありません。
大整数に必要なメモリは：<br />
Big integers are of unlimited precision and only limited in size by memory. 
The memory requirement of a big integer is:</p>

<blockquote>
<b><i>bytes = 4 * ceil(digits / 9) + 4.</i></b>
</blockquote>

<p>ここで <i>digits</i> は十進数桁数、<i>bytes</i> は 8 ビット、<i>ceil</i>は次に大きい整数に丸める切り上げ関数です。<br />
Where <i>digits</i> are decimal digits, <i>bytes</i> are 8 bits and <i>ceil</i>
is the ceiling function rounding up to the next integer.</p>

<p><b>文字列</b> は null 文字も含めることができ、異なる終端を持つことが可能です。
文字列もそれ自身に評価されます。<br />
<b>Strings</b> may contain null characters and can have different 
delimiters. They evaluate to themselves.</p>

<pre>
"hello"             <span class='arw'>&rarr;</span>"hello"  
"\032\032\065\032"  <span class='arw'>&rarr;</span>"  A " 
"\x20\x20\x41\x20"  <span class='arw'>&rarr;</span>"  A "
"\t\r\n"            <span class='arw'>&rarr;</span>"\t\r\n" 
"\x09\x0d\x0a"      <span class='arw'>&rarr;</span>"\t\r\n"

;; null characters are legal in strings:
"\000\001\002"       <span class='arw'>&rarr;</span> "\000\001\002"
{this "is" a string} <span class='arw'>&rarr;</span> "this \"is\" a string"
 
;; use [text] tags for text longer than 2047 bytes:
[text]this is a string, too[/text]
<span class='arw'>&rarr;</span> "this is a string, too"
</pre>	
<p><tt>"</tt> (ダブル・クォート) で囲まれた文字列の中では、次の文字が <tt>\</tt> (バックスラッシュ、訳注：日本語環境では '&yen;' ) でエスケープ処理されます：<br />
Strings delimited by <tt>"</tt> (double quotes) will also process 
the following characters escaped with a <tt>\</tt> (backslash):</p>

<table  width="98%" summary="special characters in strings">
<tr align="left"><th>character</th><th>description</th></tr>
<tr><td><tt>\"</tt></td>
<td>ダブル・クォートで囲まれた文字列内のダブル・クォート<br />for a double quote inside a quoted string</td></tr>

<tr><td><tt>\n</tt></td>
<td>ライン・フィード文字 (ASCII 10)<br />for a line-feed character (ASCII 10)</td></tr>

<tr><td><tt>\r</tt></td>
<td>キャリッジ・リターン文字 (ASCII 13)<br />for a return character (ASCII 13)</td></tr>

<tr><td><tt>\b</tt></td>
<td>バックスペース文字 (ASCII 8)<br />for a backspace BS character (ASCII 8)</td></tr>

<tr><td><tt>\t</tt></td>
<td>タブ文字 (ASCII 9)<br />for a TAB character (ASCII 9)</td></tr>

<tr><td><tt>\f</tt></td>
<td>フォームフィード文字 (ASCII 12)<br />for a formfeed FF character (ASCII 12)</td></tr>

<tr><td><tt>\nnn</tt></td>
<td>３桁の１０進数によるアスキーコード数（000 から 255 までの nnn）<br />for a three-digit ASCII number (nnn format between 000 and 255)</td></tr>

<tr><td><tt>\xnn</tt></td>
<td>２桁の１６進数によるアスキーコード数（x00 から xff までの xnn）<br />for a two-digit-hex ASCII number (xnn format between x00 and xff)</td></tr>

<tr><td><tt>\unnnn</tt></td>
<td>４桁の１６進数による <tt>nnnn</tt> で表すユニコード文字。UTF8版の newLISP は、これを UTF8文字に変換します。<br />for a unicode character encoded in the four <tt>nnnn</tt> hexadecimal digits. newLISP will translate this to a UTF8 character in the UTF8 enabled versions of newLISP.</td>
</tr>

<tr><td><tt>\\</tt></td><td>バックスラッシュ文字 (ASCII 92) 自体（訳注：日本語環境では '&yen;' ）<br />for the backslash character (ASCII 92) itself</td></tr>
</table><br/>

<p>クォートの付いた文字列は 2,047 文字数を超えることはできません。
それより長い文字列は <tt>[text]</tt> と <tt>[/text]</tt> のタグの境界に使います。
newLISP では 2,047 文字を超える文字列出力に、このタグを自動的に使います。<br />
Quoted strings cannot exceed 2,047 characters. Longer strings should use 
the <tt>[text]</tt> and <tt>[/text]</tt> tag delimiters.  newLISP automatically 
uses these tags for string output longer than 2,047 characters.</p>

<p><tt>{</tt>（左波括弧）<tt>,</tt> <tt>}</tt>（右波括弧）と <tt>[text], [/text]</tt> の中ではエスケープ文字処理は行われません。<br />
The <tt>{</tt> (left curly bracket), <tt>}</tt> (right curly bracket), 
and <tt>[text], [/text]</tt> delimiters do not perform escape character 
processing.</p>

<p><b>ラムダとラムダ・マクロ式</b> は、それ自身に評価されます:<br />
<b>Lambda and lambda-macro expressions</b> evaluate to themselves:</p>

<pre>
(lambda (x) (* x x))                   <span class='arw'>&rarr;</span> (lambda (x) (* x x))
(lambda-macro (a b) (set (eval a) b))  <span class='arw'>&rarr;</span> (lambda-macro (a b) (set (eval a) b))
(fn (x) (* x x))                       <span class='arw'>&rarr;</span> (lambda (x) (* x x))  ; an alternative syntax
</pre>		

<p><b>シンボル</b> は、その内容に評価されます：<br />
<b>Symbols</b> evaluate to their contents:</p>

<pre>
(set 'something 123)  <span class='arw'>&rarr;</span> 123
something             <span class='arw'>&rarr;</span> 123
</pre>		

<p><b>コンテキスト</b> は、それ自身に評価されます：<br />
<b>Contexts</b> evaluate to themselves:</p>

<pre>
(context 'CTX)  <span class='arw'>&rarr;</span> CTX
CTX             <span class='arw'>&rarr;</span> CTX
</pre>		

<p><b>組込関数</b> も、それ自身に評価されます：<br />
<b>Built-in functions</b> also evaluate to themselves:</p>

<pre>
add                <span class='arw'>&rarr;</span> add &lt;B845770D&gt;
(eval (eval add))  <span class='arw'>&rarr;</span> add &lt;B845770D&gt;
(constant '+ add)  <span class='arw'>&rarr;</span> add &lt;B845770D&gt;
+                  <span class='arw'>&rarr;</span> add &lt;B845770D&gt;
</pre>		

<p>上記例で、&lt; &gt;（山括弧）間の数字は、関数<tt>add</tt> の16進数メモリ・アドレス（マシン依存）です。
組込プリミティブを表示する時、現れます。<br />
In the above example, the number between the &lt; &gt; (angle brackets) 
is the hexadecimal memory address (machine-dependent) of the 
<tt>add</tt> function. It is displayed when printing a built-in primitive.</p>

<p><b>クォート式</b> は評価されると、一個の '（シングル・クォート）を失います：<br />
<b>Quoted expressions</b> lose one ' (single quote) when evaluated:
</p>

<pre>
'something  <span class='arw'>&rarr;</span> something
''''any     <span class='arw'>&rarr;</span> '''any
'(a b c d)  <span class='arw'>&rarr;</span> (a b c d)
</pre>		

<p>シングル・クォートは、しばしば式を評価から<em>保護</em> するのに使われます。
（例えば、シンボル自身をその内容に代わりに参照したい時や、データを表現するリストを参照したい時）。<br />
A single quote is often used to <em>protect</em> an expression 
from evaluation (e.g., when referring to the symbol itself instead 
of its contents or to a list representing data instead of a function).</p>

<p><b>リスト</b> は（Scheme と同様に）リストの第一要素が評価されてから、式の残りが評価されます。
第一要素の評価結果がリストの残りの要素に適用されますので、第一要素は <tt>lambda</tt> 式、<tt>lambda-macro</tt> 式、<tt>primitive</tt>（組込）関数のどれかでなければなりません。 <br />
<b>Lists</b> are evaluated by first evaluating the first list element
before the rest of the expression (as in Scheme). The result of the 
evaluation is applied to the remaining elements in the list and must 
be one of the following: a <tt>lambda</tt> expression, <tt>lambda-macro</tt> 
expression, or <tt>primitive</tt> (built-in) function.</p>

<pre>
(+ 1 2 3 4)                  <span class='arw'>&rarr;</span> 10
(define (double x) (+ x x))  <span class='arw'>&rarr;</span> (lambda (x) (+ x x))
</pre>		

<p>または<br />or</p>

<pre>
(set 'double (lambda (x) (+ x x)))
(double 20)               <span class='arw'>&rarr;</span> 40
((lambda (x) (* x x)) 5)  <span class='arw'>&rarr;</span> 25
</pre>		

<p>newLISP はユーザ定義ラムダ式において、引数を左から右へと評価して、パラメータに（左から右へ）束縛して、その結果を式本体で使います。<br />
For a user-defined lambda expression, newLISP evaluates the arguments from 
left to right and binds the results to the parameters (also from left to 
right), before using the results in the body of the expression. </p>

<p>Scheme のように newLISP は式の<em>ファンクタ</em>（関数オブジェクト）部分を評価して、その引数に適用します：<br />
Like Scheme, newLISP evaluates the <em>functor</em> (function object) 
part of an expression before applying the result to its arguments. For 
example:</p>

<pre>
((if (&gt; X 10) * +) X Y)
</pre>		

<p>この式では、X の値次第で <tt>*</tt>（積）か <tt>+</tt>（和）を X と Y に適用しています。
<br />Depending on the value of X, this expression applies the <tt>*</tt> 
(product) or <tt>+</tt> (sum) function to X and Y.
</p>

<p><tt>lambda-macro</tt> 式は引数を評価しないので、言語の構文を拡張する使えます。。
ほとんどの組込関数は実行時に（必要な時）引数を左から右へ評価します。
この規則の例外については、このマニュアルのリファレンス部分に示してあります。
引数の全てか一部を評価しない Lisp 関数は<em>特殊形式</em> と呼ばれます。<br />
Because their arguments are not evaluated, <tt>lambda-macro</tt> 
expressions are useful for extending the syntax of the language. Most 
built-in functions evaluate their arguments from left to right (as needed) 
when executed. Some exceptions to this rule are indicated in the reference 
section of this manual. Lisp functions that do not evaluate all or some of 
their arguments are called <em>special forms</em>.</p>

<p><b>アレイ</b> は、それ自身に評価されます：<br />
<b>Arrays</b> evaluate to themselves:</p>

<pre>
(set 'A (array 2 2 '(1 2 3 4))) <span class='arw'>&rarr;</span> ((1 2) (3 4))
(eval A)                        <span class='arw'>&rarr;</span> ((1 2) (3 4))
</pre>


<p><b>シェル・コマンド</b>：コマンドライン上で第一文字が <tt>!</tt>（感嘆符）で、
その後にシェル・コマンドが続いているなら、そのコマンドが実行されます。
例えば、Unix の <tt>!ls</tt> や MS Windows の <tt>!dir</tt> は、現在の作業ディレクトリの（訳注：ファイルの）リストを表示させます。
<tt>!</tt> とシェル・コマンドの間にスペースは必要ありません。
<tt>!</tt> で始まるシンボルは内部式として許容され、コマンドライン上ではスペースを先行することでシンボルとして認識されます。
注記：このモードはシェル上で走っている時のみ動作し、他のアプリケーションから newLISP を制御している時は動作しません。<br />
<b>Shell commands</b>: If an <tt>!</tt> (exclamation mark) 
is entered as the first character on the command-line followed by a shell 
command, the command will be executed. For example, <tt>!ls</tt> on Unix or 
<tt>!dir</tt> on MS Windows will display a listing of the present working directory. 
No spaces are permitted between the <tt>!</tt> and the shell command. Symbols 
beginning with an <tt>!</tt> are still allowed inside expressions or  on the 
command-line when preceded by a space. Note: This mode only works when running 
in the shell and does not work when controlling newLISP from another 
application.
</p>
<blockquote>
（訳例：
<pre>
> (setq !a 1)
1
> !a
'a' は、内部コマンドまたは外部コマンド、
操作可能なプログラムまたはバッチ ファイルとして認識されていません。
> (eval !a)
1
>  !a
1
> </pre>
）
</blockquote>

<p>newLISP シェルから出るには、Linux/Unix では <tt>Ctrl-D</tt> を押し、MS Windows 上では <tt>(exit)</tt> とタイプするか <tt>Ctrl-C</tt> です。<br />
To exit the newLISP shell on Linux/Unix, press <tt>Ctrl-D</tt>; on MS Windows, 
type <tt>(exit)</tt> or <tt>Ctrl-C</tt>, then the x key.
</p>

<p>他のアプリケーションでシェル・コマンドにアクセスする時や newLISP に結果を渡したい時は、関数 <a href="#exec">exec</a> を使ってください。<br />
Use the <a href="#exec">exec</a> function to access shell commands from 
other applications or to pass results back to newLISP.
</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>
<a name="lambda_expressions"></a>
<h2>9. Lambda expressions in newLISP（newLISP におけるラムダ式）</h2>

<p>newLISP におけるラムダ式は、それ自身に評価され、正規のリストと同様に扱われます：<br />
Lambda expressions in newLISP evaluate to themselves and can be treated
just like regular lists:</p>

<pre>
(set 'double (lambda (x) (+ x x)))
(set 'double (fn (x) (+ x x)))      ; alternative syntax

(last double)  <span class='arw'>&rarr;</span> (+ x x)            ; treat lambda as a list
</pre>		

<p>注記：newLISP では、ラムダ式の前に <tt>'</tt> は必要ありません。ラムダ式が、それ自身に評価されるからです。<br />
Note: No <tt>'</tt> is necessary before the lambda expression because 
lambda expressions evaluate to themselves in newLISP.</p>

<p>（訳注：上記例の）二行目では、Paul Graham が Arc 言語プロジェクトで提案している代替構文 <tt>fn</tt> キーワードを使っています。<br />
The second line uses the keyword <tt>fn</tt>, an alternative syntax first suggested 
by Paul Graham for his Arc language project.
</p>
<p>ラムダ式は<em>ラムダ・リスト</em> という<em>リスト</em> の一形態であり、その引数は左から右、あるいは、右から左へと連結可能です。
例えば、<a href="#append">append</a> を使うと、左の引数が右に引数とつながります：<br />
A lambda expression is a <em>lambda list</em>, a subtype of <em>list</em>, and its 
arguments can associate from left to right or right to left. When using 
<a href="#append">append</a>, for example, the arguments associate from left to right:
</p>
<pre>
(append (lambda (x)) '((+ x x)))  <span class='arw'>&rarr;</span> (lambda (x) (+ x x))
</pre>		<p>
一方、<a href="#cons">cons</a> は右の引数（訳注：の先頭）に左の引数を入れます：<br />
<a href="#cons">cons</a>, on the other hand, associates the arguments from right to left:
</p>
<pre>
(cons '(x) (lambda (+ x x)))  <span class='arw'>&rarr;</span> (lambda (x) (+ x x))
</pre>		<p>
<tt>lambda</tt> キーワードはリスト中のシンボルではなく、<em>ラムダ・リスト</em> というリストの特殊<em>型</em> の指定子であることに注意してください。<br />
Note that the <tt>lambda</tt> keyword is not a symbol in a list, but a
designator of a special <em>type</em> of list: the <em>lambda list</em>.
</p>
<pre>
(length (lambda (x) (+ x x)))  <span class='arw'>&rarr;</span> 2
(first (lambda (x) (+ x x)))   <span class='arw'>&rarr;</span> (x)
</pre>		<p>
ラムダ式はユーザ定義の無名関数として、map または apply の引数にすることができます：<br />
Lambda expressions can be mapped or applied onto arguments to work as user-defined, anonymous functions:
</p>
<pre>
((lambda (x) (+ x x)) 123)           <span class='arw'>&rarr;</span> 246
(apply (lambda (x) (+ x x)) '(123))  <span class='arw'>&rarr;</span> 246
(map (lambda (x) (+ x x)) '(1 2 3))  <span class='arw'>&rarr;</span> (2 4 6)
</pre>		

<p>一ラムダ式を一シンボルに割り付け、関数として使うことができます：<br />
A lambda expression can be assigned to a symbol, which in turn can be 
used as a function:</p>

<pre>
(set 'double (lambda (x) (+ x x)))  <span class='arw'>&rarr;</span> (lambda (x) (+ x x))
(double 123)                        <span class='arw'>&rarr;</span> 246
</pre>		

<p>関数 <a href="#define">define</a> はラムダ式をシンボルに割り付ける簡単な方法です：<br />
The <a href="#define">define</a> function is just a shorter way of
assigning a lambda expression to a symbol:</p>

<pre>
(define (double x) (+ x x)))  <span class='arw'>&rarr;</span> (lambda (x) (+ x x))
(double 123)                  <span class='arw'>&rarr;</span> 246
</pre>		

<p>上の例で、ラムダ・リスト内の式は <tt>double</tt> の中身としてアクセス可能です：<br />
In the above example, the expressions inside the lambda list are still 
accessible within <tt>double</tt>:</p>

<pre>
(set 'double (lambda (x) (+ x x)))  <span class='arw'>&rarr;</span> (lambda (x) (+ x x))
(last double)                       <span class='arw'>&rarr;</span> (+ x x)
</pre>		

<p>リストを操作する関数を使かえば、ラムダ・リストをファースト・クラス・オブジェクトのように操作できます：<br />
A lambda list can be manipulated as a first-class object using any function 
that operates on lists:</p>

<pre>
(setf (nth 1 double) '(mul 2 x))     <span class='arw'>&rarr;</span> (lambda (x) (mul 2 x))
double                           <span class='arw'>&rarr;</span> (lambda (x) (mul 2 x))
(double 123)                     <span class='arw'>&rarr;</span> 246
</pre>		

<p>ラムダ式に与えられる引数は全てオプションであり、ユーザの指定がない時はデフォルトで <tt>nil</tt> が割り当てられます。
これにより、多様な変数を定義する関数を書くことが可能になります。<br />
All arguments are optional when applying lambda expressions and default to <tt>nil</tt> 
when not supplied by the user. This makes it possible to write functions with 
multiple parameter signatures.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="nil_and_true"></a>
<h2>10. <tt>nil</tt>, <tt>true</tt>, <tt>cons</tt>, and <tt>()</tt>（newLISP の <tt>nil</tt>、<tt>true</tt>、<tt>cons</tt> と <tt>()</tt>）</h2>

<p>newLISP において <tt>nil</tt> と <tt>true</tt> は共にシンボルで、論理値の<em>偽（false）<em>と</em> 真（true）</em>を表します。
<tt>nil</tt> と <tt>true</tt> 内容によっては異なる扱いを受けます。
次からの例は <tt>nil</tt> を使いますが、単に論理を逆にすることによって <tt>true</tt> にも適用できます。<br />
In newLISP, <tt>nil</tt> and <tt>true</tt> represent both the symbols and the 
Boolean values <em>false</em> and <em>true</em>. Depending on their context, 
<tt>nil</tt> and <tt>true</tt> are treated differently. The following examples use 
<tt>nil</tt>, but they can be applied to <tt>true</tt> by simply reversing the logic.
</p>

<p><tt>nil</tt> の評価は論理値の偽をもたらし、<tt>if</tt>, <tt>unless</tt>, <tt>while</tt>, <tt>until</tt>, <tt>not</tt> のようなフロー制御式内部で偽として取り扱われます。
同様に <tt>true</tt> の評価は真をもたらします。<br />
Evaluation of <tt>nil</tt> yields a Boolean false and is treated as such inside 
flow control  expressions such as <tt>if</tt>, <tt>unless</tt>, <tt>while</tt>, 
<tt>until</tt>, and <tt>not</tt>. Likewise, evaluating <tt>true</tt> yields true.</p>

<pre>
(set 'lst '(nil nil nil))  <span class='arw'>&rarr;</span> (nil nil nil)
(map symbol? lst)          <span class='arw'>&rarr;</span> (true true true)
</pre>		

<p>上の例では <tt>nil</tt> はシンボルです。
次の例では <tt>nil</tt> と <tt>true</tt> が評価され、論理値になります：<br />
In the above example, <tt>nil</tt> represents a symbol. In the following example, 
<tt>nil</tt> and <tt>true</tt> are evaluated and represent Boolean values:</p>

<pre>
(if nil "no" "yes")  <span class='arw'>&rarr;</span> "yes"
(if true "yes" "no") <span class='arw'>&rarr;</span> "yes"
(map not lst)        <span class='arw'>&rarr;</span> (true true true)
</pre>		

<p>newLISP では他の Lisp と違って、<tt>nil</tt> と空リスト () が同じではありません。
両者が論理値の偽として扱われるのは、<tt>and</tt>, <tt>or</tt>, <tt>if</tt>, <tt>while</tt>, <tt>unless</tt>, <tt>until</tt>, <tt>cond</tt> の条件式においてのみです。<br />
In newLISP, <tt>nil</tt> and the empty list <tt>()</tt> are not the same as in 
some other Lisps. Only in conditional expressions are they treated as a Boolean 
false, as in <tt>and</tt>, <tt>or</tt>, <tt>if</tt>, <tt>while</tt>, 
<tt>unless</tt>, <tt>until</tt>, and <tt>cond</tt>.</p>

<p><tt>nil</tt> は空リストではなく、論理値として扱われるので、<tt>(cons 'x '())</tt> の評価は <tt>(x)</tt> となりますが、<tt>(cons 'x nil)</tt> は <tt>(x nil)</tt> になります。
newLISP では、二つのアトムのコンス（<tt>cons</tt>）はドット対にならず、二つの要素のリストになります。
述語 <tt>atom?</tt> は <tt>nil</tt> に対して 真（true）ですが、空リストに対しては 偽（false）です。
newLISP では、空リストは単なる空のリストであり、<tt>nil</tt> ではありません。<br />
Evaluation of <tt>(cons 'x '())</tt> yields <tt>(x)</tt>, but <tt>(cons 'x nil)</tt> 
yields <tt>(x nil)</tt> because <tt>nil</tt> is treated as a Boolean value when 
evaluated, not as an empty list. The <tt>cons</tt> of two atoms in newLISP 
does not yield a dotted pair, but rather a two-element list. The predicate 
<tt>atom?</tt> is true for <tt>nil</tt>, but false for the empty list. The empty 
list in newLISP is only an empty list and not equal to <tt>nil</tt>.</p>

<p>newLISP で一つのリストは、リストの形をした一 newLISP セルです。
それはリストセルの中身を形作る要素を連結するリストの入れ物のようなものです。
newLISP に<em>ドット対</em> はありません。
なぜなら、Lisp セルの <em>cdr</em>（tail）部が常に他の Lisp セルを指し示し、けして、数値やシンボルのような基本データ型を指し示さないからです。
<em>car</em>（head）部のみが基本データ型になりえます。
初期の Lisp 実装では、<em>head</em> と <em>tail</em> の名前として <em>car</em> と <em>cdr</em> を使っていました。<br />
A list in newLISP is a newLISP cell of type list. It acts like a container for the 
linked list of elements making up the list cell's contents. There is no 
<em>dotted pair</em> in newLISP because the <em>cdr</em> (tail) part of a Lisp 
cell always points to another Lisp cell and never to a basic data type, such as a 
number or a symbol. Only the <em>car</em> (head) part may contain a basic data type. 
Early Lisp implementations used <em>car</em> and <em>cdr</em> for the names 
<em>head</em> and <em>tail</em>.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="arrays"></a>
<h2>11. Arrays（アレイ）</h2>

<p>newLISP のアレイは大規模リストの高速アクセスを可能にします。
関数 <a href="#array">array</a> を使って、新規アレイを構築し、既存リストの内容で初期化します。
リストをアレイに変換することもでき、その逆もできます。
リストの変更やアクセスに使用する関数のほとんどが、アレイにも同じように適用できます。
アレイにはどのようなデータ型も収めることができ、その組み合わせもしかりです。<br />
newLISP's arrays enable fast element access within large lists. New arrays 
can be constructed and initialized with the contents of an existing list 
using the function <a href="#array">array</a>. Lists can be converted into 
arrays, and vice versa. Most of the same functions used for modifying and 
accessing lists can be applied to arrays, as well. Arrays can hold any type 
of data or combination thereof.</p>

<p>アレイの生成・アクセス・変更に、特に使われるのが次の関数群です：<br />
In particular, the following functions can be used for creating, accessing, 
and modifying arrays:</p>

<table  summary="functions using arrays">
<tr align="left"><th>function</th><th>description</th></tr>

<tr>
<td width="16%"><a href="#append">append</a></td>
<td width="80%">アレイを結合する<br />appends arrays</td>
</tr>

<tr>
<td><a href="#apply">apply</a></td>
<td>関数や演算子を引数のリストに適用する<br />apply a function or operator to a list of arguments.</td>
</tr>

<tr>
<td><a href="#array">array</a></td>
<td>16次元までのアレイを作成し、初期化する<br />creates and initializes an array with up to 16 dimensions</td>
</tr>

<tr>
<td><a href="#array-list">array-list</a></td>
<td>アレイをリストに変換する<br />converts an array into a list</td>
</tr>

<tr>
<td><a href="#arrayp">array?</a></td>
<td>アレイかどうかをチェックする<br />checks if expression is an array</td>
</tr>

<tr>
<td><a href="#corr">corr</a></td>
<td><em>積率相関</em> 係数を計算する<br />calculates the <em>product-moment correlation</em> coefficient</td>
</tr>

<tr>
<td><a href="#det">det</a></td>
<td>行列式を返す<br />returns the determinant of a matrix</td>
</tr>

<tr>
<td><a href="#dolist">dolist</a></td>
<td>アレイの各要素で一回ずつ評価する<br />evaluates once for each element in an array vector</td>
</tr>

<tr>
<td><a href="#first">first</a></td>
<td>アレイの第1要素を返す<br />returns the first row of an array</td>
</tr>

<tr>
<td><a href="#invert">invert</a></td>
<td>逆行列を返す<br />returns the inversion of a matrix</td>
</tr>

<tr>
<td><a href="#last">last</a></td>
<td>アレイの最後の要素を返す<br />returns the last row of an array</td>
</tr>

<tr>
<td><a href="#map">map</a></td>
<td>引数のベクターに関数を適用し、その結果を返す<br />applies a function to vector(s) of arguments and returns results in a list.</td>
</tr>

<tr>
<td><a href="#mat">mat</a></td>
<td>行列のスカラー演算を実行する<br />perform scalar operations on matrices</td>
</tr>

<tr>
<td><a href="#multiply">multiply</a></td>
<td>行列の積をとる<br />multiplies two matrices</td>
</tr>

<tr>
<td><a href="#nth">nth</a></td>
<td>アレイの要素を返す<br />returns an element of and array</td>
</tr>

<tr>
<td><a href="#rest">rest</a></td>
<td>アレイの第一要素以外を返す<br />returns all but the first row of an array</td>
</tr>

<tr>
<td><a href="#reverse">reverse</a></td>
<td>アレイの要素や行を逆にする<br />reverses the elements or rows in an array</td>
</tr>

<tr>
<td><a href="#setf">setf</a></td>
<td>参照アレイの内容を設定する<br />sets contents of an array reference</td>
</tr>

<tr>
<td><a href="#slice">slice</a></td>
<td>アレイの一部を返す<br />returns a slice of an array</td>
</tr>

<tr>
<td><a href="#sort">sort</a></td>
<td>アレイの要素を並べ替える<br />sort the elements in an array</td>
</tr>

<tr>
<td><a href="#stats">stats</a></td>
<td>データ・ベクターの基本的統計値を計算する<br />calculates some basic statistics for a data vector</td>
</tr>

<tr>
<td><a href="#t-test">t-test</a></td>
<td><em>スチューデントのt</em> 統計値を使って、データ・サンプルの平均を比較する<br />compares means of data samples using the <em>Student's t</em> statistic</td>
</tr>

<tr>
<td><a href="#transpose">transpose</a></td>
<td>行列を置換する<br />transposes a matrix</td>
</tr>
</table><br/>

<p>newLISP はアレイをアレイ化して、多次元アレイを表します
（すなわち、アレイの要素が、アレイ自身ということ）。<br />
newLISP represents multidimensional arrays with an array of arrays 
(i.e., the elements of the array are themselves arrays).
</p>

<p>インターラクティブに使われている時、newLISP はアレイをリストのように出力・表示するので、それらを区別できません。<br />
When used interactively, newLISP prints and displays arrays as lists, 
with no way of distinguishing between them.</p>

<p>アレイ（または、アレイを含む変数）を<ruby><rb><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">直列化</a></rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>するには、関数 <a href="#source">source</a> か <a href="#save">save</a> を使ってください。
そうすれば、アレイの<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>時に <a href="#array">array</a> 宣言文が定義部分に含まれます。<br />
Use the <a href="#source">source</a> or <a href="#save">save</a> 
functions to serialize arrays (or the variables containing them). 
The <a href="#array">array</a> statement is included as part of 
the definition when serializing arrays.</p>

<p>リストと同様に、アレイの最後の要素から数え始める負数インデックスが使えます。<br />
Like lists, negative indices can be used to enumerate the elements 
of an array, starting from the last element.</p>

<p>アレイまたはリストでインデックスが境界を超えると、エラー・メッセージが発生します。<br />
An out-of-bounds index will cause an error message on an array or list.</p>

<p>正方でないアレイを作ることはできますが、<a href="#source">source</a> や <a href="#save">save</a> を使って<ruby><rb><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">直列化</a></rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>する際に正方化されます。
関数<a href="#array">array</a> が、常に正方形式アレイを構築するからです。<br />
Arrays can be non-rectangular, but they are made rectangular 
during serialization when using <a href="#source">source</a> or <a href="#save">save</a>. 
The <a href="#array">array</a> function always constructs arrays in rectangular form.</p>

<p>行列関数 <a href="#det">det</a>, <a href="#transpose">transpose</a>, 
<a href="#multiply">multiply</a>, <a href="#invert">invert</a> は、
入れ子リストで構築された行列や <a href="#array">array</a> で構築されたアレイで使うことができます。<br />
The matrix functions <a href="#det">det</a>, <a href="#transpose">transpose</a>, 
<a href="#multiply">multiply</a>, and <a href="#invert">invert</a> can be used on 
matrices built with nested lists or arrays built with <a href="#array">array</a>.</p>

<p>詳細は、このマニュアルの <a href="#array">array</a>, <a href="#arrayp">array?</a>,
 <a href="#array-list">array-list</a> のリファレンスで見てください。<br />
For more details, see <a href="#array">array</a>, <a href="#arrayp">array?</a>, 
and <a href="#array-list">array-list</a> in the reference section of this manual.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="indexing"></a>
<h2>12. Indexing elements of strings, lists, and arrays（文字列、リスト、アレイの要素指定）</h2>

<p>アレイ・リスト・文字列（複数の文字）の要素を一個以上の <em>int-index</em> (整数インデックス) で指定して、取り出す関数があります。
リストの要素数が <tt>N</tt> 個なら、正のインデックスの候補は <tt>0, 1, &hellip;, N-2, N-1</tt> です。
<em>int-index</em> が負なら、<tt>-N, -N+1, &hellip;, -2, -1</tt> となります。
負のインデックスに <tt>N</tt> を足すと、正のインデックスになります。
関数で対応していなければ、<tt>N-1</tt> を超えるインデックスや <tt>-N</tt> より小さいインデックスは、リストやアレイの境界外エラーを起こします。<br />
Some functions take array, list, or string elements (characters) 
specified by one or more <em>int-index</em> (integer index). The positive 
indices run <tt>0, 1, &hellip;, N-2, N-1</tt>, where <tt>N</tt> is the 
number of elements in the list. If <em>int-index</em> is negative, the sequence 
is <tt>-N, -N+1, &hellip;, -2, -1</tt>. Adding <tt>N</tt> to the negative 
index of an element yields the positive index. Unless a function does 
otherwise, an index greater than <tt>N-1</tt> or less then -N causes an 
out-of-bounds error in lists and arrays.</p>

<br/>

<a name="implicit_indexing"></a>
<h3>Implicit indexing for <tt>nth</tt>（<tt>nth</tt> 的な暗黙の要素指定）</h3>

<p>暗黙の要素指定は、リストとアレイの要素や文字列中の文字を取り出す <a href="#nth">nth</a> の代わりに使えます：<br />
Implicit indexing can be used instead of <a href="#nth">nth</a> to 
retrieve the elements of a list or array or the characters of a string:</p>

<pre>
(set 'lst '(a b c (d e) (f g)))

(lst 0)    <span class='arw'>&rarr;</span> a      ; same as (nth 0 lst)
(lst 3)    <span class='arw'>&rarr;</span> (d e)
(lst 3 1)  <span class='arw'>&rarr;</span> e      ; same as (nth '(3 1) lst)
(lst -1)   <span class='arw'>&rarr;</span> (f g)

(set 'myarray (array 3 2 (sequence 1 6)))

(myarray 1)     <span class='arw'>&rarr;</span> (3 4)
(myarray 1 0)   <span class='arw'>&rarr;</span> 3
(myarray 0 -1)  <span class='arw'>&rarr;</span> 2

("newLISP" 3)   <span class='arw'>&rarr;</span> "L"

; indexing strings in UTF8 enabled versions
 ("我能吞下玻璃而不伤身体。" 3) <span class='arw'>&rarr;</span> "下"
</pre>		

<p>インデックスにはリストも使えます。
その際の暗黙の要素指定は <a href="#push">push</a>、<a href="#pop">pop</a> のようなインデックス・ベクターを引数とする関数で使い、また <a href="#ref">ref</a>、<a href="#ref-all">ref-all</a> のようなインデックス・ベクターを生成する関数もあります。<br />
Indices may also be supplied from a list. In this way, implicit 
indexing works together with functions that take or produce index 
vectors, such as <a href="#push">push</a>, <a href="#pop">pop</a>, 
<a href="#ref">ref</a> and <a href="#ref-all">ref-all</a>.</p>

<pre>
(lst '(3 1))                <span class='arw'>&rarr;</span> e
(set 'vec (ref 'e lst))     <span class='arw'>&rarr;</span> (3 1)
(lst vec)                   <span class='arw'>&rarr;</span> e

; an empty index vector yields the original list or array

(lst '())  <span class='arw'>&rarr;</span> (set 'lst '(a b c (d e) (f g)))
</pre>		

<p>暗黙の要素指定は newLISP の構文ルールを壊しませんが、ｓ式のファンクタ（関数オブジェクト）位置において、他のデータ型に対する既存のルールを拡張することに注目してください。
オリジナルの Lisp では ｓ式リストの第一要素が関数となり、残りの要素を引数とします。
newLISP ではリストがｓ式のファンクタ（関数オブジェクト）位置に置かれると、リスト自身が自己インデックス関数のように機能し、それに続くインデックスを引数に使います。（訳注：オリジナルの Lisp では newLISP のように、ｓ式リストの第一要素にリストを置くことができません。）<br />
Note that implicit indexing is not breaking newLISP
syntax rules but is merely an expansion of existing rules to
other data types in the functor position of an s-expression. 
In original Lisp, the first element in an s-expression list
is applied as a function to the rest elements as arguments. In newLISP, a list 
in the functor position of an s-expression assumes self-indexing functionality 
using the index arguments following it.</p>

<p>暗黙の要素指定は明示形式よりも速く動作し、明示形式は内容によっては可読性を良くします。<br />
Implicit indexing is faster than the explicit forms, but the explicit forms
may be more readable depending on context.</p>

<p>UTF-8 版 newLISP では、文字列への暗黙の要素指定や <a href="#nth">nth</a> の使用は、1バイト境界ではなく、文字境界で作用します。<br />
Note that in the UTF-8&ndash;enabled version of newLISP, implicit indexing 
of strings or using the <a href="#nth">nth</a> function work on character rather 
than single-byte boundaries.</p>

<br/>

<a name="implicit_default"></a>
<h3>Implicit indexing and the default functor（暗黙の要素指定とデフォルト ファンクタ）</h3>

<p><em>デフォルト・ファンクタ</em> は、コンテキスト内でコンテキスト自身と同じ名前を持つファンクタ（関数オブジェクト）です。
<a href="#default_function">コンテキスト・デフォルト・ファンクタ</a> の章を見てください。
デフォルト・ファンクタは、リストを参照する機構として用意された暗黙の要素指定と一緒に使うことができます。<br />
The <em>default functor</em> is a functor inside a context with the same 
name as the context itself. See <a href="#default_function">The context 
default function</a> chapter. A default functor can be used together with 
implicit indexing to serve as a mechanism for referencing lists:</p>

<pre>
(set 'MyList:MyList '(a b c d e f g))

(MyList 0)   <span class='arw'>&rarr;</span> a
(MyList 3)   <span class='arw'>&rarr;</span> d
(MyList -1)  <span class='arw'>&rarr;</span> g

(3 2 MyList) <span class='arw'>&rarr;</span> (d e)
(-3 MyList)  <span class='arw'>&rarr;</span> (e f g)

(set 'aList MyList)

(aList 3)  <span class='arw'>&rarr;</span> d
</pre>		

<p>この例で <tt>aList</tt> は <tt>MyList:MyList</tt> をコピーすることなく、参照しています。
このコンテキストについての詳細情報は<a href="#context_vars">コンテキストを含む変数</a>を見てください。<br />
In this example, <tt>aList</tt> references <tt>MyList:MyList</tt>, 
not a copy of it. For more information about contexts, see 
<a href="#context_vars">Variables holding contexts</a>.</p>

<p>インデックスされたデフォルト・ファンクタは、次の例で示すように <a href="#setf">setf</a> と共に使うこともできます：<br />
The indexed default functor can also be used with <a href="#setf">setf</a> as shown 
in the following example:</p>

<pre>
(set 'MyList:MyList '(a b c d e f g))

(setf (MyList 3) 999)   <span class='arw'>&rarr;</span> 999
(MyList 3)              <span class='arw'>&rarr;</span> 999

MyList:MyList           <span class='arw'>&rarr;</span> (a b c 999 e f g)
</pre>

<br/>

<a name="implicit_rest_slice"></a>
<h3>Implicit indexing for <tt>rest</tt> and <tt>slice</tt>（<tt>rest</tt> や <tt>slice</tt> 的な暗黙の要素指定）</h3>

<p> <a href="#rest">rest</a> や <a href="#slice">slice</a> 的な暗黙形式は、リストに先行する一つないし二つの数値で形成され、それぞれオフセットと長さを表します。
長さが負数の場合は、リストや文字列の終端から数えます（訳注：この場合、終端を 0 と数えるので、リストや文字列の終端まで切り出す時は負数の長さを指定できない）：<br />
Implicit forms of <a href="#rest">rest</a> and <a href="#slice">slice</a> 
can be created by prepending a list with one or two numbers for offset and length.
If the length is negative it counts from the end of the list or string:</p>

<pre>
(set 'lst '(a b c d e f g))
; or as array
(set 'lst (array 7 '(a b c d e f g)))

(1 lst)      <span class='arw'>&rarr;</span> (b c d e f g)
(2 lst)      <span class='arw'>&rarr;</span> (c d e f g)
(2 3 lst)    <span class='arw'>&rarr;</span> (c d e)
(-3 2 lst)   <span class='arw'>&rarr;</span> (e f)
(2 -2 lst)   <span class='arw'>&rarr;</span> (c d e)

; resting and slicing is always on 8-bit char borders
; even on UTF8 enabled versions

(set 'str "abcdefg")

(1 str)      <span class='arw'>&rarr;</span> "bcdefg"
(2 str)      <span class='arw'>&rarr;</span> "cdefg"
(2 3 str)    <span class='arw'>&rarr;</span> "cde"
(-3 2 str)   <span class='arw'>&rarr;</span> "ef"
(2 -2 str)   <span class='arw'>&rarr;</span> "cde"

</pre>	

<p>UTF-8 版 newLISP で、（訳注：文字列に使う）関数 <a href="#rest">rest</a>、<a href="#first">first</a>、<a href="#last">last</a> はマルチバイト境界で作用します。
しかし、<a href="#rest">rest</a> や <a href="#slice">slice</a> 的な暗黙の要素指定形式は常に 1 バイト境界で作用するので、（訳注：UTF-8 版 newLISP でも）バイナリ・データに使えます。
正規表現関数 <a href="#find">find</a> と <a href="#regex">regex</a> からのオフセットと長さの結果も 1 バイト単位でカウントされるので、<a href="#slice">slice</a> やその暗黙形式と一緒に使えます。<br />
The functions <a href="#rest">rest</a>, <a href="#first">first</a>
and <a href="#last">last</a> work on multi-byte character boundaries
in UTF-8 enabled versions of newLISP. But the implicit indexing forms for
slicing and resting will always work on single-byte boundaries and can be used for 
binary content. Offset and length results from the regular expression functions 
<a href="#find">find</a> and <a href="#regex">regex</a> are also in single-byte
counts and can be further processed with <a href="#slice">slice</a> or it's
implicit form.</p>

<br/>

<a name="implicit_modify"></a>
<h3>Modify references in lists, arrays and strings（文字列、リスト、アレイの参照変更）</h3>

<p>インデックスで参照されるリスト、アレイ、文字列の部分は <a href="#setf">setf</a> を使って変更可能です：<br />
Parts in lists, arrays and strings referenced by indices can be modified using
<a href="#setf">setf</a>:</p>

<pre>
; lists

(set 'lst '(a b c d (e f g)))

(lst 1) <span class='arw'>&rarr;</span> b

(setf (lst 1) 'z) <span class='arw'>&rarr;</span> z

lst <span class='arw'>&rarr;</span> (a z c d (e f g))

(setf (lst -1) '(E F G)) <span class='arw'>&rarr;</span> (E F G)

lst <span class='arw'>&rarr;</span> (a z c d (E F G))

; arrays

(set 'myarray (array 2 3 (sequence 1 6))) <span class='arw'>&rarr;</span> ((1 2 3) (4 5 6))

(setf (myarray 1 2) 66) <span class='arw'>&rarr;</span> 66

myarray <span class='arw'>&rarr;</span> ((1 2 3) (4 5 66))

; strings

(set 's "NewLISP")

(setf (s 0) "n") <span class='arw'>&rarr;</span> "n"

s <span class='arw'>&rarr;</span> "newLISP"
</pre>


<p>全部が要素だけでも入れ子のリストでもアレイでも、この方法を使って変更できます。
暗黙の <a href="#rest">rest</a> や <a href="#slice">slice</a> を使って取り出す部分リストや部分アレイは、<a href="#setf">setf</a> を使って直接置き換えることができません。要素毎に置き換えましょう。
文字列では、一度に置き換えられるのは一文字だけですが、複数文字からなる文字列に置き換えることは可能です。<br /> 
Note that only full elements or nested lists or arrays can be changed this way.
Slices or rest parts of lists or arrays as used in implicit resting or slicing cannot
be substituted at once using <a href="#setf">setf</a>, but would have to be substituted
element by element. In strings only one character can be replaced at a time, but
that character can be replaced by a multi-character string.</p> 

<br/>

<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>


<a name="destructive"></a>
<h2>13. Destructive versus nondestructive functions（破壊的 対 非破壊的関数）</h2>

<p>newLISP 組込の多くは非破壊的（<em>副作用</em> 無し）で、既存のオブジェクトに触らず残しますが、その代わりに新しいオブジェクトを作ります。
とは言え、数は少ないですが、変数・リスト・アレイ・文字列の内容を<em>変更する</em> 関数もあります：<br />
Most of the primitives in newLISP are nondestructive (no <em>side effects</em>) 
and leave existing objects untouched, although they may create new ones. There 
are a few destructive functions, however, that <em>do</em> change the contents of a 
variable, list, array, or string:</p>

<table  width="98%" summary="destructive functions">
<tr align="left"><th>function</th><th>description</th></tr>

<tr>
<td><a href="#inci">++</a></td>
<td>整数モードで数値を加算する<br />increments numbers in integer mode</td>
</tr>

<tr>
<td><a href="#deci">--</a></td>
<td>整数モードで数値を減算する<br />decrements numbers in integer mode</td>
</tr>

<tr>
<td><a href="#bind">bind</a></td>
<td>リストの連想変数を束縛する<br />binds variable associations in a list</td>
</tr>

<tr>
<td><a href="#constant">constant</a></td>
<td>変数の内容を設定し、それをプロテクトする<br />sets the contents of a variable and protects it</td>
</tr>

<tr>
<td><a href="#extend">extend</a></td>
<td>リストか文字列を拡張する<br />extends a list or string</td>
</tr>

<tr>
<td><a href="#dec">dec</a></td>
<td>変数、リスト、アレイで参照される数値を減算する<br />decrements a number referenced by a variable, list or array</td>
</tr>

<tr>
<td><a href="#define">define</a></td>
<td>変数の内容を設定する<br />sets the contents of a variable</td>
</tr>

<tr>
<td><a href="#define-macro">define-macro</a></td>
<td>変数の内容を設定する<br />sets the contents of a variable</td>
</tr>

<tr>
<td><a href="#inc">inc</a></td>
<td>変数、リスト、アレイで参照される数値を加算する<br />increments a number referenced by a variable, list or array</td>
</tr>


<tr>
<td><a href="#let">let</a></td>
<td>ローカル変数を宣言し、初期化する<br />declares and initializes local variables</td>
</tr>

<tr>
<td><a href="#letn">letn</a></td>
<td>入れ子の let のように、ローカル変数を初期化する<br />initializes local variables incrementally, like nested lets</td>
</tr>

<tr>
<td><a href="#letex">letex</a></td>
<td>式中にローカル変数を展開し、その後評価する<br />expands local variables into an expression, then evaluates</td>
</tr>

<tr>
<td><a href="#net-receive">net-receive</a></td>
<td>バッファ変数を読み取る<br />reads into a buffer variable</td>
</tr>

<tr>
<td><a href="#pop">pop</a></td>
<td>リストや文字列から要素を取り出す<br />pops an element from a list or string</td>
</tr>

<tr>
<td><a href="#pop-assoc">pop-assoc</a></td>
<td>連想リストから連想を取り去る<br />removes an association from an association list</td>
</tr>

<tr>
<td><a href="#push">push</a></td>
<td>リストや文字列に新要素を挿入する<br />pushes a new element onto a list or string</td>
</tr>

<tr>
<td><a href="#read">read</a></td>
<td>バッファ変数を読み取る<br />reads into a buffer variable</td>
</tr>

<tr>
<td><a href="#receive">receive</a></td>
<td>親または子プロセスからメッセージを受け取る<br />receives a message from a parent or child process</td>
</tr>

<tr>
<td><a href="#replace">replace</a></td>
<td>リストや文字列内の要素を置換する<br />replaces elements in a list or string</td>
</tr>

<tr>
<td><a href="#reverse">reverse</a></td>
<td>リストや文字列の並びを逆にする<br />reverses a list or string</td>
</tr>

<tr>
<td><a href="#rotate">rotate</a></td>
<td>リストや文字列の文字の並びを回転する<br />rotates the elements of a list or characters of a string</td>
</tr>

<tr>
<td><a href="#set">set</a></td>
<td>変数の内容を設定する<br />sets the contents of a variable</td>
</tr>

<tr>
<td><a href="#setf">setf setq</a></td>
<td>シンボル、リスト、アレイ、文字列の内容を設定する<br />sets the contents of a variable, list, array or string</td>
</tr>

<tr>
<td><a href="#set-ref">set-ref</a></td>
<td>入れ子リスト中の要素を検索し、置き換える<br />searches for an element in a nested list and replaces it</td>
</tr>

<tr>
<td><a href="#set-ref-all">set-ref-all</a></td>
<td>入れ子リスト中の要素を検索し、全ての検出を置き換える<br />searches for an element in a nested list and replaces all instances</td>
</tr>

<tr>
<td><a href="#sort">sort</a></td>
<td>リストやアレイの要素を並べ替える<br />sorts the elements of a list or array</td>
</tr>

<tr>
<td><a href="#swap">swap</a></td>
<td>リストや文字列内の二つの要素を入れ替える<br />swaps two elements inside a list or string</td>
</tr>

<tr>
<td><a href="#write">write</a></td>
<td>ファイルや文字列バッファに文字列を書き込む<br />write a string to a file or string buffer</td>
</tr>

</table><br/>

<br/>

<a name="make_nondestructive"></a>
<h3>Make a destructive function non-destructive（破壊的関数の非破壊的関数化）</h3>

<p>破壊的関数の中には、目標オブジェクトを関数 <a href="#copy">copy</a> で包み、非破壊的関数にできるものもあります。<br />
Some destructive functions can be made non-destructive by wrapping the target 
object into the <a href="#copy">copy</a> function.</p>

<pre>
(set 'aList '(a b c d e f))

(replace 'c (copy aList)) <span class='arw'>&rarr;</span> (a b d e f)

aList <span class='arw'>&rarr;</span> (a b c d e f)
</pre>

<p><tt>aList</tt> のリストは、変更されずに残っています。<br />
The list in <tt>aList</tt> is left unchanged.</p>

<br/>

<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="return"></a>
<h2>14. Early return from functions, loops, and blocks（関数、ループ、ブロックからの早期脱出）</h2>

<p>以下の記述は、ループや <a href="#begin">begin</a> 式内のフロー制御を中断する方法です。<br />
What follows are methods of interrupting the control flow inside both 
loops and the <a href="#begin">begin</a> expression.</p>

<p>ループ機能 <a href="#dolist">dolist</a>、<a href="#dotimes">dotimes</a> には、ループから早期に脱出する条件式をオプションで取ることができます。
<a href="#catch">catch</a> と <a href="#throw">throw</a> はループ本体から脱出する汎用形式であり、他の形式または制御ブロックに適用することもできます。<br />
The looping functions <a href="#dolist">dolist</a> and <a href="#dotimes">
dotimes</a> can take optional conditional expressions to leave the loop
early. <a href="#catch">catch</a> and <a href="#throw">throw</a> are a more
general form to break out of a loop body and are also applicable to other
forms or statement blocks.</p>

<br/>

<a name="flow_catch_throw"></a>
<h3>Using <tt>catch</tt> and <tt>throw</tt>（<tt>catch</tt> と <tt>throw</tt> の使用）</h3>

<p>newLISP は関数型言語なので、関数や繰り返しからの脱出に <tt>break</tt> 宣言文や <tt>return</tt> 宣言文を使いません。
代わりに、関数 <a href="#catch">catch</a> と <a href="#throw">throw</a> を使って、関数や繰り返しのいかなる場所からも脱出できます：<br />
Because newLISP is a functional language, it uses no <tt>break</tt> or 
<tt>return</tt> statements to exit functions or iterations. Instead, a 
block or function can be exited at any point using the functions 
<a href="#catch">catch</a> and <a href="#throw">throw</a>:</p>

<pre>
(define (foo x)
    ...
    (if condition (throw 123))
    ...
    456
)
									 
;; if condition is true

(catch (foo p))  <span class='arw'>&rarr;</span> 123
									 
;; if condition is not true
									 
(catch (foo p))  <span class='arw'>&rarr;</span> 456
</pre>		

<p>ループからの脱出も同じ方法で作動します：<br />
Breaking out of loops works in a similar way:</p>

<pre>
(catch
    (dotimes (i N)
        (if (= (foo i) 100) (throw i))))

<span class='arw'>&rarr;</span> value of i when foo(i) equals 100
</pre>		

<p>この例は、繰り返しを <tt>N</tt> 回実行する前に脱出する方法を示しています。<br />
The example shows how an iteration can be exited before executing <tt>N</tt> times.</p>

<p><a href="#throw">throw</a> を使えば、複数の場所からの戻りを記述できます：<br />
Multiple points of return can be coded using <a href="#throw">throw</a>:</p>

<pre>
(catch (begin
    (foo1)
    (foo2)
    (if condition-A (throw 'x))
    (foo3)
    (if condition-B (throw 'y))
    (foo4)
    (foo5)))
</pre>		

<p><tt>condition-A</tt> が真なら <tt>x</tt> が <tt>catch</tt> 式から戻り、<tt>condition-B</tt> が真なら戻り値は <tt>y</tt> になります。
それ以外では、<tt>foo5</tt> の結果が戻り値として使われます。<br />
If <tt>condition-A</tt> is true, <tt>x</tt> will be returned from 
the <tt>catch</tt> expression; if <tt>condition-B</tt> is true, the 
value returned is <tt>y</tt>. Otherwise, the result from <tt>foo5</tt> 
will be used as the return value.</p>

<p><a href="#catch">catch</a> の代わりとして、
誤ったコードやユーザ定義例外によって起こるエラーを捕まえるために、関数<a href="#error-event">error-event</a> が使えます。<br />
As an alternative to <a href="#catch">catch</a>, the <a href="#error-event">error-event</a> 
function can be used to catch errors caused by faulty code or user-initiated exceptions.</p>

<p>関数 <a href="#throw-error">throw-error</a>は、ユーザ定義エラーを発生するために使います。<br />
The <a href="#throw-error">throw-error</a> function may be used
to throw user-defined errors.</p>

<br/>

<a name="flow_and_or"></a>
<h3>Using <tt>and</tt> and <tt>or</tt>（<tt>and</tt> と <tt>or</tt> の使用）</h3>

<p>論理関数 <a href="#and">and</a> と <a href="#or">or</a> を使って、宣言文ブロックに内包する関数の論理値結果次第で脱出するよう構成できます：<br />
Using the logical functions <a href="#and">and</a> and 
<a href="#or">or</a>, blocks of statements can be built 
that are exited depending on the Boolean result of the enclosed functions:</p>

<pre>
(and
    (func-a)
    (func-b)
    (func-c)
    (func-d))
</pre>		

<p>この <a href="#and">and</a> 式はブロック中の関数が <tt>nil</tt> か <tt>()</tt> (empty list) を返すと、すぐに戻ります。
先行する関数群がどれもブロックからの脱出を起こさなければ、最後の関数の結果が返ります。<br />
The <a href="#and">and</a> expression will return as soon as one of the 
block's functions returns <tt>nil</tt> or an <tt>()</tt> (empty list). 
If none of the preceding functions causes an exit from the block, the 
result of the last function is returned.</p>

<p><a href="#or">or</a> も同じようにして使えます：<br />
<a href="#or">or</a> can be used in a similar fashion:</p>

<pre>
(or
    (func-a)
    (func-b)
    (func-c)
    (func-d))
</pre>		
<p>この <a href="#or">or</a> 式の結果を返すのは <tt>nil</tt> でも<em>なく</em>、<tt>()</tt> でも<em>ない</em> 値を返す最初の関数です。<br />
The result of the <a href="#or">or</a> expression will be the first function 
that returns a value which is <em>not</em> <tt>nil</tt> or <tt>()</tt>.
</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="scoping"></a>
<h2>15. Dynamic and lexical scoping（ダイナミック・スコープとレキシカル・スコープ）</h2>
（訳注：ダイナミック・スコープ（動的スコープ）とレキシカル・スコープ（構文スコープ）については、
以下が参考になります。
<ul>
<li><a href="http://ja.wikipedia.org/wiki/%E9%9D%99%E7%9A%84%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97">静的スコープ（static scope）、構文スコープ （lexical scope）</a></li>
<li><a href="http://ja.wikipedia.org/wiki/%E5%8B%95%E7%9A%84%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%97">動的スコープ（dynamic scope）</a></li>
<li><a href="http://en.wikipedia.org/wiki/Scope_(programming)">Scope</a>, 
<a href="http://en.wikipedia.org/wiki/Scope_(programming)#Lexical_scoping">Lexical_scoping</a> and 
<a href="http://en.wikipedia.org/wiki/Scope_(programming)#Dynamic_scoping">Dynamic_scoping</a></li>
</ul>
　）<br />
<p>newLISP はコンテキスト<em>内で</em> ダイナミック・スコープを使っています。
コンテキストはレキシカルに閉じた名前空間です。
この方法により、newLISP のプログラム部品は <em>レキシカル・スコープ</em> の利点を取る別々の名前空間で活かされます。<br />
newLISP uses dynamic scoping <em>inside</em> contexts. A context is a lexically 
closed namespace. In this way, parts of a newLISP program can live in different 
namespaces taking advantage of <em>lexical scoping</em>.</p>
<p>ラムダ式の変数シンボルが引数に束縛されると、古い束縛はスタックにプッシュされます。
ラムダ式から離れると、newLISP が自動的に元の変数束縛に復帰させます。<br />
When the parameter symbols of a lambda expression are bound to its arguments, 
the old bindings are pushed onto a stack. newLISP automatically restores the 
original variable bindings when leaving the lambda function. </p>
<p>
次の例は<em>ダイナミック・スコープ</em> の動作を示しています。
ここでボールドのテキストは newLISP の出力です：<br />
The following example illustrates the <em>dynamic scoping</em> mechanism. 
The text in bold is the output from newLISP:</p>

<pre>
&gt; (set 'x 1)
<b>1</b>
&gt; (define (f) x)
<b>(lambda () x)</b>
&gt; (f)
<b>1</b>
&gt; (define (g x) (f))
<b>(lambda (x) (f))</b>
&gt; (g 0)
<b>0</b>
&gt; (f)
<b>1</b> 
&gt; _
</pre>	

<p>変数 <tt>x</tt> は最初 <tt>1</tt> に設定されています。
しかし、<tt>(g 0)</tt> が呼ばれて <tt>x</tt> は <tt>0</tt> に束縛されます。だから、<tt>(g 0)</tt> 実行中、<tt>(f)</tt> の出力する <tt>x</tt> は <tt>0</tt> になります。
<tt>(g 0)</tt> の実行後に <tt>(f)</tt> を呼び出すと、再び <tt>x</tt> を <tt>1</tt> として出力します。<br />
The variable <tt>x</tt> is first set to <tt>1</tt>. But when <tt>(g 0)</tt> 
is called, <tt>x</tt> is bound to <tt>0</tt> and <tt>x</tt> is reported 
by <tt>(f)</tt> as <tt>0</tt> during execution of <tt>(g 0)</tt>. After 
execution of <tt>(g 0)</tt>, the call to <tt>(f)</tt> will report <tt>x</tt> as <tt>1</tt> again.</p>

<p>これが、ローカル変数の束縛が関数内部でのみ起こる C や Java のような言語で見られる <em>レキシカル・スコープ</em> 動作との違いです。
C のようなレキシカル・スコープ言語では、<tt>(f)</tt> はシンボル <tt>x</tt> のグローバル束縛として、常に <tt>1</tt> を出力します。<br />
This is different from the <em>lexical scoping</em> mechanisms found in 
languages like C or Java, where the binding of local parameters occurs inside 
the function only. In lexically scoped languages like C, <tt>(f)</tt> would 
always print the global bindings of the symbol <tt>x</tt> with <tt>1</tt>.
</p>

<p>次のユーザ定義関数において、関数の引数と同じ名前の変数名をクォート付きシンボルで渡すことが、名前の衝突を起こすことに着目してください：<br />
Be aware that passing quoted symbols to a user-defined function causes a 
name clash if the same variable name is used as a function parameter:</p>

<pre>
(define (inc-symbol x y) (inc (eval x) y))
(set 'y 200)
(inc-symbol 'y 123)  <span class='arw'>&rarr;</span> 246
y                    <span class='arw'>&rarr;</span> 200  ; y is still 200
</pre>		
<p>グローバル <tt>y</tt> は関数の第二引数と同じシンボル名なので、
<tt>inc-symbol</tt> は 246 (123 + 123) を返します。グローバル <tt>y</tt> を影響を受けずに残ります。
ダイナミック・スコープの<em>変数補足</em> はユーザ定義関数に対してシンボル参照を渡す時、不利になります。
newLISP は変数補足を避けるいくつかの方法を提供しています。<br />
Because the global <tt>y</tt> shares the same symbol as the function's second parameter, 
<tt>inc-symbol</tt> returns 246 (123 + 123), leaving the global <tt>y</tt> unaffected. 
Dynamic scoping's <em>variable capture</em> can be a disadvantage when passing symbol 
references to user-defined functions. newLISP offers several methods to avoid variable
capture.</p>

<ul>
<li>シンボルの受け渡しに関数 <a href="#args">args</a> が使えます。<br />The function <a href="#args">args</a> can be used when passing symbols.</li>
<li>一個以上の関数を <a href="#contexts">コンテキスト</a> と呼ばれるそれ自身の名前空間に置くことができます。コンテキストの<em>外から</em> シンボルをアクセスしたり、定義された関数を呼び出したりしても、シンボル名の衝突は起こりません。<br />One or more user-defined functions can be placed in their own namespace called a <a href="#contexts">context</a>. A symbol name clash cannot occur when accessing symbols and calling functions from <em>outside</em> of the defining context.</li>
</ul>

<p>
インターフェイスや関数ライブラリを作成する時は、コンテキストを使って関連する関数をグループ化すべきです。
これにより、レキシカルな〝壁〟で関数が囲われ、関数呼び出し時の変数名衝突が回避されます。
<br />〝〟
Contexts should be used to group related functions when creating interfaces 
or function libraries. This surrounds the functions with a lexical "fence", 
thus avoiding variable name clashes with the calling functions.
</p>
<p>
newLISP はレキシカル・スコープの異なる形式でコンテキストを使います。
詳細な情報は<a href="#contexts">コンテキスト</a>と<a href="#default_function">デフォルト・ファンクタ</a>の章を見てください。<br />
newLISP uses contexts for different forms of lexical scoping. See the 
chapters <a href="#contexts">Contexts</a> and 
<a href="#default_function">default functors</a> for more information.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="contexts"></a>
<h2>16. Contexts（コンテキスト）</h2>

<p>newLISPでは、<em>コンテキスト（contexts）</em> と呼ばれる名前空間でシンボルを分離できます。
各コンテキストは、他の全てのコンテキストから隔離された個別のシンボル表を持っています。
一コンテキスト内のシンボルは他のコンテキストからは見えませんので、異なるコンテキストで同じ名前を使っても衝突しません。<br />
In newLISP, symbols can be separated into namespaces called <em>contexts</em>. 
Each context has a private symbol table separate from all other contexts. Symbols 
known in one context are unknown in others, so the same name may be used 
in different contexts without conflict.</p>

<p>コンテキストは隔離された変数と関数の定義からなるモジュールの構築に使われます。
また、キー・値対の辞書を作るためにも使えます。
コンテキストはコピー可能で、動的に変数を割り当てられ、引数としても渡せます。
newLISP におけるコンテキストはレキシカルに分離された名前空間を持ちますので、<em>レキシカル・スコープ</em> によるプログラミングとプログラミングのソフトウェア・オブジェクト形式を可能にします。<br />
Contexts are used to build modules of isolated variable and function definitions. 
They also can be used to build dictionaries fo key values pairs. Contexts can be 
copied and dynamically assigned to variables or passed as arguments by reference.
Because contexts in newLISP have lexically separated namespaces, they allow programming 
with <em>lexical scoping</em> and software object styles of programming.</p>

<p>コンテキストはシンボルのルート部分に明示されているか、コンテキスト <tt>MAIN</tt> です。
この章では、コンテキスト・シンボルに大文字を使っていますが、小文字も使えます。<br />
Contexts are identified by symbols that are part of the root or <tt>MAIN</tt> 
context. Although context symbols are uppercased in this chapter, lowercase symbols 
may also be used.</p>

<p>コンテキスト <tt>MAIN</tt> はコンテキスト名であると同時に、組込関数のシンボル及び <tt>true</tt> や <tt>nil</tt> のような特殊シンボルを保持しています。
コンテキスト <tt>MAIN</tt> は newLISP を走らせる度に自動的に生成されます。
MAIN の全シンボルを見るには newLISP 開始後、次の式を入力してみてください：<br />
In addition to context names, <tt>MAIN</tt> contains the symbols for built-in 
functions and special symbols such as <tt>true</tt> and <tt>nil</tt>. The <tt>MAIN</tt> 
context is created automatically each time newLISP is run. To see all the symbols 
in MAIN, enter the following expression after starting newLISP:</p>

<pre>
(symbols)
</pre>

<p><tt>MAIN</tt> の全シンボルで使われているコンテキストを見るには：<br />
To see all symbols in <tt>MAIN</tt> pointing to contexts:</p>

<pre>
(filter context? (map eval (symbols)))
</pre>

<p>現在のコンテキストが <tt>MAIN</tt> 以外にある時、<tt>MAIN</tt> にある全コンテキスト・シンボルを見るには：<br />
To seel all context symbols in <tt>MAIN</tt> when <tt>MAIN</tt> is not the
current context:</p>

<pre>
(filter context? (map eval (symbols MAIN)))
</pre>

<br/>

<a name="context_rules"></a>
<h3>Symbol creation in contexts（コンテキストでのシンボル生成）</h3>

<p>次の規則により、
作成したシンボルがどのコンテキストに割り当てられるかが明確になり、コンテキストへの理解が簡単になるでしょう。<br />
The following rules should simplify the process of understanding contexts by 
identifying to which context the created symbols are being assigned.</p>

<ol>
<li>
<p>newLISP の各式の解析と翻訳は、トップ階層から始まります。
この解析中に全シンボルを生成します。
式は翻訳された後に、評価されます。<br />
newLISP first parses and translates each expression starting at the top
level. All symbols are created during this phase. After the expression is 
translated, it gets evaluated.</p>
</li>

<li>
<p>
関数 <a href="#load">load</a>、<a href="#sym">sym</a>、<a href="#eval-string">eval-string</a> が呼ばれた時、newLISP はシンボルを最初に<em>見つけた時</em>、生成します。
newLISP はソースの読み込み時に、評価が起こる<em>前</em> にシンボルを生成します。
関数 <a href="#reader-event">reader-event</a> は、式を読み込み翻訳するがそれを評価する前に、その式を検査できます。
関数 <a href="#read-expr">read-expr</a> は、newLISP のソースを評価することなく、読み込み翻訳するためだけに使えます。<br />
A symbol is created when newLISP first <em>sees</em> it, while calling 
the <a href="#load">load</a>, <a href="#sym">sym</a>, 
or <a href="#eval-string">eval-string</a> functions. When newLISP reads 
a source file, symbols are created <em>before</em> evaluation occurs. The
<a href="#reader-event">reader-event</a> function can be used to inspect
the expression after reading and translating but before evaluation. The
<a href="#read-expr">read-expr</a> function can be used to read and translate
newLISP source without evaluation.</p>
</li>

<li>
<p>コード翻訳中に見知らぬシンボルに出会うと、その定義の検索を現在のコンテキスト内で始めます。
検索に失敗すると、<tt>MAIN</tt> 内で組込関数、コンテキスト、グローバル変数において検索を続けます。
定義が見つからなければ、そのシンボルが現在のコンテキスト内にローカルに生成されます。<br />
When an unknown symbol is encountered during code translation, 
a search for its definition begins inside the current context. 
Failing that, the search continues inside <tt>MAIN</tt> for a 
built-in function, context, or global symbol. If no definition 
is found, the symbol is created locally inside the current context.</p>
</li>

<li>
<p>いったんシンボルが生成され、特定のコンテキストに割り当てられると、
そのシンボルは、関数 <a href="#delete">delete</a> を使って削除されるまで、そのコンテキストに恒久的に従属します。<br />
Once a symbol is created and assigned to a specific context, 
it will belong to that context permanently or until it is deleted
using the <a href="#delete">delete</a> function.</p>
</li>

<li>
<p>ユーザ定義関数の評価の際、そのシンボルを持っている名前空間にコンテキストが切り替わります。<br />
When a user-defined function is evaluated, the context is switched 
to the name-space which owns that symbol.</p>
</li>

<li>
<p>コンテキスト切り替えは <a href="#load">load</a>、<a href="#sym">sym</a>、<a href="#eval-string">eval-string</a> の間のシンボル生成にのみ、影響を及ぼします。
ロードされたファイルのトップ階層でコンテキスト切り替えが起こる時以外は、<a href="#load">load</a> はデフォルトで MAIN にロードします。
より良い使い方は、関数<a href="#sym">sym</a> と <a href="#eval-string">eval-string</a> を使う時に、コンテキストを常に指定することです。
コンテキスト切り替えは関数内部でなく、通常プログラムのトップ階層でのみ起こります。<br />
A context switch only influences symbol creation during 
<a href="#load">load</a>, <a href="#sym">sym</a>,
or <a href="#eval-string">eval-string</a>. 
<a href="#load">load</a> by default loads into MAIN except
 when context switches occur on the top level of the file loaded. 
For better style, the context should always be specified when the functions 
<a href="#sym">sym</a> and <a href="#eval-string">eval-string</a> 
are used. A context switch should normally only be made on the top level of 
a program, never inside a function.</p>
</li>
</ol>

<br/>

<a name="creating_contexts"></a>
<h3>Creating contexts（コンテキスト生成）</h3>

<p>コンテキストは関数 <a href="#context">context</a> の使用または暗黙の生成、いずれかで生成されます。
最初の方法は同じコンテキストに従属する多量のコードを書く時に使われます：<br />
Contexts can be created either by using the <a href="#context">context</a>
function or via implicit creation. The first method is used when writing larger 
portions of code belonging to the same context:</p>

<pre>
(context 'FOO)

(set 'var 123)

(define (func x y z)
    ... )

(context MAIN)
</pre>		

<p>コンテキストがまだ存在していないなら、コンテキスト・シンボルはクォートされていなければなりません。
コンテキストは、それ自身に評価されるので、MAIN のように既に存在するコンテキストはクォートを必要としません。<br />
If the context does not exist yet, the context symbol must be quoted.
If the symbol is not quoted, newLISP assumes the symbol is a variable
holding the symbol of the context to create. Because a context evaluates
to itself, already existing contexts like MAIN do not require quoting.</p>

<p>上記 newLISP コードを読み込む時、最初の宣言文 <tt>(context 'FOO)</tt> が評価されます。
これが newLISP に FOO への名前空間切り替えを起こさせ、残りの式を読み込んで評価する際に、以下のシンボル <tt>var</tt>、<tt>x</tt>、<tt>y</tt>、<tt>z</tt> 全てがコンテキスト FOO 内に生成されます。<br />
When newLISP reads the above code, it will read, then evaluate the first
statement: <tt>(context 'FOO)</tt>. This causes newLISP to switch the namespace
to FOO and the following symbols <tt>var</tt>, <tt>x</tt>, <tt>y</tt> and <tt>z</tt>
will all be created in the FOO context when reading and evaluating the remaining
expressions.</p>

<p>コンテキスト・シンボルは変更から保護されています。一回でもコンテキスト用に使われたシンボルは、<a href="#delete">delete</a> を使わなければ、他の用途に使うことはできません。<br />
A context symbol is protected against change. Once a symbol refers to a 
context, it cannot be used for any other purpose, except when using 
<a href="#delete">delete</a>.</p>

<p>名前空間 FOO の外から <tt>var</tt> や <tt>func</tt> を参照するには、コンテキスト名の先付けが必要です：<br />
To refer to <tt>var</tt> or <tt>func</tt> from anywhere else outside  the 
FOO namespace they need to be prefixed with the context name:</p>

<pre>
FOO:var <span class='arw'>&rarr;</span> 123

(FOO:func p q r)
</pre>	

<p>注記、上記例で名前空間 <tt>FOO</tt> に属しているのは <tt>func</tt> だけです。
シンボル <tt>p q r</tt> は全て、<tt>FOO:func</tt> の呼び出しで作られますが、現在のコンテキストの一部です。<br />
Note, that in the above example only <tt>func</tt> belongs to the <tt>FOO</tt>
name space the symbols <tt>p q r</tt> all are part of the current context
from which the <tt>FOO:func</tt> call is made.</p>	

<p>コンテキストに所属する全てのシンボルを表示するために、関数 <a href="#symbols">symbols</a> が使えます：<br />
The <a href="#symbols">symbols</a> function is used to show all symbols
belonging to a context:</p>

<pre>
(symbols FOO) <span class='arw'>&rarr;</span> (FOO:func FOO:var FOO:x FOO:y FOO:z)

; or from inside the context symbols are shown without context prefix
(context FOO) <span class='arw'>&rarr;</span> (func x y z)
(sumbols)
</pre>		

<br/>

<b>Implicitly creating contexts（コンテキストの暗黙の生成）</b>

<p>まだ存在していないコンテキストが参照された時は、暗黙に生成されます。
関数 <tt>context</tt> とは違い、コンテキストが切り替わりません。
続く宣言文は、全て <tt>MAIN</tt> コンテキスト内で実行されます：<br />
A context is implicitly created when referring to one that does not yet exist. 
Unlike the <tt>context</tt> function, the context is not switched. The following 
statements are all executed inside the <tt>MAIN</tt> context:</p>

<pre>
&gt; (set 'ACTX:var "hello")
<b>"hello"</b>
&gt; ACTX:var
<b>"hello"</b>
&gt; _
</pre>		

<p>コンテキスト名を先付けしたシンボルだけが、コンテキストのシンボルになることに気をつけてください：<br />
Note that only the symbols prefixed with their context name will be part
of the context:</p>

<pre>
(define (ACTX:foo x y) 
    (+ x y))
</pre>		

<p>上記コードが MAIN にロードされると、<tt>foo</tt> のみが <tt>ACTX</tt> のシンボルです。
シンボル <tt>x</tt> と <tt>y</tt> は、まだ <tt>MAIN</tt> のシンボルです。
<tt>ACTX:foo</tt> の構成要素を全て <tt>ACTX</tt> コンテキスト内に作るには、
<tt>ACTX</tt> を先付するか、
トップ階層でコンテキスト切り替えを実施してから、関数を定義する必要があります。<br />
When above code is loaded in MAIN only <tt>foo</tt> will be part of 
<tt>ACTX</tt>. The symbols <tt>x</tt> and <tt>y</tt> will still be part
of <tt>MAIN</tt>. To make all locals of <tt>ACTX:foo</tt> members of
the <tt>ACTX</tt> context, they would either have to be prefixed with
<tt>ACTX</tt>, or the whole funtion must be preceded by a context
switch satement at the top level:</p>

<pre>
(context 'ACTX)
(define (foo x y)
    (+ x y)
(context MAIN

;; above same as

(define (ACTX:foo ACTX:x ACTX:y)
    (+ ACTX:x ACTX:y))
</pre>

<br/>

<b>Loading module files（モジュール・ファイルのロード）</b>
<br/>

<p>コマンドラインで <a href="#load">load</a> を使ってソース・ファイルをロードしている時や関数 <a href="#eval-string">eval-string</a> または <a href="#sym">sym</a> を実行している時は、関数 <tt>context</tt> が全てのシンボルと関数定義をどの名前空間に置くべきかを newLISP ソース・コード・リーダー に知らせます：<br />
When loading source files on the command-line with <a href="#load">load</a>, 
or when executing the functions <a href="#eval-string">eval-string</a> or 
<a href="#sym">sym</a>, the <tt>context</tt> function tells the newLISP source
code reader in which namespace to put all of the symbols and definitions:

<pre>
;;; file MY_PROG.LSP
;;
;; everything from here on goes into GRAPH
(context 'GRAPH)
				 
(define (draw-triangle x y z)
    (&hellip;))

(define (draw-circle)
    (&hellip;))
									 
;; show the runtime context, which is GRAPH
(define (foo)
    (context))
									 
;; switch back to MAIN
(context 'MAIN)
				 
;; end of file					
</pre>		

<p>関数 <tt>draw-triangle</tt> と <tt>draw-circle</tt>&mdash;変数 <tt>x</tt>、<tt>y</tt>、<tt>z</tt> を伴う&mdash;はコンテキスト <tt>GRAPH</tt> の部品です。
これらのシンボルは <tt>GRAPH</tt> にとってのみ既知です。
これらの関数を他のコンテキストから呼び出すには <tt>GRAPH:</tt> を先付けします：<br />
The <tt>draw-triangle</tt> and <tt>draw-circle</tt> functions &mdash; along 
with their <tt>x</tt>, <tt>y</tt>, and <tt>z</tt> parameters &mdash; are now 
part of the <tt>GRAPH</tt> context. These symbols are known only to <tt>GRAPH</tt>. 
To call these functions from another context, prefix them with <tt>GRAPH:</tt></p>

<pre>
(GRAPH:draw-triangle 1 2 3)
(GRAPH:foo)  <span class='arw'>&rarr;</span> GRAPH										
</pre>		

<p>最後の宣言文は、実行中のコンテキストを（function <tt>foo</tt> の context である）<tt>GRAPH</tt> に切り替える方法です。<br />
The last statement shows how the runtime context has changed to 
<tt>GRAPH</tt> (function <tt>foo</tt>'s context).</p>

<p>他のコンテキストからシンボル同士を比較する時は、シンボルの名前とコンテキストの両方を使います。
全修飾シンボルから名前部分を取り出すには関数 <a href="#term">term</a> を使います。<br />
A symbol's name and context are used when comparing symbols from different 
contexts. The <a href="#term">term</a> function can be used to extract the term 
part from a fully qualified symbol.</p>

<pre>
;; same symbol name, but in different context
(= 'A:val 'B:val)                    <span class='arw'>&rarr;</span> nil
(= (term 'A:val) (term 'B:val))      <span class='arw'>&rarr;</span> true
(= (prefix 'A:val) (prefix 'B:val))  <span class='arw'>&rarr;</span> nil
</pre>		

<p>注記：上記例のシンボルが <tt>'</tt> (single quote) でクォートされているのは、シンボルのコンテキストではなく、シンボル自身を対象にしているからです。<br />
Note: The symbols in above example are quoted with a <tt>'</tt> (single quote) 
because we are interested in the symbol itself, not in the contents of the symbol.</p>

<br/>

<a name="scope_global"></a>
<h3>Global scope（グローバル スコープ）</h3>

<p>デフォルトでは組込関数と <tt>nil</tt> や <tt>true</tt> のような特殊シンボルのみが、<tt>MAIN</tt> 以外のコンテキスト内でも見ることができます。
どのコンテキストでもシンボルが見られるようにするには関数 <a href="#global">global</a> を使います：<br />
By default, only built-in functions and symbols like <tt>nil</tt> and
<tt>true</tt> are visible inside contexts other than <tt>MAIN</tt>. To make a symbol 
visible to every context, use the <a href="#global">global</a> function:</p>

<pre>
(set 'aVar 123) <span class='arw'>&rarr;</span> 123
(global 'aVar)  <span class='arw'>&rarr;</span> aVar

(context 'FOO)  <span class='arw'>&rarr;</span> FOO

aVar            <span class='arw'>&rarr;</span> 123
</pre>		

<p><tt>global</tt> 宣言文を使わなければ、二番目の <tt>aVar</tt> は <tt>123</tt> の代わりに <tt>nil</tt> を返すでしょう。
<tt>FOO</tt> が前もって定義されたシンボル（この例では <tt>aVar</tt>）を持っているなら、代わりに&mdash;グローバルのシンボルではなく&mdash;<em>その</em> シンボル（訳注：FOO:aVar）の値が返ります。
コンテキスト <tt>MAIN</tt> 上でのみ、シンボルをグローバルにできることに注意してください（訳注：関数<a href="#global">global</a> は <tt>MAIN</tt> 上でしか使えないということ）。<br />
Without the <tt>global</tt> statement, the second <tt>aVar</tt> would have 
returned <tt>nil</tt> instead of <tt>123</tt>. If <tt>FOO</tt> had a previously 
defined symbol (<tt>aVar</tt> in this example) <em>that</em> symbol's value 
&mdash; and not the global's &mdash; would be returned instead. Note that only 
symbols from the <tt>MAIN</tt> context can be made global.</p>

<p>関数 <a href="#global">global</a> を使って、いったんコンテキストに対して透過にしてしまうと、（訳注：<a href="#delete">delete</a> を使って削除しない限り）再びシンボルを隠すことはできません。<br />
Once it is made visible to contexts through the <a href="#global">global</a> function, 
a symbol cannot be hidden from them again.</p>

<br/>

<a name="protection"></a>
<h3>Symbol protection（シンボル保護）</h3>

<p>関数 <a href="#constant">constant</a> を使うことによって、
シンボルは設定され、同時に変更から保護されます：<br />
By using the <a href="#constant">constant</a> function, symbols can be both set 
and protected from change at the same time:</p>

<pre>
&gt; (constant 'aVar 123)  <span class='arw'>&rarr;</span> 123
&gt; (set 'aVar 999)
<span class='err'>ERR: symbol is protected in function set : aVar</span>
&gt;_
</pre>		<p>
	constant と global の両方が必要なシンボルを一遍に定義できます：<br />
	A symbol needing to be both a constant and a global can be defined simultaneously:
</p>
<pre>
(constant (global 'aVar) 123)
</pre>		

<p>現在のコンテキストで <tt>constant</tt> により保護されたシンボルを再び上書きできるのは、関数 <tt>constant</tt> の使用です。（訳注：現在のコンテキストのシンボルにしか constant を使えません）。
これにより、他のコンテキストにおけるコードによる上書きからシンボルが保護されます。<br />
In the current context, symbols protected by <tt>constant</tt> can be overwritten 
by using the <tt>constant</tt> function again. This protects the symbols from 
being overwritten by code in other contexts.</p>

<br/>

<a name="overwrite"></a>
<h3>Overwriting global symbols and built-ins（グローバル・シンボルと組込の上書き）</h3>

<p>コンテキスト内でコンテキスト<em>自身</em> のシンボルを先付けすることにより、グローバルにされたシンボルや組込関数のシンボルを上書きできます：<br />
Global and built-in function symbols can be overwritten inside a
context by prefixing them with their <em>own</em> context symbol:</p>

<pre>
(context 'Account)

(define (Account:new &hellip;)
    (&hellip;))

(context 'MAIN)
</pre>		

<p>この例では、組込関数 <a href="#new">new</a> が異なる関数として、コンテキスト <tt>Account</tt>専用の <tt>Account:new</tt> に上書きされます。<br />
In this example, the built-in function <a href="#new">new</a> is overwritten by 
<tt>Account:new</tt>, a different function that is private to the <tt>Account</tt> context.
</p>

<br/>

<a name="context_vars"></a>
<h3>Variables containing contexts（コンテキストを含む変数）</h3>

<p>コンテキストの参照に変数が使えます：<br />Variables can be used to refer to contexts:</p>

<pre>
(set 'FOO:x 123)

(set 'ctx FOO)    <span class='arw'>&rarr;</span> FOO

ctx:x             <span class='arw'>&rarr;</span> 123

(set 'ctx:x 999)  <span class='arw'>&rarr;</span> 999

FOO:x             <span class='arw'>&rarr;</span> 999
</pre>		

<p>
関数を書く時、実行中に異なるコンテキストを参照する必要がある場合や、定義中に存在しないコンテキストを使う必要がある場合には、コンテキスト変数が使えます：<br />
Context variables are useful when writing functions, which need to refer to
different contexts during runtime or use contexts which do not exist during
definition:</p>

<pre>
(define (update ctx val)
    (set 'ctx:sum val)
    (ctx:func 999)
)

(context 'FOO)
(define (func x)
    (println "=&gt;" x))
(context MAIN)
</pre>		

<p>続いては、上記定義を使ったターミナル・セッションを示します。
プログラムの出力はボールドで示しています：<br />
The following shows a terminal session using above definitions. The program
output is shown in bold-face:</p>

<pre>
<b>&gt;</b> (update FOO 123)
<b>=&gt; 999</b>

<b>&gt;</b> FOO:sum
<b>123</b>
<b>&gt;</b>
</pre>		

<p>関数 <tt>update</tt> は第一変数として渡されるコンテキスト次第で、同じ関数でも異なる動作を表示します。<br />
The same one function <tt>update</tt> can display different behavior depending
on the context passed as first parameter. </p>

<br/>

<a name="sequence_creating"></a>
<h3>Sequence of creating or loading contexts（コンテキストの生成手順）</h3>

<p>コンテキストを生成する時あるいはロードする時の一連の手続き（訳注：<a href="context_rules">コンテキストでのシンボル生成</a>を参照）が予期しない結果をもたらすことがあります。
<tt>demo</tt> と呼ばれるファイルに次のコードを入力してみてください：<br />
The sequence in which contexts are created or loaded can lead to unexpected 
results. Enter the following code into a file called <tt>demo</tt>:</p>

<pre>
;; demo - file for loading contexts
(context 'FOO)
(set 'ABC 123)
(context MAIN)

(context 'ABC)
(set 'FOO 456)
(context 'MAIN)
</pre>		

<p>次に newLISP シェルでこのファイルをロードします：<br />
Now load the file into the newlisp shell:</p>

<pre>
&gt; (load "demo")
<span class='err'>ERR: symbol is protected in function set : FOO</span>
&gt; _
</pre>		

<p>ファイルのロードが <tt>FOO</tt> についてのエラー・メッセージを出しますが、<tt>ABC</tt> に対しては出しません。
最初のコンテキスト <tt>FOO</tt> がロードされた時、コンテキスト <tt>ABC</tt> はまだ存在しないのでローカル変数 <tt>FOO:ABC</tt> が生成されます。
<tt>ABC</tt> のロード時には、すでに <tt>FOO</tt> がグローバル・プロテクト・シンボルとして存在し、正常にプロテクトのフラグがセットされています。（訳注：だから <tt>FOO</tt> のエラーになったのです。）<br />
Loading the file causes an error message for <tt>FOO</tt>, but not 
for <tt>ABC</tt>. When the first context <tt>FOO</tt> is loaded, the 
context <tt>ABC</tt> does not exist yet, so a local variable <tt>FOO:ABC</tt> 
gets created. When <tt>ABC</tt> loads, <tt>FOO</tt> already exists as a global 
protected symbol and will be correctly flagged as protected.</p>

<p>この場合でも、コンテキスト <tt>ABC</tt> で <tt>FOO</tt> をローカル変数として使うことは可能で、<tt>ABC:FOO</tt> という風に明示的にコンテキストを先付けします。<br />
<tt>FOO</tt> could still be used as a local variable in the <tt>ABC</tt> 
context by explicitly prefixing it, as in <tt>ABC:FOO</tt>.</p>

<br/>

<a name="context_modules"></a>
<h3>Contexts as programming modules（プログラミング・モジュールとしてのコンテキスト）</h3>

<p>newLISP ではソースをモジュールに区分けするために、主にコンテキストを使います。
こうすることで各モジュールが異なる名前空間で動作するので、モジュールはレキシカルに分離され、他のモジュールに同一のシンボル名があっても衝突しません。<br />
Contexts in newLISP are mainly used for partitioning source into 
modules. Because each module lives in a different namespace, modules
are lexically separated and the names of symbols cannot clash with
identical names in other modules.</p>

<p>newLISP 配布の一部である <a href="http://newlisp.org/code/modules/">modules</a> には、モジュール・ファイルに関連する関数を置く方法や <a href="http://newlisp.org/newLISPdoc.html">newLISPdoc</a> ユーティリティを使ってモジュールを文書化する方法などの例があります。<br />
The <a href="http://newlisp.org/code/modules/">modules</a>, which are
part of the newLISP distribution, are a good example of how to put related
 functions into a module file, and how to document modules using
 the <a href="http://newlisp.org/newLISPdoc.html">newLISPdoc</a> utility.</p> 

<p>最良のプログラミング習慣は、一ファイルが一モジュールを含み、ファイル名は使っているコンテキスト名と同じでなくとも、似ていることです：<br />
For best programming practice, a file should only contain one module and 
the filename should be similar if not identical to the context name used:</p>

<pre>
;; file db.lsp, commonly used database functions

(context 'db)

;; Variables used throughout this namespace

(define db:handle)
(define db:host "http://localhost")

;; Constants

(constant 'Max_N 1000000)
(constant 'Path "/usr/data/")

;; Functions

(define (db:open ... )
    ... )

(define (db:close ... )
    ... )

(define (db:update ... )
    ... )
</pre>


<p>この例では、予め変数を定義しておく良い習慣を示しています。名前空間内のグローバル変数を定義したり、変化しない変数を constant として定義したりしておくことです。<br />
The example shows a good practice of predefining variables, which are global
inside the namespace, and defining as constants the variables that will not change.</p>

<p>ファイルが一個以上のコンテキストから構成されるなら、コンテキストの終りに <tt>MAIN</tt> への切り替えを明示しておくべきです：<br />
If a file contains more than one context, then the end of the context
should be marked with a switch back to <tt>MAIN</tt>:</p>

<pre>
;; Multi context file multi.lsp

(context 'A-ctx)
...
(context MAIN)

(context 'B-ctx)
...
(context MAIN)

(context 'C-ctx)
...
(context MAIN)
</pre>

<br/>

<a name="context_data"></a>
<h3>Contexts as data containers（データ・コンテナとしてのコンテキスト）</h3>

<p>コンテキストはデータ・コンテナとしてよく使われます。例えばハッシュ似の辞書や設定データのようなものです：<br />
Contexts are frequently uses as data containers, e.g. for hash-like dictionaries
and configuration data:</p>

<pre>
;; Config.lsp - configuration setup

(context 'Config)

(set 'user-name "admin")
(set 'password "secret")
(set 'db-name "/usr/data/db.lsp")
...

;; eof
</pre>

<p>名前空間 <tt>Config</tt> をロードすると、全ての変数をメモリに一度で設定できます：<br />
Loading the <tt>Config</tt> namespace will now load a whole variable set into
memory at once:</p>

<pre>
(load "Config.lsp")

(set 'file (open Config:db-name "read"))
...
...
</pre>

<p>同様の状況を一つの全データ・セットとしてセーブすることもできます：<br />
In a similar fashion a whole data set can be saved:</p>

<pre>
(save "Config.lsp" 'Config)
</pre>

<p>これに関する詳細は <a href="#serializing">コンテキスト・オブジェクトの<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby></a> の章で読んでください。<br />
Read more about this in the section <a href="#serializing">Serializing contexts</a>.</p>

<br/>

<a name="loading_contexts"></a>
<h3>Loading and declaring contexts（コンテキストのロードと宣言）</h3>

<p>モジュール・ファイルは、関数 <a href="#load">load</a> を使ってロードされます。
プログラミング・プロジェクトが互いに参照する多数のモジュールからなる時、コンテキストをロードする前に起こり得るコンテキストの前方参照による問題を避けるために、コンテキストを予約宣言できます。<br />
Module files are loaded using the <a href="#load">load</a> function.
If a programming project contains numerous modules that refer
to each other, they can be pre-declared to avoid problems due to context forward 
references that can occur before the loading of that context.</p>

<pre>
;; pre-declaring contexts, finish with Main to return
(map context '(Utilities Config Acquisition Analysis SysLog Main))

;; loading context module files
(load "Utilities.lsp" "Acquisition.lsp")
(load "http://192.168.1.34/Config.lsp") ; load module from remote location
(load "Analysis.lsp" "SysLog.lsp")

(define (run)
    ... )

(run)

;; end of file </pre>

<p>この例が示すように予約宣言してからロードすれば、宣言やロードの一連の手続き（訳注：<a href="context_rules">コンテキストでのシンボル生成</a>を参照）を気にする必要がありません。
まだロードされていないモジュールの変数や定義への前方参照が、全ての正しく翻訳されるからです。
コンテキスト・シンボルの誤用は、コンテキストがロードされる前に、エラー・メッセージが出ます。<br />
When pre-declaring and loading modules as shown in the example, the sequence
of declaration or loading can be neglected. All forward references to variables
and definitions in modules not loaded yet will be translated correctly. Wrong
usage of a context symbol will result in an error message before that context
is loaded.</p>

<p>コンテキスト切り替えで始まっていないモジュールは、常に <tt>MAIN</tt> にロードされます。ただし、<a href="#load">load</a> 宣言文の最後のオプションで目標コンテキストを指定している時は別です。
リモート位置から <tt>HTTP</tt> 経由でモジュールをロードする際は、関数 <a href="#load">load</a> の引数に <tt>URL</tt> を取れます。<br />
Modules not starting with a context switch are always loaded into <tt>MAIN</tt>
except when the <a href="#load">load</a> statement specifies a target context
as the last parameter. The <a href="#load">load</a> function can take <tt>URL</tt>s
to load modules from remote locations, via <tt>HTTP</tt>.</p>

<p><a href="#load">load</a> 宣言文終了後の現在のコンテキストは、常に <a href="#load">load</a> の前と同じです。<br />
The current context after the <a href="#load">load</a> statement will always be 
the same as before the <a href="#load">load</a>.</p>

<br/>

<a name="serializing"></a>
<h3>Serializing contexts（コンテキスト・オブジェクトの<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby> ）</h3>

<p><ruby><rb><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">直列化</a></rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>することは、ソフトウェア・オブジェクトをファイルやメモリ内の文字列に保存される文字ストリームに置き換えることで <em>持続性</em> をもたらします。
newLISP では、シンボルで参照されるもの全てが関数 <a href="#save">save</a> を使って、ファイルに<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>可能です。
シンボルと同様、コンテキストもコンテキスト名を使って保存されます：<br />
Serialization makes a software object <em>persistent</em>
by converting it into a character stream,
which is then saved to a file or string in memory.
In newLISP, anything referenced by a symbol can be serialized to a file
by using the <a href="#save">save</a> function.
Like other symbols, contexts are saved just by using their names:
</p>

<pre>
(save "mycontext.lsp" 'MyCtx)              ; save MyCtx to mycontext.lsp

(load "mycontext.lsp")                     ; loads MyCtx into memory

(save "mycontexts.lsp" 'Ctx1 'Ctx2 'Ctx3)  ; save multiple contexts at once
</pre>		

<p>
詳細については、関数 <a href="#save">save</a> (上記内容) と <a href="#source">source</a> (newLISP 文字列への<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>) を見てください。<br />
For details, see the functions <a href="#save">save</a> (mentioned above)
and <a href="#source">source</a> (for serializing to a newLISP string).
</p>

<br/>		
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>

<a name="default_function"></a>
<h2>17. The context default functor（コンテキスト・デフォルト・ファンクタ）</h2>

<p><em>デフォルト・ファンクタ</em> または<em>デフォルト・ファンクション</em> は、その名前空間と同じ名前を持つシンボルかユーザ定義関数かマクロです。
コンテキストを関数の名前として使う時、またはｓ式の関数位置で使う時、
newLISP はデフォルト・ファンクションを実行します。<br />
A <em>default functor</em> or <em>default function</em>
is a symbol or user-defined function or macro
with the same name as its namespace. When the context is used
as the name of a function or in the functor position of an s-expression,
newLISP executes the default function.</p>

<pre>
;; the default function

(define (Foo:Foo a b c) (+ a b c))

(Foo 1 2 3)  <span class='arw'>&rarr;</span> 6
</pre>

<p>デフォルト・ファンクションが <tt>MAIN</tt> と違うコンテキストから呼ばれる時には、コンテキストがすでに存在しているか、コンテキストと関数シンボルを生成する<em>前方宣言</em> が宣言されている必要があります：<br />
If a default function is called from a context other than <tt>MAIN</tt>,
the context must already exist or be declared with a <em>forward declaration</em>,
which creates the context and the function symbol:</p>

<pre>
;; forward declaration of a default function
(define Fubar:Fubar)    

(context 'Foo)
(define (Foo:Foo a b c)
    &hellip;
    (Fubar a b)         ; forward reference
    (&hellip;))         ; to default function

(context MAIN)

;; definition of previously declared default function

(context 'Fubar)
(define (Fubar:Fubar x y)
    (&hellip;))

(context MAIN)
</pre>		

<p>デフォルト・ファンクションはグローバル関数のように動作しますが、
それが呼ばれているコンテキストからはレキシカルに分離しています。<br />
Default functions work like global functions,
but they are lexically separate from the context in which they are called.</p>

<p>ラムダ関数やラムダ・マクロのように、デフォルト・ファンクションを
<a href="#map">map</a> や <a href="#apply">apply</a> で使うことができます。<br />
Like a lambda or lambda-macro function, default functions can be used 
with <a href="#map">map</a> or <a href="#apply">apply</a>.
</p>

<br/>

<a name="func_memory"></a>
<h3>Functions with memory（メモリとしての関数）</h3>

<p>デフォルト・ファンクションはその名前空間内にあるレキシカルに隔離された静的変数を更新できます：<br />
A default function  can update the lexically isolated static variables
contained inside its namespace:</p>

<pre>
;; a function with memory

(define (Gen:Gen x)
    (if Gen:acc
        (inc Gen:acc x)
        (setq Gen:acc x)))

(Gen 1)  <span class='arw'>&rarr;</span> 1
(Gen 1)  <span class='arw'>&rarr;</span> 2
(Gen 2)  <span class='arw'>&rarr;</span> 4
(Gen 3)  <span class='arw'>&rarr;</span> 7

gen:acc  <span class='arw'>&rarr;</span> 7
</pre>		

<p>関数 <tt>Gen</tt> が初めて呼ばれると、加算器に引数の値が設定されます。
関数が続けて呼ばれる度に <tt>Gen</tt> の加算器に引数の値が加算されていきます。<br />
The first time the <tt>Gen</tt> function is called,
its accumulator is set to the value of the argument.
Each successive call increments <tt>Gen</tt>'s accumulator
by the argument's value.</p>

<p>この <tt>Gen:Gen</tt> の定義は、<tt>(context 'Gen)</tt> と <tt>(context MAIN)</tt> 宣言文で囲むこと無しに、関数を関数名と同じ名前空間に置く方法を示しています。
この場合、明示的に名前空間を先付けしたシンボルだけが、コンテキスト <tt>Gen</tt> の中に置かれます。
上記例では、変数 <tt>x</tt> は <tt>MAIN</tt> の部品のままです。<br />
The definition of <tt>Gen:Gen</tt> shows, how a function is put in its own namespace 
without using the surrounding <tt>(context 'Gen)</tt> and <tt>(context MAIN)</tt> 
statements. In that case only symbols qualified by the namespace prefix will 
end up in the <tt>Gen</tt> context. In the above example the variable 
<tt>x</tt> is still part of <tt>MAIN</tt>.</p>

<br/>

<a name="hash"></a>
<h3>Hash functions and dictionaries（ハッシュ機能と辞書）</h3>

<p>名前空間 context にシンボルを置くことで使えるようになる機能がいくつかあります。
単純なハッシュ似の変数→値対の集合体として辞書のように使う時は、<a href="#default_function">デフォルト・ファンクタ</a> に初期値を与えずに使います：
<br />
There are several functions that can be used to place symbols into namespace contexts. 
When using dictionaries as simple hash-like collections of variable &rarr; value pairs, use the 
uninitialized <a href="#default_function">default functor</a>:</p>

<pre>
(define Myhash:Myhash) ; create namespace and default functor

; or as a safer alternative

(new Tree 'MyHash) ; create from built-in template
</pre>		

<p>どちらの方法も <tt>MyHash</tt> の辞書空間とデフォルト・ファンクタを作ることができます。
二番目の手段の方が安全で、デフォルト・ファンクタ <tt>MyHash:MyHash</tt> を変更から守ることができます。
辞書として使う時は、名前空間の<em>デフォルト・ファンクタ</em> に <tt>nil</tt> を入れておく必要があります。
シンボル名に使える文字列は1022文字に制限され、コンテキストで使われるシンボル名にはアンダースコアが内部処理で先付けされます。
キー・値対の生成と（訳注：キーによる）値の呼び出しが簡単になります：<br />
Either method can be used to make the  <tt>MyHash</tt> dictionary space and default
functor. The second method is safer, as it will protect the default functor 
<tt>MyHash:MyHash</tt> from change. The <em>default functor</em> in a namespace must 
contain <tt>nil</tt> to be used as a dictionary. The string used for the symbol name
is limited to 1022 characters and internally an underscore is prepended to the symbol
name used in the context. Creating key-value pairs and retrieving 
a value is easy:</p>

<pre>
(Myhash "var" 123) ; create and set variable/value pair

(Myhash "var")  <span class='arw'>&rarr;</span> 123 ; retrieve value

; keys can be integers and will be converted to strings internally

(Myhash 456 "hello")

(Myhash 456)    <span class='arw'>&rarr;</span> "hello"

; internally an underscore is prepended to the symbol name

(symbols Myhash)  <span class='arw'>&rarr;</span> (Myhash:Myhash Myhash:_456 Myhash:_var)
</pre>

<p>この方法で作られるシンボル変数は、スペースや通常 newLISP のシンボル名としては許されない文字を含むこともできます：<br />
Symbol variables created this way can contain spaces or other characters
normally not allowed in newLISP symbol names:</p>

<pre>
(define Foo:Foo)
; or to protect the default functor from change
; (new Tree 'Foo)

(Foo "John Doe" 123)         <span class='arw'>&rarr;</span> 123
(Foo "#1234" "hello world")  <span class='arw'>&rarr;</span> "hello world"
(Foo "var" '(a b c d))       <span class='arw'>&rarr;</span> (a b c d)

(Foo "John Doe")  <span class='arw'>&rarr;</span> 123
(Foo "#1234")     <span class='arw'>&rarr;</span> "hello world"
(Foo "var")     <span class='arw'>&rarr;</span> (a b c d)
</pre>		

<p>存在しないエントリは <tt>nil</tt> を返します：<br />
An entry which doesn't exist will return <tt>nil</tt>:</p>

<pre>
(Foo "bar")    <span class='arw'>&rarr;</span> nil
</pre>		

<p>エントリに <tt>nil</tt> を設定することは、そのエントリを名前空間から実際に削除します。<br />
Setting an entry to <tt>nil</tt> will effectively delete it from
the namespace.</p>

<p>名前空間の内容から連想リストが生成できます：<br />
An association list can be generated from the contents of the namespace:</p>

<pre>
(Foo) <span class='arw'>&rarr;</span> (("#1234" "hello world") ("John Doe" 123) ("var" (a b c d)))
</pre>		

<p>このリストはソートされたキー‐&gt;値ペアで、繰り返し操作にも使えます：<br />
The list can also be used to iterate through the sorted key -&gt; value pairs:</p>

<pre>
(dolist (item (Foo)) (println (item 0) " -&gt; " (item 1)))

<b>#1234 -&gt; hello world
John Doe -&gt; 123
var -&gt; (a b c d)</b>
</pre>

<p>辞書へのエントリはリストからも可能です：<br />
Entries in the dictionary can also be created from a list:</p>

<pre>
(Foo '(("#1234" "hello world") ("John Doe" 123) ("var" (a b c d))) <span class='arw'>&rarr;</span> Foo
</pre>		

<p>多くの組込関数と同じように、ハッシュ式はその内容を直接変更可能な参照として返します：<br />
Like many built-in functions hash expressions return a reference to their content which 
can be modified directly:</p>

<pre>
(pop (Foo "var")) <span class='arw'>&rarr;</span> a

(Foo "var") <span class='arw'>&rarr;</span> (b c d)

(push 'z (Foo "var")) <span class='arw'>&rarr;</span> (z b c d)

(Foo "var") <span class='arw'>&rarr;</span> (z b c d)
</pre>

<p>ハッシュ値に新しい値をセットする時、古い値をアナフォリック・システム変数 <tt>$it</tt> で参照することができます：<br />
When setting hash values the anaphoric system variable <tt>$it</tt>
can be used to refer to the old value when setting the new:</p>

<pre>
(Foo "bar" "hello world")

(Foo "bar" (upper-case $it))

(Foo "bar") <span class='arw'>&rarr;</span> "HELLO WORLD"
</pre>

<p>ハッシュ値は<a href="#setf">setf</a> を使っても変更可能です：<br />
Hash values also can be modified using <a href="#setf">setf</a>:</p>

<pre>
(Foo "bar" 123)        <span class='arw'>&rarr;</span> 123

(setf (Foo "bar") 456) <span class='arw'>&rarr;</span> 456

(Foo "bar")            <span class='arw'>&rarr;</span> 456
</pre>

<p>ただし、ハッシュ関数の第二変数に値を与えたほうが短く書け、かつ高速です。<br />
But supplying the value as a second parameter to the hash functions 
is shorter to write and faster.</p>

<p>辞書は簡単にファイルに保存でき、後で再ロードできます：<br />
Dictionaries can easily be saved to a file and reloaded later:</p>

<pre>
; save dictionary
(save "Foo.lsp" 'Foo)

; load dictionary
(load "Foo.lsp")
</pre>	

<p>内部的には、キー文字列がハッシュ内容のシンボルとして生成され、保存されています。
全てのキー文字列にはアンダースコア文字 <tt>_</tt> が先付けされます。
このことにより、ディスクや <tt>HTTP</tt> 上からハッシュ名前空間をロードする際に必要となる <tt>set</tt> や <tt>sym</tt> などのシンボルやデフォルト・シンボルへの上書きが予防されます。
次の違いに注意してください：<br />
Internally the key strings are created and stored as symbols in the
hash context. All key strings are prepended with an <tt>_</tt> 
underscore character.  This protects against overwriting the default symbol and
symbols like <tt>set</tt> and <tt>sym</tt>, which are needed when loading
a hash namespace from disk or over <tt>HTTP</tt>. Note the following
difference:</p>

<pre>
(Foo) <span class='arw'>&rarr;</span> (("#1234" "hello world") ("John Doe" 123) ("var" (a b c d)))

(symbols Foo) <span class='arw'>&rarr;</span> (Foo:Foo Foo:_#1234 Foo:_John Doe Foo:_var)
</pre>	

<p>一行目では、先付けにアンダースコア文字の無い文字列でハッシュ・シンボルが現れます。
二行目は、アンダースコア文字の先付けされた内部形式シンボルが現れます。<br />
In the first line hash symbols are shown as strings without the preceding
underscore characters. The second line shows the internal form of the symbols with
prepended underscore characters.</p>


<p><em>名前空間</em> に関する詳細な手引きは <a href="#contexts">Contexts</a> の章を見てください。<br />
For a more detailed introduction to <em>namespaces</em>, see the chapter on
<a href="#contexts">Contexts</a>.
</p>

<br/>

<a name="pass_big"></a>
<h3>Passing data by reference（参照によるデータの受け渡し）</h3>

<p><a href="#default_function">デフォルト・ファンクタ</a> はデータ保持にも使えます。
このデータがリストか文字列なら、コンテキスト名をデータへの参照として使えます：<br />
A <a href="#default_function">default functor</a> can also be used to hold data. 
If this data contains a list or string, the context name can be used as a reference to 
the data:</p>

<pre>
;; the default functor for holding data

(define Mylist:Mylist '(a b c d e f g))

(Mylist 3) <span class='arw'>&rarr;</span> d 

(setf (Mylist 3) 'D) <span class='arw'>&rarr;</span> D

Mylist:Mylist <span class='arw'>&rarr;</span> (a b c D e f g)

;; access list or string data from a default functor

(first Mylist) <span class='arw'>&rarr;</span> a

(reverse Mylist) <span class='arw'>&rarr;</span> (g f e D c b a)

(set 'Str:Str "acdefghijklmnop") 

(upper-case Str) <span class='arw'>&rarr;</span> "ACDEFGHIJKLMNOP"
</pre>

<p>多くの場合、newLISP は変数を<em>値のコピー</em> で渡します。
大規模リストや長大な文字列をユーザ定義関数やマクロに渡す際、これが潜在的な問題を引き起こします。
デフォルト・ファンクタを使った名前空間に入れられた文字列やリストは、自動的に参照で渡されます：<br />
Most of the time, newLISP passes parameters by <em>value copy</em>.
This poses a potential problem when passing large lists or strings
to user-defined functions or macros. Strings and lists, which are packed 
in a namespace using default functors, are passed automatically by reference:
</p>

<pre>
;; use a default functor to hold a list

(set 'Mydb:Mydb (sequence 1 100000))

(define (change-db obj idx value)
    (setf (obj idx) value))

; pass by context reference
(change-db Mydb 1234 "abcdefg")

(Mydb 1234)  <span class='arw'>&rarr;</span> "abcdefg"
</pre>		

<p>リストか文字列の&mdash;他のデータ型でない&mdash;どちらかで呼び出される組込関数は引数として、参照で渡されるデータを受け取ることができます。
ユーザ定義関数なら、通常の変数を受け取るか、リストか文字列のデフォルト・ファンクタへの参照を渡すコンテキスト名を受け取ることができます。<br />
 Any argument of a built-in function calling for either a list or a string 
&mdash; but no other data type &mdash; can receive data passed by reference. 
Any user-defined function can take either normal variables, or can take a context 
name for passing a reference to the default functor containing a list or string.</p>

<p>覚えておいて欲しいのは、100 要素より少ないリストや 50000 文字より少ない文字列では、参照と値渡しの速度差は無視してよいほどだということです。
しかし、それ以上に大きなオブジェクトでは、参照と値渡しの速度とメモリ消費量の違いは検討に値します。<br />
Note that on lists with less than about 100 elements or strings of less than 
about 50000 characters, the speed difference between reference and value passing is 
negligible. But on bigger data objects, differences in both speed and memory usage 
between reference and value passing can be significant.</p>

<p>組込関数とユーザ定義関数は引数として<u>両者</u>の型に対応しますが、コンテキスト名が渡される時、データは参照で渡されます。<br />
Built-in and user-defined functions are suitable for <u>both</u> types of arguments, 
but when passing context names, data will be passed by reference.</p>

<p>参照によるデータ渡しにクォート付きシンボルを使うこともできますが、この方法には問題があります：<br />
Quoted symbols can also be used to pass data by reference, but this method
has disadvantages:</p>

<pre>
(define (change-list aList) (push 999 (eval aList)))

(set 'data '(1 2 3 4 5))

; note the quote ' in front of data
(change-list 'data)  <span class='arw'>&rarr;</span> (999 1 2 3 4 5)

data  <span class='arw'>&rarr;</span>  (999 1 2 3 4 5)
</pre>

<p>この方法は理解し易く、簡単に使えますが、関数の変数名と同じシンボルが渡されると潜在的な<em>変数捕捉</em> 問題を引き起こします：<br />
Although this method is simple to understand and use, it poses the potential 
problem of <em>variable capture</em> when passing the same symbol as used  
as a function parameter:</p>

<pre>
;; pass data by symbol reference

&gt; (set 'aList '(a b c d))
(a b c d)
&gt; (change-list 'aList)

<span class='err'>ERR: list or string expected : (eval aList)
called from user defined function change-list</span>
&gt; 
</pre>

<p>この章の始めで、デフォルト・ファンクタを使う名前空間にデータをまとめる方法を紹介しました（訳注：<a href="#hash">ハッシュ機能と辞書</a>のこと）。
データの保持に使えるコンテキストのシンボルは、デフォルト・ファンクタだけではありません。
欠点は、呼び出す関数で使われるシンボルがわかっている必要があることです：<br />
At the beginning of the chapter it was shown how to package data 
in a name-space using a default functor. Not only the default 
functor but any symbol in  context can be used to hold data. The 
disadvantage is that the calling function must have knowledge about
the symbol being used:</p>

<pre>
;; pass data by context reference

(set 'Mydb:data (sequence 1 100000))

(define (change-db obj idx value)
    (setf (obj:data idx) value))

(change-db Mydb 1234 "abcdefg")

(nth 1234 Mydb:data)   <span class='arw'>&rarr;</span> "abcdefg"
; or
(Mydb:data 1234)   <span class='arw'>&rarr;</span> "abcdefg"
</pre>

<p>
関数は変数 <tt>obj</tt> に名前空間を受け取りますが、アクセスするリストが名前空間（コンテキスト）のシンボル <tt>data</tt> にあることを知っていなければなりません。<br />
The function receives the namespace in the variable <tt>obj</tt>,
but it must have the knowledge that the list to access is contained
in the <tt>data</tt> symbol of that namespace (context).</p>

<br/>

<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>

<a name="foop"></a>
<h2>18. Functional object-oriented programming（関数的オブジェクト指向プログラミング）</h2>

<p>関数的オブジェクト指向プログラミング (FOOP) は、次の五つの原理に基づいています：<br />
Functional-object oriented programming (FOOP) is based on the following 
five principles:</p>

<ul>
<li><p>クラスの属性とメソッドは、オブジェクトクラスの名前空間に保存されている。<br />
Class attributes and methods are stored in the namespace of the object class.</p></li>
<li><p>名前空間のデフォルト・ファンクタは、オブジェクト・コンストラクタ・メソッドを保持する。
<br />The namespace default functor holds the object constructor method.</p></li>
<li><p>オブジェクトはリストを使って構成される。そのリストの第一要素には、オブジェクトのクラスを表すコンテキスト・シンボルが入る。<br />
An object is constructed using a list, the first element of which is the 
context symbol describing the class of the object.</p></li>
<li><p>多態性の実装には、オブジェクトから特定のクラスを選択する <a href="#colon"><tt>:</tt> (colon)</a> オペレータが使われる。<br />
Polymorphism is implemented using the <a href="#colon"><tt>:</tt> (colon)</a>
operator, which selects the appropriate class from the object.</p></li>
<li><p>クラス・メソッド関数内の目的オブジェクトは、関数 <a href="#self">self</a> を介してアクセスされる。<br />
A target object inside a class-method function is accessed via the <a href="#self">self</a>
function.</p></li>
</ul>

<p>以下の節は、 <a href="http://neglook.com">neglook.com</a> の <em>Michael Michaels</em> の企画による FOOP についての 短い入門書です。<br />
The following paragraphs are a short introduction to FOOP as designed by 
<em>Michael Michaels</em> from <a href="http://neglook.com">neglook.com</a>.</p>

<br/>

<a name="newlisp_classes"></a>
<h3>FOOP classes and constructors（FOOP クラスとコンストラクタ）</h3>

<p>クラスの属性とメソッドは、オブジェクト・クラスの名前空間に保存されます。
オブジェクトの実体データは、この名前空間／コンテキストに保存されません。
クラス名前空間でのデータ変数は、オブジェクト特有の情報を含まない完全体として、オブジェクトのクラスのみを記述します。
<tt>new</tt> で新しいオブジェクト・クラスを生成する時、特定のオブジェクト・コンストラクタのテンプレートとして、包括的な FOOP オブジェクト・コンストラクタを使えます：<br />
Class attributes and methods are stored in the namespace of the object class. 
No object instance data is stored in this namespace/context. Data variables in
the class namespace only describe the class of objects as a whole but don't contain
any object specific information. A generic FOOP object constructor can be used
as a template for specific object constructors when creating new object classes
with <tt>new</tt>:</p>

<pre>
; built-in generic FOOP object constructor
(define (Class:Class) 
    (cons (context) (args)))

; create some new classes

(new Class 'Rectangle)   <span class='arw'>&rarr;</span> Rectangle
(new Class 'Circle)      <span class='arw'>&rarr;</span> Circle

; create some objects using the default constructor

(set 'rect (Rectangle 10 20))   <span class='arw'>&rarr;</span> (Rectangle 10 20)
(set 'circ (Circle 10 10 20))   <span class='arw'>&rarr;</span> (Circle 10 10 20)

; create a list of objects
; building the list using the list function instead of assigning
; a quoted list ensures that the object constructors are executed

(set 'shapes (list (Circle 5 8 12) (Rectangle 4 8) (Circle 7 7 15)))
<span class='arw'>&rarr;</span> ((Circle 5 8 12) (Rectangle 4 8) (Circle 7 7 15))
</pre>

<p>包括的な FOOP コンストラクタはあらかじめ定義されていて、直ちに <tt>(new Class ...)</tt> 宣言文から FOOP コードを始めることができます。<br />
The generic FOOP constructor is already pre-defined, and FOOP
code can start with <tt>(new Class ...)</tt> statements right away.</p>

<p>スタイルの問題として、新しいクラスは MAIN コンテキストでのみ生成すべきです。
違う名前空間に新しいクラスを生成すると、新しいクラス名に MAIN を先付しなくてはならず、宣言文をトップ・レベル上に置く必要があります：<br />
As a matter of style, new classes should only be created in the MAIN context. 
If creating a new class while in a different namespace, the new class name 
must be prefixed with MAIN and the statement should be on the top-level:</p>

<pre>
(context 'Geometry)

(new Class 'MAIN:Rectangle)
(new Class 'MAIN:Circle)

...
</pre>

<p><a href="#new">new</a> を使って名前空間クラスを生成することは、newLISP のコンテキストにクラス名を予約し、前方参照を容易にします。
同時に新しいクラスにとっては、新しいオブジェクトをインスタンス化するための簡易コンストラクタが定義されます。
慣習として、名前が名前空間であることを知らしめるために、クラス名を大文字で始めることを推奨します。<br />
Creating the namespace classes using <a href="#new">new</a> reserves the class 
name as a context in newLISP and facilitates forward references. At the same time, 
a simple constructor is defined for the new class for instantiating new objects. 
As a convention, it is recommended to start class names in upper-case to signal that 
the name stands for a namespace.</p>

<p><tt>new</tt> によるクラス生成の際に生成される簡易コンストラクタを上書きする方が便利な場合もあります。<br />
In some cases, it may be useful to overwrite the simple constructor, that was 
created during class creation, with <tt>new</tt>:</p>

<pre>
; overwrite simple constructor 
(define (Circle:Circle x y radius)
    (list Circle x y radius))
</pre>

<p>コンストラクタはデフォルト（訳注：引数の初期値）も指定可能です：<br />
A constructor can also specify defaults:</p>

<pre>
; constructor with defaults
(define (Circle:Circle (x 10) (y 10) (radius 3))
    (list Circle x y radius))

(Circle) <span class='arw'>&rarr;</span> (Circle 10 10 3)
</pre>

<p>多くの場合、<tt>new</tt> を使った時に生成されるコンストラクタで十分であり、その上書きは必要ありません。<br />
In many cases the constructor as created when using <tt>new</tt> is sufficient and overwriting
it is not necessary.</p>

<br/>

<a name="newlisp_objects"></a>
<h3>Objects and associations（オブジェクト）</h3>

<p>FOOP はオブジェクトをリストで表現します。
リストの第一要素はオブジェクトの種類やクラスを示し、残りの要素はデータになります。
次の宣言文は、前もって定義されたコンストラクタを使って、二つの<em>オブジェクト</em> を定義しています：<br />
FOOP represents objects as lists. The first element of the list indicates the 
object's kind or class, while the remaining elements contain the data. The following 
statements define two <em>objects</em> using any of the constructors defined previously:</p>

<pre>
(set 'myrect (Rectangle 5 5 10 20)) <span class='arw'>&rarr;</span> (Rectangle 5 5 10 20)
(set 'mycircle (Circle 1 2 10)) <span class='arw'>&rarr;</span> (Circle 1 2 10)
</pre>

<p>生成されたオブジェクトは、それを生成するのに必要な関数と同一です (FOOP 故に) 。
同様な方法で入れ子のオブジェクトを生成可能です：<br />
An object created is identical to the function necessary to create it (hence FOOP). 
Nested objects can be created in a similar manner:</p>

<pre>
; create classes
(new Class 'Person)
(new Class 'Address)
(new Class 'City)
(new Class 'Street)

; create an object containing other objects
(set 'JohnDoe (Person (Address (City "Boston") (Street 123 "Main Street"))))
<span class='arw'>&rarr;</span> (Person (Address (City "Boston") (Street 123 "Main Street")))
</pre>

<p>FOOP のオブジェクトは関数に似ているばかりでなく、連想にも似ています。
名前でオブジェクトをアクセスするために関数<a href="#assoc"> assoc</a> を使うことができます：<br />
Objects in FOOP not only resemble functions they also resemble associations. The
<a href="#assoc">assoc</a> function can be used to access object data by name:</p>

<pre>
(assoc Address JohnDoe) <span class='arw'>&rarr;</span> (Address (City "Boston") (Street 123 "Main Street"))

(assoc (list Address Street) JohnDoe) <span class='arw'>&rarr;</span> (Street 123 "Main Street")
</pre>

<p>同様に <a href="#assoc">assoc</a> と一緒に <a href="#setf">setf</a> を使って、オブジェクト・データを変更できます：<br />
In a similar manner <a href="#setf">setf</a> together with <a href="#assoc">assoc</a> 
can be used to modify object data:</p>

<pre>
(setf (assoc (list Address Street) JohnDoe) '(Street 456 "Main Street"))
<span class='arw'>&rarr;</span> (Street 456 "Main Street")
</pre>

<p>このように、ストリート番号が <tt>123</tt> から <tt>456</tt> に変わります。<br />
The street number has been changed from <tt>123</tt> to <tt>456</tt>.</p>

<p><tt>assoc</tt> 宣言文の <tt>Address</tt> や <tt>Street</tt> にクォートを付ける必要がないことに注意してください。
データを割り付けるための set 宣言文：<tt>(set 'JohnDoe (Person ...))</tt> でも同様です。
どちらの場合も、シンボルやシンボルのリストではなく、
それ自身に評価されるコンテキストと FOOP オブジェクトを扱っています。
クォート付きでも違いは起きません。<br />
Note that in none of the <tt>assoc</tt> statements <tt>Address</tt> and <tt>Street</tt>
need to carry quotes. The same is true in the set statement: 
<tt>(set 'JohnDoe (Person ...))</tt> for the data part assigned. In both cases we do not 
deal with symbols or lists of symbols but rather with contexts and FOOP objects which 
evaluate to themselves. Quoting would not make a difference.</p>

<br/>

<a name="colon_operator"></a>
<h3>The colon <tt>:</tt> operator and polymorphism（コロン <tt>:</tt> 演算子と多態性）</h3>

<p>newLISP でコロン文字 <tt>:</tt> は、主にコンテキスト・シンボルとシンボルの接続に使われ、シンボルを特定します。
二つ目の使い方としてのコロン関数は FOOP において、関数の用途を<a href="http://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0">多態的に</a>解決するために使われます。<br />
In newLISP, the colon character <tt>:</tt> is primarily used to
connect the context symbol with the symbol it is qualifying. 
Secondly, the colon function is used in FOOP to resolve a function's 
application <em>polymorphously</em>.</p>

<p>次のコードで定義されている二つの関数は <tt>area</tt> と呼ばれ、それぞれ異なる名前空間／クラスに属しています。
両関数は個別の異なるモジュールで定義されていますが、この場合、同じファイル上で定義されていて、<a href="#context">context</a> 宣言文で囲まれていません。
<tt>rectangle:area</tt> と <tt>circle:area</tt> というように、異なる名前空間に属しているだけです。
ローカル・パラメータ <tt>p</tt>、<tt>c</tt>、<tt>dx</tt>、<tt>dy</tt> は、全て <tt>MAIN</tt> の部品ですが、気にする必要はありません。<br />
The following code defines two functions called <tt>area</tt>, 
each belonging to a different namespace / class. Both functions could
have been defined in different modules for better separation, but in 
this case they are defined in the same file and without bracketing 
<a href="#context">context</a> statements. Here, only
the symbols <tt>rectangle:area</tt> and <tt>circle:area</tt> belong
to different namespaces. The local parameters <tt>p</tt>, <tt>c</tt>, 
<tt>dx</tt>, and <tt>dy</tt> are all part of <tt>MAIN</tt>,
but this is of no concern.</p>

<pre>
;; class methods for rectangles

(define (Rectangle:area)
    (mul (self 3) (self 4)))

(define (Rectangle:move dx dy)
    (inc (self 1) dx) 
    (inc (self 2) dy))

;; class methods for circles

(define (Circle:area)
    (mul (pow (self 3) 2) (acos 0) 2))

(define (Circle:move dx dy)
    (inc (self 1) dx) 
    (inc (self 2) dy))
</pre>

<p><tt>area</tt> や <tt>move</tt> シンボルに <a href="#colon"><tt>:</tt> (colon)</a> を先付することで、各オブジェクトのクラス関数を呼び出せます。 
コロンとそれに続くシンボル間にスペースはいらず、newLISP が別々のエントリとして解析します。
コロンが変数を処理する関数として動作します：<br />
By prefixing the <tt>area</tt> or <tt>move</tt> symbol with the
<a href="#colon"><tt>:</tt> (colon)</a>, 
we can call these functions for each class of object. Although there is no space 
between the colon and the symbol following it, newLISP parses them as distinct entities. 
The colon works as a function that processes parameters:</p> 

<pre>
(:area myrect) <span class='arw'>&rarr;</span> 200 ; same as (: area myrect)
(:area mycircle) <span class='arw'>&rarr;</span> 314.1592654 ; same as (: area mycircle)

;; map class methods uses curry to enclose the colon operator and class function

(map (curry :area) (list myrect mycircle)) <span class='arw'>&rarr;</span> (200 314.1592654)

(map (curry :area) '((Rectangle 5 5 10 20) (Circle 1 2 10))) <span class='arw'>&rarr;</span> (200 314.1592654) 


;; objects are mutable (since v10.1.8)

(:move myrect 2 3)
(:move mycircle 4 5) 

myrect    <span class='arw'>&rarr;</span> (Rectangle 7 8 10 20)
mycircle  <span class='arw'>&rarr;</span> (Circle 5 7 10)
</pre>

<p>この例では、シンボル（<tt>rectangle:area</tt> か <tt>circle:area</tt>）が正しく特定され、コロンに続くシンボルとコンテキスト名（オブジェクト・リストの第一要素）に基づくオブジェクト・データに適用されています。<br />
In this example, the correct qualified symbol (<tt>rectangle:area</tt> or 
<tt>circle:area</tt>) is constructed and applied to the object data based on 
the symbol following the colon and the context name (the first element of the object list).</p>

<p>呼び出し側は呼び出された目標オブジェクトを特定しますが、
メソッド定義には変数としてオブジェクトが含まれていないことに注意してください。
FOOP オブジェクトを変更する関数を書く時は、オブジェクトのアクセスやインデックスの指定に関数 <a href="#self">self</a> を使います。<br />
Note, that although the caller specifies the called target object of the call,
the method definition does not include the object as a parameter. When writing 
functions to modify FOOP objects, instead the function <a href="#self">self</a>
is used to access and index the object.</p>

<br/>
<a name="structure_foop"></a>
<h3>Structuring a larger FOOP program（大規模 FOOP プログラムの構造化）</h3>

<p>前述の例全てにおいて、クラス関数は MAIN コンテキスト名前空間に直接書かれたメソッドです。
これでも動作しますし、一人のプログラマによる小規模のプログラムにとっては十分です。
大規模なシステムを書く時は、使用されるパラメータ変数の独立を保ち、潜在的クラス変数用の隔離場所を作っておくために、一クラスの全メソッドを <a href="#context">context</a> 宣言文で囲むべきです。<br />
In all the previous examples, class function methods where directly
written into the MAIN context namespace. This works and is adequate 
for smaller programs written by just one programmer. When writing larger 
systems, all the methods for one class should be surrounded by 
<a href="#context">context</a> statements to provide better isolation 
of parameter variables used and to create an isolated location for potential
class variables.</p>

<p>この場合、クラス変数を特定のオブジェクト用ではなく、オブジェクトやカウンタやクラスに固有なその他の情報のリスト用の入れ物として使います。
次のコードは、上記例をこの状況用に書き直しています。<br />
Class variables could be used in this example as a container for
lists of objects, counters or other information specific to a class
but not to a specific object. The following code segment rewrites the 
example from above in this fashion.</p>

<p>各コンテキスト／名前空間は、クラスと同名の個別のファイルに入れておきます。
クラス生成、開始コード、主制御コードは、ファイル <tt>MAIN.lsp</tt> にあります：<br />
Each context / namespace could go into an extra file with the same
name as the class contained. Class creation, startup code and the main
control code is in a file <tt>MAIN.lsp</tt>:</p>

<pre>
; file MAIN.lsp - declare all classes used in MAIN

(new Class 'Rectangle)
(new Class 'Circle)

; start up code

(load "Rectangle.lsp")
(load "Circle.lsp")

; main control code

; end of file
</pre>

<p>各クラスは独立したファイルの中にあります：<br />
Each class is in a separate file:</p>

<pre>
; file Rectangle.lsp - class methods for rectangles

(context Rectangle)

(define (Rectangle:area)
(mul (self 3) (self 4)))

(define (Rectangle:move dx dy)
(inc (self 1) dx) 
(inc (self 2) dy))

; end of file
</pre>

<p>そして <tt>Circle</tt> クラスのファイルは次にようになっています：<br />
And the <tt>Circle</tt> class file follows:</p>

<pre>
; file Circle.lsp - class methods for circles

(context Circle)

(define (Circle:area)
    (mul (pow (self 3) 2) (acos 0) 2))

(define (Circle:move dx dy)
    (inc (self 1) dx) 
    (inc (self 2) dy))

; end of file
</pre>

<p>これでクラス関数の全設定がレキシカルに他から分離されます。<br />
All sets of class functions are now lexically separated
from each other.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>


<a name="multi_processing"></a>
<h2>19. Concurrent processing and distributed computing（並列処理と分散コンピューティング）</h2>

<p>newLISP は、同じ CPU または TCP/IP ネットワーク上の異なるコンピュータ・ノードに分散されるマルチ・プロセス制御用の高レベル API を持っています。<br />
newLISP has high-level APIs to control multiple processes on the same
CPU or distributed onto different computer nodes on a TCP/IP network.</p>

<br/>

<a name="cilk"></a>
<h3>Cilk API（Cilk API）</h3>

<p>newLISP は並列処理を起動し制御する <a href="http://supertech.csail.mit.edu/cilk/">Cilk</a> 似の API を実装しています。
この API はマルチコア・コンピュータ構成の利点を活かせます。
マルチ・プロセスを開始して、同期状態における結果を収集するために必要なのは、関数 <a href="#spawn">spawn</a>、<a href="#sync">sync</a>、<a href="#abort">abort</a> の三つだけです。
基盤となるオペレーティングシステムが、プロセスを CPU 内の異なるコアに分配するか、十分なコアがない場合は同一コアで並列に実行させます。
newLISP は API を実装しているだけなので、子プロセスとして呼び出された手続きのスケジュール最適化が Cilk のように実施されるわけではないことに注意してください。
関数は <tt>spawn</tt> 宣言文に現れた順に開始され、オペレーティングシステムによって、
CPU の異なるコアに分配され、スケジュールされます。<br />
newLISP implements a <a href="http://supertech.csail.mit.edu/cilk/">Cilk</a>-
like API to launch and control concurrent processes. The API can take advantage of 
multi-core computer architectures. Only three functions, <a href="#spawn">spawn</a>, 
<a href="#sync">sync</a> and <a href="#abort">abort</a>, are necessary to start
multiple processes and collect the results in a synchronized fashion. The underlying
operating system distributes processes onto different cores inside the CPU or
executes them on the same core in parallel if there are not enough cores present.
Note that newLISP only implements the API; optimized scheduling
of spawned procedures is not performed as in Cilk. Functions are started in the order
they appear in <tt>spawn</tt> statements and are distributed and scheduled onto 
different cores in the CPU by the operating system.</p>

<p>マルチコアの存在は関数を並列に実行することにより、全体的な処理速度向上を可能にします。
とは言え、シングルコア CPU での走行中でもプログラマにとっては、 Cilk API がより簡単な並列処理化を可能にし、I/O やスリープの待ち状態を含むタスクが存在する時には、処理速度を上げられる可能性があります。<br />
When multiple cores are present, this can increase overall processing speed
by evaluating functions in parallel. But even when running on single core CPUs,
the Cilk API makes concurrent processing much easier for the programmer and
may speed up processing if subtasks include waiting for I/O or sleeping.</p>

<p>バージョン 10.1 以降、メッセージ関数 <a href="#send">send</a> と <a href="#receive">receive</a> はプロセスの親子間通信に利用可能です。
これらの関数はブロッキングとノン・ブロッキング通信に使うことができ、newLISP のいかなる種類のデータや式でも転送できます。
送信された式は受け取り側の環境で評価可能です。<br />
Since version 10.1 <a href="#send">send</a> and <a href="#receive">receive</a>
message functions are available for communications between parent and child 
processes. The functions can be used in blocking and non blocking communications 
and can transfer any kind of newLISP data or expressions. Transmitted expressions 
can be evaluated in the recipients environment.</p>

<p>newLISP は内部的に、プロセスや計算結果の共有メモリを通した受け渡しの同期を制御するロー・レベル関数 <a href="#fork">fork</a>、
<a href="#wait-pid">wait-pid</a>、
<a href="#destroy">destroy</a>、
<a href="#share">share</a> を使います。<br />
Internally, newLISP uses the lower level <a href="#fork">fork</a>,
<a href="#wait-pid">wait-pid</a>, <a href="#destroy">destroy</a>, and 
<a href="#share">share</a> functionalities to control processes and synchronize
the passing of computed results via a shared memory interface.</p>

<p>Cilk API は macOS や他の Unix 上でのみ、タスクを並列化します。
MS Windows では、この API は 利用できません。
この方法により、全てのプラットフォームで走るコードを書く事ができます。<br />
Only on macOS and other Unixes will the Cilk API parallelize tasks.
On MS Windows, the API is not available.</p>

<br/>

<a name="distributed"></a>
<h3>Distributed network computing（分散ネットワーク コンピューティング）</h3>

<p>newLISP は <a href="#net-eval">net-eval</a> の一関数だけを使って、分散コンピューティングを実装しています。
<tt>net-eval</tt> を使えば、TCP/IP ネットワーク上のなるノード、または同じコンピュータで走っているローカル・ドメイン Unix ソケット上の異なるノードに、別個のタスクが配され、評価されます。
<tt>net-eval</tt> はリモート・ノードの接続、実行関数の転送、結果の収集などの全<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>をこなします。
<tt>net-eval</tt> では、リモート・ノードからのデータ入力を構造的に統合するコール・バック関数も使えます。<br />
With only one function, <a href="#net-eval">net-eval</a>, newLISP implements
distributed computing. Using <tt>net-eval</tt>, different tasks can be mapped
and evaluated on different nodes running on a TCP/IP network or local domain Unix sockets
network when running on the same computer. <tt>net-eval</tt> does all the housekeeping 
required to connect to remote nodes, transfer functions to execute, and
collect the results. <tt>net-eval</tt> can also use a call-back function to
further structure consolidation of incoming results from remote nodes.</p>

<p>関数 <a href="#read-file">read-file</a>、
<a href="#write-file">write-file</a>、 
<a href="#append-file">append-file</a>、
<a href="#delete-file">delete-file</a> は全て、
パス・ファイル名の代わりに URL を取ることができます。
デーモン・モードで走っている newLISP のサーバー側や Apache のような他の HTTP サーバーでは、標準 HTTP <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を受け取り、ファイルに対応する操作を行います。<br />
The functions <a href="#read-file">read-file</a>, <a href="#write-file">write-file</a>,  
<a href="#append-file">append-file</a> and <a href="#delete-file">delete-file</a> all can 
take URLs instead of path-file names. Server side newLISP running in demon mode or an other 
HTTP server like Apache, receive standard HTTP requests and translate them into the 
corresponding actions on files.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>
<a name="JSON_XML"></a>
<h2>20. JSON, XML, S-XML, and XML-RPC（JSON、XML、SXML と XML-RPC）</h2>
<b>JSON support（JSON 支援）</b>
<p>関数 <a href="#json-parse">json-parse</a> を使って JSON エンコード・データをＳ式に変換できます。
JSON の変換に失敗した情報は <a href="#json-error">json-error</a> を使って引き出せます。<br />
JSON-encoded data can be parsed into S-expressions using the 
<a href="#json-parse">json-parse</a> function. Error information for
failed JSON translations can be retrieved using <a href="#json-error">json-error</a>.</p>

<p>JSON 形式 (<u>J</u>ava<u>S</u>cript <u>O</u>bject <u>N</u>otation) の詳細は <a href="http://json.org">json.org</a> で調べてください。
正しい JSON 形式のテキストは <a href="http://json.org/examples.html">json.org/examples.html</a> で見ることができます。<br />
For a description of the JSON format (<u>J</u>ava<u>S</u>cript <u>O</u>bject <u>N</u>otation)
consult <a href="http://json.org">json.org</a>.
Examples for correct formatted JSON text can be seen at 
<a href="http://json.org/examples.html">json.org/examples.html</a>.</p>

<p>JSON 変換で得られる入れ子リストからデータを取り出すには、関数 <a href="#assoc">assoc</a>、<a href="#lookup">lookup</a>、<a href="#ref">ref</a> を使ってください。<br />
To retrieve data in nested lists resulting from JSON translation, use the
<a href="#assoc">assoc</a>, <a href="#lookup">lookup</a> and <a href="#ref">ref</a>
functions.</p>

<p>JSON データの変換と処理の全例は <a href="#json-parse">json-parse</a> の項を見てください。<br />
See the description of <a href="#json-parse">json-parse</a> for a complete example
of parsing and processing JSON data.</p>

<b>XML support（XML 支援）</b>
<p>XML-エンコード・データまたはドキュメントの newLISP の組込サポートは、三つの関数：
<a href="#xml-parse">xml-parse</a>、
<a href="#xml-type-tags">xml-type-tags</a>、
<a href="#xml-error">xml-error</a> からなります。<br />
newLISP's built-in support for XML-encoded data or documents
comprises three functions:
<a href="#xml-parse">xml-parse</a>,
<a href="#xml-type-tags">xml-type-tags</a>, and <a href="#xml-error">xml-error</a>.
</p>

<p>
XML-エンコード文字列を解析するには、関数 <a href="#xml-parse">xml-parse</a> を使ってください。
<tt>xml-parse</tt> がエラーに出会った時は、<tt>nil</tt> が返ります。
正しくない形式の XML によって起こった構文エラーを診断するには、関数 <a href="#xml-error">xml-error</a> を使ってください。
関数 <a href="#xml-type-tags">xml-type-tags</a> は XML タイプ・タグの出現を制御または抑制するのに使えます。
これらのタグは XML を四つのカテゴリ：テキスト、生の文字列データ、コメント、エレメント・データの中の一つに分類分けします。<br />
Use the <a href="#xml-parse">xml-parse</a> function
to parse XML-encoded strings.
When <tt>xml-parse</tt> encounters an error,
<tt>nil</tt> is returned.
To diagnose syntax errors caused by incorrectly formatted XML,
use the function <a href="#xml-error">xml-error</a>.
The <a href="#xml-type-tags">xml-type-tags</a> function can be used
to control or suppress the appearance of XML type tags.
These tags classify XML into one of four categories:
text, raw string data, comments, and element data.</p>


<b>XML source:</b>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;DATABASE name="example.xml"&gt;
&lt;!--This is a database of fruits--&gt;
&lt;FRUIT&gt;
&lt;NAME&gt;apple&lt;/NAME&gt;
&lt;COLOR&gt;red&lt;/COLOR&gt;
&lt;PRICE&gt;0.80&lt;/PRICE&gt;
&lt;/FRUIT&gt;
&lt;/DATABASE&gt;
</pre>		<br/>
<b>Parsing without options:</b>
<pre>
(xml-parse (read-file "example.xml"))
<span class='arw'>&rarr;</span>  (("ELEMENT" "DATABASE" (("name" "example.xml")) (("TEXT" "\r\n")
("COMMENT" "This is a database of fruits")
("TEXT" "\r\n        ")
("ELEMENT" "FRUIT" () (
	("TEXT" "\r\n\t        ")
	("ELEMENT" "NAME" () (("TEXT" "apple")))
	("TEXT" "\r\n\t\t")
	("ELEMENT" "COLOR" () (("TEXT" "red")))
	("TEXT" "\r\n\t\t")
	("ELEMENT" "PRICE" () (("TEXT" "0.80")))
	("TEXT" "\r\n\t")))
("TEXT" "\r\n"))))
</pre>		<p>
	関数 <a href="#xml-type-tags">xml-type-tags</a> と <a href="#xml-parse">xml-parse</a> の特殊オプション・パラメータを使って、XML から直接 S-XML を生成できます：<br />
	S-XML can be generated directly from XML
	using <a href="#xml-type-tags">xml-type-tags</a>
	and the special option parameters
	of the <a href="#xml-parse">xml-parse</a> function:
</p>
<br/>
<b>S-XML generation using all options:</b>
<pre>
(xml-type-tags nil nil nil nil)
(xml-parse (read-file "example.xml") (+ 1 2 4 8 16))
<span class='arw'>&rarr;</span>  ((DATABASE (@ (name "example.xml"))
  (FRUIT (NAME "apple")
	  (COLOR "red")
	  (PRICE "0.80"))))
	
</pre>
<p>S-XML は newLISP の<em>Ｓ式</em> として再構成された XML です。
<tt>@</tt> (at symbol) は XML の属性詳細を付与します。<br />
S-XML is XML reformatted as newLISP <em>S-expressions</em>.
The <tt>@</tt> (at symbol) denotes an XML attribute specification.</p>

<p>S-XML 変換で得られる入れ子リストからデータを取り出すには、関数 <a href="#assoc">assoc</a>、<a href="#lookup">lookup</a>、<a href="#ref">ref</a> を使ってください。<br />
To retrieve data in nested lists resulting from S-XML translation, use the
<a href="#assoc">assoc</a>, <a href="#lookup">lookup</a> and <a href="#ref">ref</a>
functions.</p>

<p>マニュアルのリファレンス項にある <a href="#xml-parse">xml-parse</a> を見てください。解析とオプション番号の詳細について、より長い例があります。<br />
See <a href="#xml-parse">xml-parse</a> in the reference section of the manual
for details on parsing and option numbers, as well as for a longer example.</p>

<br/>
<b>XML-RPC</b>
<br/>
<p>
	XML-RPC プロトコルを呼び出すリモート手続きは、転送とメソッド名、パラメータ、パラメータ・タイプをエンコードする XML に HTTP ポスト<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を使います。
	XML-RPC クライアントのライブラリとサーバーは、最も一般的なコンパイルされたスクリプト言語で実装されています。<br />
	The remote procedure calling protocol XML-RPC uses
	HTTP post requests as a transport and
	XML for the encoding of method names, parameters, and parameter types.
	XML-RPC client libraries and servers have been implemented
	for most popular compiled and scripting languages.
</p>
<p>
	XML についての詳しい情報は <a href="http://www.xmlrpc.com/">www.xmlrpc.com</a> を訪れて見てください。<br />
	For more information about XML,
	visit <a href="http://www.xmlrpc.com/">www.xmlrpc.com</a>.
</p>
<p>
	XML-RPC クライアントのライブラリとサーバーは、newLISP の組込ネットーワークと XML サポートを使って容易に書けます。
	CGI サービスとして実装された非公式（stateless）XML-RPC サーバーは、ファイル <tt>examples/xmlrpc.cgi</tt> に見つかります。
	このスクリプトを Apache のようなウェブ・サーバーとしても使うことができます。
	この XML-RPC サーバー・スクリプトは次のメソッドを実装します：<br />
	XML-RPC clients and servers are easy to write
	using newLISP's built-in network and XML support.
	A stateless XML-RPC server implemented as a CGI service
	can be found in the file <tt>examples/xmlrpc.cgi</tt>. This
	script can be used together with a web server, like Apache.
	This XML-RPC service script implements
	the following methods:
</p>

<table  width="98%" summary="XMPRPC methods for newLISP server">
<tr align="left"><th>method</th><th>description</th></tr>
<tr>
<td><tt>system.listMethods</tt></td>
<td>全てのメソッド名を返す<br />Returns a list of all method names</td>
</tr>
<tr>
<td><tt>system.methodHelp</tt></td>
<td>特定のメソッドのヘルプを返す<br />Returns help for a specific method</td>
</tr>
<tr>
<td><tt>system.methodSignature</tt></td>
<td>特定のメソッドのリターン／署名の呼び出しのリストを返す<br />Returns a list of return/calling signatures for a specific method </td>
</tr>
<tr>
<td><tt>newLISP.evalString</tt></td>
<td>Base64（訳注：でエンコードされた）newLISP 式の文字列を評価する<br />Evaluates a Base64 newLISP expression string</td></tr>
</table><br/>

<p>
最初の三つは、ほとんどの XML-RPC サーバーで実装されたメソッドとして<em>見つかります</em> 。
最後の一つは newLISP の XML-RPC サーバー・スクリプトに特有のもので、newLISP ソース・コードの Base64 エンコード文字列のリモート評価を実装します。
newLISP の関数 <a href="#base64-enc">base64-enc</a> と <a href="#base64-dec">base64-dec</a> を Base64 エンコード情報のエンコードとデコードに使えます。
<br />
The first three methods are <em>discovery</em> methods implemented by most XML-RPC servers.
The last one is specific to the newLISP XML-RPC server script and
implements remote evaluation of a Base64-encoded string of newLISP source code.
newLISP's <a href="#base64-enc">base64-enc</a> and <a href="#base64-dec">base64-dec</a> functions
can be used to encode and decode Base64-encoded information.
</p>

<p>
配布ソースの <tt>modules</tt> ディレクトリにあるファイル <tt>xmlrpc-client.lsp</tt> は、上記メソッド全てについての具体的なクライアント・インターフェイスを実装しています。<br />
In the <tt>modules</tt> directory of the source distribution,
the file <tt>xmlrpc-client.lsp</tt> implements a specific client interface for
all of the above methods.</p>

<pre>
(load "xmlrpc-client.lsp")  ; load XML-RPC client routines						 

(XMLRPC:newLISP.evalString
"http://localhost:8080/xmlrpc.cgi"
"(+ 3 4)")  <span class='arw'>&rarr;</span> "7"
</pre>		<p>
	同様に、標準 <tt>system.xxx</tt> 呼出しを発行できます。
<br />
	In a similar fashion,
	standard <tt>system.xxx</tt> calls can be issued.
</p>
<p>
すべての関数は成功なら結果を、<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>が失敗なら <tt>nil</tt> を返します。
失敗の場合、<tt>(XMLRPC:error)</tt> の式を評価すればエラー・メッセージが返ります。<br />
All functions return either a result if successful, or <tt>nil</tt> if a request fails.
In case of failure, the expression <tt>(XMLRPC:error)</tt> can be evaluated
to return an error message.</p>

<p>
詳細な情報は、どうかをファイル <tt>modules/xmlrpc-client.lsp</tt> のヘッダーを調べて見てください。
<br />
For more information, please consult the header of the file <tt>modules/xmlrpc-client.lsp</tt>.
</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="internationalization"></a>
<h2>21. Customization, localization, and UTF-8（カスタマイズ、ローカライズと UTF-8）</h2>

<a name="naming"></a>
<h3>Customizing function names（関数名のカスタマイズ）</h3>

<p>newLISP では、全ての組込関数を簡単にリネームできます：<br />
All built-in primitives in newLISP can be easily renamed:</p>

<pre>
(constant 'plus +)
</pre>		<p>
	これで、<tt>plus</tt> は関数として <tt>+</tt> に評価され、同じスピードで走ります。
<br />
	Now, <tt>plus</tt> is functionally equivalent to <tt>+</tt>
	and runs at the same speed.
</p>
<p>
	組込関数シンボルのリネームには、関数 <tt>set</tt> よりも関数 <a href="#constant">constant</a> を使うべきです。
	全組込関数シンボルは、デフォルトで不慮の上書きに対して保護されています。<br />
	The <a href="#constant">constant</a> function,
	rather than the <tt>set</tt> function,
	must be used to rename built-in primitive symbols.
	By default, all built-in function symbols
	are protected against accidental overwriting.
</p>

<p>
全ての整数算術演算子を浮動小数点同等品に再定義することが可能です：<br />
It is possible to redefine all integer arithmetic operators to their floating
point equivalents:
</p>

<pre>
(constant '+ add)
(constant '- sub)
(constant '* mul)
(constant '/ div)
</pre>		

<p>これで、<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt> を使った全ての操作が、浮動小数点演算として実行されます。<br />
All operations using <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, and <tt>/</tt>
are now performed as floating point operations.</p>

<p>同じ方法で、組込関数名を英語以外の言語にも変換できます：<br />
Using the same mechanism, the names of built-in functions
can be translated into languages other than English:</p>

<pre>
(constant 'wurzel sqrt)    ; German for 'square-root'

; make the new symbol global at the same time
(constant (global 'imprime) print)  ; Spanish for 'print'
&hellip;
</pre>		

<p>同時に <a href="#global">global</a> を使うことで、新関数を（訳注：どのコンテキストからも使える）グローバルにできます。<br />
The new symbol can be made global at the same time using <a href="#global">global</a>.</p>

<br/>

<a name="switching"></a>
<h3>Switching the locale（ロケールの切り替え）</h3>

<p>newLISP は、プラットフォームやオペレーティングシステムに基づく<a href="http://ja.wikipedia.org/wiki/%E5%9B%BD%E9%9A%9B%E5%8C%96%E3%81%A8%E5%9C%B0%E5%9F%9F%E5%8C%96">ロケール</a>を切り替えることができます。
開始時に、UTF-8版でない newLISP は、ほとんどのプラットフォームやロケールで利用可能な POSIX ロケールのデフォルト、ISO C 標準 の設定を試みます。
UTF-8版 newLISP では、プラットフォームのデフォルト・ロケールに設定します。
デフォルトのロケールを切り替えるのに、関数 <a href="#set-locale">set-locale</a> を使えます：
<br />
newLISP can switch locales based on the platform and operating system.
On startup, non-UTF-8 enabled newLISP attempts to set the ISO C standard 
default POSIX locale, available for most platforms and locales.  On UTF-8
enabled newLISP the default locale for the platform is set. The 
<a href="#set-locale">set-locale</a> function can also be used to switch 
to the default locale:</p>
<pre>
(set-locale "")
</pre>		
<p>
これは、あなたのプラットフォーム／オペレーティングシステムで使われているデフォルトのロケールに切り替え、文字操作（例えば、<a href="#upper-case">upper-case</a>）の正しい動作を保証します。<br />
This switches to the default locale used on your platform/operating system
and ensures character handling (e.g., <a href="#upper-case">upper-case</a>)
works correctly.</p>

<p>多くの Unix システムは、多数の利用可能なロケールを持っています。
個々の Linux/Unix/BSD システムで利用可能な一つを見つけるには、システム・シェルで次のコマンドを実行してください：<br />
Many Unix systems have
a variety of locales available. To find out which ones are available on
a particular Linux/Unix/BSD system, execute the following command
in a system shell:</p>

<pre>
locale -a
</pre>		

<p>
このコマンドは、あなたのシステムで利用可能な全ロケールのリストを表示します。
それらのどれもが <a href="#set-locale">set-locale</a> の引数に使えます：<br />
This command prints a list of all the locales available on your system.
Any of these may be used as arguments to <a href="#set-locale">set-locale</a>:</p>

<pre>
(set-locale "es_US")
</pre>		<p>
	これは、U.S. Spanish ロケールに切り替えます。
	U.S. Spanish 環境で使えるアクセントや文字が正しく変換されます。
<br />
	This would switch to a U.S. Spanish locale.
	Accents or other characters
	used in a U.S. Spanish environment
	would be correctly converted.
</p>
<p>
	詳細は、<a href="#set-locale">set-locale</a> の使い方のマニュアルの記述を見てください。
<br />
	See the manual description for more details
	on the usage of <a href="#set-locale">set-locale</a>.
</p>

<br/>

<a name="decimal_point"></a>
<h3>Decimal point and decimal comma（十進点と十進カンマ）</h3>

<p>多くの国々が十進数の区切りにピリオドでなくカンマを使っています。
newLISP はロケールの設定次第で正しく数値を解析します：<br />
Many countries use a comma instead of a period
as a decimal separator in numbers.
newLISP correctly parses numbers
depending on the locale set:</p>

<pre>
; switch to German locale on a Linux  or OSX system
(set-locale "de_DE") <span class='arw'>&rarr;</span> ("de_DE" ",")

; newLISP source and output use a decimal comma
(div 1,2 3)  <span class='arw'>&rarr;</span> 0,4
</pre>		

<p>newLISP 開始時に設定されるデフォルトの POSIX C ロケールは、十進数の区切りにピリオドを使います。
uses a period as a decimal separator.<br />
The default POSIX C locale, which is set when newLISP starts up,
uses a period as a decimal separator.</p>

<p>次の国々は <b>十進数の区切りにピリオド</b>を使います:<br />
The following countries use a <b>period as a decimal separator</b>:</p>

<blockquote>Australia, Botswana, Canada (English-speaking), China, Costa Rica, 
Dominican Republic, El Salvador, Guatemala, Honduras, Hong Kong, India, Ireland, 
Israel, Japan, Korea (both North and South), Malaysia, Mexico, Nicaragua, 
New Zealand, Panama, Philippines, Puerto Rico, Saudi Arabia, Singapore, Switzerland, 
Thailand, United Kingdom, and United States.</blockquote>

<p>次の国々は <b>十進数の区切りにカンマ</b>を使います:<br />
The following countries use a <b>comma as a decimal separator</b>:</p>

<blockquote>Albania, Andorra, Argentina, Austria, Belarus, Belgium, Bolivia, 
Brazil, Bulgaria, Canada (French-speaking), Croatia, Cuba, Chile, Colombia, 
Czech Republic, Denmark, Ecuador, Estonia, Faroes, Finland, France, Germany, 
Greece, Greenland, Hungary, Indonesia, Iceland, Italy, Latvia, Lithuania, 
Luxembourg, Macedonia, Moldova, Netherlands, Norway, Paraguay, Peru, Poland, 
Portugal, Romania, Russia, Serbia, Slovakia, Slovenia, Spain, South Africa, 
Sweden, Ukraine, Uruguay, Venezuela, and Zimbabwe.</blockquote>


<br/>
<a name="unicode_utf8"></a>
<h3>Unicode and UTF-8 encoding（Unicode と UTF-8 エンコーディング）</h3>

<p>多くのヨーロッパ言語では、内部的に各文字が<em>一バイト</em> で表示されている限り、非 ASCII 文字セットを表示するのに <a href="#set-locale">set-locale</a> 機構で十分であることに注意してください。
この章で記述されるマルチ・バイト文字セット用にのみ、UTF-8 エンコードが必要となります。<br />
Note that for many European languages,
the <a href="#set-locale">set-locale</a> mechanism
is sufficient to display non-ASCII character sets,
as long as each character is presented as <em>one</em> byte internally.
UTF-8 encoding is only necessary for multi-byte character sets as described 
in this chapter.</p>

<p>newLISP を UTF-8版アプリケーションとしてコンパイルできます。
UTF-8 は国際 Unicode 文字セットのマルチ・バイト・エンコーディングです。
UTF-8 利用可能なオペレーティングシステムで走っている UTF-8 版 newLISP は、導入されるロケールの文字セットを処理できます。
<br />
	newLISP can be compiled
	as a UTF-8&ndash;enabled application.
	UTF-8 is a multi-byte encoding
	of the international Unicode character set.
	A UTF-8&ndash;enabled newLISP
	running on an operating system with UTF-8 enabled
	can handle any character of the installed locale.
</p>
<p>次のステップは、特定のオペレーティングシステムやプラットフォームで、UTF-8 版 newLISP を作成します：<br />
	The following steps
	make UTF-8 work with newLISP
	on a specific operating system and platform:
</p>
<p><tt>(1)</tt>
newLISP を UTF-8 アプリケーションとしてコンパイルするために、<tt>utf8</tt> で終わっている makefile の一つを使ってください。
あなたのプラットフォームで利用可能な UTF-8 makefile がないならば、あなたのプラットフォーム用の一般 makefile に UTF-8 用に変えるための指示が入っています。
<br />
	　　Use one of the makefiles
	ending in <tt>utf8</tt>
	to compile newLISP as
	a UTF-8 application.
	If no UTF-8 makefile
	is available for your platform,
	the normal makefile
	for your operating system
	contains instructions
	on how to change it
	for UTF-8.
</p>
<p>
macOS バイナリ・インストーラには、デフォルトで UTF-8 版が入っています。
<br />
	The macOS binary installer contains
	a UTF-8&ndash;enabled version by default.
</p>
<p><tt>(2)</tt>
あなたのプラットフォームで、UTF-8 ロケールを許可してください。
Unix や Unix-like OS 上の <tt>locale</tt> コマンドか newLISP の関数 <tt>set-locale</tt> を使って、UTF-8 ロケールのチェックと設定をしてください。
Linux では、適切な環境変数を設定することでロケールを変更できます。
次の例は、U.S. ロケールの設定に <tt>bash</tt> を使っています：
<br />
	　　Enable the UTF-8 locale
	on your operating system.
	Check and set a UTF-8 locale
	on Unix and Unix-like OSes
	by using the <tt>locale</tt> command
	or the <tt>set-locale</tt> function within newLISP.
	On Linux, the locale can be changed by setting
	the appropriate environment variable.
	The following example uses <tt>bash</tt>
	to set the U.S. locale:
</p>
<pre>
export LC_CTYPE=en_US.UTF-8
</pre>		
<p><tt>(3)</tt>
UTF-8 版 newLISP はオペレーティングシステムで見つかったロケールに自動的に切り替えます。
コマンド・シェルを確実に UTF-8 可能にしてください。
U.S. 版 WinXP の <tt>notepad.exe</tt> はユニコード UTF-8 エンコード文字を表示可能ですが、コマンド・シェルはそれを表示できません。
Linux や他の Unix では、Xterm シェルの開始時、次のようにすれば可能です：<br />
　　The UTF-8&ndash;enabled newLISP automatically switches to the locale found
on the operating system.  Make sure the command shell
is UTF-8&ndash;enabled.  The U.S. version of WinXP's <tt>notepad.exe</tt>
can display Unicode UTF-8&ndash;encoded characters, but the command shell cannot.
On Linux and other Unixes, the Xterm shell can be used
when started as follows:</p>

<pre>
LC_CTYPE=en_US.UTF-8 xterm
</pre>		<p>
次の手続きを UTF-8 サポートのチェックに使えます。
newLISP を開始した後、次をタイプすると：
<br />
	The following procedure can now be used
	to check for UTF-8 support.
	After starting newLISP, type:
</p><pre>
(println (char 937))               ; displays Greek uppercase omega
(println (lower-case (char 937)))  ; displays lowercase omega
</pre>		<p>
ラテン・アルファベットでは、大文字のオメガ (&Omega;) が二つの小さい足の上に大きいＯのように見えている時、小文字のオメガ (&omega;) は小文字の <tt>w</tt> に似た形状を持ちます。<br />
	While the uppercase omega (&Omega;) looks
	like a big O on two tiny legs,
	the lowercase omega (&omega;) has
	a shape similar to a small <tt>w</tt>
	in the Latin alphabet.
</p>
<p>
注記：<tt>println</tt> の出力の時だけ、文字として表示されます。
<tt>println</tt> の戻り値は、マルチ・バイト ASCII 文字としてコンソールに現れます。<br />
	Note: Only the output of <tt>println</tt>
	will be displayed as a character;
	<tt>println</tt>'s return value
	will appear on the console
	as a multi-byte ASCII character.
</p>
<p>
UTF-8 を表示できない環境でも UTF-8 版 newLISP を使え、出力と戻り値の両方が２文字になります。
オメガ文字をエンコードするのに２バイト必要です。<br />
	When UTF-8&ndash;enabled newLISP
	is used on a non-UTF-8&ndash;enabled display,
	both the output and the return value
	will be two characters.
	These are the two bytes necessary
	to encode the omega character.
</p>

<br/>

<a name="utf8_capable"></a>
<h3>Functions working on UTF-8 characters（UTF-8 文字で動作する関数）</h3>

<p>UTF-8 版 newLISP が使える時、次の文字列関数は ８ビットの１バイト文字上ではなく、１バイトもしくはマルチ・バイト文字上で動作します（訳注：バイト単位でなく、文字単位で動作します）：<br />
When UTF-8&ndash;enabled newLISP is used, the following string functions work
on one- or multi-byte characters rather than one 8-bit byte boundaries:</p>

<table  width="98%" summary="functions working on character boundaries in UTF-8">
<tr align="left"><th>function</th><th>description</th></tr>

<tr>
<td><a href="#char">char</a></td>
<td>文字と ASCII/Unicode 間の変換をする<br />translates between characters and ASCII/Unicode</td>
</tr>

<tr>
<td><a href="#chop">chop</a></td>
<td>文字列の最後から文字を削除する<br />chops characters from the end of a string</td>
</tr>

<tr>
<td><a href="#date">date</a></td>
<td>（第三引数と共に使って）日付数値を文字列に変換する<br />converts date number to string (when used with the third argument)</td>
</tr>

<tr>
<td><a href="#dostring">dostring</a></td>
<td>文字列の各文字列で一回ずつ評価する<br />evaluates once for each character in a string</td>
</tr>

<tr>
<td><a href="#explode">explode</a></td>
<td>文字列を文字のリストに変換する<br />transforms a string into a list of characters</td>
</tr>

<tr>
<td><a href="#first">first</a></td>
<td>リスト (car, head) か文字列の第一要素を取得する<br />gets first element in a list (car, head) or string</td>
</tr>

<tr>

<td><a href="#last">last</a></td>
<td>リストか文字列の最後の要素を取得する<br />returns the last element of a list or string</td>
</tr>


<tr>
<td><a href="#lower-case">lower-case</a></td>
<td>文字列を小文字に変換する<br />converts a string to lowercase characters</td>
</tr>

<tr>
<td><a href="#nth">nth</a></td>
<td>リストか文字列のｎ番目の要素を取得する<br />gets the <em>nth</em> element of a list or string</td>
</tr>

<tr>
<td><a href="#pop">pop</a></td>
<td>リストや文字列から要素を削除する<br />deletes an element from a list or string</td>
</tr>

<tr>
<td><a href="#push">push</a></td>
<td>リストや文字列に新しい要素を挿入する<br />inserts a new element in a list or string</td>
</tr>

<tr>
<td><a href="#rest">rest</a></td>
<td>リスト (cdr, tail) か文字列の第一要素以外の全てを取得する<br />gets all but the first element of a list (cdr, tail) or string</td>
</tr>

<tr>
<td><a href="#select">select</a></td>
<td>リストか文字列から要素を選んで並べ換える<br />selects and permutes elements from a list or string</td>
</tr>

<tr>
<td><a href="#title-case">title-case</a></td>
<td>文字列の第一文字を大文字に変換する<br />converts the first character of a string to uppercase</td>
</tr>

<tr>
<td><a href="#trim">trim</a></td>
<td>文字列の両端からトリム（訳注：空白文字を削除）する<br />trims a string from both sides</td>
</tr>

<tr>
<td><a href="#upper-case">upper-case</a></td>
<td>文字列を大文字に変換する<br />converts a string to uppercase characters</td>
</tr>

</table><br/>

<p>他の文字列関数は全て、8ビット・バイト上で動作します。
<a href="#find">find</a> や <a href="#regex">regex</a> で返る位置は、マルチ・バイトの文字位置ではなく、１バイト単位の位置です。
関数 <a href="#get-char">get-char</a> と <a href="#slice">slice</a> は、UTF-8 版 newLISP であってもマルチ・バイト文字のオフセットを取らず、１バイト単位のオフセットになります。
関数 <a href="#reverse">reverse</a> は文字ベクターではなくバイト・ベクターで逆転します。
UTF-8 版 newLISP で、最後の三つの関数（訳注：<a href="#get-char">get-char</a>、<a href="#slice">slice</a>、<a href="#reverse">reverse</a> ）にできるのは、バイナリの非テキストデータ操作です。
UTF-8 文字列で動作する <a href="#slice">slice</a> と <a href="#reverse">reverse</a> を作成するには、<a href="#explode">explode</a> と <a href="#join">join</a> を組み合わせます。<br />
All other string functions work on 8-bit bytes.  When positions are returned,
as in <a href="#find">find</a> or <a href="#regex">regex</a>,
they are single 8-bit byte positions rather than character positions which
may be multi-byte.
The <a href="#get-char">get-char</a> and <a href="#slice">slice</a> functions
do not take multi-byte character offsets, but single-byte offsets, even
in UTF-8 enabled versions of newLISP.
The <a href="#reverse">reverse</a> function reverses
a byte vector, not a character vector. The last three functions can still 
be used to manipulate binary non-textual data in the UTF-8&ndash;enabled 
version of newLISP. To make <a href="#slice">slice</a> and <a href="#reverse">reverse</a>
work with UTF-8 strings, combine them with <a href="#explode">explode</a> and
<a href="#join">join</a>.</p>

<p><a href="#directory">directory</a>、<a href="#find">find</a>、<a href="#member">member</a>、<a href="#parse">parse</a>、<a href="#regex">regex</a>、<a href="#regex-comp">regex-comp</a>、<a href="#replace">replace</a> で使われる&mdash;Perl Compatible Regular Expressions (PCRE) で UTF-8 利用する際は、適宜オプション番号 (2048) を設定してください。
<a href="#regex">regex</a> の結果のオフセットと長さは、常に１バイト単位のカウントであることに注意してください。
詳細は、<a href="#regex">regex</a> の項を見てください。<br />
To enable UTF-8 in Perl Compatible Regular Expressions (PCRE)
&mdash; used by <a href="#directory">directory</a>, <a href="#find">find</a>, 
<a href="#member">member</a>, <a href="#parse">parse</a>, <a href="#regex">regex</a>, 
<a href="#regex-comp">regex-comp</a> and <a href="#replace">replace</a> &mdash;
set the option number accordingly (2048). Note that offset and lengths in 
<a href="#regex">regex</a> results are always in single byte counts.
See the <a href="#regex">regex</a> documentation for details.</p>

<p>
UTF-8 を操作できない関数関数で UTF-8 文字列のアレイを入手したり、バイトではなく文字を操作したい時は、<a href="#explode">explode</a> を使ってください<br />
Use <a href="#explode">explode</a> to obtain an array
of UTF-8 characters and to manipulate characters rather than bytes
when a UTF-8&ndash;enabled function is unavailable:</p>

<pre>
(join (reverse (explode str)))  ; reverse UTF-8 characters
</pre>		

<p>こうすれば、上記（非テキストのバイナリ・データの操作によく使われる）文字列関数がバイト境界ではなく文字境界で動作します。このように、UTF-8 バージョンを使う時は注意が必要です。
ISO 8859 のような一般的なコード・ページでは、ASCII 文字の最初の 127 個は１バイト長です。
このようなコード・ページでのみ動かすなら、UTF-8 版 newLISP は必要ありません。
動作をローカル化するための関数 <a href="#set-locale">set-locale</a> で十分です。<br />
The above string functions (often used to manipulate non-textual binary data)
now work on character, rather than byte, boundaries,
so care must be exercised when using the UTF-8&ndash;enabled version.
The size of the first 127 ASCII characters &mdash;
along with the characters in popular code pages such as ISO 8859 &mdash;
is one byte long.  When working exclusively within these code pages,
UTF-8&ndash;enabled newLISP is not required. 
The <a href="#set-locale">set-locale</a> function alone
is sufficient for localized behavior.</p>

<br/>

<a name="utf8_version"></a>
<h3>Functions only available on UTF-8 enabled versions（UTF-8 バージョンでのみ利用できる関数）</h3>

<table  width="98%" summary="functions only available on UTF-8 version">
<tr align="left"><th>function</th><th>description</th></tr>

<tr>
<td><a href="#unicode">unicode</a></td>
<td>UTF-8 文字列や ASCII 文字列を USC-4 ユニコードに変換する<br />converts UTF-8 or ASCII strings into USC-4 Unicode</td>
</tr>

<tr>
<td><a href="#utf8">utf8</a></td>
<td>USC-4 ユニコード文字列を UTF-8 に変換する<br />converts UCS-4 Unicode strings to UTF-8</td>
</tr>

<tr>
<td><a href="#utf8len">utf8len</a></td>
<td>文字列の UTF-8 文字数を返す<br />returns the number of UTF-8 characters in a string</td>
</tr>

</table><br/>

<p>
ほとんどの Unicode テキストは、すでに（4バイト文字を使う UCS-4 よりはむしろ）UTF-8 エンコードされているので、最初の二つの関数が実際に使われることは、めったにありません。
<a href="#format">format</a> の <tt>"%ls"</tt> 指定子を使って、Unicode を直接表示できます。<br />
The first two functions are rarely used in practice,
as most Unicode text files are already UTF-8&ndash;encoded
(rather than UCS-4, which uses four-byte integer characters).
Unicode can be displayed directly when using the 
<tt>"%ls"</tt> <a href="#format">format</a> specifier.</p>

<p>UTF-8 と Unicode のさらなる詳細については、<em>Markus Kuhn</em> による <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html"><em>UTF-8 and Unicode FAQ for Unix/Linux</em></a> を調べてみてください。<br />
For further details on UTF-8 and Unicode,
consult <a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html"><em>UTF-8 and Unicode FAQ 
for Unix/Linux</em></a> by <em>Markus Kuhn</em>.</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>

<a name="commas"></a>
<h2>22. Commas in parameter lists（パラメータ リストのカンマ）</h2>

<p>
	例題プログラムの中には、パラメータを二つのグループに分けるカンマを使っている関数があります。
	これは newLISP の特殊構文でなく、どちらかというと視覚的トリックです。
	カンマは他のシンボルと同様に単なるシンボルです。
	関数が呼ばれた時、カンマ以降のパラメータが必要とされておらず（訳注：必要とされないように関数が書かれているという意味）、単にローカル変数として簡易的な方法で宣言されているだけです。
	これが newLISP で可能なのは、ラムダ式内のパラメータ変数がローカルになり、引数はオプションになるためです：<br />
	Some of the example programs contain functions
	that use a comma to separate the parameters into two groups.
	This is not a special syntax of newLISP,
	but rather a visual trick.
	The comma is a symbol just like any other symbol.
	The parameters after the comma are not required
	when calling the function;
	they simply declare local variables in a convenient way.
	This is possible in newLISP because parameter variables in lambda expressions
	are local and arguments are optional:
</p>
<pre>
(define (my-func a b c , x y z)
    (set 'x &hellip;)
(&hellip;))
</pre>		<p>
この関数が呼ばれた時、<tt>a</tt>、<tt>b</tt>、<tt>c</tt> だけがパラメータとして使われます。
他 (<tt>x, y</tt>, <tt>z</tt>) は nil で初期化され、関数のローカル変数になります。
実行後、この関数の内部変数は忘れ去られ、環境に存在したシンボルの値は、以前の値に戻ります。<br />
When calling this function, only <tt>a, b</tt>, and <tt>c</tt> are used as parameters.
The others (the comma symbol, <tt>x</tt>, <tt> y</tt>, and <tt>z</tt>) are initialized 
to <tt>nil</tt> and are local to the function.  After execution, the function's contents 
are forgotten and the environment's symbols are restored to their previous values.
</p>
<p>
	ローカル変数を宣言し、初期化する他の方法については <a href="#let">let</a>、<a href="#letex">letex</a>、<a href="#letn">letn</a> を見てください。<br />
	For other ways of declaring and initializing local variables,
	see <a href="#let">let</a>, <a href="#letex">letex</a> and
	<a href="#letn">letn</a>.
</p>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>


<br/><br/><br/>


<center style="font-size: 150%">
<span class="divider">(&nbsp;<font color="#7ba9d4">&part;</font>&nbsp;)</span>
</center>

<a name="function_ref"></a>
<center><h1>newLISP Function Reference（newLISP 関数リファレンス）</h1></center>

<br/><br/>

<a name="symbol_names"></a>
<h2>1. Syntax of symbol variables and numbers（シンボル変数と数値の構文）</h2>

<p>newLISP におけるソース・コードは、ここで概説される規則に従って解析されます。
疑わしい時は、オプションの引数無しで <a href="#parse">parse</a> を使い、newLISP の内部解析動作を確認してください。<br />
Source code in newLISP is parsed according to the rules outlined here. 
When in doubt, verify the behavior of newLISP's internal parser
by calling <a href="#parse">parse</a> without optional arguments.</p>

<br/>

<h3>Symbols for variable names（変数名のシンボル）</h3>

<p>
変数や関数に使われるシンボルの命名には、次の規則が適用されます：
<br />
The following rules apply to the naming of symbols 
used as variables or functions:
</p>

<ol>
<li>変数シンボルは、次の文字から始まってはならない：<br/><tt># ; " ' ( )  { } . , 0 1 2 3 4 5 6 7 8 9</tt><br />Variable symbols should not start with any of the following characters:<br/><tt># ; " ' ( )  { } . , 0 1 2 3 4 5 6 7 8 9</tt><br/><br/></li>

<li><tt>+</tt> または <tt>-</tt> で始まる変数シンボルは、二文字目に数字を使うことはできない。<br />Variable symbols starting with a <tt>+</tt> or <tt>-</tt> cannot have a number as the second character.<br/><br/></li>

<li>変数名の内部にはどんな文字も許されるが、以下の文字は除く：<br><tt>" ' ( ) : ,</tt> 半角スペース。これらは、変数シンボルの終りを意味する。<br />Any character is allowed inside a variable name, except for:<br/><tt>" ' ( ) : ,</tt> and the space character. These mark the end of a variable symbol.<br/><br/></li>

<li><tt>[</tt>（左角括弧）で始まり <tt>]</tt>（右角括弧）で終わるシンボルは、右角括弧を除くどんな文字を含んでもよい。<br />A symbol name starting with <tt>[</tt> (left square bracket) and ending with <tt>]</tt> (right square bracket) may contain any character except the right square bracket.<br/><br/></li>

<li><tt>$</tt>（ドル記号）で始まるシンボルはグローバルになる。前もって <a href="#system_symbols">newLISP に組み込まれているもの</a>も有り、内部で設定または変更される。この種のグローバル・シンボルをユーザが生成することもできる。<br />A symbol name starting with <tt>$</tt> (dollar sign) is global. There are several of these symbols already <a href="#system_symbols">built into newLISP</a> and set and changed internally. This type of global symbol can also be created by the user.</li>

</ol>

<p>
newLISP において、次のシンボルは全て適正なシンボル名です：<br />
All of the following symbols are legal variable names in newLISP:
</p>

<!-- example -->

<pre>
myvar
A-name
X34-zz
[* 7 5 ()};]
*111*
</pre>

<p>
newLISP の変数としては不適切な文字からなるキーを持つハッシュ似の<a href="#hash">検索辞書</a>を生成することが、時として有用です。
このような文字を含むシンボルの生成に関数 <a href="#sym">sym</a> と <a href="#context">context</a> が使えます：<br />
Sometimes it is useful to create hash-like <a href="#hash">lookup dictionaries</a>
with keys containing characters that are illegal in newLISP variables. 
The functions <a href="#sym">sym</a> and <a href="#context">context</a> 
can be used to create symbols containing these characters:
</p>

<pre>
(set (sym "(#:L*") 456)  <span class='arw'>&rarr;</span> 456 ; the symbol '(#:L*'

(eval (sym "(#:L*"))  <span class='arw'>&rarr;</span> 456

(set (sym 1) 123)  <span class='arw'>&rarr;</span> 123

(eval (sym 1))  <span class='arw'>&rarr;</span> 123

1        <span class='arw'>&rarr;</span> 1
(+ 1 2)  <span class='arw'>&rarr;</span> 3
</pre>

<p>
最後の例は、値 <tt>123</tt> を持つシンボル <tt>1</tt> を生成しています。<tt>1</tt> は数字の一としても解析される状態のまま残ります。このようなシンボル生成が newLISP の通常操作を変更しないことにも注意が必要です。<br />
The last example creates the symbol <tt>1</tt> 
containing the value <tt>123</tt>. 
Also note that creating such a symbol does not alter newLISP's normal operations, 
since <tt>1</tt> is still parsed as the number one.
</p>

<br/>

<h3>Numbers（数値）</h3>

<p>二進数、十六進数、十進数、浮動小数、整数値の解析において、今のところ 1000 桁までは解析されます。残りは新トークンとして読み込まれます。
注記：IEEE 754 の 64 ビット倍精度で識別できる桁数は高々16桁です。指数部が308以上ならば、その数値は <tt>inf</tt>（無限大）になります。
大整数においてもソースの解析時には 1000 桁の制限があります。1000桁を超える整数の演算の結果には制限はありません。<br />
When parsing binary, hex, decimal, float and integer numbers, up to
1000 digits are parsed when present. The rest will be read as new token(s).
Note that IEEE 754 64-bit doubles distinguish only up to 16 significant
digits. If more than 308 digits are present before the decimal point, the
number will convert to <tt>inf</tt> (infinity). For big integers the 1000 
limitation exists only when parsing source. There is no limit when a result 
of big integers math exceeds 1000 digits.</p>

<p>
newLISP は次の数値形式を認識します：<br />
newLISP recognizes the following number formats:
</p>

<p>
<b>整数</b>は一個以上のアラビア数字からなり、オプションで <tt>+</tt> か <tt>-</tt> の符号が先に付きます。
それ以外の文字は整数の終りを意味します。
浮動小数点として解析される場合は、数値の一部の可能性もあります（下の浮動小数点構文を見てください）。<br />
<b>Integers</b> are one or more digits long, 
optionally preceded by a <tt>+</tt> or <tt>-</tt> sign. 
Any other character marks the end of the integer 
or may be part of the sequence 
if parsed as a float (see float syntax below).
</p>

<!-- example -->

<pre>
123
+4567
-999
</pre>

<p>
<b>大整数</b>の桁数には制限がなく、通常の 64 ビット整数とは内部処理が異なります。<br />
<b>Big integers</b> can be of unlimited precision and are processed
differently from normal 64-bi integers internally.</p>

<!-- example -->
<pre>
123456789012345678901234567890 ; will automatically be converted to big int
-123L                          ; appended L forces conversion
0L
</pre>

<p>newLISP はコマンド・ラインやプログラミング・ソースを解析する際、64ビット整数より大きな数を認識すると、大整数に変換します。
小さい数でも末尾に文字 L を追加することで、強制的に大変数にできます。<br />
when parsing the command line or programming source, newLISP will
recognise, integers bigger than 64-bit and convert the to big integers.
Smaller numbers can be forced to big integer format by appending the
letter L.</p>


<p>
<b>十六進数</b>は、<tt>0x</tt> (または <tt>0X</tt>) で始まり、十六進数字 <tt>0123456789abcdefABCDEF</tt> の組み合わせが続きます。
それ以外の文字は十六進数の終りを意味します。
その際、十六進数までが有効で、それ以上の桁は全て無視されます。<br />
<b>Hexadecimals</b> start with a <tt>0x</tt> (or <tt>0X</tt>),  
followed by any combination of the hexadecimal digits: 
<tt>0123456789abcdefABCDEF</tt>. 
Any other character ends the hexadecimal number. Only up to 16 hexadecimal digits
are valid and any more digits are ignored.
</p>

<!-- example -->

<pre>
0xFF    <span class='arw'>&rarr;</span>  255
0x10ab  <span class='arw'>&rarr;</span> 4267
0X10CC  <span class='arw'>&rarr;</span> 4300
</pre>

<p><b>二進数</b>は<tt>0b</tt> (または <tt>0B</tt>) で始まり、64個まで 1 か 0 が 続きます。
それ以外の文字は二進数の終わりを意味します。
つまり、どんな文字も二進数の終わりになります。
64 ビットまでが有効でそれ以上のビットは無視されます。<br />
<b>Binaries</b> start with a <tt>0b</tt> (or <tt>0B</tt>),
followed by up to 64 bits coded with 1's or 0s. Any other character ends the binary number.
Only up to 64 bits are valid and any more bits are ignored.
</p>

<!-- example -->

<pre>
0b101010   <span class='arw'>&rarr;</span>  42
</pre>



<p>
<b>八進数</b>はオプションの <tt>+</tt> (plus) か <tt>-</tt> (minus) 符号と <tt>0</tt>（ゼロ）から始まり、八進数字 <tt>01234567</tt> の組み合わせが続きます。
21 桁までが有効で、それ以上の桁は無視されます。<br />
<b>Octals</b> start with an optional <tt>+</tt> (plus) or <tt>-</tt> (minus) sign and a <tt>0</tt> (zero), 
followed by any combination of the octal digits: <tt>01234567</tt>. 
Any other character ends the octal number. Only up to 21 octal digits are valid
and any more digits are ignored.
</p>

<!-- example -->

<pre>
012   <span class='arw'>&rarr;</span>  10
010   <span class='arw'>&rarr;</span>   8
077   <span class='arw'>&rarr;</span>  63
-077  <span class='arw'>&rarr;</span> -63
</pre>

<p>
<b>浮動小数点</b>数はオプションの <tt>+</tt> (plus) か <tt>-</tt> (minus) 符号で始められますが、その後に <tt>0</tt> (zero) を続けることはできません。
それでは浮動小数点の代わりに八進数になってしまうからです。
先頭を含む、浮動小数点数中のどこにでも一個の <tt>.</tt> (小数点) を置けます。<br />
<b>Floating point</b> numbers can start 
with an optional <tt>+</tt> (plus) or <tt>-</tt> (minus) sign, 
but they cannot be followed by a <tt>0</tt> (zero); 
this would make them octal numbers instead of floating points. 
A single <tt>.</tt> (decimal point) can appear anywhere within
a floating point number, including at the beginning.
</p>

<p>16 桁までが有効で、それ以上の桁は無視されます。（訳注:16 桁を超える<b>入力</b>はすべきではありません）<br />
Only 16 digits are siginificant and any more digits are ignored.</p>

<!-- example -->

<pre>
1.23     <span class='arw'>&rarr;</span>  1.23
-1.23    <span class='arw'>&rarr;</span> -1.23
+2.3456  <span class='arw'>&rarr;</span>  2.3456
.506     <span class='arw'>&rarr;</span>  0.506
</pre>

<p>
下記のように、<b><a href="http://ja.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E8%A1%A8%E8%A8%98">指数表記</a></b>（または、科学的表記）は<em>仮数部</em>（または<em>仮数</em> ）と呼ばれる浮動小数点数から始まり、<tt>e</tt> か <tt>E</tt> の文字と整数の<em>指数部</em> が続きます。<br />
As described below, <b>scientific notation</b> 
starts with a floating point number 
called the <em>significand</em> (or <em>mantissa</em>), 
followed by the letter <tt>e</tt> or <tt>E</tt> 
and an integer <em>exponent</em>.
</p>

<!-- example -->

<pre>
1.23e3    <span class='arw'>&rarr;</span>  1230
-1.23E3   <span class='arw'>&rarr;</span> -1230
+2.34e-2  <span class='arw'>&rarr;</span>  0.0234
.506E3    <span class='arw'>&rarr;</span>  506
</pre>

<br/>
<center>

<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>
<br/>

<a name="type_ids"></a>
<h2>2. Data types and names in the reference（リファレンスでのデータ型と名前）</h2>

<p>
このリファレンス項での関数パラメータの型と名前の表記には、次の命名則が適用されます：<br />
To describe the types and names of a function's parameters, 
the following naming convention is used throughout the reference section:</p>

<b>syntax&#058; (format <em>str-format</em> <em>exp-data-1</em> [<em>exp-data-i</em> ... ])</b>

<p>引数は、引数の型と名前を <tt>-</tt> (hyphen) で区切った形式で表す。
例えば、 <em>str-format</em>（一個の文字列）と <em>exp-data-1</em>（一個の式）の名前は、それぞれ "format" と "data-1" となる。<br />
Arguments are represented by symbols formed by the argument's type and name, 
separated by a <tt>-</tt> (hyphen). Here, <em>str-format</em> (a string) and 
<em>exp-data-1</em> (an expression) are named "format" and "data-1", respectively.</p>

<p>角括弧 <tt>[</tt> と <tt>]</tt> で囲まれた引数はオプションである。
縦線 <tt>|</tt> で区切られた引数は、その中の一つが選択される。<br />
Arguments enclosed in brackets <tt>[</tt> and <tt>]</tt> are optional. When
arguments are separated by a vertical <tt>|</tt> then one of them must be chosen.</p>

<h3>array</h3>

<p>（関数 <a href="#array">array</a> で作成される）アレイ。<br />
An array (constructed with the <a href="#array">array</a> function).</p>

<h3>body</h3>

<p>評価するための一個以上の式。
一個より多い式は、連続して評価される。<br />
One or more expressions for evaluation. The expressions are evaluated sequentially 
if there is more than one.</p>

<pre>
1 7.8
nil
(+ 3 4)
"Hi" (+ a b)(print result)
(do-this)(do-that) 123
</pre>

<h3>bool</h3>

<p><tt>true</tt> か <tt>nil</tt>、または、この二つのどちらかに評価される式。<br />
<tt>true</tt>, <tt>nil</tt>, or an expression evaluating to one of these two.
</p>

<pre>
true, nil, (&lt;= X 10)

</pre>

<h3>context</h3>

<p>コンテキスト（名前空間）に評価される式、または、コンテキストを保持する変数シンボル。<br />
An expression evaluating to a context (namespace) or a variable symbol 
holding a context.</p>

<pre>
MyContext, aCtx, TheCTX
</pre>

<h3>exp</h3>

<p>この章に表記されているあらゆるデータ型。<br />
Any data type described in this chapter.</p>

<h3>func</h3>

<p>演算子シンボルかラムダ式に評価されるシンボル、または、式。<br />
	A symbol or an expression evaluating to 
	an operator symbol or lambda expression.
</p>

<pre>
+, add, (first '(add sub)), (lambda (x) (+ x x))
</pre>

<h3>int</h3>

<p>
整数、または、整数に評価される式。
一般に、整数が予想されるところに浮動小数点数が使われた場合、値は整数に切り捨てらる。<br />
An integer or an expression evaluating to an integer. 
Generally, if a floating point number is used 
when an int is expected, 
the value is truncated to an integer.
</p>

<pre>
123, 5, (* X 5)
</pre>

<h3>list</h3>
<p>（あらゆる型の）要素のリスト、または、リストに評価される式。<br />
	A list of elements (any type) 
	or an expression evaluating to a list.
</p>

<pre>
(a b c "hello" (+ 3 4))
</pre>

<h3>num</h3>

<p>
整数か浮動小数点数、または、このどちらかに評価される式。
整数が渡された場合は、浮動小数点数に変換される。<br />
An integer, a floating point number, 
or an expression evaluating to one of these two. 
If an integer is passed, 
it is converted to a floating point number.
</p>

<pre>
1.234, (div 10 3), (sin 1)

</pre>

<h3>matrix</h3>

<p>各行の要素がリストのリスト、または、各行の要素がアレイのアレイ。
全ての（行の）要素リストまたはアレイは、同じ長さである。
どのようなような型も行列の要素にできるが、
<a href="#det">det</a>、
<a href="#multiply">multiply</A>、
<a href="#invert">invert</A> 
のような行列専用操作を使う時は、全ての数値が浮動小数点数か整数でなければならない。<br />
A list in which each row element is itself a list 
or an array in which each row element is itself an array.
All element lists or arrays (rows) are of the same length.
Any data type can be element of a matrix, but when
using specific matrix operations like <a href="#det">det</a>, 
<a href="#multiply">multiply</a>, or <a href="#invert">invert</a>, 
all numbers must be floats or integers.
</p>

<p>
行列の次元は、行の数と行当たりの列の数を指し示すことで定義される。
行列で動作する関数は、行中の余計な列を無視する。
見つからない行の要素には、
関数<a href="#det">det</a>、
<a href="#multiply">multiply</a>、
<a href="#invert">invert</a> では <tt>0.0</tt> が割り当てられ、
<a href="#transpose">transpose</a> では <tt>nil</tt> が割り当てられる。
行がリストやアレイでなく、何か他のデータ型の時、<a href="#transpose">transpose</a> には特殊規則が適用される。<br />
The dimensions of a matrix are defined 
by indicating the number of rows 
and the number of column elements per row. 
Functions working on matrices 
ignore superfluous columns in a row. 
For missing row elements, 
<tt>0.0</tt> is assumed by the functions 
<a href="#det">det</a>, <a href="#multiply">multiply</a>, 
and <a href="#invert">invert</a>, 
while <a href="#transpose">transpose</a> assumes <tt>nil</tt>.
Special rules apply for <a href="#transpose">transpose</a> 
when a whole row is not a list or an array, 
but some other data type.
</p>

<pre>
((1  2  3  4)
(5  6  7  8)
(9 10 11 12))        ; 3 rows 4 columns
		   
((1 2) (3 4) (5 6))  ; 3 rows 2 columns
</pre>

<h3>place</h3>

<p>シンボルによって参照される位置、または、リストやアレイで定義される位置、または、<a href="#nth">nth</a> や <a href="#indexing">暗黙の要素指定</a> で
指し示される文字列、または、
<a href="#first">first</a>、
<a href="#last">last</a>、
<a href="#assoc">assoc</a>、
<a href="#lookup">lookup</a> のような関数で参照される位置。
<br />
A place referenced by a symbol or a place defined in a list, array 
or string by indexing with <a href="#nth">nth</a> or <a href="#indexing">implicit indexing</a> 
or a place referenced by functions like <a href="#first">first</a>, <a href="#last">last</a>, 
<a href="#assoc">assoc</a> or <a href="#lookup">lookup</a>.</p>


<h3>str</h3>

<p>
文字列、または、文字列に評価される式。<br />
A string or an expression that evaluates to a string.
</p>

<p>文字列は長さや特殊文字の処理により範囲が決まります。クォート <tt>""</tt> や括弧 <tt>{}</tt>、<tt>[text][/text]</tt> タグ によってです。<br />
Depending on the length and processing of special characters, strings are delimited
by either quotes <tt>""</tt>, braces <tt>{}</tt> or <tt>[text][/text]</tt> tags.</p>

<p>クォート <tt>""</tt> や括弧 <tt>{}</tt> でくくる文字列は 2047 文字を超えてはいけません。それより長い文字列には長さ制限のない文字列をくくれる <tt>[text][/text]</tt> タグを使うべきです。<br />
Strings limited by either quotes <tt>""</tt> or braces <tt>{}</tt> must not exceed
2047 characters. Longer strings should be limited by <tt>[text][/text]</tt> tags for
unlimited text length.</p>

<pre>
"Hello", (append first-name  " Miller")
</pre>


<p>
特殊文字は、キャラクタか数字の前にエスケープを示す <tt>\</tt> (バックスラッシュ、訳注：日本語環境では円記号 &yen; ) を置くことでクォートされた文字内に含めることが可能：<br />
Special characters can be included in quoted strings 
by placing a <tt>\</tt> (backslash) before the character or 
digits to escape them:</p>

<table width="98%"  summary="escaping special characters in strings">
<tr align="left" valign="bottom"><th>character</th><th>description</th></tr>
<tr><td><tt>\"</tt></td><td>ダブル・クォートで囲まれた文字列内のダブル・クォート<br />for a double quote inside a quoted string</td></tr>
<td><tt>\n</tt></td><td>ライン・フィード文字 (ASCII 10)<br />the line-feed character (ASCII 10)</td></tr>
<tr><td><tt>\r</tt></td><td>キャリッジ・リターン文字 (ASCII 13)<br />the carriage return character (ASCII 13)</td></tr>
<tr><td><tt>\b</tt></td><td>バックスペース文字 (ASCII 8)<br />for a backspace BS character (ASCII 8)</td></tr>
<tr><td><tt>\t</tt></td><td>タブ文字 (ASCII 9)<br />the tab character (ASCII 9)</td></tr><tr>
<tr><td><tt>\f</tt></td><td>フォームフィード文字 (ASCII 12)<br />for a formfeed FF character (ASCII 12)</td></tr>
<td><tt>\nnn</tt></td><td>十進数のアスキー・コードで、nnn は 000 から 255 です<br />a decimal ASCII code where nnn is between 000 and 255</td></tr>
<tr><td><tt>\xnn</tt></td><td>十六進数コードで、nn は 00 から FF です<br />a hexadecimal code where nn is between 00 and FF</td></tr>
<tr><td><tt>\unnnn</tt></td><td>4 つの <tt>nnnn</tt> 十六進数にエンコードされたユニコード文字。UTF-8 版 newLISP がクォートされた文字列を読みる時は、UTF8 文字に翻訳する。<br />a unicode character encoded in the four <tt>nnnn</tt> hexadecimal digits. When reading a quoted string, newLISP will translate this to a UTF8 character in the UTF8 enabled versions of newLISP.</td></tr>
<tr><td><tt>\\</tt></td><td>バックスラッシュ文字（訳注：日本語環境では円記号 &yen; ）自体<br />the backslash character itself</td></tr>
</table><br/>

<p>十進数は数字で始まる。十六進数は <tt>x</tt>で始まる：<br />
Decimals start with a digit. Hexadecimals start with <tt>x</tt>:</p>

<pre>
"\065\066\067" <span class='arw'>&rarr;</span> "ABC"
"\x41\x42\x43" <span class='arw'>&rarr;</span> "ABC"
</pre>

<p><tt>"</tt> (double quote) の代わりに、<tt>{</tt> (左波括弧) と <tt>}</tt> (右波括弧) が文字列を囲むのに使える。
これは、引用マークが文字列内に必要な時、役に立つ。
波括弧による引用は、特殊文字用のバックスラッシュのエスケープ効果を抑制する。
対応が取れている波括弧も文字列における場合もある。
これは、正規表現や HTML の短い部品を書く時の助けになる。<br />
Instead of a <tt>"</tt> (double quote), a <tt>{</tt> (left curly bracket) 
and <tt>}</tt> (right curly bracket) can be used to delimit strings.
This is useful when quotation marks need to occur inside strings. 
Quoting with the curly brackets suppresses the backslash escape effect 
for special characters. Balanced nested curly brackets may be used within 
a string.  This aids in writing regular expressions or short sections of 
HTML.</p>

<pre>
(print "&lt;a href=\"http://mysite.com\"&gt;" ) ; the cryptic way

(print {&lt;a href="http://mysite.com"&gt;} )   ; the readable way


; path names on MS Windows

(set 'path "C:\\MyDir\\example.lsp")

; no escaping when using braces

(set 'path {C:\MyDir\example.lsp})

; on MS Windows the forward slash can be used in path names

(set 'path "C:/MyDir/example.lsp")

; inner braces are balanced
(regex {abc{1,2}} line) 

(print [text]
  this could be
  a very long (&gt; 2048 characters) text,
  i.e. HTML.
[/text])

</pre>

<p><tt>[text]</tt> と <tt>[/text]</tt> のタグは、長い文字列を囲みたい時やエスケープ文字翻訳を抑圧したい時に使える。
	これは、newLISP で書かれた CGI ファイルの HTML 節を囲見たい時や文字変換を完全に抑圧したい時に役立つ。
	2048文字を超える文字列では、常に <tt>[text]</tt> タグを使う。<br />
	The tags <tt>[text]</tt> and <tt>[/text]</tt> 
	can be used to delimit long strings 
	and suppress escape character translation. 
	This is useful for delimiting long HTML passages 
	in CGI files written in newLISP 
	or for situations where character translation 
	should be completely suppressed. 
	Always use the <tt>[text]</tt> tags 
	for strings longer than 2048 characters.
</p>

<h3>sym</h3>

<p>シンボル、または、シンボルに評価される式。<br />
	A symbol or expression evaluating to a symbol.
</p>

<pre>
'xyz, (first '(+ - /)), '*, '- , someSymbol,
</pre>

<p>このマニュアルにあるコンテキスト・シンボルの多くは、他のシンボルと区別するために、大文字で始まっている。<br />
Most of the context symbols in this manual start with an uppercase letter 
to distinguish them from other symbols.</p>

<h3>sym-context</h3>

<p>
シンボル、存在するコンテキスト、または、コンテキストが生成されるシンボルに評価される式。
コンテキストが存在していない場合、多くの関数は無条件にコンテキストを生成する（例えば、<a href="#bayes-train">bayes-train</a>、
<a Href="#context">context</a>、 
<a href="#eval-string">eval-string</a>、
<a href="#load">load</a>、
<a href="#sym">sym</a>、
<a href="#xml-parse">xml-parse</a>）。
これらの関数が存在するコンテキストで使われる時、コンテキストは指定される必要がある。
いくつかの関数は、クォートされたシンボルを取ることで継続する（例えば、<a href="#context">context</a>）。
<a href="#contextp">context?</a> のような関数にとって、この区別は重要である。<br>
（訳注：<a href="#context">context</a> にクォートされたシンボルを渡した場合、そのコンテキストが存在していない時は、生成され、そのコンテキストに入ります。
<a href="#contextp">context?</a> にクォートされたシンボルを渡した場合、<tt>nil</tt> になります。）<br />
A symbol, an existing context, or an expression evaluating to a symbol 
from which a context will be created.  If a context does not already exist, 
many functions implicitly create them 
(e.g., <a href="#bayes-train">bayes-train</a>, <a Href="#context">context</a>, 
<a href="#eval-string">eval-string</a>, 
<a href="#load">load</a>, <a href="#sym">sym</a>, and <a href="#xml-parse">xml-parse</a>). 
The context must be specified when these functions are used 
on an existing context.  Even if a context already exists, 
some functions may continue to take quoted symbols (e.g., <a href="#context">context</a>). 
For other functions, such as <a href="#contextp">context?</a>, the distinction is critical.
</p>

<br/>

<br/>
<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">§</font>&nbsp;)</span>
</center>
<br/>

<a name="functions"></a>
<h2>3. Functions in groups（グループ毎の関数）</h2>

<p>いくつかの関数は複数のグループに現れます。<br />
Some functions appear in more than one group.</p>

<a name="list_processing"></a>
<h3>List processing, flow control, and integer arithmetic（リスト処理、フロー制御と整数演算）</h3>

<table border="0" cellpadding="1" width="95%" align="center" summary="List processing, flow control and integer
arithmetic">

<tbody><tr>
<td width="16%"><a href="#arithmetic">+, -, *, /, %</a></td>
<td width="80%">整数演算<br />integer arithmetic</td>
</tr>

<tr>
<td><a href="#inci">++</a></td>
<td>整数を加算する<br />increment integer numbers</td>
</tr>

<tr>
<td><a href="#deci">--</a></td>
<td>整数を減算する<br />decrement integer numbers</td>
</tr>

<tr>
<td><a href="#logical">&lt;, &gt;, =</a></td>
<td>あらゆるデータの比較：未満、超過、等号<br />compares any data type: less, greater, equal</td>
</tr>

<tr>
<td><a href="#logical">&lt;=, &gt;=, !=</a></td>
<td>あらゆるデータの比較：以下、以上、不等号<br />compares any data type: less-equal, greater-equal, not-equal</td>
</tr>

<tr>
<td><a href="#colon">:</a></td>
<td>コンテキスト・シンボルを作成し、オブジェクトに適用する<br />constructs a context symbol and applies it to an object</td>
</tr>

<tr>
<td><a href="#and">and</a></td>
<td>論理積<br />logical <tt>and</tt></td>
</tr>

<tr>
<td><a href="#append">append</a></td>
<td>リスト、アレイ、文字列を結合し、新しいリスト、アレイ、文字列を形成する<br />appends lists ,arrays or strings to form a new list, array or string</td>
</tr>

<tr>
<td><a href="#apply">apply</a></td>
<td>関数や組込関数を引数のリストに適用する<br />applies a function or primitive to a list of arguments</td>
</tr>

<tr>
<td><a href="#args">args</a></td>
<td>関数やマクロ式の引数リストを取り出す<br />retrieves the argument list of a function or macro expression</td>
</tr>

<tr>
<td><a href="#assoc">assoc</a></td>
<td>リストの連想キーワードを検索する<br />searches for keyword associations in a list</td>
</tr>

<tr>
<td><a href="#begin">begin</a></td>
<td>関数のブロックを開始する<br />begins a block of functions</td>
</tr>

<tr>
<td><a href="#bigint">bigint</a></td>
<td>数値を大整数に変換する<br />convert a number to big integer format</td>
</tr>

<tr>
<td><a href="#bind">bind</a></td>
<td>リストの連想変数を束縛する<br />binds variable associations in a list</td>
</tr>

<tr>
<td><a href="#case">case</a></td>
<td>制御変数の内容で分岐する<br />branches depending on contents of control variable</td>
</tr>

<tr>
<td><a href="#catch">catch</a></td>
<td>式の評価する、あるいは、エラーを補足する<br />evaluates an expression, possibly catching errors</td>
</tr>

<tr>
<td><a href="#chop">chop</a></td>
<td>リストの最後の要素をきり落とす<br />chops elements from the end of a list</td>
</tr>

<tr>
<td><a href="#clean">clean</a></td>
<td>リストから要素を取り除く<br />cleans elements from a list</td>
</tr>

<tr>
<td><a href="#collect">collect</a></td>
<td>式を繰り返し評価し、結果をリストに集める<br />repeat evaluating an expression and collect results in a list</td>
</tr>

<tr>
<td><a href="#cond">cond</a></td>
<td>式次第で分岐する<br />branches conditionally to expressions</td>
</tr>

<tr>
<td><a href="#cons">cons</a></td>
<td>リストの前に要素をつけ、新リストを作る<br />prepends an element to a list, making a new list</td>
</tr>

<tr>
<td><a href="#constant">constant</a></td>
<td>定数シンボルを定義する<br />defines a constant symbol</td>
</tr>

<tr>
<td><a href="#count">count</a></td>
<td>リストの要素が別のリストに出現する数を数える<br />counts elements of one list that occur in another list</td>
</tr>

<tr>
<td><a href="#curry">curry</a></td>
<td>関数 fx(y) を関数 f(x, y) に変換する<br />transforms a function f(x, y) into a function fx(y)</td>
</tr>

<tr>
<td><a href="#define">define</a></td>
<td>新関数やラムダ式を定義する<br />defines a new function or lambda expression</td>
</tr>

<tr>
<td><a href="#define-macro">define-macro</a></td>
<td>マクロやラムダ・マクロ式を定義する<br />defines a macro or lambda-macro expression</td>
</tr>

<tr>
<td><a href="#def-new">def-new</a></td>
<td>異なるコンテキスト（名前空間）にシンボルをコピーする<br />copies a symbol to a different context (namespace)</td>
</tr>

<tr>
<td><a href="#difference">difference</a></td>
<td>二つのリスト間の差を返す<br />returns the difference between two lists</td>
</tr>

<tr>
<td><a href="#doargs">doargs</a></td>
<td>関数の引数を通して繰り返す<br />iterates through the arguments of a function</td>
</tr>

<tr>
<td><a href="#dolist">dolist</a></td>
<td>リストの各要素で一回ずつ評価する<br />evaluates once for each element in a list</td>
</tr>

<tr>
<td><a href="#dostring">dostring</a></td>
<td>文字列の各文字で一回ずつ評価する<br />evaluates once for each character in a string</td>
</tr>

<tr>
<td><a href="#dotimes">dotimes</a></td>
<td>範囲内の各数字で一回ずつ評価する<br />evaluates once for each number in a range</td>
</tr>

<tr>
<td><a href="#dotree">dotree</a></td>
<td>コンテキスト内のシンボルを通して一回ずつ評価する<br />iterates through the symbols of a context</td>
</tr>

<tr>
<td><a href="#do-until">do-until</a></td>
<td>条件が合致するまで式ブロックの評価を繰り返す<br />repeats evaluation of an expression until the condition is met</td>
</tr>

<tr>
<td><a href="#do-while">do-while</a></td>
<td>条件が真の間、式ブロックの評価を繰り返す<br />repeats evaluation of an expression while the condition is true</td>
</tr>

<tr>
<td><a href="#dup">dup</a></td>
<td>指定された回数、リストか文字列を複製する<br />duplicates a list or string a specified number of times</td>
</tr>

<tr>
<td><a href="#ends-with">ends-with</a></td>
<td>文字列かリストの終りと同じ型のキーとの一致をチェックする<br />checks the end of a string or list against a key of the same type</td>
</tr>

<tr>
<td><a href="#eval">eval</a></td>
<td>式を評価する<br />evaluates an expression</td>

</tr>
<tr>
<td><a href="#exists">exists</a></td>
<td>リスト中の条件の存在をチェックする<br />checks for the existence of a condition in a list</td>
</tr>

<tr>
<td><a href="#expand">expand</a></td>
<td>入れ子リスト中のシンボルを置き換える<br />replaces a symbol in a nested list</td>
</tr>

<tr>
<td><a href="#explode">explode</a></td>
<td>リストか文字列を分割する<br />explodes a list or string</td>
</tr>

<tr>
<td><a href="#extend">extend</a></td>
<td>リストか文字列を拡張する<br />extends a list or string</td>
</tr>

<tr>
<td><a href="#first">first</a></td>
<td>リストか文字列の第一要素を取得する<br />gets the first element of a list or string</td>
</tr>

<tr>
<td><a href="#filter">filter</a></td>
<td>リストをフィルタする<br />filters a list</td>
</tr>

<tr>
<td><a href="#find">find</a></td>
<td>リストか文字列中の要素を検索する<br />searches for an element in a list or string</td>
</tr>

<tr>
<td><a href="#flat">flat</a></td>
<td>（訳注：入れ子でない）フラットなリストを返す<br />returns the flattened list</td>
</tr>

<tr>
<td><a href="#define">fn</a></td>
<td>新関数やラムダ式を定義する<br />defines a new function or lambda expression</td>
</tr>

<tr>
<td><a href="#for">for</a></td>
<td>範囲内の各数字で一回ずつ評価する<br />evaluates once for each number in a range</td>
</tr>

<tr>
<td><a href="#for-all">for-all</a></td>
<td>リスト中の全ての要素が条件と合うかどうかをチェックする<br />checks if all elements in a list meet a condition</td>
</tr>

<tr>
<td><a href="#if">if</a></td>
<td>条件によって式を評価する<br />evaluates an expression conditionally</td>
</tr>

<tr>
<td><a href="#if-not">if-not</a></td>
<td>条件によって式を評価する（訳注：if と論理が逆）<br />evaluates an expression conditionally</td>
</tr>

<tr>
<td><a href="#index">index</a></td>
<td>リストから要素をフィルタし、それらのインデックスを返す<br />
filters elements from a list and returns their indices</td>
</tr>


<tr>
<td><a href="#intersect">intersect</a></td>
<td>二つのリストの両方にある要素を返す<br />returns the intersection of two lists</td>
</tr>

<tr>
<td><a href="#define">lambda</a></td>
<td>新関数やラムダ式を定義する<br />defines a new function or lambda expression</td>
</tr>

<tr>
<td><a href="#last">last</a></td>
<td>リストか文字列の最後の要素を（訳注：リストにしないで）返す<br />returns the last element of a list or string</td>
</tr>

<tr>
<td><a href="#length">length</a></td>
<td>リストか文字列の長さを返す<br />calculates the length of a list or string</td>
</tr>

<tr>
<td><a href="#let">let</a></td>
<td>ローカル変数を宣言し、初期化する<br />declares and initializes local variables</td>
</tr>

<tr>
<td><a href="#letex">letex</a></td>
<td>式中にローカル変数を展開し、その後評価する<br />expands local variables into an expression, then evaluates</td>
</tr>

<tr>
<td><a href="#letn">letn</a></td>
<td>入れ子の let のように、ローカル変数を初期化する<br>（訳注：先に定義されたシンボルの内容が展開される。Common Lisp の let* 相当）<br />initializes local variables incrementally, like nested lets</td>
</tr>

<tr>
<td><a href="#list">list</a></td>
<td>リストを作る<br />makes a list</td>
</tr>

<tr>
<td><a href="#local">local</a></td>
<td>ローカル変数を宣言する<br />declares local variables</td>
</tr>

<tr>
<td><a href="#lookup">lookup</a></td>
<td>連想リスト中のメンバーを調べる<br />looks up members in an association list</td>
</tr>

<tr>
<td><a href="#map">map</a></td>
<td>リストの要素に関数を適用し、その結果を集める<br />maps a function over members of a list, collecting the results</td>
</tr>

<tr>
<td><a href="#match">match</a></td>
<td>リストに対してパターン・マッチングする。文字列に対しては、<a href="#find">find</a> と <a href="#regex">regex</a> を参照<br />matches patterns against lists; for matching against strings, see <a href="#find">find</a> and <a href="#regex">regex</a></td>
</tr>

<tr>
<td><a href="#member">member</a></td>
<td>リストか文字列のメンバーを見つける<br />finds a member of a list or string</td>
</tr>

<tr>
<td><a href="#not">not</a></td>
<td>論理否定<br />logical <tt>not</tt></td>
</tr>

<tr>
<td><a href="#nth">nth</a></td>
<td>リストか文字列のｎ番目の要素を取得する<br />gets the <em>nth</em> element of a list or string</td>
</tr>

<tr>
<td><a href="#or">or</a></td>
<td>論理和<br />logical <tt>or</tt></td>
</tr>

<tr>
<td><a href="#pop">pop</a></td>
<td>リストか文字列から要素を削除して返す<br />deletes and returns an element from a list or string</td>
</tr>

<tr>
<td><a href="#pop-assoc">pop-assoc</a></td>
<td>連想リストから連想を取り去る<br />removes an association from an association list</td>
</tr>

<tr>
<td><a href="#push">push</a></td>
<td>リストか文字列に新要素を挿入する<br />inserts a new element into a list or string</td>
</tr>

<tr>
<td><a href="#quote">quote</a></td>
<td>式をクォートする<br />quotes an expression</td>
</tr>

<tr>
<td><a href="#ref">ref</a></td>
<td>入れ子リスト中の要素の位置を返す<br />returns the position of an element inside a nested list</td>
</tr>

<tr>
<td><a href="#ref-all">ref-all</a></td>
<td>入れ子リスト中の要素のインデックス・ベクターのリストを返す<br />returns a list of index vectors of elements inside a nested list</td>
</tr>

<tr>
<td><a href="#rest">rest</a></td>
<td>リストか文字列の第一要素以外を返す<br />returns all but the first element of a list or string</td>
</tr>

<tr>
<td><a href="#replace">replace</a></td>
<td>リストか文字列内の要素を置換する<br />replaces elements inside a list or string</td>
</tr>

<tr>
<td><a href="#reverse">reverse</a></td>
<td>リストか文字列の並びを逆にする<br />reverses a list or string</td>
</tr>

<tr>
<td><a href="#rotate">rotate</a></td>
<td>リストか文字列の並びを回転する<br />rotates a list or string</td>
</tr>

<tr>
<td><a href="#select">select</a></td>
<td>リストか文字列から要素を選んで並べ換える<br />selects and permutes elements from a list or string</td>
</tr>

<tr>
<td><a href="#self">self</a></td>
<td>FOOP <a href="http://ja.wikipedia.org/wiki/%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%A6%29">メソッド</a>内で目標オブジェクトをアクセスする<br />Accesses the target object inside a FOOP method</td>
</tr>

<tr>
<td><a href="#set">set</a></td>
<td>束縛やシンボルの内容を設定する<br />sets the binding or contents of a symbol</td>
</tr>

<tr>
<td><a href="#setf">setf setq</a></td>
<td>シンボル、リスト、アレイ、文字列参照の内容を設定する<br />sets contents of a symbol or list, array or string reference</td>
</tr>

<tr>
<td><a href="#set-ref">set-ref</a></td>
<td>入れ子リスト中の要素を検索し、置き換える<br />searches for an element in a nested list and replaces it</td>
</tr>

<tr>
<td><a href="#set-ref-all">set-ref-all</a></td>
<td>入れ子リスト中の要素を検索し、全ての検出を置き換える<br />searches for an element in a nested list and replaces all instances</td>
</tr>

<tr>
<td><a href="#silent">silent</a></td>
<td><a href="#begin">begin</a> のように動作するが、戻り値のコンソール出力を抑制する<br />works like <a href="#begin">begin</a> but suppresses console output of the return value</td>
</tr>

<tr>
<td><a href="#slice">slice</a></td>
<td>リストか文字列の一部を取り出す<br />extracts a sublist or substring</td>
</tr>

<tr>
<td><a href="#sort">sort</a></td>
<td>リストのメンバーを並べ替える<br />sorts the members of a list</td>
</tr>

<tr>
<td><a href="#starts-with">starts-with</a></td>
<td>文字列かリストの始まりと同じ型のキーとの一致をチェックする<br />checks the beginning of a string or list against a key of the same type</td>
</tr>

<tr>
<td><a href="#swap">swap</a></td>
<td>リストか文字列内の二つの要素を入れ替える<br />swaps two elements inside a list or string</td>
</tr>

<tr>
<td><a href="#unify">unify</a></td>
<td>二つの式を<a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%8B%E3%83%95%E3%82%A3%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3">統一化（ユニフィケーション）</a>する<br />unifies two expressions</td>
</tr>

<tr>
<td><a href="#unique">unique</a></td>
<td>重複しない要素のリストを返す<br />returns a list without duplicates</td>
</tr>

<tr>
<td><a href="#union">union</a></td>
<td>二つかそれ以上のリストで重複しない要素のリストを返す<br />returns a unique list of elements found in two or more lists.</td>
</tr>

<tr>
<td><a href="#unless">unless</a></td>
<td>条件により（訳注：nil か '() の時）式ブロックを評価する<br />evaluates a block of statements conditionally</td>
</tr>

<tr>
<td><a href="#until">until</a></td>
<td>条件が合致するまで式ブロックの評価を繰り返す<br />repeats evaluation of an expression until the condition is met</td>
</tr>

<tr>
<td><a href="#when">when</a></td>
<td>条件により（訳注：nil か '() 以外の時）式ブロックを評価する<br />evaluates a block of statements conditionally</td>
</tr>

<tr>
<td><a href="#while">while</a></td>
<td>条件が真の間、式ブロックの評価を繰り返す<br />repeats evaluation of an expression while the condition is true</td>
</tr>
</table><br/>

<a name="string_operators"></a>
<h3>String and conversion functions（文字列と変換関数）</h3>

<table border="0" cellpadding="1" width="95%" align="center" summary="String and conversion functions">


<tr>
<td width="16%"><a href="#address">address</a></td>
<td width="84%">数値か文字列のメモリ・アドレスを取得する<br />gets the memory address of a number or string</td>
</tr>

<tr>
<td><a href="#bigint">bigint</a></td>
<td>数値を大整数に変換する<br />convert a number to big integer format</td>
</tr>

<tr>
<td><a href="#bits">bits</a></td>
<td>数値をバイナリ表現に変換する<br />translates a number into binary representation</td>
</tr>

<tr>
<td><a href="#char">char</a></td>
<td>文字と ASCII コード間の変換をする<br />translates between characters and ASCII codes</td>
</tr>

<tr>
<td><a href="#chop">chop</a></td>
<td>文字列の最後から文字を削除する<br />chops off characters from the end of a string</td>
</tr>

<tr>
<td><a href="#dostring">dostring</a></td>
<td>文字列の各文字列で一回ずつ評価する<br />evaluates once for each character in a string</td>
</tr>

<tr>
<td><a href="#dup">dup</a></td>
<td>指定された回数、リストか文字列を複製する<br />duplicates a list or string a specified number of times</td>
</tr>

<tr>
<td><a href="#ends-with">ends-with</a></td>
<td>文字列かリストの終りと同じ型のキーとの一致をチェックする<br />checks the end of a string or list against a key of the same type</td>
</tr>

<tr>
<td><a href="#encrypt">encrypt</a></td>
<td>ワン・タイム・パッド暗号化と文字列の解読をする<br />does a one-time?pad encryption and decryption of a string</td>
</tr>

<tr>
<td><a href="#eval-string">eval-string</a></td>
<td>文字列をコンパイル（訳注：すなわち、newLISPソース解析）し、評価する<br />compiles, then evaluates a string</td>
</tr>

<tr>
<td><a href="#explode">explode</a></td>
<td>文字列を文字のリストに変換する<br />transforms a string into a list of characters</td>
</tr>

<tr>
<td><a href="#extend">extend</a></td>
<td>リストか文字列を拡張する<br />extends a list or string</td>
</tr>

<tr>
<td><a href="#find">find</a></td>
<td>リストか文字列中の要素を検索する<br />searches for an element in a list or string</td>
</tr>

<tr>
<td><a href="#find-all">find-all</a></td>
<td>文字列中でパターン・マッチングした全てをリストで返す<br />returns a list of all pattern matches found in string</td>
</tr>

<tr>
<td><a href="#first">first</a></td>
<td>リストか文字列の第一要素を取得する<br />gets the first element in a list or string</td>
</tr>

<tr>
<td><a href="#float">float</a></td>
<td>文字列か整数を浮動小数点数に変換をする<br />translates a string or integer into a floating point number</td>
</tr>

<tr>
<td><a href="#format">format</a></td>
<td>C 言語のように数値と文字列を整形する<br />formats numbers and strings as in the C language</td>
</tr>

<tr>
<td><a href="#get-char">get-char</a></td>
<td>メモリ・アドレスから文字を取得する<br />gets a character from a memory address</td>
</tr>

<tr>
<td><a href="#get-float">get-float</a></td>
<td>メモリ・アドレスから倍精度浮動小数点を取得する<br />gets a double float from a memory address</td>
</tr>

<tr>
<td><a href="#get-int">get-int</a>&nbsp;&nbsp;</td>
<td>メモリ・アドレスから32ビット整数を取得する<br />gets a 32-bit integer from a memory address</td>
</tr>

<tr>
<td><a href="#get-long">get-long</a>&nbsp;&nbsp;</td>
<td>メモリ・アドレスから64ビット整数を取得する<br />gets a long 64-bit integer from a memory address</td>
</tr>

<tr>
<td><a href="#get-string">get-string</a></td>
<td>メモリ・アドレスから文字列を取得する<br />gets a string from a memory address</td>
</tr>

<tr>
<td><a href="#int">int</a></td>
<td>文字列か浮動小数点を整数に変換する<br />translates a string or float into an integer</td>
</tr>

<tr>
<td><a href="#join">join</a></td>
<td>文字列のリストを結合する<br />joins a list of strings</td>
</tr>

<tr>
<td><a href="#last">last</a></td>
<td>リストか文字列の最後の要素を取得する<br />returns the last element of a list or string</td>
</tr>

<tr>
<td><a href="#lower-case">lower-case</a></td>
<td>文字列を小文字に変換する<br />converts a string to lowercase characters</td>
</tr>

<tr>
<td><a href="#member">member</a></td>
<td>リストか文字列のメンバーを検索する<br />finds a list or string member</td>
</tr>

<tr>
<td><a href="#name">name</a></td>
<td>この関数は、削除されました。代わりに <a href="#term">term</a> を使ってください。<br />returns the name of a symbol or its context as a string</td>
</tr>

<tr>
<td><a href="#nth">nth</a></td>
<td>リストか文字列のｎ番目の要素を取得する<br />gets the <em>nth</em> element in a list or string</td>
</tr>

<tr>
<td><a href="#pack">pack</a></td>
<td>newLISP の式をバイナリ構造体にパックする<br />packs newLISP expressions into a binary structure</td>
</tr>

<tr>
<td><a href="#parse">parse</a></td>
<td>文字列を<a href "http://ja.wikipedia.org/wiki/%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3">
トークン</a>（訳注：ソースコードを構成する単語や記号の最小単位）に分解する<br />
breaks a string into tokens</td>
</tr>

<tr>
<td><a href="#pop">pop</a></td>
<td>文字列からポップする<br />pops from a string</td>
</tr>

<tr>
<td><a href="#push">push</a></td>
<td>文字列にプッシュする<br />pushes onto a string</td>
</tr>

<tr>
<td><a href="#regex">regex</a></td>
<td>Perlコンパチの正規表現検索を実行する<br />performs a Perl-compatible regular expression search</td>
</tr>

<tr>
<td><a href="#regex-comp">regex-comp</a></td>
<td>正規表現パターンを前以てコンパイルする<br />pre-compiles a regular expression pattern</td>
</tr>

<tr>
<td><a href="#replace">replace</a></td>
<td>リストか文字列内の要素を置換する<br />replaces elements in a list or string</td>
</tr>

<tr>
<td><a href="#rest">rest</a></td>
<td>リストか文字列の第一要素以外を取得する<br />gets all but the first element of a list or string</td>
</tr>

<tr>
<td><a href="#reverse">reverse</a></td>
<td>リストか文字列の並びを逆にする<br />reverses a list or string</td>
</tr>

<tr>
<td><a href="#rotate">rotate</a></td>
<td>リストか文字列の並びを回転する<br />rotates a list or string</td>
</tr>

<tr>
<td><a href="#select">select</a></td>
<td>リストか文字列から要素を選んで並べ換える<br />selects and permutes elements from a list or string</td>
</tr>

<tr>
<td><a href="#setf">setf setq</a></td>
<td>文字列参照の内容を設定する<br />sets contents of a string reference</td>
</tr>

<tr>
<td><a href="#slice">slice</a></td>
<td>文字列かリストの一部を取り出す<br />extracts a substring or sublist</td>
</tr>

<tr>
<td><a href="#source">source</a></td>
<td>シンボルに束縛を要求されているソースを文字列で返す<br />returns the source required to bind a symbol as a string</td>
</tr>

<tr>
<td><a href="#starts-with">starts-with</a></td>
<td>文字列かリストの始まりと同じ型のキーとの一致をチェックする<br />checks the start of the string or list against a key string or list</td>
</tr>

<tr>
<td><a href="#string">string</a></td>
<td>何であれ文字列に変換する<br />transforms anything into a string</td>
</tr>

<tr>
<td><a href="#sym">sym</a></td>
<td>文字列をシンボルに変換する<br />translates a string into a symbol</td>
</tr>

<tr>
<td><a href="#title-case">title-case</a></td>
<td>文字列の第一文字を大文字に変換する<br />converts the first character of a string to uppercase</td>
</tr>

<tr>
<td><a href="#trim">trim</a></td>
<td>文字列の一端または両端でトリム（訳注：空白文字を削除）する<br />trims a string on one or both sides</td>
</tr>

<tr>
<td><a href="#unicode">unicode</a></td>
<td>ASCII か UTF-8 を UCS-4 Unicode に変換する<br />converts ASCII or UTF-8 to UCS-4 Unicode</td>
</tr>

<tr>
<td><a href="#utf8">utf8</a></td>
<td>UCS-4 Unicode を UTF-8 に変換する<br />converts UCS-4 Unicode to UTF-8</td>
</tr>

<tr>
<td><a href="#utf8len">utf8len</a></td>
<td>UTF-8 文字列の長さを UTF-8 文字単位で返す<br />returns length of an UTF-8 string in UTF-8 characters</td>
</tr>

<tr><td><a href="#unpack">unpack</a></td>
<td>バイナリ構造体を newLISP 式にアンパックする<br />unpacks a binary structure into newLISP expressions</td>
</tr>

<tr>

<td><a href="#upper-case">upper-case</a></td>
<td>文字列を大文字に変換する<br />converts a string to uppercase characters</td>
</tr>

</table><br/>

<a name="floating_point"></a>
<h3>Floating point math and special functions（浮動小数点数学と特殊関数）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Floating point math and special functions">


<tr>
<td width="16%"><a href="#abs">abs</a></td>
<td width="84%">数値の絶対値を返す<br />returns the absolute value of a number</td>
</tr>

<tr>
<td><a href="#acos">acos</a></td>
<td>逆余弦関数<br />calculates the arc-cosine of a number</td>
</tr>

<tr>
<td><a href="#acosh">acosh</a></td>
<td>双曲線逆余弦関数<br />calculates the inverse hyperbolic cosine of a number</td>
</tr>

<tr>
<td><a href="#add">add</a></td>
<td>浮動小数点数か整数を加算し、浮動小数点数を返す<br />adds floating point or integer numbers and returns a floating point number</td>
</tr>

<tr>
<td><a href="#array">array</a></td>
<td>アレイを作成する<br />creates an array</td>
</tr>

<tr>
<td><a href="#array-list">array-list</a></td>
<td>アレイからリストに変換し返す<br />returns a list conversion from an array</td>
</tr>

<tr>
<td><a href="#asin">asin</a></td>
<td>逆正弦関数<br />calculates the arcsine of a number</td>
</tr>

<tr>
<td><a href="#asinh">asinh</a></td>
<td>逆双曲線正弦関数<br />calculates the inverse hyperbolic sine of a number</td>
</tr>


<tr>
<td><a href="#atan">atan</a></td>
<td>逆正接関数<br />calculates the arctangent of a number</td>
</tr>

<tr>
<td><a href="#atanh">atanh</a></td>
<td>逆双曲線正接関数<br />calculates the inverse hyperbolic tangent of a number</td>
</tr>

<tr>
<td><a href="#atan2">atan2</a></td>
<td>Y / X の逆正接を ラジアンで計算<br />computes the principal value of the arctangent of Y / X in radians</td>
</tr>

<tr>
<td><a href="#beta">beta</a></td>
<td>ベータ関数<br />calculates the beta function</td>
</tr>

<tr>
<td><a href="#betai">betai</a></td>
<td>不完全ベータ関数<br />calculates the incomplete beta function</td>
</tr>

<tr>
<td><a href="#binomial">binomial</a></td>
<td>二項分布関数<br />calculates the binomial function</td>
</tr>

<tr>
<td><a href="#ceil">ceil</a></td>

<td>切り上げ<br />rounds up to the next integer</td>
</tr>

<tr>
<td><a href="#cos">cos</a></td>
<td>余弦関数<br />calculates the cosine of a number</td>

</tr>
<tr>
<td><a href="#cosh">cosh</a></td>
<td>双曲線余弦関数<br />calculates the hyperbolic cosine of a number</td>
</tr>

<tr>
<td><a href="#crc32">crc32</a></td>
<td>データ・バッファの32ビットCRCを計算する<br />calculates a 32-bit CRC for a data buffer</td>
</tr>

<tr>
<td><a href="#dec">dec</a></td>
<td>変数、リスト、アレイ中の数値を減算する<br />decrements a number in a variable, list or array</td>
</tr>

<tr>
<td><a href="#div">div</a></td>
<td>浮動小数点数か整数を除算する<br />divides floating point or integer numbers</td>
</tr>

<tr>
<td><a href="#erf">erf</a></td>
<td>誤差関数<br />calculates the error function of a number</td>
</tr>

<tr>
<td><a href="#exp">exp</a></td>
<td>指数関数<br />calculates the exponential <em>e</em> of a number</td>
</tr>

<tr>
<td><a href="#factor">factor</a></td>
<td>数値を素因数分解する<br />factors a number into primes</td>
</tr>

<tr>
<td><a href="#fft">fft</a></td>
<td>高速フーリエ変換<br />performs a fast Fourier transform (FFT)</td>
</tr>

<tr>
<td><a href="#floor">floor</a></td>
<td>切り捨て<br />rounds down to the next integer</td>
</tr>

<tr>
<td><a href="#flt">flt</a></td>
<td>浮動小数点数を表す32ビット整数に変換する<br />converts a number to a 32-bit integer representing a float</td>
</tr>

<tr>
<td><a href="#gammai">gammai</a></td>
<td>不完全ガンマ関数<br />calculates the incomplete Gamma function</td>
</tr>

<tr>
<td><a href="#gammaln">gammaln</a></td>
<td>対数ガンマ関数<br />calculates the log Gamma function</td>
</tr>

<tr>
<td><a href="#gcd">gcd</a></td>
<td>最大公約数を計算する<br />calculates the greatest common divisor of a group of integers</td>
</tr>

<tr>
<td><a href="#ifft">ifft</a></td>
<td>逆高速フーリエ変換<br />performs an inverse fast Fourier transform (IFFT)</td>
</tr>

<tr>
<td><a href="#inc">inc</a></td>
<td>変数、リスト、アレイ中の数値を加算する<br />increments a number in a variable, list or array</td>
</tr>

<tr>
<td><a href="#infp">inf?</a></td>
<td>無限大をチェックする<br />checks if a floating point value is infinite</td>
</tr>

<tr>
<td><a href="#log">log</a></td>
<td>対数を計算する<br />calculates the natural or other logarithm of a number</td>
</tr>

<tr>
<td><a href="#min">min</a></td>
<td>最小値検出<br />finds the smallest value in a series of values</td>
</tr>

<tr>
<td><a href="#max">max</a></td>
<td>最大値検出<br />finds the largest value in a series of values</td>

</tr>

<tr>
<td><a href="#mod">mod</a></td>
<td>余りを計算する<br />calculates the modulo of two numbers</td>
</tr>

<tr>
<td><a href="#mul">mul</a></td>
<td>浮動小数点数か整数を乗算する<br />multiplies floating point or integer numbers</td>
</tr>

<tr>
<td><a href="#NaNp">NaN?</a></td>
<td>NaN をチェックする<br />checks if a float is NaN (not a number)</td>
</tr>

<tr>
<td><a href="#round">round</a></td>
<td>数値を丸める<br />rounds a number</td>
</tr>

<tr>
<td><a href="#pow">pow</a></td>
<td><em>x</em> の <em>y</em> 乗を計算する<br />calculates <em>x</em> to the power of <em>y</em></td>
</tr>

<tr>
<td><a href="#sequence">sequence</a></td>
<td>等差数列リストを生成する<br />generates a list sequence of numbers</td>
</tr>

<tr>
<td><a href="#series">series</a></td>
<td>等比数列リストを生成する<br />creates a geometric sequence of numbers</td>
</tr>

<tr>
<td><a href="#sgn">sgn</a></td>
<td>符号を取り出す<br />calculates the signum function of a number</td>
</tr>

<tr>
<td><a href="#sin">sin</a></td>
<td>正弦関数<br />calculates the sine of a number</td>
</tr>

<tr>
<td><a href="#sinh">sinh</a></td>
<td>双曲線正弦関数<br />calculates the hyperbolic sine of a number</td>
</tr>

<tr>
<td><a href="#sqrt">sqrt</a></td>
<td>平方根を計算する<br />calculates the square root of a number</td>
</tr>

<tr>
<td><a href="#ssq">ssq</a></td>
<td>ベクトルの二乗和を計算する<br />calculates the sum of squares of a vector</td>
</tr>

<tr>
<td><a href="#sub">sub</a></td>
<td>浮動小数点数か整数を減算する<br />subtracts floating point or integer numbers</td>
</tr>

<tr>
<td><a href="#tan">tan</a></td>
<td>正接関数<br />calculates the tangent of a number</td>
</tr>

<tr>
<td><a href="#tanh">tanh</a></td>
<td>双曲線正接関数<br />calculates the hyperbolic tangent of a number</td>
</tr>

<tr>
<td><a href="#uuid">uuid</a>&nbsp;</td>
<td><a href="http://ja.wikipedia.org/wiki/%E6%B1%8E%E7%94%A8%E4%B8%80%E6%84%8F%E8%AD%98%E5%88%A5%E5%AD%90">汎用一意識別子</a>（UUID）を返す<br />returns a UUID (Universal Unique IDentifier)</td>
</tr>

</table><br/>

<a name="matrices"></a>
<h3>Matrix functions（行列関数）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Matrix functions">


<tr>
<td width="16%"><a href="#det">det</a></td>
<td width="84%">行列式<br />returns the determinant of a matrix</td>
</tr>

<tr>
<td><a href="#invert">invert</a></td>
<td>逆行列を返す<br />returns the inversion of a matrix</td>
</tr>

<tr>
<td><a href="#mat">mat</a></td>
<td>行列のスカラー演算を実行する<br />performs scalar operations on matrices</td>
</tr>

<tr>
<td><a href="#multiply">multiply</a></td>
<td>行列の積をとる<br />multiplies two matrices</td>
</tr>

<tr>
<td><a href="#transpose">transpose</a>&nbsp;</td>
<td>行列を置換する<br />returns the transposition of a matrix</td>
</tr>

</table><br/>

<a name="array-funcs"></a>
<h3>Array functions（アレイ関数）</h3>

<table border="0" cellpadding="1" width="95%" align="center" summary="Array functions">

<tr>
<td width="16%"><a href="#append">append</a></td>
<td width="84%">アレイを結合する<br />appends arrays</td>
</tr>

<tr>
<td><a href="#array">array</a></td>
<td>16次元までのアレイを作成し、初期化する<br />creates and initializes an array with up to 16 dimensions</td>
</tr>

<tr>
<td><a href="#array-list">array-list</a></td>
<td>アレイをリストに変換する<br />converts an array into a list</td>
</tr>

<tr>
<td><a href="#arrayp">array?</a></td>
<td>アレイかどうかをチェックする<br />checks if expression is an array</td>
</tr>

<tr>
<td><a href="#det">det</a></td>
<td>行列式を返す<br />returns the determinant of a matrix</td>
</tr>

<tr>
<td><a href="#first">first</a></td>
<td>アレイの第1要素を返す<br />returns the first row of an array</td>
</tr>

<tr>
<td><a href="#invert">invert</a></td>
<td>逆行列を返す<br />returns the inversion of a matrix</td>
</tr>

<tr>
<td><a href="#last">last</a></td>
<td>アレイの最後の要素を返す<br />returns the last row of an array</td>
</tr>

<tr>
<td><a href="#mat">mat</a></td>
<td>行列のスカラー演算を実行する<br />performs scalar operations on matrices</td>
</tr>


<tr>
<td><a href="#multiply">multiply</a></td>
<td>行列の積をとる<br />multiplies two matrices</td>
</tr>

<tr>
<td><a href="#nth">nth</a></td>
<td>アレイの要素を返す<br />returns an element of an array</td>
</tr>

<tr>
<td><a href="#rest">rest</a></td>
<td>アレイの第一要素以外を返す<br />returns all but the first row of an array</td>
</tr>

<tr>
<td><a href="#setf">setf</a></td>
<td>アレイの参照内容を設定する<br />sets contents of an array reference</td>
</tr>

<tr>
<td><a href="#slice">slice</a></td>
<td>アレイの一部を返す<br />returns a slice of an array</td>
</tr>

<tr>
<td><a href="#transpose">transpose</a></td>
<td>行列を置換する<br />transposes a matrix</td>
</tr>
</table><br/>

<a name="bit_operators"></a>
<h3>Bit operators（ビット演算子）</h3>

<table border="0" cellpadding="1" width="95%" align="center" summary="bit operators">


<tr>
<td width="16%"><a href="#bit_shift">&lt;&lt;, &gt;&gt;</a>&nbsp;&nbsp;&nbsp;</td>
<td width="84%">左ビット・シフト、右ビット・シフト<br />bit shift left, bit shift right</td>
</tr>

<tr>
<td><a href="#bit_and">&amp;</a></td>
<td>ビット単位の論理積<br />bitwise and</td>
</tr>

<tr>
<td><a href="#bit_inclusive">|</a></td>
<td>ビット単位の論理和<br />bitwise inclusive or</td>

</tr>

<tr>
<td><a href="#bit_exclusive">^</a></td>
<td>ビット単位の排他的論理和<br />bitwise exclusive or</td>
</tr>

<tr>
<td><a href="#bit_not">~</a></td>
<td>ビット単位の論理否定<br />bitwise not</td>
</tr>
</table><br/>

<a name="predicates"></a>
<h3>Predicates（述語）</h3>
<p>（訳注：述語の意味は、<a href="http://ja.wikipedia.org/wiki/%E4%B8%80%E9%9A%8E%E8%BF%B0%E8%AA%9E%E8%AB%96%E7%90%86">こちらをどうぞ</a>。）<br /></p>
<table border="0" cellpadding="1" width="95%" align="center" summary="Predicates">

<tr>
<td width="16%"><a href="#atomp">atom?</a></td>
<td width="84%">アトムのチェック<br />checks if an expression is an atom</td>
</tr>

<tr>
<td><a href="#arrayp">array?</a></td>
<td>アレイのチェック<br />checks if an expression is an array</td>
</tr>

<tr>
<td><a href="#bigintp">bigint?</a></td>
<td>大整数のチェック<br />checks if a number is a big integer</td>
</tr>

<tr>
<td><a href="#contextp">context?</a></td>
<td>コンテキストのチェック<br />checks if an expression is a context</td>
</tr>

<tr>
<td><a href="#directoryp">directory?</a></td>
<td>ディレクトリのチェック<br />checks if a disk node is a directory</td>
</tr>

<tr>
<td><a href="#emptyp">empty?</a></td>
<td>空リストか空文字列のチェック<br />checks if a list or string is empty</td>
</tr>

<tr>
<td><a href="#evenp">even?</a></td>
<td>整数の偶奇をチェック<br />checks the parity of an integer number</td>
</tr>

<tr>
<td><a href="#filep">file?</a></td>
<td>ファイルの存在チェック<br />checks if a file exists</td>
</tr>

<tr>
<td><a href="#floatp">float?</a></td>
<td>浮動小数点数のチェック<br />checks if an expression is a float</td>
</tr>

<tr>
<td><a href="#globalp">global?</a></td>
<td>シンボルのグローバルのチェック<br />checks if a symbol is global</td>
</tr>

<tr>
<td><a href="#infp">inf?</a></td>
<td>無限大のチェック<br />checks if a floating point value is infinite</td>
</tr>

<tr>
<td><a href="#integerp">integer?</a></td>
<td>整数のチェック<br />checks if an expression is an integer</td>
</tr>

<tr>
<td><a href="#lambdap">lambda?</a></td>
<td>ラムダ式のチェック<br />checks if an expression is a lambda expression</td>
</tr>

<tr>
<td><a href="#legalp">legal?</a></td>
<td>シンボルの適正チェック<br />checks if a string contains a legal symbol</td>
</tr>

<tr>
<td><a href="#listp">list?</a></td>
<td>リストのチェック<br />checks if an expression is a list</td>
</tr>

<tr>
<td><a href="#macrop">macro?</a></td>
<td>ラムダ・マクロ式のチェック<br />checks if an expression is a lambda-macro expression</td>
</tr>

<tr>
<td><a href="#NaNp">NaN?</a></td>
<td>NaN のチェック<br />checks if a float is NaN (not a number)</td>
</tr>

<tr>
<td><a href="#nilp">nil?</a></td>
<td><tt>nil</tt> のチェック<br />checks if an expression is <tt>nil</tt></td>
</tr>

<tr>
<td><a href="#nullp">null?</a></td>
<td> <tt>nil</tt>, <tt>""</tt>, <tt>()</tt>, <tt>0</tt>, <tt>0.0</tt>のチェック<br />checks if an expression is <tt>nil</tt>, <tt>""</tt>, <tt>()</tt>, <tt>0</tt> or <tt>0.0</tt></td>
</tr>

<tr>
<td><a href="#numberp">number?</a></td>
<td>数値のチェック<br />checks if an expression is a float or an integer</td>
</tr>

<tr>
<td><a href="#oddp">odd?</a></td>
<td>整数の奇数をチェック<br />checks the parity of an integer number</td>
</tr>

<tr>
<td><a href="#protectedp">protected?</a></td>
<td>プロテクトのチェック<br />checks if a symbol is protected</td>
</tr>

<tr>
<td><a href="#primitivep">primitive?</a></td>
<td>組込のチェック<br />checks if an expression is a primitive</td>
</tr>

<tr>
<td><a href="#quotep">quote?</a></td>
<td>クォートのチェック<br />checks if an expression is quoted</td>
</tr>

<tr>
<td><a href="#stringp">string?</a></td>
<td>文字列のチェック<br />checks if an expression is a string</td>
</tr>

<tr>
<td><a href="#symbolp">symbol?</a></td>
<td>シンボルのチェック<br />checks if an expression is a symbol</td>
</tr>

<tr>
<td><a href="#truep">true?</a></td>
<td><tt>nil</tt>以外のチェック<br />checks if an expression is not <tt>nil</tt></td>
</tr>

<tr>
<td><a href="#zerop">zero?</a></td>
<td>ゼロのチェック<br />checks if an expression is <tt>0</tt> or <tt>0.0</tt></td>
</tr>

</table><br/>

<a name="timedate"></a>
<h3>Date and time functions（日付と時刻の関数）</h3>

<table border="0" cellpadding="1" width="95%" align="center" summary="Time and date functions">

<tr>
<td width="16%"><a href="#date">date</a></td>
<td width="84%">date-time 値を文字列に変換する<br />converts a date-time value to a string</td>
</tr>

<tr>
<td><a href="#date-list">date-list</a></td>
<td>（訳注：1970年1月1日からの）秒数から年月日時分秒のリストを返す<br />returns a list of year, month, day, hours, minutes, seconds from a time value in seconds</td>
</tr>

<tr>
<td><a href="#date-parse">date-parse</a></td>
<td>日付文字を解析し、1970年1月1日からの秒数を返す（以前は、<tt>parse-date</tt>）<br />parses a date string and returns the number of seconds passed since January 1, 1970, (formerly <tt>parse-date</tt>)</td>
</tr>

<tr>
<td><a href="#date-value">date-value</a></td>
<td>日付と時刻に対して、1970年1月1日からの秒数を返す<br />calculates the time in seconds since January 1, 1970 for a date and time</td>
</tr>

<tr>
<td><a href="#now">now</a></td>
<td>現在の日付・時刻の情報をリストで返す<br />returns a list of current date-time information</td>
</tr>

<tr>
<td><a href="#time">time</a></td>
<td>式の評価に要する時間をミリ秒単位で計測する<br />calculates the time it takes to evaluate an expression in milliseconds</td>
</tr>

<tr>
<td><a href="#time-of-day">time-of-day</a></td>
<td>その日で経過した時間をミリ秒数で返す<br />calculates the number of milliseconds elapsed since the day started</td>
</tr>

</table><br/>

<a name="montecarlo"></a>
<h3>Statistics, simulation and modeling functions（統計、シミュレーション、モデル化関数）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Statistics, simulation and modelling math functions">


<tr>
<td width="16%"><a href="#amb">amb</a></td>
<td width="84%">引数からランダムに選択し、それを評価する<br />randomly selects an argument and evaluates it</td>
</tr>

<tr>
<td width="16%"><a href="#bayes-query">bayes-query</a></td>
<td width="84%">データ・セットのベイズ確率を計算する<br />calculates Bayesian probabilities for a data set</td>
</tr>

<tr>
<td width="16%"><a href="#bayes-train">bayes-train</a></td>
<td width="84%">ベイズ法か頻度解析のリストで要素を数える<br />counts items in lists for Bayesian or frequency analysis</td>
</tr>

<tr>
<td><a href="#corr">corr</a></td>
<td><em>積率相関</em> 係数を計算する<br />calculates the <em>product-moment correlation</em> coefficient</td>
</tr>

<tr>
<td><a href="#crit-chi2">crit-chi2</a></td>
<td>与えられた確率の<em>カイ二乗</em> 統計値を計算する<br />calculates the <em>Chi&sup2;</em> statistic for a given probability</td>
</tr>

<tr>
<td><a href="#crit-f">crit-f</a></td>
<td>与えられた確率の <em>F</em> 統計値を計算する<br />calculates the <em>F</em> statistic for a given probability</td>
</tr>

<tr>
<td><a href="#crit-t">crit-t</a></td>
<td>与えられた確率の <em>スチューデントのt</em> 統計値を計算する<br />calculates the <em>Student's t</em> statistic for a given probability</td>
</tr>

<tr>
<td><a href="#crit-z">crit-z</a></td>
<td>与えられた確率の正規分布 <em>Z</em> 統計値を計算する<br />calculates the normal distributed <em>Z</em> for a given probability</td>
</tr>

<tr>
<td><a href="#kmeans-query">kmeans-query</a></td>
<td>クラスタの重心やデータ・ポイントまでの距離を計算する<br />calculates distances to cluster centroids or other data points</td>
</tr>

<tr>
<td><a href="#kmeans-train">kmeans-train</a></td>
<td>一連のデータをクラスターに区分けする<br />partitions a data set into clusters</td>
</tr>

<tr>
<td><a href="#normal">normal</a></td>
<td>正規分布する浮動小数点数のリストを生成する<br />makes a list of normal distributed floating point numbers</td>
</tr>

<tr>
<td><a href="#prob-chi2">prob-chi2</a></td>
<td><em>カイ二乗</em> 分布の尾部片側の確率を計算する<br />calculates the tail probability of a <em>Chi&sup2;</em> distribution value</td>
</tr>

<tr>
<td><a href="#prob-f">prob-f</a></td>
<td><em>F</em> 分布の尾部片側の確率を計算する<br />calculates the tail probability of a <em>F</em> distribution value</td>
</tr>

<tr>
<td><a href="#prob-t">prob-t</a></td>
<td><em>スチューデントのt</em> 分布の尾部片側の確率を計算する<br />calculates the tail probability of a <em>Student's t</em> distribution value</td>
</tr>

<tr>
<td><a href="#prob-z">prob-z</a></td>
<td><em>Z</em> 分散値の累積確率を計算する<br />calculates the cumulated probability of a <em>Z</em> distribution value</td>
</tr>

<tr>
<td><a href="#rand">rand</a></td>
<td>ある範囲の乱数を生成する<br />generates random numbers in a range</td>
</tr>

<tr>
<td><a href="#random">random</a></td>
<td>均等に分布する浮動小数点数のリストを生成する<br />generates a list of evenly distributed floats</td>
</tr>

<tr>
<td><a href="#randomize">randomize</a></td>
<td>リスト中のすべての要素をシャッフルする<br />shuffles all of the elements in a list</td>
</tr>

<tr>
<td><a href="#seed">seed</a></td>
<td>内部乱数発生器の種を指定する<br />seeds the internal random number generator</td>
</tr>

<tr>
<td><a href="#stats">stats</a></td>
<td>ベクトル・データの基本的統計値を計算する<br />calculates some basic statistics for a data vector</td>
</tr>

<tr>
<td><a href="#t-test">t-test</a></td>
<td><em>スチューデントのt</em> 統計値を使って、データ・サンプルの平均を比較する<br />compares means of data samples using the <em>Student's t</em> statistic</td>
</tr>

</table><br/>

<a name="pattern"></a>
<h3>Pattern matching（パターン マッチング）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Pattern matching">

<tr>
<td><a href="#ends-with">ends-with</a></td>
<td>リストか文字列の終りとパターンの一致をチェックする<br />tests if a list or string ends with a pattern</td>
</tr>

<tr>
<td width="16%"><a href="#find">find</a></td>
<td width="84%">リストか文字列中のパターンを検索する<br />searches for a pattern in a list or string</td>
</tr>

<tr>
<td><a href="#find-all">find-all</a></td>
<td>文字列中のパターンの出現を全て検索する<br />finds all occurrences of a pattern in a string</td>
</tr>

<tr>
<td><a href="#match">match</a></td>
<td>リストのパターン・マッチング<br />matches list patterns</td>
</tr>

<tr>
<td><a href="#parse">parse</a></td>
<td>パターンに従って文字列を分解する<br />breaks a string along around patterns</td>
</tr>
<tr>
<td><a href="#ref">ref</a></td>
<td>入れ子リスト中の要素の位置を返す<br />returns the position of an element inside a nested list</td>
</tr>
<tr>
<td><a href="#ref-all">ref-all</a></td>
<td>入れ子リスト中の要素のインデックス・ベクトルのリストを返す<br />returns a list of index vectors of elements inside a nested list</td>
</tr>
<tr>
<td><a href="#regex">regex</a></td>
<td>文字列中のパターンを検出する<br />finds patterns in a string</td>
</tr>

<tr>
<td><a href="#replace">replace</a></td>
<td>文字列中のパターンを置き換える<br />replaces patterns in a string</td>
</tr>

<tr>
<td><a href="#search">search</a></td>
<td>ファイル中のパターンを検索する<br />searches for a pattern in a file</td>
</tr>

<tr>
<td><a href="#starts-with">starts-with</a></td>
<td>リストか文字列の最初とパターンの一致をチェックする<br />tests if a list or string starts with a pattern</td>
</tr>

<tr>
<td><a href="#unify">unify</a></td>
<td>パターンの論理的<a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%8B%E3%83%95%E3%82%A3%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3"><ruby>単一化<rp>（</rp><rt>ユニフィケーション</rt><rp>）</rp></ruby></a>を実行する<br />performs a logical unification of patterns</td>
</tr>

</table><br/>

<a name="financial"></a>
<h3>Financial math functions（財務関数）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Financial math functions">

<tr>
<td width="16%"><a href="#fv">fv</a></td>
<td width="84%"><a href="http://office.microsoft.com/ja-jp/excel/HP052090991041.aspx">投資の将来価値</a>を返す<br />returns the future value of an investment</td>
</tr>

<tr>
<td><a href="#irr">irr</a></td>
<td><a href="http://office.microsoft.com/ja-jp/excel/HP052091461041.aspx">内部利益率</a>を計算する<br />calculates the internal rate of return</td>
</tr>

<tr>
<td><a href="#nper">nper</a></td>
<td><a href="http://office.microsoft.com/ja-jp/excel/HP052091981041.aspx">投資に必要な支払回数</a>を計算する<br />calculates the number of periods for an investment</td>
</tr>

<tr>
<td><a href="#npv">npv</a></td>
<td><a href="http://office.microsoft.com/ja-jp/excel/HP052092251041.aspx">投資の現在価値</a>を計算する<br />calculates the net present value of an investment</td>
</tr>

<tr>
<td><a href="#pv">pv</a></td>
<td><a href="http://office.microsoft.com/ja-jp/excel/HP052091991041.aspx">投資の正味現在価値</a>を計算する<br />calculates the present value of an investment</td>
</tr>

<tr>
<td><a href="#pmt">pmt</a></td>
<td><a href="http://office.microsoft.com/ja-jp/excel/HP052092151041.aspx">ローンの定期支払額</a>を計算する<br />calculates the payment for a loan</td>
</tr>

</table><br/>

<a name="input_output"></a>
<h3>Input/output and file operations（ファイルと I/O の操作）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Input/output and file operations">


<tr>
<td width="16%"><a href="#append-file">append-file</a></td>
<td width="84%">ファイルにデータを追加する<br />appends data to a file</td>
</tr>

<tr>
<td><a href="#close">close</a></td>
<td>ファイルを閉じる<br />closes a file</td>
</tr>

<tr>
<td><a href="#current-line">current-line</a></td>
<td>最後の read-line バッファの内容を取り出す<br />retrieves contents of last read-line buffer</td>
</tr>

<tr>
<td><a href="#device">device</a></td>
<td>現在の出力デバイスの設定または問合せ<br />sets or inquires about current print device</td>
</tr>

<tr>

<td><a href="#exec">exec</a></td>
<td>別のプログラムを起動し、それに読み書きする<br />launches another program, then reads from or writes to it</td>
</tr>

<tr>
<td><a href="#load">load</a></td>
<td>newLISP コードのファイルをロードし、評価する<br />loads and evaluates a file of newLISP code</td>
</tr>

<tr>
<td><a href="#open">open</a></td>
<td>読み書き用にファイルを開く<br />opens a file for reading or writing</td>

</tr>

<tr>
<td><a href="#peek">peek</a></td>
<td>ファイル<ruby>記述子<rp>（</rp><rt>デスクリプタ</rt><rp>）</rp></ruby>に読み取りできるバイト数をチェックする<br />checks file descriptor for number of bytes ready for reading</td>
</tr>

<tr>
<td><a href="#print">print</a></td>
<td>コンソールかデバイスに出力する<br />prints to the console or a device</td>
</tr>

<tr>

<td><a href="#println">println</a></td>
<td>コンソールかデバイスに改行付きで出力する<br />prints to the console or a device with a line-feed</td>
</tr>

<tr>
<td><a href="#read">read</a></td>
<td>ファイルからバイナリ・データを読み取る<br />reads binary data from a file</td>
</tr>

<tr>
<td><a href="#read-char">read-char</a></td>
<td>ファイルから8ビット文字を一個読み取る<br />reads an 8-bit character from a file</td>
</tr>

<tr>
<td><a href="#read-file">read-file</a></td>
<td>一動作でファイルを全て読み取る<br />reads a whole file in one operation</td>
</tr>

<tr>
<td><a href="#read-key">read-key</a></td>
<td>キーボードのキーを読み取る<br />reads a keyboard key</td>
</tr>

<tr>
<td><a href="#read-line">read-line</a></td>
<td>コンソールかファイルから一行読み取る<br />reads a line from the console or file</td>
</tr>

<tr>
<td><a href="#read-utf8">read-utf8</a></td>
<td>ファイルからUTF-8文字を読み取る<br />reads an UTF-8 character from a file</td>
</tr>

<tr>
<td><a href="#save">save</a></td>
<td>ワークスペース、コンテキスト、シンボルをファイルに書き込む<br />saves a workspace, context, or symbol to a file</td>
</tr>

<tr>
<td><a href="#search">search</a></td>
<td>文字列についてファイルを検索する<br />searches a file for a string</td>

</tr>

<tr>
<td><a href="#seek">seek</a></td>
<td>ファイル・ポジションを設定、または読み取る<br />sets or reads a file position</td>
</tr>

<tr>
<td><a href="#write">write</a></td>
<td>ファイルや文字列にバイナリ・データを書き込む<br />writes binary data to a file or string</td>
</tr>

<tr>
<td><a href="#write-char">write-char</a></td>
<td>ファイルに一文字書き込む<br />writes a character to a file</td>
</tr>

<tr>
<td><a href="#write-file">write-file</a></td>
<td>一動作でファイルを書き込む<br />writes a file in one operation</td>
</tr>

<tr>
<td><a href="#write-line">write-line</a></td>
<td>コンソールかファイルに一行書き込む<br />writes a line to the console or a file</td>
</tr>

</table><br/>

<a name="processes"></a>
<h3>Processes and the Cilk API（プロセスと CilK API）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Processes and the Cilk API">

<tr>
<td width="16%"><a href="#shell">!</a></td>
<td width="84%">オペレーティング・システムのシェルに出る<br />shells out to the operating system</td>
</tr>

<tr>
<td><a href="#abort">abort</a></td>
<td><tt>spawn</tt> で開始した子プロセスを中断する<br />aborts a child process started with <tt>spawn</tt></td>
</tr>

<tr>
<td><a href="#destroy">destroy</a></td>
<td><tt>fork</tt> か <tt>process</tt> で生成したプロセスを破棄する<br />destroys a process created with <tt>fork</tt> or <tt>process</tt></td>
</tr>

<tr>
<td><a href="#exec">exec</a></td>
<td>プロセスを走らせ、それに読み書きする<br />runs a process, then reads from or writes to it</td>
</tr>

<tr>
<td><a href="#fork">fork</a></td>
<td>newLISP 子プロセスを起動する<br />launches a newLISP child process</td>
</tr>

<tr>
<td><a href="#pipe">pipe</a></td>
<td>プロセス間通信用パイプを生成する<br />creates a pipe for interprocess communication</td>
</tr>

<tr>
<td><a href="#process">process</a></td>
<td>子プロセスを起動し、標準I／O と 標準エラーを割り当てる<br />launches a child process, remapping standard I/O and standard error</td>
</tr>

<tr>
<td><a href="#receive">receive</a></td>
<td>他のプロセスからのメッセージを受信する<br />receive a message from another process</td>
</tr>

<tr>
<td><a href="#semaphore">semaphore</a></td>
<td>セマフォの生成と制御<br />creates and controls semaphores</td>
</tr>

<tr>
<td><a href="#send">send</a></td>
<td>他のプロセスにメッセージを送信する<br />send a message to another process</td>
</tr>


<tr>
<td><a href="#share">share</a></td>
<td>他のプロセスとメモリを共有する<br />shares memory with other processes</td>
</tr>

<tr>
<td><a href="#spawn">spawn</a></td>
<td>Cilk プロセス管理で子プロセスを起動する<br />launches a child process for Cilk process management</td>
</tr>

<tr>
<td><a href="#sync">sync</a></td>
<td><tt>spawn</tt> で起動した子プロセスを待ち、結果を収集する<br />waits for child processes launched with <tt>spawn</tt> and collects results</td>
</tr>

<tr>
<td><a href="#wait-pid">wait-pid</a></td>
<td>子プロセスが終わるまで待つ<br />waits for a child process to end</td>
</tr>

</table><br/>

<a name="directory_management"></a>
<h3>File and directory management（ファイルとディレクトリの管理）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="File and directory management">

<tr>
<td width="16%"><a href="#change-dir">change-dir</a>&nbsp;</td>
<td width="84%">違うドライブやディレクトリに変更する<br />changes to a different drive and directory</td>
</tr>

<tr>
<td><a href="#copy-file">copy-file</a></td>
<td>ファイルをコピーする<br />copies a file</td>
</tr>

<tr>
<td><a href="#delete-file">delete-file</a></td>
<td>ファイルを削除する<br />deletes a file</td>
</tr>

<tr>
<td><a href="#directory">directory</a></td>
<td>ディレクトリ・エントリのリストを返す<br />returns a list of directory entries</td>
</tr>

<tr>
<td><a href="#file-info">file-info</a></td>
<td>ファイルのサイズ、時間、属性を取得する<br />gets file size, date, time, and attributes</td>
</tr>

<tr>
<td><a href="#make-dir">make-dir</a></td>
<td>新ディレクトリを作成する<br />makes a new directory</td>
</tr>

<tr>
<td><a href="#real-path">real-path</a></td>
<td>相対ファイル・パスの絶対ファイル・パスを返す<br />returns the full path of the relative file path</td>
</tr>

<tr>
<td><a href="#remove-dir">remove-dir</a></td>
<td>空のディレクトリを削除する<br />removes an empty directory</td>
</tr>

<tr>
<td><a href="#rename-file">rename-file</a></td>
<td>ファイルまたはディレクトリの名前を変える<br />renames a file or directory</td>
</tr>

</table><br/>

<a name="http_api"></a>
<h3>HTTP networking API（HTTP ネットワーキング API）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="HTTP networking API">


<tr>
<td width="16%"><a href="#base64-enc">base64-enc</a></td>
<td width="84%">文字列を BASE64 形式にエンコードする<br />encodes a string into BASE64 format</td>
</tr>

<tr>
<td><a href="#base64-dec">base64-dec</a></td>
<td>BASE64 形式から文字列にデコードする<br />decodes a string from BASE64 format</td>
</tr>

<tr>
<td><a href="#delete-url">delete-url</a></td>
<td>ウェブからファイルまたはページを削除する<br />deletes a file or page from the web</td>
</tr>

<tr>
<td><a href="#get-url">get-url</a></td>
<td>ウェブからファイルまたはページを読み取る<br />reads a file or page from the web</td>
</tr>

<tr>
<td><a href="#json-error">json-error</a></td>
<td>JSON 変換で失敗したエラー情報を<br />returns error information from a failed JSON translation.</td>
</tr>

<tr>
<td><a href="#json-parse">json-parse</a></td>
<td>JSON 形式データを解析する<br />parses JSON formatted data</td>
</tr>

<tr>
<td><a href="#post-url">post-url</a></td>
<td>URL アドレスにポストする<br />posts info to a URL address</td>
</tr>

<tr>
<td><a href="#put-url">put-url</a></td>
<td>URL アドレスにページをアップロードする<br />uploads a page to a URL address</td>
</tr>

<tr>
<td><a href="#xfer-event">xfer-event</a></td>
<td>HTTP バイト転送用のイベント・ハンドラを登録する<br />registers an event handler for HTTP byte transfers</td>
</tr>

<tr>
<td><a href="#xml-error">xml-error</a></td>
<td>最後の XML 解析エラーを返す<br />returns last XML parse error</td>
</tr>

<tr>
<td><a href="#xml-parse">xml-parse</a></td>
<td>XML ドキュメント を解析する<br />parses an XML document</td>
</tr>

<tr>
<td><a href="#xml-type-tags">xml-type-tags</a>&nbsp;</td>
<td>XML タイプのタグを示すまたは変更する<br />shows or modifies XML type tags</td>
</tr>

</table><br/>

<a name="socket_tcpip"></a>
<h3>Socket TCP/IP, UDP and ICMP network API（ソケット TCP/IP、UDP と ICMP ネットワーク API）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Socket TCP/IP and UDP network API">


<tr>
<td width="16%"><a href="#net-accept">net-accept</a></td>
<td width="84%">受信用接続を受け付る<br />accepts a new incoming connection</td>
</tr>

<tr>
<td><a href="#net-close">net-close</a></td>
<td>ソケット接続を閉じる<br />closes a socket connection</td>
</tr>

<tr>
<td><a href="#net-connect">net-connect</a></td>
<td>リモート・ホストに接続する<br />connects to a remote host</td>
</tr>

<tr>
<td><a href="#net-error">net-error</a></td>
<td>最後のエラーを返す<br />returns the last error</td>
</tr>

<tr>
<td><a href="#net-eval">net-eval</a></td>
<td>複数のリモート newLISP サーバーで式を評価する<br />evaluates expressions on multiple remote newLISP servers</td>
</tr>

<tr>
<td><a href="#net-interface">net-interface</a></td>
<td>マルチホーム・コンピュータの既定インターフェース IP アドレスをセットする<br />Sets the default interface IP address on multihomed computers.</td>
</tr>

<tr>
<td><a href="#net-ipv">net-ipv</a></td>
<td>インターネット・プロトコル・バージョン IPv4 と IPv6 間を切り替える<br />Switches between IPv4 and IPv6 internet protocol versions.</td>
</tr>

<tr>
<td><a href="#net-listen">net-listen</a></td>
<td>通信用ローカル・ソケットを待ち受け（listen）る<br />listens for connections to a local socket</td>
</tr>

<tr>
<td><a href="#net-local">net-local</a></td>
<td>通信用ローカル IP とポート番号を返す<br />returns the local IP and port number for a connection</td>
</tr>

<tr>
<td><a href="#net-lookup">net-lookup</a></td>
<td>IP 番号用の名前を返す<br />returns the name for an IP number</td>
</tr>

<tr>
<td><a href="#net-packet">net-packet</a></td>
<td>生のソケット上にカスタム構成の IP パケットを送信する<br />send a custom configured IP packet over raw sockets</td>
</tr>

<tr>
<td><a href="#net-peek">net-peek</a></td>
<td>ネットワーク・ソケットから読み出せる文字数を返す<br />returns the number of characters ready to be read from a network socket</td>
</tr>

<tr>
<td><a href="#net-peer">net-peer</a></td>
<td>ネット接続用リモート IP とポートを返す<br />returns the remote IP and port for a net connect</td>
</tr>

<tr>
<td><a href="#net-ping">net-ping</a></td>
<td>一個以上のアドレスに ping パケット (ICMP echo request) を送信する<br />sends a ping packet (ICMP echo request) to one or more addresses</td>
</tr>

<tr>
<td><a href="#net-receive">net-receive</a></td>
<td>接続ソケット上のデータを読み取る<br />reads data on a socket connection</td>
</tr>

<tr>
<td><a href="#net-receive-from">net-receive-from</a>&nbsp;</td>
<td>開いてる接続の UDP を読み取る<br />reads a UDP on an open connection</td>
</tr>

<tr>
<td><a href="#net-receive-udp">net-receive-udp</a></td>
<td>UDP を読み取り、接続を閉じる<br />reads a UDP and closes the connection</td>
</tr>

<tr>
<td><a href="#net-select">net-select</a></td>
<td>ソケットまたはソケットのリストの状態をチェックする<br />checks a socket or list of sockets for status</td>
</tr>

<tr>
<td><a href="#net-send">net-send</a></td>
<td>接続ソケットにデータを送信する<br />sends data on a socket connection</td>
</tr>

<tr>
<td><a href="#net-send-to">net-send-to</a></td>
<td>開いてる接続に UDP を送信する<br />sends a UDP on an open connection</td>
</tr>

<tr>
<td><a href="#net-send-udp">net-send-udp</a></td>
<td>UDP を送信し、接続を閉じる<br />sends a UDP and closes the connection</td>
</tr>

<tr>
<td><a href="#net-service">net-service</a></td>
<td>サービス名をポート番号に翻訳する<br />translates a service name into a port number</td>
</tr>

<tr>
<td><a href="#net-sessions">net-sessions</a></td>
<td>現在開いてる接続のリストを返す<br />returns a list of currently open connections </td>
</tr>

</table><br/>

<a name="JS"></a>
<h3>API for newLISP in a web browser（ウェブ・ブラウザ用 newLISP の API）</h3>

<table border="0" cellpadding="1" width="95%" align="center" summary="Reflection and customization">

<tr>
<td width="16%"><a href="#display-html">display-html</a></td>
<td width="84%">ウェブ・ブラウザに HTML ページを表示する<br />display an HTML page in a web browser</td>
</tr>

<tr>
<td><a href="#eval-string-js">eval-string-js</a></td>
<td>現在のウェブ・ブラウザ・ページで JavaScript を評価する<br />evaluate JavaScript in the current web browser page</td>
</tr>

</table><br/>


<a name="reflection"></a>
<h3>Reflection and customization（リフレクションとカスタマイズ）</h3>
<p>（訳注：Reflection については、<a href="http://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6)">こちらを参照してください</a>。）<br /></p>

<table border="0" cellpadding="1" width="95%" align="center" summary="Reflection and customization">

<tr>
<td width="16%"><a href="#command-event">command-event</a></td>
<td width="84%">コマンドラインや HTTP リスクエストを前処理する<br />pre-processes the command-line and HTTP requests</td>
</tr>

<tr>
<td><a href="#error-event">error-event</a></td>
<td>エラー・ハンドラを定義する<br />defines an error handler</td>
</tr>

<tr>
<td><a href="#history">history</a></td>
<td>関数の呼び出し履歴を返す<br />returns the call history of a function</td>
</tr>

<tr>
<td><a href="#last-error">last-error</a></td>
<td>エラー番号とテキストを報告する<br />report the last error number and text</td>
</tr>

<tr>
<td><a href="#macro">macro</a></td>
<td>リーダー拡張マクロ（訳注：<em>macro</em>）を生成する<br />create a reader expansion macro</td>
</tr>

<tr>
<td><a href="#ostype">ostype</a></td>
<td>OSプラットフォームを表す文字列を取得する<br />contains a string describing the OS platform</td>
</tr>

<tr>
<td><a href="#prefix">prefix</a></td>
<td>シンボルのコンテキストを返す<br />Returns the context prefix of a symbol</td>
</tr>

<tr>
<td><a href="#prompt-event">prompt-event</a></td>
<td>インタラクティブ newLISP シェル・プロンプトをカスタマイズする<br />customizes the interactive newLISP shell prompt</td>
</tr>

<tr>
<td><a href="#read-expr">read-expr</a></td>
<td>ソースから S 式を読み取り、翻訳する<br />reads and translates s-expressions from source</td>
</tr>

<tr>
<td><a href="#reader-event">reader-event</a></td>
<td>評価イベント駆動の前に、式を前処理する<br />preprocess expressions before evaluation event-driven</td>
</tr>

<tr>
<td><a href="#set-locale">set-locale</a></td>
<td>異なる<a href="http://ja.wikipedia.org/w/index.php?title=%E3%83%AD%E3%82%B1%E3%83%BC%E3%83%AB&redirect=no">ロケール</a>に切り替える<br />switches to a different locale</td>
</tr>

<tr>
<td><a href="#source">source</a></td>
<td>シンボルに束縛を要求されているソースを文字列で返す<br />returns the source required to bind a symbol to a string</td>
</tr>

<tr>
<td><a href="#sys-error">sys-error</a></td>
<td>OS システム・エラー番号を報告する<br />reports OS system error numbers</td>
</tr>

<tr>
<td><a href="#sys-info">sys-info</a></td>
<td>システム・リソースについての情報を与える<br />gives information about system resources</td>
</tr>

<tr>
<td><a href="#term">term</a></td>
<td>コンテキスト無しのシンボル部分を文字列で返す<br />returns the term part of a symbol without the context prefix as a string</td>
</tr>

</table><br/>

<a name="system_functions"></a>
<h3>System functions（システム関数）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="System functions">

<tr>
<td width="16%"><a href="#systemsymbol">$</a></td>
<td width="84%">システム変数 $0 -&gt; $15 にアクセスする<br />accesses system variables $0 -&gt; $15</td>
</tr>

<tr>
<td><a href="#callback">callback</a></td>
<td>導入した関数用の<a href ="http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF_%28%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%29">コールバック関数</a>を登録する<br />registers a callback function for an imported library</td>
</tr>

<tr>
<td><a href="#catch">catch</a></td>
<td>式を評価し、エラーを補足したら、すぐに戻る<br />evaluates an expression, catching errors and early returns</td>
</tr>

<tr>
<td><a href="#context">context</a></td>
<td>異なる名前空間の生成か切り替えをする<br />creates or switches to a different namespace</td>
</tr>

<tr>
<td><a href="#copy">copy</a></td>
<td>評価結果をコピーする<br />copies the result of an evaluation</td>
</tr>

<tr>
<td><a href="#debug">debug</a></td>
<td>ユーザ定義関数をデバックする<br />debugs a user-defined function</td>
</tr>

<tr>
<td><a href="#delete">delete</a></td>
<td>シンボル・テーブルからシンボルを削除する<br />deletes symbols from the symbol table</td>
</tr>

<tr>
<td><a href="#default">default</a></td>
<td>コンテキストのデフォルト・ファンクタを返す<br />returns the contents of a default functor from a context</td>
</tr>

<tr>
<td><a href="#env">env</a></td>
<td>オペレーティング・システム環境を取得または設定する<br />gets or sets the operating system's environment</td>
</tr>

<tr>
<td><a href="#exit">exit</a></td>
<td>newLISPを終了し、戻り値をセットする<br />exits newLISP, setting the exit value</td>
</tr>

<tr>
<td><a href="#global">global</a></td>
<td>MAIN以外から（訳注：MAINコンテキストを指定せずに）アクセスできるシンボルにする<br />makes a symbol accessible outside MAIN</td>
</tr>

<tr>
<td><a href="#import">import</a></td>
<td>共有ライブラリを導入する<br />imports a function from a shared library</td>
</tr>

<tr>
<td><a href="#main-args">main-args</a></td>
<td>コマンドライン引数を取得する<br />gets command-line arguments</td>
</tr>

<tr>
<td><a href="#new">new</a></td>
<td>コンテキストのコピーを生成する<br />creates a copy of a context</td>
</tr>

<tr>
<td><a href="#pretty-print">pretty-print</a></td>
<td>pretty-print 文字（訳注： <a href="#print">print</a>、<a href="#save">save</a>、<a href="#source">source</a> 時の整形文字）を変更する<br />changes the pretty-printing characteristics</td>
</tr>

<tr>
<td><a href="#read-expr">read-expr</a></td>
<td>文字列を S 式に翻訳するが、評価はしない<br />translates a string to an s-expression without evaluating it</td>
</tr>

<tr>
<td><a href="#reset">reset</a></td>
<td>トップレベルに行く（訳注：いわゆる、リセット）<br />goes to the top level</td>
</tr>

<tr>
<td><a href="#signal">signal</a></td>
<td><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%B0%E3%83%8A%E3%83%AB_%28%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%29">シグナル</a>・ハンドラを設定する<br />sets a signal handler</td>
</tr>

<tr>
<td><a href="#sleep">sleep</a></td>
<td>指定されたミリ秒プロセスを中断する<br />suspends processing for specified milliseconds</td>
</tr>

<tr>
<td><a href="#sym">sym</a></td>
<td>文字列からシンボルを生成する<br />creates a symbol from a string</td>
</tr>

<tr>
<td><a href="#symbols">symbols</a></td>
<td>システムの全てのシンボルのリストを返す<br />returns a list of all symbols in the system</td>
</tr>

<tr>
<td><a href="#throw">throw</a></td>
<td>先行する <a href="#catch">catch</a> への戻りを起こす<br />causes a previous <a href="#catch">catch</a> to return</td>
</tr>

<tr>
<td><a href="#throw-error">throw-error</a></td>
<td>ユーザ定義エラーを発生する<br />throws a user-defined error</td>
</tr>

<tr>
<td><a href="#timer">timer</a></td>
<td>ワン・ショット・タイマを開始して、イベントを起こす<br />starts a one-shot timer, firing an event</td>
</tr>

<tr>
<td><a href="#trace">trace</a></td>
<td>トレース・モードの設定と問い合わせ<br />sets or inquires about trace mode</td>
</tr>

<tr>
<td><a href="#trace-highlight">trace-highlight</a></td>
<td>トレース・モード時のハイライト文字列の設定<br />sets highlighting strings in trace mode</td>
</tr>

</table><br/>

<a name="importing_libraries"></a>
<h3>Importing libraries（ライブラリのインポート）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="Importing libraries<">


<tr>
<td width="16%"><a href="#address">address</a></td>
<td width="84%">数値や文字列のメモリ・アドレスを返す<br />returns the memory address of a number or string</td>

</tr>

<tr>
<td><a href="#callback">callback</a></td>
<td>導入した関数用の<a href ="http://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%AB%E3%83%90%E3%83%83%E3%82%AF_%28%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%29">コールバック関数</a>を登録する<br />registers a callback function for an imported library</td>
</tr>

<tr>
<td><a href="#flt">flt</a></td>
<td>浮動小数点数を表す32ビット整数に変換する<br />converts a number to a 32-bit integer representing a float</td>
</tr>

<tr>
<td><a href="#float">float</a></td>
<td>文字列や整数を浮動小数点数に変換する<br />translates a string or integer into a floating point number</td>
</tr>

<tr>
<td><a href="#get-char">get-char</a></td>
<td>メモリ・アドレスから文字を取得する<br />gets a character from a memory address</td>
</tr>

<tr>
<td><a href="#get-float">get-float</a></td>
<td>メモリ・アドレスから倍精度浮動小数点を取得する<br />gets a double float from a memory address</td>
</tr>

<tr>
<td><a href="#get-int">get-int</a>&nbsp;&nbsp;</td>
<td>メモリ・アドレスから32ビット整数を取得する<br />gets a 32-bit integer from a memory address</td>
</tr>

<tr>
<td><a href="#get-long">get-long</a>&nbsp;&nbsp;</td>
<td>メモリ・アドレスから64ビット整数を取得する<br />gets a long 64-bit integer from a memory address</td>
</tr>

<tr>
<td><a href="#get-string">get-string</a></td>
<td>メモリ・アドレスから文字列を取得する<br />gets a string from a memory address</td>
</tr>

<tr>
<td><a href="#import">import</a></td>
<td>共有ライブラリから関数を導入する<br />imports a function from a shared library</td>
</tr>

<tr>
<td><a href="#int">int</a></td>
<td>文字列か浮動小数点数を整数に変換する<br />translates a string or float into an integer</td>
</tr>

<tr>
<td><a href="#pack">pack</a></td>
<td>newLISP の式をバイナリ構造体にパックする<br />packs newLISP expressions into a binary structure</td>
</tr>

<tr>
<td><a href="#struct">struct</a></td>
<td>C言語タイプの構造体データを定義する<br />Defines a data structure with C types</td>
</tr>

<tr>
<td><a href="#unpack">unpack</a></td>
<td>バイナリ構造体を newLISP 式にアンパックする<br />unpacks a binary structure into newLISP expressions</td>
</tr>
</table><br/>

<a name="internals"></a>
<h3>newLISP internals API（newLISP 内部 API）</h3>


<table border="0" cellpadding="1" width="95%" align="center" summary="newLISP internals API">

<tr>
<td width="16%"><a href="#command-event">command-event</a></td>
<td width="84%">コマンドラインや HTTP リスクエストを前処理する<br />pre-processes the command-line and HTTP requests</td>
</tr>

<tr>
<td><a href="#cpymem">cpymem</a></td>
<td>アドレス間でメモリをコピーする<br />copies memory between addresses</td>
</tr>

<tr>
<td><a href="#dump">dump</a></td>
<td>newLISP セルのメモリ・アドレスと内容を示す<br />shows memory address and contents of newLISP cells</td>
</tr>

<tr>
<td><a href="#prompt-event">prompt-event</a></td>
<td>インタラクティブ newLISP シェル・プロンプトをカスタマイズする<br />customizes the interactive newLISP shell prompt</td>
</tr>

<tr>
<td><a href="#read-expr">read-expr</a></td>
<td>ソースから S 式を読み取り、翻訳する<br />reads and translates s-expressions from source</td>
</tr>

<tr>
<td><a href="#reader-event">reader-event</a></td>
<td>評価イベント駆動の前に、式を前処理する<br />preprocess expressions before evaluation event-driven</td>
</tr>


</table><br/>

<br/>

<center>
<span class="divider">(&nbsp;<font color="#7ba9d4">&sect;</font>&nbsp;)</span>
</center>

<br/>

<a name="functions_alphabetical"></a>
<h2>4. Functions in alphabetical order（アルファベット順の関数）</h2>

<br/>

<a name="shell"></a>
<h2><span class="function">!</span></h2>
<h4>syntax: (! <em>str-shell-command</em> [<em>int-flags</em>])</h4>

<p>OSのシェル上で <em>str-shell-command</em> のコマンドを実行します。
この関数は、ホスト・オペレーティング・システムによって異なる値を返します。<br />
Executes the command in <em>str-command</em> by shelling out to the 
operating system and executing.  This function returns a different value
depending on the host operating system.</p>

<!-- example -->

<pre>
(! "vi")  
(! "ls -ltr")
</pre>


<p>シェル・コマンドを実行したり、標準出力を取得したり、標準入力を与えたりするのに関数<a href="#exec">exec</a> を使ってください。
ノン・ブロッキングの子プロセスを起動し、標準 I/O や標準エラーをパイプへリダイレクトするためには、関数<a href="#process">process</a> が使えます。<br />
Use the <a href="#exec">exec</a> function to execute a shell command 
and capture the standard output or to feed standard input. 
The <a href="#process">process</a> function may be used to launch a 
non-blocking child process and redirect std I/O and std error to pipes.</p>

<p>Ms Windows では、オプションの <em>int-flags</em> パラメータが、
プロセス生成の様々なパラメータを制御する Windows 関数 <tt>CreateProcessA</tt> 用に定義されたプロセス生成フラグを取ります。
このパラメータ―― <tt>0</tt> が使われる――を含めると、コマンド・シェル・ウィンドウ無しプロセス生成が強制されます。
このパラメータは、Unix では無視されます。<br />
On Ms Windows the optional <em>int-flags</em> parameter takes process
creation flags as defined for the Windows <tt>CreateProcessA</tt> function
to control various parameters of process creation. The inclusion of this
parameter &ndash; which also can be <tt>0</tt> &ndash; forces a different 
creation of the process without a command shell window. This parameter is 
ignored on Unix.</p>

<pre>
; on MS Windows
; close the console of the currently running newLISP process
(apply (import "kernel32" "FreeConsole")) 

; start another process and wait for it to finish
(! "notepad.exe" 0)

(exit)
</pre>

<p>付加パラメータ無しの <tt>!</tt> 呼出しは、コマンド・ウィンドウを閉じて、代わりに新しいコマンド・ウィンドウを生成します。<br />
Without the additional parameter, the <tt>!</tt> call would create a
new command window replacing the closed one.</p>

<p><tt>!</tt>（感嘆符）は、括弧や <tt>!</tt> に続くスペースを省略して、
コマンド・ラインのシェル・オペレータとしても使えることに注意してください：<br />
Note that <tt>!</tt> (exclamation mark) can be also be used as 
a command-line shell operator by omitting the parenthesis and space 
after the <tt>!</tt>:</p>

<!-- example -->

<pre><b>&gt;</b> !ls -ltr    ; executed in the newLISP shell window
</pre>


<p>
	この方法で使う <tt>!</tt> オペレータは全く newLISP 関数らしくなく、いわば newLISP コマンド・シェルの特殊機能です。
	<tt>!</tt> は、必ずコマンド・ラインの先頭に、入力しなければなりません。<br />
	Used in this way, 
	the <tt>!</tt> operator 
	is not a newLISP function at all, 
	but rather a special feature of 
	the newLISP command shell. 
	The <tt>!</tt> must be entered 
	as the first character
	on the command-line.
</p>

<br/><br/>

<a name="systemsymbol"></a>
<h2><span class="function">$</span></h2>
<h4>syntax: ($ <em>int-idx</em>)</h4>

<p>
正規表現を使う関数（<a href="#directory">directory</a>、<a href="#ends-with">ends-with</a>、
<a href="#find">find</a>、<a href="#find-all">find-all</a>、<a href="#parse">parse</a>、<a href="#regex">regex</a>、<a href="#search">search</a>、<a href="#starts-with">starts-with</a>、<a href="#replace">replace</a>）は全て、
実行中もしくは実行後の関数の結果をシステム変数として予約されている <tt>$0</tt>、<tt>$1</tt>、<tt>$2</tt>&ndash;<tt>$15</tt> に束縛します。
システム変数は他のシンボルと同じように扱えます。
選択肢の一つとして、これらの変数の内容を <tt>($ 0)</tt>、<tt>($ 1)</tt>、<tt>($ 2)</tt> 等を使ってアクセスすることもできます。
この方法はインデックス操作を使っています（すなわち <tt>($ i)</tt>、ここで <tt>i</tt> は整数）。<br />
The functions that use regular expressions 	(<a href="#directory">directory</a>,
<a href="#ends-with">ends-with</a>, <a href="#find">find</a>, <a href="#find-all">find-all</a>, 
<a href="#parse">parse</a>, <a href="#regex">regex</a>, <a href="#search">search</a>, 
<a href="#starts-with">starts-with</a> and <a href="#replace">replace</a>) 
all bind their results to the predefined system variables <tt>$0</tt>, <tt>$1</tt>, 
<tt>$2</tt>&ndash;<tt>$15</tt> after or during the function's execution. System variables 
can be treated the same as any other symbol. As an alternative, the contents of these 
variables may also be accessed by using <tt>($ 0)</tt>, <tt>($ 1)</tt>, <tt>($ 2)</tt>, 
etc. This method allows indexed access (i.e., <tt>($ i)</tt>, where <tt>i</tt> is an integer).</p>

<!-- example -->

<pre>
(set 'str  "http://newlisp.org:80")
(find "http://(.*):(.*)" str 0)  <span class='arw'>&rarr;</span> 0
                                 
$0  <span class='arw'>&rarr;</span> "http://newlisp.org:80"
$1  <span class='arw'>&rarr;</span> "newlisp.org"
$2  <span class='arw'>&rarr;</span> "80"
                                 
($ 0)  <span class='arw'>&rarr;</span> "http://newlisp.org:80"
($ 1)  <span class='arw'>&rarr;</span> "newlisp.org"
($ 2)  <span class='arw'>&rarr;</span> "80"
</pre>

<br/><br/>

<a name="arithmetic"></a>
<h2><span class="function">+, -, *, / ,%</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (+ <em>int-1</em> [<em>int-2</em> ... ])</h4>

<p><em>int-1</em> から続く全ての数値の和を返します。<br />
Returns the sum of all numbers in <em>int-1</em> &mdash;.</p>

<h4>syntax: (- <em>int-1</em> [<em>int-2</em> ... ])</h4>

<p><em>int-1</em> から <em>int-2</em> を引き算し、続く <em>int-i</em> 以下を前の結果から次々に引き算します。もし、引数が一つなら、符号を反転します。<br />
Subtracts <em>int-2</em> from <em>int-1</em>, then the next <em>int-i</em> 
from the previous result. If only one argument is given, 
its sign is reversed. </p>

<h4>syntax: (* <em>int-1</em> [<em>int-2</em> ... ])</h4>

<p><em>int-1</em> から <em>int-i</em> までを掛け算します。<br />
The product is calculated for <em>int-1</em> to <em>int-i</em>.</p>

<h4>syntax: (/ <em>int-1</em> [<em>int-2</em> ... ])</h4>

<p>リストの終わりに達するまで、次々と割り算して行きます。
ゼロで割るとエラーを起こします。<br />
Each result is divided successively until the end of the list is reached. 
Division by zero causes an error.</p>

<h4>syntax: (% <em>int-1</em> [<em>int-2</em> ... ])</h4>

<p>次（訳注：右隣）の <em>int</em> で割った余りを返します。
ゼロでの割り算はエラーを起こします。
浮動小数点数の場合は、関数 <a href="#mod">mod</a>を使ってください。<br />
Each result is divided successively by the next <em>int</em>, 
then the rest (modulo operation) is returned. Division by zero causes an error. 
For floating point numbers, use the <a href="#mod">mod</a> function.</p>

<!-- example -->

<pre>
(+ 1 2 3 4 5)        <span class='arw'>&rarr;</span> 15
(+ 1 2 (- 5 2) 8)    <span class='arw'>&rarr;</span> 14
(- 10 3 2 1)         <span class='arw'>&rarr;</span> 4
(- (* 3 4) 6 1 2)    <span class='arw'>&rarr;</span> 3
(- 123)              <span class='arw'>&rarr;</span> -123
(map - '(10 20 30))  <span class='arw'>&rarr;</span> (-10 -20 -30)
(* 1 2 3)            <span class='arw'>&rarr;</span> 6
(* 10 (- 8 2))       <span class='arw'>&rarr;</span> 60
(/ 12 3)             <span class='arw'>&rarr;</span> 4
(/ 120 3 20 2)       <span class='arw'>&rarr;</span> 1
(% 10 3)             <span class='arw'>&rarr;</span> 1
(% -10 3)            <span class='arw'>&rarr;</span> -1
(+ 1.2 3.9)          <span class='arw'>&rarr;</span> 4
</pre>


<p>
<tt>+</tt>、<tt>-</tt>、<tt>*</tt>、<tt>/</tt>、<tt>%</tt> の引数に与えられた浮動小数点数は、<tt>0</tt>（ゼロ）に近い整数に丸められます。<br />
Floating point values in arguments to 
<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt>, and <tt>%</tt> 
are truncated to the integer value closest to <tt>0</tt> (zero).
</p>

<p>
整数値の最大値(<tt>9,223,372,036,854,775,807</tt>)より大きい浮動小数点数は整数値の最大値に丸められ、
最小値(<tt>-9,223,372,036,854,775,808</tt>) より小さい浮動小数点数は整数値の最小値に丸められます。
これは、<tt>+Inf</tt> と <tt>-Inf</tt> も含みます。<br />
Floating point values larger or smaller than
the maximum (<tt>9,223,372,036,854,775,807</tt>)
or minimum (<tt>-9,223,372,036,854,775,808</tt>) integer values 
are truncated to those values. This includes the values for
<tt>+Inf</tt> and <tt>-Inf</tt>.
</p>

<p>
	計算結果が <tt>9,223,372,036,854,775,807</tt> より大きい値になると符合が＋から－に、
	<tt>-9,223,372,036,854,775,808</tt> より小さい値になると符合が－から＋に変わります。<br />
	Calculations resulting in values 
	larger than <tt>9,223,372,036,854,775,807</tt> 
	or smaller than <tt>-9,223,372,036,854,775,808</tt> 
	wrap around from positive to negative 
	or negative to positive.
</p>
<blockquote>
（訳例：
<pre>
> (+ 9223372036854775807 1)
-9223372036854775808
> (- -9223372036854775808 1)
9223372036854775807
> 
</pre>）</blockquote>

<p>
	<tt>NaN</tt> (Not a Number) に評価される浮動小数点数は <tt>0</tt>（ゼロ）として扱われます。<br />
Floating point values that evaluate to <tt>NaN</tt> (Not a Number), 
ar treated as <tt>0</tt> (zero). 
</p>
<blockquote>
（訳例：
<pre>
> (sqrt -1)
nan
> (+ 0 (sqrt -1))
0
> (mul 1E308 10)
inf
> (+ 0 (mul 1E308 10))
9223372036854775807
> (mul 1E308 -10)
-inf
> (+ 0 (mul 1E308 -10))
9223372036854775807
> 
</pre>）</blockquote>

<br/><br/>

<a name="inci"></a>
<h2><span class="function">++</span>&nbsp;<a href="#destructive">!</a>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (++ <em>place</em> [<em>num</em> ... ])</h4>

<p><tt>++</tt> 演算子は <a href="#inc">inc</a>のように動作しますが、実行されるのは整数演算です。
オプションの引数 <em>num</em> が無い時、<tt>++</tt> は <em>place</em> の数値に <tt>1</tt> を加算します。<br />
The <tt>++</tt> operator works like <a href="#inc">inc</a>, but performs
integer arithmetic. Without the optional argument in <em>num</em>,
<tt>++</tt> increments the number in <em>place</em> by <tt>1</tt>.</p>

<p>引数に浮動小数点数が渡されると、最初に小数点以下が切り捨てられます。<br />
If floating point numbers are passed as arguments, their fractional part
gets truncated first.</p>

<p>
計算結果が <tt>9,223,372,036,854,775,807</tt> より大きい値になると符合が正から負に、<tt>-9,223,372,036,854,775,808</tt> より小さい値になると符合が負から正に変わります。<br />
Calculations resulting in numbers greater than 9,223,372,036,854,775,807 wrap 
around to negative numbers.  Results smaller than -9,223,372,036,854,775,808 
wrap around to positive numbers.</p>

<p><em>place</em> はシンボルか、数値を保持するリスト構造の位置か、式によって返される数値のいずれかです。<br />
<em>place</em> is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.</p>

<!-- example -->

<pre>
(set 'x 1)    
(++ x)        <span class='arw'>&rarr;</span> 2
(set 'x 3.8)
(++ x)        <span class='arw'>&rarr;</span> 4
(++ x 1.3)    <span class='arw'>&rarr;</span> 5
(set 'lst '(1 2 3))
(++ (lst 1) 2))  <span class='arw'>&rarr;</span> 4
lst              <span class='arw'>&rarr;</span> (1 4 3)
</pre>


<p><em>place</em> のシンボルに <tt>nil</tt> が入っていたら、<tt>0</tt> として扱われます。<br />
If the symbol for <em>place</em> contains <tt>nil</tt>, it is treated
as if containing <tt>0</tt>.</p>

<p>整数モードで数値を減算するには <a href="#deci">--</a> を見てください。
浮動小数点数モードで数値を加算するには <a href="#inc">inc</a> を見てください。<br />
See <a href="#deci">--</a> for decrementing numbers in integer mode.
See <a href="#inc">inc</a> for incrementing numbers in floating point mode.</p>

<br/><br/>

<a name="deci"></a>
<h2><span class="function">--</span>&nbsp;<a href="#destructive">!</a>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (-- <em>place</em> [<em>num</em> ... ])</h4>

<p><tt>--</tt> 演算子は <a href="#inc">dec</a> のように動作しますが、実行されるのは整数演算です。
オプションの引数 <em>num</em> が無い時、<tt>--</tt> は <em>place</em> の数値から <tt>1</tt> を引きます。<br />
The <tt>--</tt> operator works like <a href="#inc">dec</a>, but performs
integer arithmetic. Without the optional argument in <em>num-2</em>,
<tt>--</tt> decrements the number in <em>place</em> by <tt>1</tt>.</p>

<p>引数に浮動小数点数が渡されると、最初に小数点以下が切り捨てられます。<br />
If floating point numbers are passed as arguments, their fractional part
gets truncated first.</p>

<p>
計算結果が <tt>9,223,372,036,854,775,807</tt> より大きい値になると符合が正から負に、
<tt>-9,223,372,036,854,775,808</tt> より小さい値になると符合が負から正に変わります。<br />
Calculations resulting in numbers greater than 9,223,372,036,854,775,807 wrap 
around to negative numbers.  Results smaller than -9,223,372,036,854,775,808 
wrap around to positive numbers.</p>

<p><em>place</em> はシンボルか、数値を保持するリスト構造の位置か、式によって返される数値のいずれかです。<br />
<em>place</em> is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.</p>

<!-- example -->

<pre>
(set 'x 1)    
(-- x)        <span class='arw'>&rarr;</span> 0
(set 'x 3.8)
(-- x)        <span class='arw'>&rarr;</span> 2
(-- x 1.3)    <span class='arw'>&rarr;</span> 1


(set 'lst '(1 2 3))
(-- (lst 1) 2))  <span class='arw'>&rarr;</span> 0
lst              <span class='arw'>&rarr;</span> (1 0 3)
</pre>

<p><em>place</em> のシンボルに <tt>nil</tt> が入っていたら、<tt>0</tt> として扱われます。<br />
If the symbol for <em>place</em> contains <tt>nil</tt>, it is treated
as if containing <tt>0</tt>.</p>

<p>整数モードで数値を加算するには <a href="#inci">++</a> を見てください。
浮動小数点数モードで数値を減算するには <a href="#dec">dec</a> を見てください。<br />
See <a href="#inci">++</a> for incrementing numbers in integer mode.
See <a href="#dec">dec</a> for decrementing numbers in floating point mode.</p>

<br/><br/>
<a name="logical"></a>
<h2><span class="function">&lt;, &gt;, =, &lt;=, &gt;=, !=</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (&lt; <em>exp-1</em> [<em>exp-2</em> ... ])<br/>
syntax: (&gt; <em>exp-1</em> [<em>exp-2</em> ... ])<br/>
syntax: (= <em>exp-1</em> [<em>exp-2</em> ... ])<br/>
syntax: (&lt;= <em>exp-1</em> [<em>exp-2</em> ... ])<br/>
syntax: (&gt;= <em>exp-1</em> [<em>exp-2</em> ... ])<br/>
syntax: (!= <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p>式が評価され、その結果が続けて比較されます。
比較した結果が比較演算子に一致する間は、全ての引数が試されるまで評価と比較が続けられ、結果は、<tt>true</tt> になります。
比較が一致しなかったら、直ちに <tt>nil</tt> が返ります。<br />
Expressions are evaluated and the results are compared successively. 
As long as the comparisons conform to the comparison operators, 
evaluation and comparison will continue until all arguments are tested 
and the result is <tt>true</tt>. As soon as one comparison fails, 
<tt>nil</tt> is returned.
</p>

<p>全ての演算子で、引数が一つなら、第二引数は <tt>0</tt> として扱われます。
これは、数値が負か正か、ゼロかゼロでないか等を確認するのに使えます。<br />
If only one argument is supplied, all comparison operators assume <tt>0</tt> (zero)
as a second argument. This can be used to check if a number is negative, positive, zero 
or not zero.</p>

<p>全ての型の式（アトム、数値、シンボル、文字列）が比較可能です。
リスト式も比較可能です(リストの要素が再帰的に比較されます）。<br />
All types of expressions can be compared: 
	atoms, numbers, symbols, and strings. 
	List expressions can also be compared 
	(list elements are compared recursively).
</p>

<p>リスト式の比較では、リストの最初の要素が続く要素よりも先に判断されます（文字列の文字も同様）。
長さも要素も異なるリスト式の比較では、長いリスト式がより大きいと判断されます（例題を見てください）。<br />
	When comparing lists, 
	elements at the beginning of the list 
	are considered more significant than the elements following 
	(similar to characters in a string). 
	When comparing lists of different lengths but equal elements, 
	the longer list is considered greater (see examples).
</p>

<p>混在型の式では、型が低い方から高い方に比較されます。
浮動小数点数と整数は、それらを数値として比較するため、最初に必要な型へ変換してから比較されます。<br />
	In mixed-type expressions, 
	the types are compared from lowest to highest. 
	Floats and integers are compared by first
	converting them to the needed type, 
	then comparing them as numbers.
</p>

<blockquote>
<b>Atoms:</b> nil, true, integer or float, string, symbol, primitive<br/>
<b>Lists:</b> quoted list/expression, list/expression, lambda, lambda-macro<br/>
（訳注：型の比較順列。左から右へ行くにつれて高くなり、<br/>
	アトムとリストでは、リストの方が大きいと判断されます。）
</blockquote>

<!-- example -->
<pre>
(&lt; 3 5 8 9)                     <span class='arw'>&rarr;</span> true
(&gt; 4 2 3 6)                     <span class='arw'>&rarr;</span> nil
(&lt; "a" "c" "d")                 <span class='arw'>&rarr;</span> true
(&gt;= duba aba)                   <span class='arw'>&rarr;</span> true
(&lt; '(3 4) '(1 5))               <span class='arw'>&rarr;</span> nil
(&gt; '(1 2 3) '(1 2))             <span class='arw'>&rarr;</span> true
(= '(5 7 8) '(5 7 8))           <span class='arw'>&rarr;</span> true
(!= 1 4 3 7 3)                  <span class='arw'>&rarr;</span> true
(&lt; 1.2 6 "Hello" 'any '(1 2 3))           <span class='arw'>&rarr;</span> true
(&lt; nil true)                              <span class='arw'>&rarr;</span> true
(&lt; '(((a b))) '(((b c))))                 <span class='arw'>&rarr;</span> true
(&lt; '((a (b c)) '(a (b d)) '(a (b (d)))))  <span class='arw'>&rarr;</span> true

; with single argument compares against 0

(&gt; 1)    <span class='arw'>&rarr;</span> true ; checks for positive
(&gt; -1)   <span class='arw'>&rarr;</span> nil ; checks for negative
(= 123)  <span class='arw'>&rarr;</span> nil ; checks for zero

(map &gt; '(1 3 -4 -3 1 2))   <span class='arw'>&rarr;</span> (true true nil nil true true)
</pre>

<br/><br/>

<a name="bit_shift"></a>
<h2><span class="function">&lt;&lt;, &gt;&gt;</span></h2>
<h4>syntax: (&lt;&lt; <em>int-1</em> <em>int-2</em> [<em>int-3</em> ... ])<br/>

syntax: (&gt;&gt; <em>int-1</em> <em>int-2</em> [<em>int-3</em> ... ])<br/>

syntax: (&lt;&lt; <em>int-1</em>)<br/>
syntax: (&gt;&gt; <em>int-1</em>)</h4>

<p>数値 <em>int-1</em> が <em>int-2</em> で与えられたビット数分、左または右に算術シフトされ、続けて <em>int-3</em> 分シフトされるという風に続きます。
例えば、64ビット整数では 63 個までシフトできます。
右シフトの場合、最上位ビットがそのまま残ります（<a href="http://ja.wikipedia.org/wiki/%E3%83%93%E3%83%83%E3%83%88%E6%BC%94%E7%AE%97#.E7.AE.97.E8.A1.93.E3.82.B7.E3.83.95.E3.83.88">算術シフト</a>）：<br />
	The number <em>int-1</em> is arithmetically shifted 
	to the left or right by the number of bits given as <em>int-2</em>, 
	then shifted by <em>int-3</em> and so on. 
	For example, 64-bit integers may be shifted up to 63 positions. 
	When shifting right, 
	the most significant bit is duplicated 
	(<em>arithmetic shift</em>):
</p>


<pre>
(&gt;&gt; 0x8000000000000000 1)  <span class='arw'>&rarr;</span> 0xC000000000000000  ; not 0x0400000000000000!
</pre>

<br/>
<!-- example -->

<pre>
(&lt;&lt; 1 3)      <span class='arw'>&rarr;</span>  8
(&lt;&lt; 1 2 1)    <span class='arw'>&rarr;</span>  8
(&gt;&gt; 1024 10)  <span class='arw'>&rarr;</span>  1
(&gt;&gt; 160 2 2)  <span class='arw'>&rarr;</span> 10

(&lt;&lt; 3)        <span class='arw'>&rarr;</span>  6
(&gt;&gt; 8)        <span class='arw'>&rarr;</span>  4
</pre>


<p><em>int-1</em> が唯一の引数の場合、<tt>&lt;&lt;</tt> と <tt>&gt;&gt;</tt> は １ビットシフトします。<br />
When <em>int-1</em> is the only argument, <tt>&lt;&lt;</tt>
and <tt>&gt;&gt;</tt> shift by one bit.
</p>

<br/><br/>

<a name="bit_and"></a>
<h2><span class="function">&amp;</span></h2>
<h4>syntax: (&amp; <em>int-1</em> <em>int-2</em> [<em>int-3</em> ... ])</h4>

<p><em>int-1</em> の数値と <em>int-2</em> の数値のビット単位 <tt>and</tt> 演算を行います。
続く <em>int-3</em> 以下の数値に対しても同様です。<br />
	A bitwise <tt>and</tt> operation is performed 
	on the number in <em>int-1</em> with the number in <em>int-2</em>, 
	then successively with <em>int-3</em>, etc.
</p>

<!-- example -->

<pre>
(&amp; 0xAABB 0x000F)  <span class='arw'>&rarr;</span> 11  ; which is 0xB
</pre>

<br/><br/>

<a name="bit_inclusive"></a>
<h2><span class="function">|</span></h2>
<h4>syntax: (| <em>int-1</em> <em>int-2</em> [<em>int-3</em> ... ])</h4>

<p><em>int-1</em> の数値と <em>int-2</em> の数値のビット単位 <tt>or</tt> 演算を行います。
続く <em>int-3</em> 以下の数値に対しても同様です。<br />
	A bitwise <tt>or</tt> operation is performed 
	on the number in <em>int-1</em> with the number in <em>int-2</em>, 
	then successively with <em>int-3</em>, etc.
</p>

<!-- example -->

<pre>
(| 0x10 0x80 2 1)  <span class='arw'>&rarr;</span> 147
</pre>

<br/><br/>

<a name="bit_exclusive"></a>
<h2><span class="function">^</span></h2>
<h4>syntax: (^ <em>int-1</em> <em>int-2</em> [<em>int-3</em> ... ])</h4>

<p><em>int-1</em> の数値と <em>int-2</em> の数値のビット単位 <tt>xor</tt> 演算を行います。
続く <em>int-3</em> 以下の数値に対しても同様です。<br />
	A bitwise <tt>xor</tt> operation is performed 
	on the number in <em>int-1</em> with the number in <em>int-2</em>, 
	then successively with <em>int-3</em>, etc.
</p>

<!-- example -->

<pre>
(^ 0xAA 0x55)  <span class='arw'>&rarr;</span> 255
</pre>

<br/><br/>

<a name="bit_not"></a>
<h2><span class="function">~</span></h2>
<h4>syntax: (~ <em>int</em>)</h4>

<p><em>int</em> の数値に対して、全てのビットを反転するビット単位 <tt>not</tt> 演算を行います。<br />
	A bitwise <tt>not</tt> operation is performed 
	on the number in <em>int</em>,
	reversing all of the bits.
</p>

<!-- example -->

<pre>
(format "%X" (~ 0xFFFFFFAA))  <span class='arw'>&rarr;</span> "55"
(~ 0xFFFFFFFF)                <span class='arw'>&rarr;</span> 0
</pre>

<br/><br/>

<a name="colon"></a>
<h2><span class="function">:</span></h2>
<h4>syntax: (: <em>sym-function</em> <em>list-object</em> [ ... ])</h4>

<p>コロンは名前空間のコンテキストとシンボル名を別けるために使われるだけでなく、演算子としても使われます。
演算子として使う時、コロン <tt>:</tt> はオブジェクト・リストのコンテキスト名のコンテキスト・シンボルとコロンに続くシンボルを組み立てます。
<em>list-object</em> のオブジェクト・リストは他のパラメータを続けることができます。<br />
The colon is used not only as a syntactic separator between
namespace prefix  and the term inside but also as an operator.
When used as an operator, the colon <tt>:</tt> constructs a 
context symbol from the context name in the object list and the 
symbol following the colon. The object list in <em>list-object</em> 
can be followed by other parameters.</p>

<p>演算子<tt>:</tt> は、コンテキスト（名前空間）によって表される異なるオブジェクト・クラスの部品となるオブジェクト・<a href="http://ja.wikipedia.org/wiki/%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89_%28%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%A6%29">メソッド</a>の<em><a href="http://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0">多態性</a></em>を実装します。
newLISP では、オブジェクトは、第一要素がクラス・コンテキストのシンボル（名前）であるリストで表現されます。
クラス・コンテキストはオブジェクトに適用する関数群を実装します。コロンとそれに続くシンボルの間はスペース無しです。<br />
The <tt>:</tt> operator implements <em>polymorphism</em> of 
object methods, which are part of different object classes 
represented by contexts (namespaces). In newLISP, an object is 
represented by a list, the first element of which is the 
symbol (name) of its class context.
The class context implements the functions applicable to the object. 
No space is required between the colon and the symbol following it.</p>

<!-- example -->

<pre>
(define (Rectangle:area)
    (mul (self 3) (self 4)))

(define (Circle:area)
    (mul (pow (self 3) 2) (acos 0) 2))

(define (Rectangle:move dx dy)
    (inc (self 1) dx) 
	(inc (self 2) dy)) 

(define (Circle:move p dx dy)
    (inc (self 1) dx) (inc (self 2) dy)) 

(set 'myrect '(Rectangle 5 5 10 20)) ; x y width height
(set 'mycircle '(Circle 1 2 10)) ; x y radius

;; using the : (colon) operator to resolve to a specific context

(:area myrect)     <span class='arw'>&rarr;</span> 200
(:area mycircle)   <span class='arw'>&rarr;</span> 314.1592654

;; map class methods uses curry to enclose the colon operator and class function

(map (curry :area) (list myrect mycircle)) <span class='arw'>&rarr;</span> (200 314.1592654)

(map (curry :area) '((Rectangle 5 5 10 20) (Circle 1 2 10))) <span class='arw'>&rarr;</span> (200 314.1592654) 

;; change object attributes using a function and re-assigning
;; to the objects name

(:move myrect 2 3)       
myrect   <span class='arw'>&rarr;</span> (Rectangle 7 8 10 20)

(:move mycircle 4 5)   
mycircle <span class='arw'>&rarr;</span> (Circle 5 7 10)
</pre>

<p>FOOP メソッド内部では、メソッドの目的オブジェクトをアクセスするために関数 <a href="#self">self</a> が使えます。<br />
Inside the FOOP methods the <a href="#self">self</a> function is used to access
the target object of the method.</p>

<br/><br/>

<a name="abort"></a>
<h2><span class="function">abort</span></h2>
<h4>syntax: (abort <em>int-pid</em>)<br/>
syntax: (abort)</h4>

<p>第一形式の <tt>abort</tt> は、現在の親プロセスが与えるプロセスIDの <em>int-pid</em> で特定される子プロセスを中断します。
プロセスは <a href="#spawn">spawn</a> を使って開始されている必要があります。
<a href="#fork">fork</a> を使って開始されたプロセスには、代わりに <a href="#destroy">destroy</a> を使います。<br />
In the first form, <tt>abort</tt> aborts a specific child process of the
current parent process giving the process id in <em>int-pid</em>. The process
must have been started using <a href="#spawn">spawn</a>. For processes
started using <a href="#fork">fork</a>, use <a href="#destroy">destroy</a>
instead.</p>

<p>MS Windows では、この関数 <tt>abort</tt> を利用できません。<br />
The function <tt>abort</tt> is not available on Windows.</p>


<!-- example -->

<pre>
(abort 2245)  <span class='arw'>&rarr;</span> true
</pre>


<p>現プロセスから起動した全ての子プロセスを中断したい時は、引数無しの <tt>abort</tt> を使います：<br />
To abort all child processes spawned from the current process use <tt>abort</tt>
without any parameters:</p>


<pre>
(abort)  <span class='arw'>&rarr;</span> true ; abort all
</pre>

<p>関数 <tt>abort</tt> は、子プロセス同期とプロセス並列化用の Cilk API の部品です。
Cilk API の全貌については、関数<a href="#spawn">spawn</a> の項を見てください。<br />
The function <tt>abort</tt> is part of the Cilk API for synchronizing
child processes and process parallelization. See the reference for the
function <a href="#spawn">spawn</a> for a full discussion of the Cilk API.</p>

<br/><br/>

<a name="abs"></a>
<h2><span class="function">abs</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (abs <em>num</em>)</h4>

<p>数値 <em>num</em> の絶対値を返します。<br />
	Returns the absolute value of the number in <em>num</em>.
</p>

<!-- example -->

<pre>
(abs -3.5)  <span class='arw'>&rarr;</span> 3.5
</pre>

<br/><br/>

<a name="acos"></a>
<h2><span class="function">acos</span></h2>
<h4>syntax: (acos <em>num-radians</em>)</h4>

<p>数値 <em>num-radians</em> の逆余弦関数を計算します。<br />
	The arc-cosine function is calculated 
	from the number in <em>num-radians</em>.
</p>

<!-- example -->

<pre>
(acos 1)  <span class='arw'>&rarr;</span> 0
(cos (acos 1)) <span class='arw'>&rarr;</span> 1
</pre>

<br/><br/>

<a name="acosh"></a>
<h2><span class="function">acosh</span></h2>
<h4>syntax: (acosh <em>num-radians</em>)</h4>

<p><em>num-radians</em> の逆双曲線余弦関数を計算します。
ここで、<em>num-radians</em> は双曲線余弦関数値です。
<em>num-radians</em> が 1 より小さい時、<tt>acosh</tt> は <tt>NaN</tt> を返します。<br />
Calculates the inverse hyperbolic cosine of <em>num-radians</em>, 
the value whose hyperbolic cosine is <em>num-radians</em>. 
If <em>num-radians</em> is less than 1, 
<tt>acosh</tt> returns <tt>NaN</tt>.</p>

<!-- example -->

<pre>
(acosh 2)  <span class='arw'>&rarr;</span> 1.316957897
(cosh (acosh 2)) <span class='arw'>&rarr;</span> 2
(acosh 0.5) <span class='arw'>&rarr;</span> NaN
</pre>

<br/><br/>


<a name="add"></a>
<h2><span class="function">add</span></h2>
<h4>syntax: (add <em>num-1</em> [<em>num-2</em> ... ])</h4>

<p><em>num-1</em>, <em>num-2</em> と続く全ての数値を加算します。
<tt>add</tt> は浮動小数点数か整数の引数を取りますが、返すのは常に浮動小数点数です。 
<tt>NaN</tt> となる浮動小数点数には <tt>NaN</tt> を返します。<br />
	All of the numbers in <em>num-1</em>, <em>num-2</em>, and on 
	are summed.
	<tt>add</tt> accepts float or integer operands, 
	but it always returns a floating point number. 
	Any floating point calculation with <tt>NaN</tt> 
	also returns <tt>NaN</tt>.
</p>

<!-- example -->

<pre>
(add 2 3.25 9)   <span class='arw'>&rarr;</span> 14.25
(add 1 2 3 4 5)  <span class='arw'>&rarr;</span> 15
</pre>

<br/><br/>

<a name="address"></a>
<h2><span class="function">address</span></h2>
<h4>syntax: (address <em>int</em>)<br/>

syntax: (address <em>float</em>)<br/>
syntax: (address <em>str</em>)</h4>

<p>整数 <em>int</em>、倍精度浮動小数点数 <em>float</em>、文字列 <em>str</em> のメモリ・アドレスを返します。
この関数は関数 <a href="#import">import</a> を使って導入されるライブラリ関数への変数引渡しに使われます。<br />
	Returns the memory address of the integer in <em>int</em>, 
	the double floating point number in <em>float</em>, 
	or the string in <em>str</em>. 
	This function is used for passing parameters to library functions 
	that have been imported using the <a href="#import">import</a> function.
</p>

<!-- example -->

<pre>
(set 's "\001\002\003\004")

(get-char (+ (address s) 3))   <span class='arw'>&rarr;</span> 4

(set 'x 12345) ; x is a 64-bit long int

; on a big-endian CPU, i.e. PPC or SPARC 
(get-long (address x))         <span class='arw'>&rarr;</span> 12345
; the 32-bit int is in high 32-bit part of the long int
(get-int (+ (address x) 4))    <span class='arw'>&rarr;</span> 12345

; on a little-endian CPU, i.e. Intel i386
; the 32-bit int is in the low 32-bit part of the long int
(get-int (address x))          <span class='arw'>&rarr;</span> 12345

; on both architectures (integers are 64 bit in newLISP)
(set 'x 1234567890)
(get-long (address x))         <span class='arw'>&rarr;</span>  1234567890

</pre>

<p>
Cライブラリ関数に文字列を渡す時は、文字列のアドレスが自動的に使われますので <tt>address</tt> を使う必要はありません。
例が示すように、<tt>address</tt> は文字列アドレスのポインタ計算に使うことができます。<br />
When a string is passed to C library function the address of the string is 
used automatically, and it is not necessary to use the <tt>address</tt> 
function in that case. As the example shows, <tt>address</tt> can be used 
to do pointer arithmetic on the string's address.</p>

<p><tt>address</tt> は消えてなくなる中間式オブジェクトに対してではなく、変数シンボルで参照されるデータ・オブジェクトの実アドレスでのみ、使われるべきです。<br />
<tt>address</tt> should only be used on persistent addresses from
data objects referred to by a variable symbol, not from volatile intermediate
expression objects.</p>

<p>関数 <a href="#get-char">get-char</a>、
<a href="#get-int">get-int</a>、
<a href="#get-long">get-long</a>、
<a href="#get-float">get-float</a> も見てください。<br />
	See also the <a href="#get-char">get-char</a>, <a href="#get-int">get-int</a>, 
	<a href="#get-long">get-long</a> and <a href="#get-float">get-float</a> functions.
</p>

<br/><br/>

<a name="amb"></a>
<h2><span class="function">amb</span></h2>

<h4>syntax: (amb <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p>式 <em>exp-1</em> ... <em>n</em> 中の一つが無作為に選択され、その評価結果が返ります。<br />
	One of the expressions <em>exp-1</em> ... <em>n</em> is selected at random, 
	and the evaluation result is returned.
</p>

<!-- example -->

<pre>
(amb 'a 'b 'c 'd 'e)  <span class='arw'>&rarr;</span> one of: a, b, c, d, or e at random

(dotimes (x 10) (print (amb 3 5 7)))  <span class='arw'>&rarr;</span> 35777535755
</pre>

<p>
	無作為な数値の選択に、newLISP は内部で <a href="#rand">rand</a> と同じ関数を使います。
無作為な浮動小数点数の生成には、<a href="#random">random</a>、<a href="#randomize">randomize</a>、<a href="#normal">normal</a> を使ってください。
擬似乱数生成処理を特定の開始位置で初期化するには、<a href="#seed">seed</a> を使ってください。<br />
	Internally, newLISP uses the same function as <a href="#rand">rand</a> to pick a random number. 
	To generate random floating point numbers, 
	use <a href="#random">random</a>, 
	<a href="#randomize">randomize</a>, or <a href="#normal">normal</a>. 
	To initialize the pseudo random number generating process 
	at a specific starting point,
	use the <a href="#seed">seed</a> function.
</p>

<br/><br/>

<a name="and"></a>
<h2><span class="function">and</span></h2>
<h4>syntax: (and <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p>式 <em>exp-1</em>, <em>exp-2</em>, <em>等</em> が順に評価され、最後の式の結果を返します。
もし、式が <tt>nil</tt> か空リスト <tt>()</tt> になれば、評価を終了し、<tt>nil</tt> か空リスト <tt>()</tt> を返します。
<br />
	The expressions <em>exp-1</em>, <em>exp-2</em>, <em>etc.</em> are evaluated in order,
	returning the result of the last expression.
	If any of the expressions yield <tt>nil</tt> or the empty list <tt>()</tt>, 
	evaluation is terminated and <tt>nil</tt> or the empty list <tt>()</tt> is returned.
</p>

<!-- example -->

<pre>
(set 'x 10)                       <span class='arw'>&rarr;</span> 10
(and (&lt; x 100) (&gt; x 2))           <span class='arw'>&rarr;</span> true
(and (&lt; x 100) (&gt; x 2) "passed")  <span class='arw'>&rarr;</span> "passed"
(and '())                         <span class='arw'>&rarr;</span> ()
(and true)                        <span class='arw'>&rarr;</span> true
(and)                             <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="append"></a>
<h2><span class="function">append</span></h2>
<h4>syntax: (append <em>list-1</em> [<em>list-2</em> ... ])<br/>
syntax: (append <em>array-1</em> [<em>array-2</em> ... ])<br/>
syntax: (append <em>str-1</em> [<em>str-2</em> ... ])</h4>

<p>第一形式の <tt>append</tt> はリストに作用し、<em>list-1</em> から <em>list-n</em> までを一つの新しいリストに結合します。
元のリスト群は変わりません。（訳注：つまり、副作用がない）<br />
In the first form, <tt>append</tt> works with lists, 
appending <em>list-1</em> through <em>list-n</em> to form a new list. 
The original lists are left unchanged.</p>

<!-- example -->

<pre>
(append '(1 2 3) '(4 5 6) '(a b))  <span class='arw'>&rarr;</span> (1 2 3 4 5 6 a b)

(set 'aList '("hello" "world"))    <span class='arw'>&rarr;</span> ("hello" "world")

(append aList '("here" "I am"))    <span class='arw'>&rarr;</span> ("hello" "world" "here" "I am")
</pre>


<p>二つ目の形式では、<tt>append</tt> はアレイに対して作用します：<br />
In the second form <tt>append</tt> works on arrays:</p>

<!-- example -->

<pre>
(set 'A (array 3 2 (sequence 1 6)))
<span class='arw'>&rarr;</span> ((1 2) (3 4) (5 6))
(set 'B (array 2 2 (sequence 7 10)))
<span class='arw'>&rarr;</span> ((7 8) (9 10))

(append A B)
<span class='arw'>&rarr;</span> ((1 2) (3 4) (5 6) (7 8) (9 10))

(append B B B)
<span class='arw'>&rarr;</span> ((7 8) (9 10) (7 8) (9 10) (7 8) (9 10))

</pre>

<p>三番目の形式では、<tt>append</tt> は文字列に作用します。
<em>str-n</em> の文字列が一つの新しい文字列に結合されて返ります。<br />
In the third form, <tt>append</tt> works on strings.  The strings in 
<em>str-n</em> are concatenated into a new string and returned.</p>

<!-- example -->

<pre>
(set 'more " how are you")       <span class='arw'>&rarr;</span> " how are you"

(append "Hello " "world," more)  <span class='arw'>&rarr;</span> "Hello world, how are you"
</pre>

<p><tt>append</tt> はゼロを含むバイナリ文字列を操作するのにも適しています。
関数 <a href="#string">string</a> なら、ゼロのバイトで文字列を切ってしまうからです。<br />
<tt>append</tt> is also suitable for processing binary strings containing zeroes.
The <a href="#string">string</a> function would cut off strings at zero bytes.</p>

<p>結合する文字や文字列を指定するには、関数<a href="#join"> join</a> が使えます。
引数の文字列への型変換と結合を一回で済ますには、関数 <a href="#string">string</a> を使ってください。<br />
Linkage characters or strings can be specified using the 
<a href="#join">join</a> function. Use the <a href="#string">string</a> 
function to convert arguments to strings and append in one step.</p>

<p>変更を目的とする既存のリストや文字列の結合には（訳注：つまり、副作用が必要な時）、関数 <a href="#extend">extend</a> や <a href="#push">push</a> を使ってください。<br />
Use the functions <a href="#extend">extend</a> and <a href="#push">push</a>
to append to an existing list or string modifying the target.</p>

<br/><br/>

<a name="append-file"></a>
<h2><span class="function">append-file</span></h2>
<h4>syntax: (append-file <em>str-filename</em> <em>str-buffer</em>)</h4>

<p>
<a href="#write-file">write-file</a> のように動作しますが、<em>str-filename</em> のファイルが存在する時は、<em>str-buffer</em> の内容を追加します。
ファイルが存在しない時には、それを作ります（この場合、<tt>append-file</tt> は <a href="#write-file">write-file</a> と同じ動作)。
この関数の戻り値は、書き込んだバイト数です。<br />
Works similarly to <a href="#write-file">write-file</a>, but the content 
in <em>str-buffer</em> is appended if the file in <em>str-filename</em> exists. 
If the file does not exist, it is created (in this case, <tt>append-file</tt> 
works identically to <a href="#write-file">write-file</a>). This function 
returns the number of bytes written.</p>

<p>失敗した時、関数は <tt>nil</tt> を返します。ファイルで使っている時のエラー情報には、<a href="#sys-error">sys-error</a> も使えます。<br />
On failure the function returns <tt>nil</tt>. For error information, 
use either <a href="#sys-error">sys-error</a> when used on files.</p>

<!-- example -->

<pre>
(write-file "myfile.txt" "ABC") 
(append-file "myfile.txt" "DEF")

(read-file "myfile.txt")  <span class='arw'>&rarr;</span> "ABCDEF"
</pre>


<p><tt>append-file</tt> は、<em>str-file-name</em> に <tt>http://</tt> や <tt>file://</tt> の URL を取ることができます。
接頭語が、<tt>http://</tt> の場合、<tt>append-file</tt> は、ちょうど <tt>"Pragma: append\r\n"</tt> のヘッダー・オプションを持つ <a href="#put-url">put-url</a> のように動作し、追加のパラメータにも同じものが使えます。
オプションの <tt>"Pragma: append\r\n"</tt> は自動的に与えられます。<br />
<tt>append-file</tt> can take a <tt>http://</tt> or <tt>file://</tt> URL
in <em>str-file-name</em>. In case of the <tt>http://</tt>  prefix ,
<tt>append-file</tt> works exactly like <a href="#put-url">put-url</a> with 
<tt>"Pragma: append\r\n"</tt> in the header option and can take the same 
additional parameters. The <tt>"Pragma: append\r\n"</tt> option is supplied 
automatically.</p>

<!-- example -->

<pre>
(append-file "http://asite.com/message.txt" "More message text.")
</pre>

<p>この <tt>message.txt</tt> ファイルは、リモート位置の <tt>http://asite.com</tt> で <em>str-buffer</em> の内容を追加されます。
もし、ファイルが存在しないなら、作成されます。
このモードにおいて、<tt>append-file</tt> はリモート newLISP サーバー・ノードにファイルを転送するためにも使えます。<br />
The file <tt>message.txt</tt> is appended at a remote
location <tt>http://asite.com</tt> with the contents of 
<em>str-buffer</em>. If the file does not yet exist, it
will be created. In this mode, <tt>append-file</tt> can also be used
to transfer files to remote newLISP server nodes.
</p>

<p><a href="#read-file">read-file</a> と <a href="#write-file">write-file</a> も見てください。<br />
See also <a href="#read-file">read-file</a> and
<a href="#write-file">write-file</a>.
</p>

<br/><br/>

<a name="apply"></a>
<h2><span class="function">apply</span></h2>
<h4>syntax: (apply <em>func</em> <em>list</em> [<em>int-reduce</em>])<br/>
syntax: (apply <em>func</em>)</h4>

<p>引数の <em>list</em> に <em>func</em>（組込関数、ユーザ定義関数、ラムダ式）の内容を適用します（訳注：引数の <em>list</em> の括弧を外して、<em>func</em> に与えるのと同等）。
関数や演算子が引数に対して標準的な評価を行ないます。<br />
Applies the contents of <em>func</em> (primitive, user-defined function, or 
lambda expression)  to the arguments in <em>list</em>. Only functions and
operators with standard evaluation of their arguments can be applied.</p>

<p>第二構文の <tt>apply</tt> は引数を取らない関数に使います。<br />
In the second syntax <tt>apply</tt> is used on functions without any 
arguments.</p>

<!-- example -->

<pre>
(apply + '(1 2 3 4))                   <span class='arw'>&rarr;</span> 10
(set 'aList '(3 4 5))                  <span class='arw'>&rarr;</span> (3 4 5)
(apply * aList)                        <span class='arw'>&rarr;</span> 60
(apply sqrt '(25))                     <span class='arw'>&rarr;</span> 5
(apply (lambda (x y) (* x y)) '(3 4))  <span class='arw'>&rarr;</span> 12
</pre>



<p><em>int-reduce</em> パラメータはオプションで、関数 <em>func</em> の受け取る要素数が入ります。
この場合、<em>func</em> は前の結果を第一引数として取り、受け取る残りの要素を <em>list</em> から（左から順に）取ることを繰り返します。
例えば、<tt>op</tt> が二つの引数を取るなら、こうなります：<br />
	The <em>int-reduce</em> parameter can optionally contain 
	the number of arguments taken by the function in <em>func</em>. 
	In this case, 
	<em>func</em> will be repeatedly applied using the previous result 
	as the first argument and taking the other arguments required 
	successively from <em>list</em> 
	(in left-associative order). 
	For example, if <tt>op</tt> takes two arguments, then:
</p>


<pre>
(apply op '(1 2 3 4 5) 2)

;; is equivalent to

(op (op (op (op 1 2) 3) 4) 5)

;; find the greatest common divisor 
;; of two or more integers 
;; note that newLISP already has a gcd function

(define (gcd_ a b)
    (let (r (% b a))
        (if (= r 0) a (gcd_ r a))))

(define-macro (my-gcd)
    (apply gcd_ (map eval (args)) 2))

(my-gcd 12 18 6)    <span class='arw'>&rarr;</span> 6
(my-gcd 12 18 6 4)  <span class='arw'>&rarr;</span> 2
</pre>

<p>最後の例は、<tt>apply</tt> の<em>畳み込み（縮約）</em> を使って、引数二つの関数が一度に複数の引数を取れる様子を示しています。
記しておきますが、これは組込 <a href="#gcd">gcd</a> でも可能です。（訳注：組込<a href="#gcd">gcd</a> は二つ以上の整数値の最大公約数を返します。）<br />
The last example shows how <tt>apply</tt>'s <em>reduce</em> functionality 
can be used to convert a two-argument function into one that takes multiple arguments. Note, that a built-in <a href="#gcd">gcd
</a> is available.</p>

<p><tt>apply</tt> は、<a href="#dotimes">dotimes</a> や <a href="#case">case</a> のようにいくつかの引数だけを評価するような<em>特殊形式</em> を持つものではなく、引数を全て評価する関数や演算子に対して使うべきです。
そうしないと、その関数は失敗します。<br />
<tt>apply</tt> should only be used on functions and operators that evaluate all 
of their arguments, not on <em>special forms</em> like <a href="#dotimes">dotimes</a> 
or <a href="#case">case</a>, which evaluate only some of their arguments. 
Doing so will cause the function to fail.
</p>
<blockquote>
（訳例：<em>Common Lisp</em> では <em>or</em> や <em>and</em> を <em>apply</em> できませんが、<em>newLISP</em> では可能です。
<pre>
> (apply or '(nil nil 1))
1
> (apply and '(1 2 3))
3
> 
</pre>）</blockquote>

<br/><br/>

<a name="args"></a>
<h2><span class="function">args</span></h2>
<h4>syntax: (args)<br/>
syntax: (args <em>int-idx-1</em> [<em>int-idx-2</em> ... ])</h4>

<p>
現在評価中の <a href="#define">define</a> のラムダ式や <a href="#define-macro">define-macro</a> のラムダ・マクロ式に渡された引数の内、束縛されていない引数全てをリストとして扱えます。
つまり、現関数または現マクロで、ローカル変数に束縛された後に残った引数のみが利用できるわけです。
関数 <tt>args</tt> は、パラメータ数が可変の関数やマクロの定義に役立ちます。<br />
Accesses a list of all unbound arguments passed to the currently evaluating 
<a href="#define">define</a>, <a href="#define-macro">define-macro</a> 
lambda, or lambda-macro expression. Only the arguments of the current function 
or macro that remain after local variable binding has occurred are available. 
The <tt>args</tt> function is useful for defining functions or macros 
with a variable number of parameters.</p>

<p><tt>args</tt> は、変数捕捉の危険を避ける安全なマクロを定義するのにも使えます。
<a href="#define-macro">define-macro</a> を見てください。<br />
<tt>args</tt> can be used to define hygienic macros that avoid the danger of 
variable capture. See <a href="#define-macro">define-macro</a>.
</p>

<!-- example -->

<pre>
(define-macro (print-line)
    (dolist (x (args))
        (print x "\n")))
                        
(print-line "hello" "World")
</pre>

<p>この例は各引数の後に改行を出力します。
このマクロは組込関数 <a href="#println">println</a> の効果を真似ています。<br />
	This example prints a line-feed after each argument. 
	The macro mimics the effect of the built-in function 
	<a href="#println">println</a>.
</p>

<p>第二構文では、<tt>args</tt> は一つ以上のインデックス（<em>int-idx-n</em>）を取ることができます。<br />
	In the second syntax, 
	<tt>args</tt> can take one or more indices (<em>int-idx-n</em>).
</p>

<!-- example -->

<pre>
(define-macro (foo)
    (print (args 2) (args 1) (args 0)))

(foo x y z) 
<b>zyx</b> 

(define (bar)
	(args 0 2 -1))

(bar '(1 2 (3 4)))  <span class='arw'>&rarr;</span> 4
</pre>

<p>関数 <tt>foo</tt> は引数の順序を逆にして出力します。
関数 <tt>bar</tt> では、入れ子リストにアクセスするために複数のインデックスを使った <tt>args</tt> を示しています。<br />
	The function <tt>foo</tt> 
	prints out the arguments in reverse order. 
	The <tt>bar</tt> function 
	shows <tt>args</tt> being used 
	with multiple indices
	to access nested lists.
</p>

<p><tt>(args)</tt> には、現関数や現マクロの局所変数として束縛されていない引数のみが入ることを忘れないでください：<br />
	Remember that <tt>(args)</tt> only contains the arguments 
	not already bound to local variables 
	of the current function or macro:
</p>

<!-- example -->

<pre>
(define (foo a b) (args))
  
(foo 1 2)        <span class='arw'>&rarr;</span> ()
                 
(foo 1 2 3 4 5)  <span class='arw'>&rarr;</span> (3 4 5)
</pre>

<p>最初の例では、引数が二つの局所変数 <tt>a</tt> と <tt>b</tt> に束縛されるので、空リストが返ります。
二番目の例は、（最初の例と同様）最初の二つの引数が束縛され、三つの引数が残り、<tt>args</tt> で返される様子を示します。<br />
	In the first example, 
	an empty list is returned because 
	the arguments are bound to the 
	two local symbols, <tt>a</tt> and <tt>b</tt>.
	The second example demonstrates that, 
	after the first two arguments are bound 
	(as in the first example), three arguments remain 
	and are then returned by <tt>args</tt>.
</p>

<p><tt>(args)</tt> は組込やユーザ定義関数の呼び出しに引数として渡すことができますが、マクロの呼び出しには引数として渡すべきではありません、
その場合、<tt>(args)</tt> は評価されず、結果として、新たなマクロ環境で誤った内容を持つことになります。<br />
	<tt>(args)</tt> can be used as an argument 
	to a built-in or user-defined function call, 
	but it should not be used as an argument to another macro, 
	in which case <tt>(args)</tt> would not be evaluated 
	and would therefore have the wrong
	contents in the new macro environment.
</p>

<br/><br/>

<a name="array"></a>
<h2><span class="function">array</span></h2>

<h4>syntax: (array <em>int-n1</em> [<em>int-n2</em> ... ] [<em>list-init</em>])</h4>

<p><em>int-n1</em> 個の要素のアレイを作成し、オプションで <em>list-init</em> の内容に初期化できます。
16次元までの多次元アレイを指定できます。（訳注：初期化できるのが 16 次元まで）<br />
Creates an array with <em>int-n1</em> elements, 
optionally initializing it with the contents of <em>list-init</em>. 
Up to sixteen dimensions may be specified for multidimensional arrays.</p>

<p>newLISP の内部では、一次元アレイの要素群を使って、多次元アレイを作ります。
大規模リストにおけるランダム要素指定があまりに遅くなる時はいつでも、newLISP のアレイを使うべきです。
全てのリスト関数がアレイに使えるわけではありません。
詳細は、<a href="#arrays">リスト</a> の章を見てください。<br />
Internally, newLISP builds multidimensional arrays by using arrays as the 
elements of an array. newLISP arrays should be used whenever random indexing 
into a large list becomes too slow. Not all list functions may be used on arrays. 
For a more detailed discussion, see the chapter on <a href="#arrays">arrays</a>.</p>

<!-- example -->

<pre>
(array 5)                  <span class='arw'>&rarr;</span> (nil nil nil nil nil)

(array 5 (sequence 1  5))  <span class='arw'>&rarr;</span> (1 2 3 4 5)

(array 10 '(1 2))          <span class='arw'>&rarr;</span> (1 2 1 2 1 2 1 2 1 2)
</pre>

<p>いかなる型のオブジェクトでも、アレイを初期化できます。
もし、初期化用リストの要素がアレイの要素より少なければ、アレイの全要素が初期化されるまで、リストが繰り返し使われます。<br />
Arrays can be initialized with objects of any type. If fewer initializers than 
elements are provided, the list is repeated until all elements of the array are 
initialized.</p>


<pre>

(set 'myarray (array 3 4 (sequence 1 12)))
<span class='arw'>&rarr;</span> ((1 2 3 4) (5 6 7 8) (9 10 11 12))
</pre>

<p>アレイの操作とアクセスには、リストを操作する関数とほとんど同じものが使われます：<br />
Arrays are modified and accessed using most of the same functions used for 
modifying lists:</p>


<pre>
(setf (myarray 2 3) 99) <span class='arw'>&rarr;</span> 99)
myarray <span class='arw'>&rarr;</span> ((1 2 3 4) (5 6 7 8) (9 10 11 99))

(setf (myarray 1 1) "hello")  <span class='arw'>&rarr;</span> "hello"

myarray <span class='arw'>&rarr;</span> ((1 2 3 4) (5 "hello" 7 8) (9 10 11 99))

(setf (myarray 1) '(a b c d)) <span class='arw'>&rarr;</span> (a b c d)
myarray <span class='arw'>&rarr;</span> ((1 2 3 4) (a b c d) (9 10 11 99))

(nth 1 myarray)     <span class='arw'>&rarr;</span> (a b c d)  ; access a whole row
                    
;; use implicit indexing and slicing on arrays
                    
(myarray 1)     <span class='arw'>&rarr;</span> (a b c d)
                    
(myarray 0 -1)  <span class='arw'>&rarr;</span> 4

(2 myarray)     <span class='arw'>&rarr;</span> ((9 10 11 99)) 

(-3 2 myarray)  <span class='arw'>&rarr;</span> ((1 2 3 4) (a b c d)) 
</pre>

<p>行全体を置き換える際は、アレイを使ってするよう注意すべきです。（訳注；上記例ではリストを使っているので、置き換え後の myarray が (アレイ リスト アレイ) になっている）<br />
Care must be taken to use an array when replacing a whole row.
</p>

<p>アレイからリストへの変換には、<a href="#array-list">array-list</a> が使えます：<br />
<a href="#array-list">array-list</a> can be used to convert arrays back into lists:
</p>


<pre>
(array-list myarray)  <span class='arw'>&rarr;</span> ((1 2 3 4) (a b c d) (1 2 3 99))
</pre>

<p>リストをアレイに戻すには、リストに <a href="#flat">flat</a> を適用します：<br />
To convert a list back into an array, apply <a href="#flat">flat</a> to the list:
</p>


<pre>
(set 'aList '((1 2) (3 4)))             <span class='arw'>&rarr;</span> ((1 2) (3 4))

(set 'aArray (array 2 2 (flat aList)))  <span class='arw'>&rarr;</span> ((1 2) (3 4))
</pre>

<p>式がアレイかどうかをチェックするには、関数 <a href="#arrayp">array?</a> が使えます：<br />
The <a href="#arrayp">array?</a> function 
can be used to check if an expression is an array:
</p>


<pre>
(array? myarray)               <span class='arw'>&rarr;</span> true
                               
(array? (array-list myarray))  <span class='arw'>&rarr;</span> nil
</pre>

<p>
関数 <a href="#source">source</a> や <a href="#save">save</a> を使ってアレイを<ruby><rb><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">直列化</a></rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>すると、アレイを生成するために必要な <tt>array</tt> 宣言文が生成されたコードに含まれます。
この方法により、<a href="#save">save</a> を使って保存する時や <a href="#source">source</a> を使ってソース文字列を生成する時、アレイを含む変数が正しく<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>されます。<br />
When serializing arrays using the  function <a href="#source">source</a> 
or <a href="#save">save</a>, the generated code includes the <tt>array</tt> 
statement necessary to create them. This way, variables containing arrays are 
correctly serialized when saving with <a href="#save">save</a> or creating 
source strings using <a href="#source">source</a>.</p>

<pre>
(set 'myarray (array 3 4 (sequence 1 12)))

(save "array.lsp" 'myarray)

;; contents of file arraylsp ;;

(set 'myarray (array 3 4 (flat '(
  (1 2 3 4) 
  (5 6 7 8) 
  (9 10 11 12)))))
</pre>

<br/><br/>

<a name="array-list"></a>
<h2><span class="function">array-list</span></h2>
<h4>syntax: (array-list <em>array</em>)</h4>

<P><em>array</em> から変換されたリストを返し、オリジナルのアレイは変わずに、そのまま残ります：<br />
	Returns a list conversion from <em>array</em>, 
	leaving the original array unchanged:
</p>

<!-- example -->

<pre>
(set 'myarray (array 3 4 (sequence 1 12)))
<span class='arw'>&rarr;</span> ((1 2 3 4) (5 6 7 8) (9 10 11 12))

(set 'mylist (array-list myarray))
<span class='arw'>&rarr;</span> ((1 2 3 4) (5 6 7 8) (9 10 11 12))

(list (array? myarray) (list? mylist))
<span class='arw'>&rarr;</span> (true true)
</pre>

<br/><br/>

<a name="arrayp"></a>
<h2><span class="function">array?</span></h2>
<h4>syntax: (array? <em>exp</em>)</h4>

<p>
	<em>exp</em> がアレイかどうかをチェックします：<br />
	Checks if <em>exp</em> is an array:
</p>

<!-- example -->

<pre>
(set 'M (array 3 4 (sequence 1 4)))   
<span class='arw'>&rarr;</span> ((1 2 3 4) (1 2 3 4) (1 2 3 4)))


(array? M)               <span class='arw'>&rarr;</span> true

(array? (array-list M))  <span class='arw'>&rarr;</span> nil
</pre>

<br/><br/>

<a name="asin"></a>
<h2><span class="function">asin</span></h2>
<h4>syntax: (asin <em>num-radians</em>)</h4>

<p><em>num-radians</em> の数値の逆正弦関数を計算し、その結果を返します。<br />
	Calculates the arcsine function from the number in <em>num-radians</em> 
	and returns the result.
</p>

<!-- example -->

<pre>
(asin 1)  <span class='arw'>&rarr;</span> 1.570796327
(sin (asin 1)) <span class='arw'>&rarr;</span> 1
</pre>

<br/><br/>

<a name="asinh"></a>
<h2><span class="function">asinh</span></h2>
<h4>syntax: (asinh <em>num-radians</em>)</h4>

<p><em>num-radians</em> の逆双曲線正弦関数を計算します。
ここで、<em>num-radians</em> は双曲線正弦関数値です。<br />
Calculates the inverse hyperbolic sine of <em>num-radians</em>, 
the value whose hyperbolic sine is <em>num-radians</em>.</p>

<!-- example -->

<pre>
(asinh 2)         <span class='arw'>&rarr;</span> 1.443635475
(sinh (asinh 2))  <span class='arw'>&rarr;</span> 2
</pre>

<br/><br/>

<a name="assoc"></a>
<h2><span class="function">assoc</span></h2>
<h4>syntax: (assoc <em>exp-key</em> <em>list-alist</em>)<br/>
syntax: (assoc <em>list-exp-key</em> <em>list-alist</em>)</h4>


<p>
第一構文では、<em>exp-key</em> の値が最初にキー値と一致する要素を含む <em>member-list</em> を、<em>list-alist</em> から検索するのに使われます。
見つかれば、その <em>member-list</em> が返り、見つからなければ、結果は <tt>nil</tt> になります。<br />
In the first syntax the value of <em>exp-key</em> is used 
to search <em>list-alist</em> for a <em>member-list</em> 
whose first element matches the key value. 
If found, the <em>member-list</em> is returned;
otherwise, the result will be <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(assoc 1 '((3 4) (1 2)))  <span class='arw'>&rarr;</span> (1 2)

(set 'data '((apples 123) (bananas 123 45) (pears 7)))

(assoc 'bananas data)  <span class='arw'>&rarr;</span> (bananas 123 45)
(assoc 'oranges data)  <span class='arw'>&rarr;</span> nil
</pre>

<p><tt>assoc</tt> は <a href="#setf">setf</a> と一緒に用いて、連想を変更できます。<br />
Together with <a href="#setf">setf</a> <tt>assoc</tt> can be used
to change an association.</p>

<pre>
(setf (assoc 'pears data) '(pears 8))

data  <span class='arw'>&rarr;</span> ((apples 123) (bananas 123 45) (pears 8))
</pre>

<p>第二構文では、入れ子になっている高次の連想リスト検索用に、一個以上のキー式を指定できます：<br />
In the second syntax more then one key expressions can be specified
to search in nested, multilevel association lists:</p>

<!-- example -->

<pre>
(set 'persons '(
    (id001 (name "Anne") (address (country "USA") (city "New York")))
    (id002 (name "Jean") (address (country "France") (city "Paris")))
))

(assoc '(id001 address) persons) <span class='arw'>&rarr;</span> (address (country "USA") (city "New York"))
(assoc '(id001 address city) persons) <span class='arw'>&rarr;</span> (city "New York")
</pre>


<p><em>list-aList</em> 中のリストには、<em>デフォルト・ファンクタ</em> として解釈されるコンテキストにすることができます。
この方法では、大規模リストが参照で渡され、高速にアクセスでき、メモリ使用量も少なくて済みます：<br />
The list in <em>list-aList</em> can be a context which will be interpreted
as its <em>default functor</em>. This way very big lists can be passed by reference
for speedier access and less memory usage:</p>


<pre>
(set 'persons:persons '(
    (id001 (name "Anne") (address (country "USA") (city "New York")))
    (id002 (name "Jean") (address (country "France") (city "Paris")))
))

(define (get-city db id)
    (last (assoc (list id 'address 'city) db ))
)

(get-city persons 'id001) <span class='arw'>&rarr;</span> "New York"
</pre>


<p>
連想リストの置換には、関数 <tt>assoc</tt> を <a href="#setf">setf</a> と共に使います。
関数 <a href="#lookup">lookup</a> を使えば、連想検索と要素取り出しを一度にできます。<br />
For making replacements in association lists, use the 
<a href="#setf">setf</a> together with the <tt>assoc</tt> function.
The <a href="#lookup">lookup</a> function is used to perform association lookup 
and element extraction in one step.</p>

<br/><br/>

<a name="atan"></a>
<h2><span class="function">atan</span></h2>
<h4>syntax: (atan <em>num-radians</em>)</h4>

<p><em>num-radians</em> の逆正接を計算し、返します。<br />
	The arctangent of <em>num-radians</em> 
	is calculated and returned.
</p>

<!-- example -->

<pre>
(atan 1)        <span class='arw'>&rarr;</span> 0.7853981634
(tan (atan 1))  <span class='arw'>&rarr;</span> 1
</pre>

<br/><br/>

<a name="atan2"></a>
<h2><span class="function">atan2</span></h2>
<h4>syntax: (atan2 <em>num-Y-radians</em> <em>num-X-radians</em>)</h4>

<p>関数<tt>atan2</tt> は Y / X の逆正接をラジアンで計算します。
両引数の符号を戻り値の象限の決定に使います。
<tt>atan2</tt> は<a href="http://ja.wikipedia.org/wiki/%E7%9B%B4%E4%BA%A4%E5%BA%A7%E6%A8%99%E7%B3%BB">デカルト座標</a>を<a href="http://ja.wikipedia.org/wiki/%E6%A5%B5%E5%BA%A7%E6%A8%99%E7%B3%BB">極座標</a>に変換するのに役立ます。<br />
	The <tt>atan2</tt> function computes 
	the principal value of 
	the arctangent of Y / X in radians. 
	It uses the signs of both arguments 
	to determine the quadrant of
	the return value. 
	<tt>atan2</tt> is useful for converting 
	Cartesian coordinates 
	into polar coordinates.
</p>

<!-- example -->

<pre>
(atan2 1 1)                       <span class='arw'>&rarr;</span> 0.7853981634
(div (acos 0) (atan2 1 1))        <span class='arw'>&rarr;</span> 2
(atan2 0 -1)                      <span class='arw'>&rarr;</span> 3.141592654
(= (atan2 1 2) (atan (div 1 2)))  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="atanh"></a>
<h2><span class="function">atanh</span></h2>
<h4>syntax: (atanh <em>num-radians</em>)</h4>

<p><em>num-radians</em> の逆双曲線正接を計算します。
ここで、<em>num-radians</em> は双曲線正接値です。
もし、<em>num-radians</em> の絶対値が 1 より大きいなら、<tt>atanh</tt> は <tt>NaN</tt> を返します。
1 ならば、<tt>atanh</tt> は無限大を返します。<br />
Calculates the inverse hyperbolic tangent of <em>num-radians</em>, 
the value whose hyperbolic tangent is <em>num-radians</em>. If the 
absolute value of <em>num-radians</em> is greater than 1, 
<tt>atanh</tt> returns <tt>NaN</tt>; if it is equal to 1, <tt>atanh</tt> returns infinity.</p>

<!-- example -->

<pre>
(atanh 0.5) <span class='arw'>&rarr;</span> 0.5493061443
(tanh (atanh 0.5)) <span class='arw'>&rarr;</span> 0.5
(atanh 1.1) <span class='arw'>&rarr;</span> NaN
(atanh 1) <span class='arw'>&rarr;</span> inf
</pre>

<br/><br/>

<a name="atomp"></a>
<h2><span class="function">atom?</span></h2>
<h4>syntax: (atom? <em>exp</em>)</h4>

<p><em>exp</em> の値がアトムなら、<tt>true</tt> を返し、それ以外は <tt>nil</tt> を返します。
式の評価結果が nil、true、整数、浮動小数点数、文字列、シンボル、組込ならば、その式はアトムです。
リスト、ラムダ式、ラムダ・マクロ式、クォート式はアトムではありません。<br />
	Returns <tt>true</tt> if the value of <em>exp</em> is an atom, 
	otherwise <tt>nil</tt>.	
	An expression is an atom if it evaluates to nil, 
	true, an integer, a float, a string, a symbol or a primitive. 
	Lists, lambda or lambda-macro expressions, 
	and quoted expressions are not atoms.
</p>

<!-- example -->

<pre>
(atom? '(1 2 3))      <span class='arw'>&rarr;</span> nil
(and (atom? 123)
     (atom? "hello")
     (atom? 'foo))    <span class='arw'>&rarr;</span> true
(atom? ''foo)         <span class='arw'>&rarr;</span> nil
</pre>

<br/><br/>

<a name="base64-dec"></a>
<h2><span class="function">base64-dec</span></h2>
<h4>syntax: (base64-dec <em>str</em>)</h4>

<p><em>str</em> の <a href="http://ja.wikipedia.org/wiki/Base64">BASE64</a> 文字列をデコードします。
<em>str</em> が有効な BASE64 文字列かどうかは、検査されないことに注意してください。
デコードされた文字列が返ります。<br />
	The BASE64 string in <em>str</em> is decoded. 
	Note that <em>str</em> is not verified
	to be a valid BASE64 string. 
	The decoded string is returned.
</p>

<!-- example -->

<pre>
(base64-dec "SGVsbG8gV29ybGQ=")  <span class='arw'>&rarr;</span> "Hello World"
</pre>


<p>エンコードするには、関数 <a href="#base64-enc">base64-enc</a> を使ってください。<br />
	For encoding,
	use the <a href="#base64-enc">base64-enc</a> function.
</p>
	
<p>newLISP の BASE64 処理は、Unix <a href="http://curl.haxx.se/">curl</a> ユーティリティで見つかるルーチンに由来していて、RFC 4648 標準に準拠しています。<br />
	newLISP's BASE64 handling is derived from 
	routines found in the Unix <a href="http://curl.haxx.se/">curl</a>
	utility and conforms to the RFC 4648 standard.
</p>

<br/><br/>

<a name="base64-enc"></a>
<h2><span class="function">base64-enc</span></h2>
<h4>syntax: (base64-enc <em>str</em> [<em>bool-flag</em>])</h4>

<p>
<em>str</em> の文字列が <a href="http://ja.wikipedia.org/wiki/Base64">BASE64</a> フォーマットにエンコードされます。
このフォーマットは、3 * 8 = 24 の入力ビット列を 4 * 8 = 32 出力ビット列にエンコードします。
出力ビット列の各８ビットは入力文字列からの６ビットに相当します。
この６ビットは、文字 A&ndash;Z と a&ndash;z 数字 0&ndash;9、そして、キャラクタ +（プラス記号）と /（スラッシュ）からなる 64 語にエンコードされます。 
=（等号）は、置き換えで使われなかった3,4バイト目を埋めるために使われます。
この関数は、バイナリ・データを出力可能なキャラクタに変換する助けとなります。<br />
The string in <em>str</em> is encoded into BASE64 format. 
This format encodes groups of 3 * 8 = 24 input bits 
into 4 * 8 = 32 output bits, 
where each 8-bit output group 
represents 6 bits from the input string. 
The 6 bits are encoded into 64 possibilities
from the letters A&ndash;Z and a&ndash;z; 
the numbers 0&ndash;9; 
and the characters + (plus sign) and / (slash). 
The = (equals sign) is used as a filler 
in unused 3- to 4-byte translations. 
This function is helpful for converting binary content 
into printable characters.
</p>

<p>オプションの引数 <em>bool-flag</em> が無い時、空文字列 <tt>""</tt> は <tt>"===="</tt> にコード化されます。
<em>bool-flag</em> が <tt>true</tt> に評価されると、空文字列 <tt>""</tt> は <tt>""</tt> になります。
どちらの変換物も <a href="base64-dec">base64-dec</a> でデコードすると、<tt>""</tt> になります。<br />
Without the optional <em>bool-flag</em> parameter the empty string <tt>""</tt> is
encoded into <tt>"===="</tt>. If <em>bool-flag</em>  evaluates to <tt>true</tt>, 
the empty string <tt>""</tt> is translated into <tt>""</tt>. Both translations
result in <tt>""</tt> when using <a href="base64-dec">base64-dec</a>.</p>

<p>エンコード文字が返ります。<br />
The encoded string is returned.
</p>

<p>
BASE64 エンコードは、バイナリ･データをエンコードしてテキスト･ベースのメッセージに含める多くのインターネット･プロトコルで使われています（例えば、XML-RPC）。<br />
BASE64 encoding is used with many Internet protocols 
to encode binary data for inclusion in text-based messages
(e.g., XML-RPC).
</p>

<!-- example -->

<pre>
(base64-enc "Hello World")  <span class='arw'>&rarr;</span> "SGVsbG8gV29ybGQ="

(base64-enc "")             <span class='arw'>&rarr;</span> "===="
(base64-enc "" true)        <span class='arw'>&rarr;</span> ""
</pre>


<p><tt>base64-enc</tt> は、長いBASE64シーケンス中に改行（CR/LPペア）を挿入できないことに注意してください。
その代わりに、純粋な BASE64 エンコード文字列を返します。<br />
	Note that <tt>base64-enc</tt> does not insert 
	carriage-return/line-feed pairs in longer BASE64 sequences 
	but instead returns a pure BASE64-encoded string.
</p>


<p>デコードするには、関数 <a href="#base64-dec">base64-dec</a> を使います。<br />
	For decoding, 
	use the <a href="#base64-dec">base64-dec</a> function.
</p>
	
<p>newLISP の BASE64 処理は、Unix <a href="http://curl.haxx.se/">curl</a> ユーティリティで見つかるルーチンに由来していて、RFC 4648 標準に準拠しています。<br />
	newLISP's BASE64 handling is derived from routines 
	found in the Unix <a href="http://curl.haxx.se/">curl</a> 
	utility and conforms to the RFC 4648 standard.
</p>

<br/><br/>

<a name="bayes-query"></a>
<h2><span class="function">bayes-query</span></h2>
<h4>syntax: (bayes-query <em>list-L</em> <em>context-D</em> [<em>bool-chain</em> [<em>bool-probs</em>]])</h4>

<p>（訳注:訳者は、この手の事情に疎いので、
<a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%82%A4%E3%82%BA%E3%81%AE%E5%AE%9A%E7%90%86">ベイズの定理</a>、
<a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%82%A4%E3%82%BA%E6%8E%A8%E5%AE%9A">ベイズ推定</a>、
<a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%82%A4%E3%82%BA%E7%A2%BA%E7%8E%87">ベイズ確率</a>、
<a href="http://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%AB%E3%82%B3%E3%83%95%E9%80%A3%E9%8E%96">マルコフ連鎖</a>等をご一読の上、原文をお読み頂くことを強くお薦めします。）<br>
<a href="http://ja.wikipedia.org/wiki/%E5%AD%97%E5%8F%A5%E8%A7%A3%E6%9E%90#.E3.83.88.E3.83.BC.E3.82.AF.E3.83.B3_.28token.29">トークン</a>リスト (<em>list-L</em>) と学習辞書 (<em>context-D</em>) を取り、一つのカテゴリ (<em>A</em> または <em>Mc</em>) 対カテゴリ (<em>B</em>) か他のすべてのカテゴリ (<em>Mi</em>) に対する結合確率のリストを返します。
<em>list-L</em> の全てのトークンは <em>context-D</em> に見出されるべきです。
デフォルトの <em>R.A. Fisher 逆カイ二乗法</em> モードを使う時、存在しないトークンは全てのカテゴリでの等確率へと結果を歪曲するでしょう。<br />
Takes a list of tokens (<em>list-L</em>) and a trained dictionary (<em>context-D</em>) 
and returns a list of the combined probabilities of the tokens in one category 
(<em>A</em> or <em>Mc</em>) versus a category (<em>B</em>) or
against all other categories (<em>Mi</em>). All tokens in <em>list-L</em> 
should occur in <em>context-D</em>. 
When using the default <em>R.A. Fisher inverse Chi&sup2;&nbsp;</em> mode, 
nonexistent tokens will skew results toward equal probability in all categories.
</p>

<p><em>bool-chain</em> を <tt>true</tt> にして <em>Chain Bayesian</em> モードを使った時、存在しないトークンは結果に如何なる影響も持ちません。
オプションの最後のフラグ <em>bool-probs</em> は、頻度もしくは確率値がデータ･セットに使われるかどうかを示します。
普通、関数<a href="#bayes-train">bayes-train</a> がデータ･セットの頻度を生成するのに使われます。<br />
Non-existing tokens will not have any influence on the result when using the 
true <em>Chain Bayesian</em> mode with <em>bool-chain</em> set to <tt>true</tt>. 
The optional last flag, <em>bool-probs</em>, indicates whether frequencies or 
probability values are used in the data set. The <a href="#bayes-train">bayes-train</a> 
function is typically used to generate a data set's frequencies.
</p>

<p>トークンは文字列かシンボルです。 
文字列が使われたなら、<em>context-D</em> 上で検索される前にアンダースコアが前に付けられます。
<em>context-D</em> の頻度生成に <a href="#bayes-train">bayes-train</a> を使えば、アンダースコアは学習過程で自動的に付加されます。<br />
Tokens can be strings or symbols. If strings are used, they are prepended 
with an underscore before being looked up in <em>context-D</em>. If 
<a href="#bayes-train">bayes-train</a> was used to generate <em>context-D</em>'s 
frequencies, the underscore was automatically prepended during the learning process.
</p>

<p><a href="#bayes-query">bayes-query</a> は <em>bool-probs</em> に指定されたフラグ次第で、確率を合成する <a href="http://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A3%E3%83%83%E3%82%B7%E3%83%A3%E3%83%BC%E3%81%AE%E7%9B%B4%E6%8E%A5%E7%A2%BA%E7%8E%87%E6%A4%9C%E5%AE%9A">R. A. Fisher 逆カイ二乗法</a>か <a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%82%A4%E3%82%BA%E6%8E%A8%E5%AE%9A">Chain Bayesian 法</a>のどちらかを使います。
<em>bool-probs</em> にフラグが無いか <tt>nil</tt> の時、デフォルトで確率を合成する逆カイ二乗法が使われます。
<em>bool-probs</em> が <tt>true</tt> の時は、Chain Bayesian 法が使われます。<br />
	Depending on the flag specified in <em>bool-probs</em>, 
	<a href="#bayes-query">bayes-query</a> employs either the 
	R. A. Fisher inverse Chi&sup2; method of compounding probabilities 
	or the Chain Bayesian method. 
	By default, when no flag or <tt>nil</tt> is specified in <em>bool-probs</em>,
	the inverse Chi&sup2; method of compounding probabilities is used. 
	When specifying <tt>true</tt> in <em>bool-probs</em>, 
	the Chain Bayesian method is used.
</p>

<p>逆カイ二乗法が使われるなら、異なる学習セットのカテゴリのトークンの全数は、同じか、同程度あるべきです。
カテゴリ中の頻度が不均衡なら、結果は歪曲されるでしょう。<br />
	If the inverse Chi&sup2; method is used, 
	the total number of tokens 
	in the different training set's categories 
	should be equal or similar. 
	Uneven frequencies in categories 
	will skew the results.
</p>

<p><em>A</em> と <em>B</em> の二つのカテゴリに対して、<tt>bayes-query</tt> は次の公式を使います：<br />
	For two categories <em>A</em> and <em>B</em>, 
	<tt>bayes-query</tt> uses the following formula:
</p>


<b><em>p(A|tkn) = p(tkn|A) * p(A) / ( p(tkn|A) * p(A) + p(tkn|B) * p(B) )</em></b>

   
<p><em>N</em> カテゴリなら、次の公式に一般化します：<br />
	For <em>N</em> categories,  the formula can be generalized to:
</p>
   

<b><em>p(Mc|tkn) = p(tkn|Mc) * p(Mc) / sum-i-N( p(tkn|Mi) * p(Mi) )</em></b>
 

<p>確率（<em>p(B)</em> と一緒の <em>p(Mi)</em> または <em>p(A)</em>）は、<em>ベイズの事前確率</em>を表します。
<em>p(Mc|tkn)</em> と <em>p(A|tkn)</em> はカテゴリやモデルの <em>ベイズの事後確率</em> です。
この<i>単純</i> ベイズ公式は成り立ちますが、異なるカテゴリの依存関係を織り込めません。
<br />
	The probabilities (<em>p(Mi)</em> or <em>p(A)</em>, along with <em>p(B)</em>) 
	represent the <em>Bayesian prior probabilities</em>. 
	<em>p(Mc|tkn)</em> and <em>p(A|tkn)</em> are the 
	<em>posterior Bayesian</em> probabilities of a category or model.
    This <i>naive</i> Bayes formula does nor take into account dependencies
    between different categories. 
</p>

<p>逆カイ二乗法か Chain Bayesian 法で、事前確率の扱いが異なります。
Chain Bayesian 法では、一トークン計算からの事後確率で次の計算の事前確率を得ます。
デフォルトの逆カイ二乗法では事前確率を連鎖として伝えませんが、確率は逆カイ二乗法を使って合成されます。<br />
	Priors are handled differently, 
	depending on whether the inverse Chi&sup2; 
	or the Chain Bayesian method is used. 
	In Chain Bayesian mode, 
	posteriors from one token calculation get the priors in the next calculation. 
	In the default inverse Chi&sup2; method, 
	priors are not passed on via chaining, 
	but probabilities are compounded using the inverse Chi&sup2; method.
</p>

<p>Chain Bayes モードでは、一カテゴリのゼロ頻度のトークンはカテゴリの確率を事実上 0（ゼロ）にします。
これはまた、結果として全ての事後や事前を 0 へセットし、完全に抑えられたカテゴリをもたらします。
全てのカテゴリに 0 確率の結果をもたらす<ruby>質問<rp>（</rp><rt>クエリ</rt><rp>）</rp></ruby>は <em>NaN</em> 値を引き起こします。<br />
	In Chain Bayes mode, 
	tokens with zero frequency in one category 
	will effectively put the probability of that category to 0 (zero). 
	This also causes all posterior priors to be set to 0
	and the category to be completely suppressed in the result. 
	Queries resulting in zero probabilities for all categories 
	yield <em>NaN</em> values.
</p>

<p>デフォルトの逆カイ二乗法は 0 頻度に敏感ではありませんし、まだ、そのトークンの低確率を持続します。
これは <em>ベイズ統計</em> を使う自然言語処理において重要な特徴です。
五つの異なる言語の<em>集大成</em> のカテゴリが学習されているけれど、一カテゴリのいくつかの単語が他に存在しない時のことを考えてください。
純粋な Chain Bayesian 法が使われる時、文章は、その正しいカテゴリに分類されません。
なぜなら、ちょうど一つのトークンのゼロ・カウントが、その所属するカテゴリへの分類を事実上、拒むからです。<br />
	The default inverse Chi&sup2; method 
	is less sensitive about zero frequencies 
	and still maintains a low probability for that token. 
	This may be an important feature in natural language processing 
	when using <em>Bayesian statistics</em>. 
	Imagine that five different language <em>corpus</em> categories have been trained, 
	but some words occurring in one category are not present in another. 
	When the pure Chain Bayesian method is used, 
	a sentence could never be classified into its correct category
	because the zero-count of just one word token could effectively exclude it 
	from the category to which it belongs.
</p>

<p>一方で、Chain Bayesian 法はデータの具体的な比率の正確な結果を提供します。
自然言語データで Chain Bayesian モードを使う時、最初に全てのゼロ頻度が学習された辞書から取り除かれます。<br />
	On the other hand, 
	the Chain Bayesian method offers exact results 
	for specific proportions in the data. 
	When using Chain Bayesian mode for natural language data,
	all zero frequencies should be removed from the trained dictionary first.
</p>

<p><tt>bayes-query</tt> の戻り値は、各カテゴリの一つの確率値のリストです。
次に二つの事例を示します：
最初はデフォルトの逆カイ二乗モード、二つ目は Chain Bayesian 法によるデータセット処理。<br />
The return value of <tt>bayes-query</tt> is a list of probability values, 
one for each category. Following are two examples: the first for the 
default inverse Chi&sup2; mode, the second for a data set processed with the 
Chain Bayesian method.
</p>

<br/>
<h3>R.A. Fisher inverse Chi&sup2; method（R.A. Fisher 逆カイ二乗法）</h3>

<p>次の例で、二つのデータ･セットはグーテンベル・グプロジェクト（訳注;日本でいう青空文庫に相当）の本です。
私たちは、作家が違えば、使われる単語の頻度が異なると推測し、文章が一方の作家が書いたものか、それとも他方の作家のものか、可能性の高い方を決定したいと思います。
似たような方法が、しばしば、スパムか合法的なメールかの識別に使われます。<br />
	In the following example, 
	the two data sets are books from Project Gutenberg.
	We assume that different authors 
	use certain words with different frequencies 
	and want to determine if a sentence is more likely to occur in one 
	or the other author's writing.
	A similar method is frequently used to differentiate between spam 
	and legitimate email.
</p>


<pre>
;; from Project Gutenberg: http://www.gutenberg.org/catalog/
;; The Adventures of Sherlock Holmes - Sir Arthur Conan Doyle

(bayes-train (parse (lower-case (read-file "Doyle.txt")) 
                    "[^a-z]+" 0) '() 'DoyleDowson)

;; A Comedy of Masks - Ernest Dowson and Arthur Moore

(bayes-train '() (parse (lower-case (read-file "Dowson.txt")) 
                    "[^a-z]+" 0) 'DoyleDowson)

(save "DoyleDowson.lsp" 'DoyleDowson)
</pre>


<p>二つの学習セットがロードされ、トークンに分解され、関数 <a href="#bayes-train">bayes-train</a> で処理されます。
最後に、関数<tt>bayes-query</tt> で使えるように、<tt>DoyleDowson</tt> 辞書をファイルにセーブします。<br />
	The two training sets are loaded, split into tokens, 
	and processed by the <a href="#bayes-train">bayes-train</a> function. 
	In the end, the <tt>DoyleDowson</tt> dictionary is saved to a file, 
	which will be used later with the <tt>bayes-query</tt> function.
</p>

<p>次のコードは、文章を <em>Doyle</em> か <em>Dowson</em> に分類するのに、<tt>bayes-query</tt> がどのように使われるかを示します。<br />
	The following code illustrates how <tt>bayes-query</tt> is used 
	to classify a sentence as <em>Doyle</em> or <em>Dowson</em>:
</p>


<pre>
(load "DoyleDowson.lsp")
(bayes-query (parse "he was putting the last touches to a picture") 
    'DoyleDowson)
<span class='arw'>&rarr;</span> (0.0359554723158327 0.964044527684167) 

(bayes-query (parse "immense faculties and extraordinary powers of observation") 
    'DoyleDowson)
<span class='arw'>&rarr;</span> (0.983569359827141 0.0164306401728594) 
</pre>


<p><ruby>質問<rp>（</rp><rt>クエリ</rt><rp>）</rp></ruby>は、最初の文章が <em>Dowson</em> の文章で、二番目が <em>Doyle</em> の文章であることを正しく識別しています。<br />
	The queries correctly identify the first sentence as a <em>Dowson</em> sentence,
	and the second one as a <em>Doyle</em> sentence.
</p>
      
<br/>
      
<h3>Chain Bayesian method</h3>

<p>二番目の例は、ベイズ統計学の紹介文献にしばしば見られます。
前もって処理されたデータ･セットのデータ上で <tt>bayes-query</tt> を使う Chain Bayesian法 を示しています：<br />
	The second example is frequently found 
	in introductory literature on Bayesian statistics. 
	It shows the Chain Bayesian method of 
	using <tt>bayes-query</tt> on the data of a previously processed data set:
</p>

<!-- example -->

<pre>
(set 'Data:test-positive '(8 18))
(set 'Data:test-negative '(2 72))
(set 'Data:total '(10 90))
</pre>

   
<p>ある病気は、人口の10％で発生します。
この病気を検査するために開発されたテストは、健康な人の 20％に偽陽性反応と病気な人の 20％に偽陰性反応を生じます。 
テストが陽性で病気に感染している確率はいくらでしょうか？<br>
（訳注：上記例は、感染者10人のグループと非感染者90人のグループの二つがあり、感染者の内、8人が検査に陽性、2人が陰性。
そして、非感染者の内、18人が検査に陽性、72人が陰性。
という設定）<br />
	A disease occurs in 10 percent of the population. 
	A blood test developed to detect this disease 
	produces a false positive rate of 20 percent in the healthy population 
	and a false negative rate of 20 percent in the sick. 
	What is the probability of a person carrying 
	the disease after testing positive?</p>

<!-- example -->

<pre>
(bayes-query '(test-positive) Data true)
<span class='arw'>&rarr;</span> (0.3076923077 0.6923076923)

(bayes-query '(test-positive test-positive) Data true)
<span class='arw'>&rarr;</span> (0.64 0.36)

(bayes-query '(test-positive test-positive test-positive) Data true)
<span class='arw'>&rarr;</span> (0.8767123288 0.1232876712)
</pre>


<p><tt>bayes-query</tt> を正しく動作させるためには、イベント間の統計上の独立を前提にベイズの公式を使用するよう、注意してください。<br />
	Note that the Bayesian formulas used 
	assume statistical independence of events 
	for the <tt>bayes-query</tt> to work correctly.
</p>

<p>この例は、病気であると確実に分類される前に、何回か陽性をテストしなければならないことを示しています。<br>
（訳注：3回検査して全部陽性なら、9割弱の確率で感染しているということ）
<br />
	The example shows that a person must test positive several times 
	before they can be confidently classified as sick.
</p>

<p>同じ例の計算に R.A. Fisher Chi&sup2; 法を使えば、区別し難い結果となります。<br />
	Calculating the same example using the R.A. Fisher Chi&sup2; method
	will give less-distinguished results.
</p> 

<br/>
<h3>Specifying probabilities instead of counts</h3>

<p>データは、しばしば既に確率値として利用できるようになっていて、それらを頻度に戻す追加の作業が要求されます。
最後の例では、データは初めからパーセンテージで定義されています。
追加のオプション <em>bool-probs</em> フラグは確率の直接入力を許可し、最大の効果を得るために Chain Bayesian モードで使うべきです：<br />
	Often, data is already available as probability values 
	and would require additional work to reverse them into frequencies. 
	In the last example, the data were originally defined as percentages. 
	The additional optional <em>bool-probs</em> flag 
	allows probabilities to be entered directly 
	and should be used together with the Chain Bayesian mode 
	for maximum performance:
</p>

<!-- example -->

<pre>
(set 'Data:test-positive '(0.8 0.2))
(set 'Data:test-negative '(0.2 0.8))
(set 'Data:total '(0.1 0.9))

(bayes-query '(test-positive) Data true true)
<span class='arw'>&rarr;</span> (0.3076923077 0.6923076923)

(bayes-query '(test-positive test-positive) Data true true)
<span class='arw'>&rarr;</span> (0.64 0.36)

(bayes-query '(test-positive test-positive test-positive) Data true true)
<span class='arw'>&rarr;</span> (0.8767123288 0.1232876712)
</pre>


<p>予想されるように、結果は頻度の時と同じ確率になります。<br />
	As expected, the results are the same for probabilities 
	as they are for frequencies.
</p>

<br/><br/>

<a name="bayes-train"></a>
<h2><span class="function">bayes-train</span></h2>
<h4>syntax: (bayes-train <em>list-M1</em> [<em>list-M2</em> ... ] <em>sym-context-D</em>)</h4>

<p><a href="http://ja.wikipedia.org/wiki/%E5%AD%97%E5%8F%A5%E8%A7%A3%E6%9E%90#.E3.83.88.E3.83.BC.E3.82.AF.E3.83.B3_.28token.29">トークン</a>のジョイント・セットから、単語 (<em>M1</em>, <em>M2&ndash;</em>) のリストを一つ以上取ります。
newLISP上では、トークンはシンボルか、文字列になります（他のデータ・タイプは無視されます）。
トークンは <em>sym-context-D</em> の共通辞書上に置かれ、各カテゴリ <em>Mi</em> における各トークンの頻度がカウントされます。
コンテキストが、まだ存在しない時は、それを示す必要があります（訳注：つまり、<em>sym-context-D</em>は必ず指定しなければならないということ）。<br />
Takes one or more lists of tokens (<em>M1</em>, <em>M2&mdash;</em>) 
from a joint set of tokens. In newLISP, tokens can be symbols or strings 
(other data types are ignored). Tokens are placed in a common dictionary 
in <em>sym-context-D</em>, and the frequency is counted  for each token 
in each category <em>Mi</em>. If the context does not yet exist, 
it must be quoted.
</p>
   
<p>カテゴリ<em>M</em> は分類可能なトークンの列のデータ・モデルを示します（<a href="#bayes-query">bayes-query</a> 参照）。
<em>D</em> の各トークンは各カテゴリでのそのトークンの頻度のリストを含むコンテキストで参照可能なシンボルです。
トークン文字列はシンボルに変換される前に、先頭に <tt>_</tt>（アンダースコア）が付加されます。 
<tt>total</tt> という名前のシンボルが生成され、各カテゴリの（訳注：トークンの）全数の入ります。
シンボル<tt>total</tt> は、カテゴリ<em>Mi</em> で渡されるシンボルにはなりません。<br />
 The <em>M</em> categories represent data models for which sequences of 
tokens can be classified  (see <a href="#bayes-query">bayes-query</a>). 
Each token in <em>D</em> is a content-addressable symbol 
containing a list of the frequencies for this token within each category. 
String tokens are prepended with an <tt>_</tt> (underscore) 
before being converted into symbols. A symbol named <tt>total</tt> is created
containing the total of each category. The <tt>total</tt> symbol cannot be part 
of the symbols passed as an <em>Mi</em> category.
</p>
<blockquote>
（訳例：つまり、total というシンボルをトークンにすると、まずいことになります。
<pre>
> (bayes-train '(A A B C C) '(A B B C C total C) 'L)
(5 8)
> L:A
(2 1)
> L:B
(1 2)
> L:C
(2 3)
> L:total
(5 8)
</pre>
しかし、文字列を使えば、回避できます。
<pre>
> (bayes-train '("A" "A" "B" "C" "C") '("A" "B" "B" "C" "C" "total" "C") 'L)
(5 7)
> L:_A
(2 1)
> L:_B
(1 2)
> L:_C
(2 3)
> L:_total
(0 1)
</pre>
）</blockquote>

<p>
この関数は、異なるカテゴリやモデルで見つかったトークン頻度のリストを返します。<br />
The function returns a list of token frequencies found in the different categories 
or models.
</p>

<!-- example -->

<pre>
; count the symbols in two lists
(bayes-train '(A A B C C) '(A B B C C C) 'L)  <span class='arw'>&rarr;</span> (5 6)

L:A      <span class='arw'>&rarr;</span> (2 1)
L:B      <span class='arw'>&rarr;</span> (1 2)
L:C      <span class='arw'>&rarr;</span> (2 3)
L:total  <span class='arw'>&rarr;</span> (5 6)

; count words in three lists
(bayes-train '("one" "two" "two" "three")
             '("three" "one" "three") 
             '("one" "two" "three") 'S)       
<span class='arw'>&rarr;</span> (4 3 3)

; inspect the symbols created
S:_one    <span class='arw'>&rarr;</span> (1 1 1)
S:_two    <span class='arw'>&rarr;</span> (2 0 1)
S:_three  <span class='arw'>&rarr;</span> (1 2 1)
S:total   <span class='arw'>&rarr;</span> (4 3 3)
</pre>


<p>一番目の例は二つのシンボル・リストによる学習を示しています。
二番目の例は文字列による学習で、どのように <tt>_</tt> が付加されるかを示しています。<br />
The first example shows training with two lists of symbols. The second example 
illustrates how an <tt>_</tt> is prepended when training with strings.</p>

<p><tt>bayes-train</tt> は、アンダースコアを付加することで文字列からシンボルを生成します。これは、<a href="#hash">ハッシュが作られる時の方法</a>と同じで、<tt>bayes-train</tt> のシンボルが入ったコンテキストはハッシュのように使えます：<br />
<tt>bayes-train</tt> creates symbols from strings prepending an underscore
character. This is the same way hashes are created and contexts populates with
symbols by <tt>bayes-train</tt> can be used like hashes:</p>


<pre>
; use a bayes-trained context namespace like a hash dictionary

(S "two")   <span class='arw'>&rarr;</span> (2 0 1)
(S "three") <span class='arw'>&rarr;</span> (1 2 1)

; translate the namespace into an association list

(S) <span class='arw'>&rarr;</span> (("one" (1 1 1)) ("three" (1 2 1)) ("two" (2 0 1)))
</pre>


	
<p>これらの例は、デモ用であることに注意してください。
実際、学習セットは特に自然言語モデルの学習のような時に、千から万単位の単語を持ちます。
しかし、シンボルの頻度が既に知られている割合で記述されている時は、小さいデータセットが使われます。
このような場合は、関数 <tt>bayes-train</tt> を使わずに、きっちりとしたモデル・データ・セットを記述した方が良いでしょう：<br />
Note that these examples are just for demonstration purposes. In reality, training 
sets may contain thousands or millions of words, especially when training natural 
language models. But small data sets may be used when the frequency of symbols 
just describe already-known proportions. In this case, it may be better to describe 
the model data set explicitly, without the <tt>bayes-train</tt> function:
</p>


<pre>
(set 'Data:tested-positive '(8 18))
(set 'Data:tested-negative '(2 72))
(set 'Data:total '(10 90))
</pre>


<p>最後のデータは関数 <a href="#bayes-query">bayes-query</a> を記述するために、<em>ベイジアン・ネットワーク</em> の紹介文や本で、よく使われる例から取っています。<br />
The last data are from a popular example used to describe the 
<a href="#bayes-query">bayes-query</a> function in introductory papers 
and books about <em>bayesian networks</em>.
</p>

<p>学習は実際にある学習したコンテキストとそれと同数のカテゴリ上で、<tt>bayes-train</tt> を使って異なるステージで行われます。
新シンボルが付加され、カウント値と全数が正しく更新されます。<br />
Training can be done in different stages by using <tt>bayes-train</tt> on an 
existing trained context with the same number of categories. The new symbols 
will be added, then counts and totals will be correctly updated.</p>

<p>複数のバッチによる学習は、最初、トークン化が必要な大きなテキスト集や文献で必要になるかもしれません。
これらの集合体は複数のステージで <tt>bayes-train</tt> に与えることで、小さな部品としてのトークン化が可能です、集まりの無い空のリストを与えられると、カテゴリの学習は不自然になります：<br />
Training in multiple batches may be necessary on big text corpora or documents 
that must be tokenized first. These corpora can be tokenized in small portions, 
then fed into <tt>bayes-train</tt> in multiple stages. Categories can also be 
singularly trained by specifying an empty list for the absent corpus:
</p>


<pre>
(bayes-train shakespeare1 '() 'data)
(bayes-train shakespeare2 '() 'data)
(bayes-train '() hemingway1 'data)
(bayes-train '() hemingway2 'data)
(bayes-train shakepeare-rest hemingway-rest 'data)
</pre>


<p>
<tt>bayes-train</tt> は、単語のカウントと全数を正しく更新します。<br />
<tt>bayes-train</tt> will correctly update word counts and totals.</p>

<p><tt>bayes-train</tt> を <tt>MAIN</tt> でない他のコンテキストで使うには、関数 <a href="#context">context</a> によって、<tt>MAIN</tt> 上に前もって学習用コンテキストを用意しておく必要があります。<br />
	Using <tt>bayes-train</tt> inside a context other than <tt>MAIN</tt> 
	requires the training contexts to have been created previously within 
	the <tt>MAIN</tt> context via the <a href="#context">context</a> function.
</p>

<p><tt>bayes-train</tt> は、関数<a href="#bayes-query">bayes-query</a> に役立つだけでなく、汎用的なカウント関数としても使えます。
例えば、頻度の結果はカテゴリ中のアイテムの比例分布の<a href="http://ja.wikipedia.org/wiki/%E5%B8%B0%E7%84%A1%E4%BB%AE%E8%AA%AC">帰無仮説</a>に対して、<a href="#prob-chi2">prob-chi2</a> を使った解析を可能にします。<br />
	<tt>bayes-train</tt> is not only useful with the <a href="#bayes-query">bayes-query</a> function, 
	but also as a function for counting in general.
	For instance, the resulting frequencies 
	could be analyzed using <a href="#prob-chi2">prob-chi2</a> 
	against a <em>null hypothesis</em> of proportional distribution 
	of items across categories.
</p>

<br/><br/>

<a name="begin"></a>
<h2><span class="function">begin</span></h2>
<h4>syntax: (begin <em>body</em>)</h4>

<p>関数<tt>begin</tt> は、式のブロックをグループ化して使うことができます。
<em>body</em> 中の式は順次評価され、<em>body</em> の最後の式の値を返します。<br />
	The <tt>begin</tt> function is used to group a block of expressions. 
	The expressions in <em>body</em> are evaluated in sequence, and 
	the value of the last expression in <em>body</em> is returned.
</p>

<!-- example -->

<pre>
(begin
  (print "This is a block of 2 expressions\n")
  (print "================================"))
</pre>


<p><a href="#cond">cond</a>、<a href="#define">define</a>、<a href="#doargs">doargs</a>、<a href="#dolist">dolist</a>、<a href="#dostring">dostring</a>、<a href="#dotimes">dotimes</a>、<a href="#when">when</a>、<a href="#while">while</a> のような組込関数は本体に複数の式を持つことができますが、<a href="#if">if</a> 式では <tt>begin</tt> がよく使われます。<br />
	Some built-in functions like <a href="#cond">cond</a>, <a href="#define">define</a>,
	<a href="#doargs">doargs</a>, <a href="#dolist">dolist</a>, <a href="#dostring">dostring</a>, 
    <a href="#dotimes">dotimes</a>, <a href="#when">when</a> and <a href="#while">while</a> 
	already allow multiple expressions in their bodies,
	but <tt>begin</tt> is often used in an <a href="#if">if</a> expression.
</p>

<p>関数 <a href="#silent">silent</a> は <tt>begin</tt> のように動作しますが、戻り値のコンソール出力を抑えます。<br />
	The <a href="#silent">silent</a> function works like <tt>begin</tt>, 
	but suppresses console output on return.
</p>

<br/><br/>

<a name="beta"></a>
<h2><span class="function">beta</span></h2>
<h4>syntax: (beta <em>cum-a</em> <em>num-b</em>)</h4>

<p><em>ベータ</em> 関数 <tt>beta</tt> は、<em>ガンマの対数</em> の関数 <tt>gammaln</tt> から次のようにして、得られます：（訳注：<a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%83%BC%E3%82%BF%E9%96%A2%E6%95%B0">ベータ関数</a>）<br />
	The <em>Beta</em> function, <tt>beta</tt>,  
	is derived from the <em>log Gamma</em> 
	<tt>gammaln</tt> function as follows:
</p>

<p><em><b>
beta = exp(gammaln(a) + gammaln(b) - gammaln(a + b))
</b></em></p>

<!-- example -->

<pre>
(beta 1 2)  <span class='arw'>&rarr;</span> 0.5
</pre>

<br/><br/>

<a name="betai"></a>
<h2><span class="function">betai</span></h2>

<h4>syntax: (betai <em>num-x</em> <em>num-a</em> <em>num-b</em>)</h4>

<p><em>不完全ベータ</em> 関数 <tt>betai</tt> は、<em>num-x</em> 上の <em>x</em> の<em>ベータ</em> 分布 <tt>betai</tt> の累積確率と等しくなります。
この累積2項分布は、確率 <em>p</em> が <em>N</em> 回試行中 <em>k</em> 回または、それ以上の回数が起こるイベントの確率 <em>pev</em> として定義されます：（訳注：<a href="http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%AE%8C%E5%85%A8%E3%83%99%E3%83%BC%E3%82%BF%E9%96%A2%E6%95%B0">不完全ベータ関数</a>）<br />
	The <em>Incomplete Beta</em> function, <tt>betai</tt>, 
	equals the cumulative probability of the <em>Beta</em> distribution, <tt>betai</tt>, 
	at <em>x</em> in <em>num-x</em>. 
	The cumulative binomial distribution is defined as the probability of an event, <em>pev</em>, 
	with probability <em>p</em> to occur <em>k</em> or more times in <em>N</em> trials:
</p>


<p><em><b> pev = Betai(p, k, N - k + 1) </b></em></p>

<!-- example -->

<pre>
(betai 0.5 3 8)  <span class='arw'>&rarr;</span> 0.9453125
</pre>


<p>
例では、0.5 の確率のイベントが 10 回 (8 = 10 - 3 + 1) 中 3 回以上起こる確率を計算しています。
不完全ベータ分散は数学や統計において、様々な関数を得るために使われます。
関数 <a href="#binomial">binomial</a> も見てください。<br />
The example calculates the probability for an event 
with a probability of 0.5 to occur 3 or more times in 10 trials (8 = 10 - 3 + 1). 
The incomplete Beta distribution can be used to derive a variety of other functions 
in mathematics and statistics. 
See also the <a href="#binomial">binomial</a> function.
</p>
<blockquote>（訳例：Lutz氏作(by Lutz)<pre>
;; probability of F ratio for df1/df2
;; by Lutz
;;
(define (Lutz-prob-f f df1 df2)
  (let (prob (mul 2 (betai (div df2 (add df2 (mul df1 f))) 
                           (mul 0.5 df2) 
                           (mul 0.5 df1)))) 
    (div (if (&gt; prob 1) (sub 2 prob) prob) 2)
))

;; one-tailed probablity of Student's t
;; by Lutz
;;
(define (Lutz-prob-t t df)
    (let (bta (betai (div (add 1 (div (pow t) df))) (div df 2) 0.5))
        (if  
            (&gt; t 0) (sub 1 (mul 0.5 bta))
            (&lt; t 0) (mul 0.5 bta) 
            0.5)
))
;; 組込prob-t とは
;; (prob-t t df) = (sub 1 (Lutz-prob-t t df))
;; という関係にあります
</pre>）</blockquote>

<br/><br/>


<a name="bigint"></a>
<h2><span class="function">bigint</span></h2>
<h4>syntax: (bigint <em>number</em>)<br/>
syntax: (bigint <em>string</em>)</h4>

<p>浮動小数点数または整数を大整数に変換します。
浮動小数点数の変化の際は、十進数と二進数間の丸め誤差が生じます。<br />
A floating point or integer number gets converted to big integer format.
When converting from floating point, rounding errors occur going back and forth
between decimal and binary arithmetic.</p>

<p>引数が文字列の時は、数値を解析して大整数に変換します。<br />
A string argument gets parsed to a number and converted to a big integer.</p>

<!-- example -->

<pre>
(bigint 12345)          <span class='arw'>&rarr;</span> 12345L

(bigint 1.234567890e30) <span class='arw'>&rarr;</span> 1234567889999999957361000000000L 

(set 'num 567890)
(bigint num)            <span class='arw'>&rarr;</span> 567890L

(bigint "-54321")       <span class='arw'>&rarr;</span> -54321L
(bigint "123.45")       <span class='arw'>&rarr;</span> 123L
(bigint "123hello")     <span class='arw'>&rarr;</span> 123L
</pre>

<p>このマニュアルの<a href="#big_int">算術精度に制限のない大整数</a>の章も見てください。<br />
See also the manual chapter <a href="#big_int">Big integer, unlimited precision arithmetic</a></p>

<br/><br/>

<a name="bigintp"></a>
<h2><span class="function">bigint?</span></h2>
<h4>syntax: (bigint? <em>number</em>)</h4>

<p>数値が大整数かどうかをチェックします。<br />
Check if a number is formatted as a big integer.</p>

<!-- example -->

<pre>
(set 'x 12345)
(set 'y 12345L)
(set 'z 123456789012345678901234567890)
(set 'p 1.2345e20)
(set 'q (bigint p))

(bigint? x)  <span class='arw'>&rarr;</span> nil
(bigint? y)  <span class='arw'>&rarr;</span> true
(bigint? z)  <span class='arw'>&rarr;</span> true
(bigint? p)  <span class='arw'>&rarr;</span> nil
(bigint? q)  <span class='arw'>&rarr;</span> true
</pre>

<p>このマニュアルの<a href="#big_int">算術精度に制限のない大整数</a>の章も見てください。<br />
See also the manual chapter <a href="#big_int">Big integer, unlimited precision arithmetic</a></p>

<br/><br/>

<a name="bind"></a>

<h2><span class="function">bind</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (bind <em>list-variable-associations</em> [<em>bool-eval</em>])</h4>

<p><em>list-variable-associations</em> には、シンボルとその値からなる連想リスト（訳注：((シンボル1 連想値1) (シンボル2 連想値2) …) ）が入ります。
<tt>bind</tt> は、全てのシンボルにその連想値をセットします。<br />
<em>list-variable-associations</em> contains an association list of 
symbols and their values. <tt>bind</tt> sets all symbols
to their associated values.</p>

<p><em>bool-eval</em> が <tt>true</tt> なら、連想値は評価されます：<br />
The associated values are evaluated if the <em>bool-eval</em> flag is <tt>true</tt>:</p>

<pre>
(set 'lst '((a (+ 3 4)) (b "hello")))

(bind lst)         <span class='arw'>&rarr;</span> "hello"

a    <span class='arw'>&rarr;</span> (+ 3 4)
b    <span class='arw'>&rarr;</span> "hello"

(bind lst true)    <span class='arw'>&rarr;</span> "hello"

a    <span class='arw'>&rarr;</span> 7
</pre>

<p>bind の戻り値は最後の連想値です。<br />
The return value of bind is the value of the last association.</p>

<p><tt>bind</tt> is often used to bind association lists returned
by <a href="#unify">unify</a>.</p>

<pre>
(bind (unify '(p X Y a) '(p Y X X)))    <span class='arw'>&rarr;</span> a

X    <span class='arw'>&rarr;</span> a
Y    <span class='arw'>&rarr;</span> a
</pre>

<p>これは、構造体の仕分けに使えます：<br />
This can be used for de-structuring:</p>

<pre>
(set 'structure '((one "two") 3 (four (x y z))))
(set 'pattern '((A B) C (D E)))
(bind (unify pattern structure))

A <span class='arw'>&rarr;</span> one
B <span class='arw'>&rarr;</span> "two"
C <span class='arw'>&rarr;</span> 3
D <span class='arw'>&rarr;</span> four
E <span class='arw'>&rarr;</span> (x y z)
</pre>


<p><a href="#unify">unify</a> が連想リストを返し、<tt>bind</tt> がその関連付け（訳注：連想）を束縛します。<br />
<a href="#unify">unify</a>  returns an association list and <tt>bind</tt> binds the 
associations.</p>

<br/><br/>

<a name="binomial"></a>

<h2><span class="function">binomial</span></h2>
<h4>syntax: (binomial <em>int-n</em> <em>int-k</em> <em>float-p</em>)</h4>

<p>
二項分布関数は、イベントが <em>float-p</em> の確率を持ち、各試行で互いに独立である時、 <em>int-n</em> 中 <em>int-k</em> 回起こる確率として定義されます：<br />
The binomial distribution function is defined as the probability for an event 
to occur <em>int-k</em> times in <em>int-n</em> trials if that event has a 
probability of <em>float-p</em> and all trials are independent of one another:</p>


<em><b>binomial = pow(p, k) * pow(1.0 - p, n - k) * n! / (k! * (n - k)!)</b></em>


<p>ここで、<em>x!</em> は <em>x</em> の階乗、<em>pow(x, y)</em> は <em>x</em> の <em>y</em> 乗です。<br />
	where <em>x!</em> is the factorial of <em>x</em> 
	and <em>pow(x, y)</em> is <em>x</em> raised to the power of <em>y</em>.
</p>

<br/>

<!-- example -->

<pre>
(binomial 10 3 0.5)  <span class='arw'>&rarr;</span> 0.1171875
</pre>


<p>この例では、0.5 の確率のイベントが 10 回中 3 回起こる確率を計算しています。
累積分布については、関数 <a href="#betai">betai</a> を見てください。<br />
	The example calculates the probability for an event 
	with a probability of 0.5 to occur 3 times in 10 trials. 
	For a cumulated distribution, 
	see the <a href="#betai">betai</a> function.
</p>

<br/><br/>

<a name="bits"></a>
<h2><span class="function">bits</span></h2>
<h4>syntax: (bits <em>int</em> [<em>bool</em>])</h4>

<p><em>int</em> の数値を 1 と 0 の文字列に変換します。
<em>bool</em> が <tt>nil</tt> 以外なら、（訳注：真偽の）リストを返します。<br />
Transforms a number in <em>int</em> to a string of 1's and 0's or a 
list, if <em>bool</em> evaluates to anything not <tt>nil</tt>.</p>

<p>文字列で再定義されたビットは、高位から下位への順です。
リスト表現では、1 と 0 が <tt>true</tt> と <tt>nil</tt> になり、下位から上位への順になります。
これにより、結果の直接的要素指定や結果によるプログラム制御切替が可能になります。<br />
In string representation bits are in high to low order. In list
presentation 1's and 0's are represented as <tt>true</tt> and <tt>nil</tt>
and in order from the lowest to the highest bit. This allows direct
indexing and program control switching on the result.</p>

<!-- example -->

<pre>
(bits 1234)      <span class='arw'>&rarr;</span> "10011010010"

(int (bits 1234) 0 2) <span class='arw'>&rarr;</span> 1234

(bits 1234 true)     <span class='arw'>&rarr;</span> (nil true nil nil true nil true true nil nil true)

((bits 1234 true) 0) <span class='arw'>&rarr;</span> nil ; indexing of the result
</pre>

<p>基底 2 で使う <a href="#int">int</a> は <tt>bits</tt> の逆関数です。<br />
<a href="#int">int</a> with a base of 2 is the inverse function to <tt>bits</tt>.</p>

<br/><br/>

<a name="callback"></a>
<h4>syntax: (callback <em>int-index</em> <em>sym-function</em>)<br/>
syntax: (callback <em>sym-function</em> <em>str-return-type</em> [<em>str_param_type</em> ...])<br/>
syntax: (callback <em>sym-function</em>)</h4>

<p>第一<b>単純 <tt>callback</tt> 構文</b>では、8つまでのパラメータを持てる 16 個 (0 ～ 15) の <em>callback</em> 関数を導入ライブラリとして登録することができます。
関数 <tt>callback</tt> はユーザ定義関数 <em>sym-function</em> を実行させるための開始アドレスを返します。
次の例で、<a href="http://www.opengl.org/">OpenGL</a> グラフィック・ライブラリ導入時のコールバック関数の使い方を示します：<br />
In the first <b>simple <tt>callback</tt> syntax</b> up to sixteen (0 to 15) <em>callback</em> 
functions for up to eight parameters can be registered with imported libraries. 
The <tt>callback</tt> function returns a procedure address that invokes a 
user-defined function in <em>sym-function</em>. The following example shows 
the usage of callback functions when importing the <a href="http://www.opengl.org">OpenGL</a> 
graphics library:</p>

<p>もし、16 個より多いコールバック関数が必要なら、スロットを異なるコールバック関数に再定義する必要があります。<br />
If more than sixteen callback functions are required, slots must be 
reassigned to a different callback function.</p>

<!-- example -->

<pre>
...
(define (draw)
    (glClear GL_COLOR_BUFFER_BIT )
    (glRotated rotx 0.0 1.0 0.0)
    (glRotated roty 1.0 0.0 0.0)
    (glutWireTeapot 0.5)
    (glutSwapBuffers))

(define (keyboard key x y)
    (if (= (&amp; key 0xFF) 27) (exit)) ; exit program with ESC
    (println "key:" (&amp; key 0xFF) " x:" x  " y:" y))

(define (mouse button state x y)
    (if (= state 0)
        (glutIdleFunc 0) ; stop rotation on button press
        (glutIdleFunc (callback 4 'rotation)))
    (println "button: " button " state:" state " x:" x " y:" y))

(glutDisplayFunc (callback 0 'draw))
(glutKeyboardFunc (callback 1 'keyboard))
(glutMouseFunc (callback 2 'mouse))
...
</pre>


<p><tt>callback</tt> で返されるアドレスは <a href="http://www.opengl.org/documentation/specs/glut/spec3/spec3.html">Glut</a> ライブラリに登録されます。
上記コードは、newLISP 配布ソースの <tt>examples/</tt> ディレクトリにある <tt>opengl-demo.lsp</tt> ファイルの一部です。
また、<a href="http://www.newlisp.org/downloads/OpenGL/">newlisp.org/downloads/OpenGL</a> からもダウンロードできます。<br />
The address returned by <tt>callback</tt> is registered with the 
<a href="http://www.opengl.org/documentation/specs/glut/spec3/spec3.html">Glut</a> library. 
The above code is a snippet from the file <tt>opengl-demo.lsp</tt>, 
in the <tt>examples/</tt> directory of the source distribution of newLISP 
and can also be downloaded from
<a href="http://www.newlisp.org/downloads/OpenGL/">newlisp.org/downloads/OpenGL</a>.</p>

<p>第二<b>拡張 <tt>callback</tt> 構文</b>では、関数が呼び出される時の戻り値とパラメーター値の型を表わすために型指定子を使います。
第二構文で登録されるコールバック関数は数に制限がありません。
そして、戻り値は呼び出した関数に渡されます。
<em>sym-function</em> のシンボルには、C プログラムから呼び出し可能なコールバック関数として定義された newLISP の関数が入ります。<br />
In the second <b>extanded <tt>callback</tt> syntax</b> type specifiers are used to 
describe the functions return and parameter value types when the function is called. 
An unlimited number of callback functions can be registered with the second syntax, and 
return values are passed back to the calling function. The symbol in <em>sym-function</em>
contains a newLISP defined function used as a callback function callable from a C program.</p>

<p>第三構文では、<tt>callback</tt>はそのシンボルに前もって返される C 呼び出し可能アドレスを返します。<br />
In the third syntax <tt>callback</tt> returns a previously returned C-callable
address for that symbol.</p>

<p>第一<b>単純 <tt>callback</tt> 構文</b>は整数値とポインタのみ扱いますが、拡張構文の <tt>callback</tt> では <tt>callback</tt> 関数の出力に渡される単精度と倍精度の浮動小数点数も扱えます。<br />
While the first simple <tt>callback</tt> syntax only handles integers and pointer
values, <tt>callback</tt> in the expanded syntax can also handle simple and double precision
floating point numbers passed in an out of the <tt>callback</tt> function.</p>

<p>単純及び拡張構文は同じプログラム内に混在できます。<br />
Both the simple and extended syntax can be mixed inside the same program.</p>

<p>次に例には C ライブラリ関数 <tt>qsort</tt> の <a href="#import">import</a> があり、その引数の一つに比較関数のアドレスを取ります。
この場合の比較関数は newLISP で書かれ、導入した <tt>qsort</tt> の中で呼び出されています：<br />
The following example shows the <a href="#import">import</a> of the <tt>qsort</tt>
C library function, which takes as one of it's arguments the address of a comparison
function. The comparison function in this case is written in newLISP and called into
by the imported <tt>qsort</tt> function:</p>

<pre>
; C void qsort(...) takes an integer array with number and width
; of array elements and a pointer to the comparison function
(import "libc.dylib" "qsort" "void" "void*" "int" "int" "void*")

(set 'rlist '(2 3 1 2 4 4 3 3 0 3))
; pack the list into an C readable 32-bit integer array
(set 'carray (pack (dup "ld " 10) rlist))

; the comparison callback function receives pointers to integers
(define (cmp a b) 
    (- (get-int a) (get-int b)))

; generate a C callable address for cmp
(set 'func (callback 'cmp "int" "void*" "void*"))

; sort the carray
(qsort carray 10 4 func)

; unpack the sorted array into a LISP list
(unpack (dup "ld" 10) carray)  <span class='arw'>&rarr;</span>  (0 1 2 2 3 3 3 3 4 4) 
</pre>

<p>型指定子には、関数 <a href="#import">import</a> で使われるのと同じ文字列タグが使えます。
全てのポインタ型は <tt>callback</tt> 関数の入出力で、数値として渡されます。
パラメータから異なる精度の数値を取り出すには、関数 <a href="#get-char">get-char</a>、
<a href="#get-int">get-int</a>、<a href="#get-long">get-long</a>、<a href="#get-string">get-string</a> が使えます。
バイナリ・バッファや構造体からデータを取り出すには、<a href="#pack">pack</a> と <a href="#unpack">unpack</a> を使ってください。<br />
As type specifiers the same string tags can be used as in the 
<a href="#import">import</a> function. All pointer types are passed as numbers in and
out of the <tt>callback</tt> function. The functions <a href="#get-char">get-char</a>,
<a href="#get-int">get-int</a>, <a href="#get-long">get-long</a> and 
<a href="#get-string">get-string</a> can be used to extract numbers of
different precision from parameters. Use <a href="#pack">pack</a> and 
<a href="#unpack">unpack</a> to extract data from binary buffers and structures.</p>

<p>すでに newLISP には、高速の組込関数 <a href="#sort">sort</a> があることをお忘れなく。<br />
Note that newLISP as already a fast built-in <a href="#sort">sort</a> function.</p>

<br/><br/>

<a name="case"></a>
<h2><span class="function">case</span></h2>
<h4>syntax: (case <em>exp-switch</em> (<em>exp-1</em> <em>body-1</em>) [(<em>exp-2</em> <em>body-2</em>) ... ])</h4>

<p>
<em>exp-switch</em> の評価結果が <em>評価されない</em>式 <em>exp-1, exp-2,</em> &ndash; と比較されます。
もし、一致するものが見つかれば、続く <em>body</em> 中の式群が評価されます。
 <em>body</em> の最後の式の結果が <tt>case</tt> 式全体の結果として返ります。<br />
The result of evaluating <em>exp-switch</em> 
is compared to each of the <em>unevaluated</em> expressions 
<em>exp-1, exp-2,</em> &mdash;. If a match is found, the 
corresponding expressions in <em>body</em> 
are evaluated.  The result of the last body expression is returned 
as the result for the entire <tt>case</tt> expression. 
</p>


<!-- example -->

<pre>
(define (translate n)
  (case n
    (1 "one")
    (2 "two")          
    (3 "three")
    (4 "four")
    (true "Can't translate this")))

(translate 3)   <span class='arw'>&rarr;</span> "three"
(translate 10)  <span class='arw'>&rarr;</span> "Can't translate this"
</pre>


<p>この例が示すように、一致するものがなかった時、関数 <tt>case</tt> 本体の最後式を評価するようにできます。<br />
	The example shows how, 
	if no match is found, 
	the last expression in the body of a <tt>case</tt> function
	can be evaluated.
</p>

<br/><br/>

<a name="catch"></a>
<h2><span class="function">catch</span></h2>

<h4>syntax: (catch <em>exp</em>)<br/>
syntax: (catch <em>exp</em> <em>symbol</em>)</h4>

<p>第一構文の <tt>catch</tt> は <em>exp</em> の評価結果か、<em>exp</em> の評価中に実行される <a href="#throw">throw</a> の引数の評価結果を返します：<br />
	In the first syntax, 
	<tt>catch</tt> will return the result of the evaluation of <em>exp</em> 
	or the evaluated argument of a <a href="#throw">throw</a> 
	executed during the evaluation of <em>exp</em>:
</p>

<!-- example -->

<pre>
(catch (dotimes (x 1000) 
  (if (= x 500) (throw x))))  <span class='arw'>&rarr;</span> 500
</pre>


<p>この形式は、繰り返しループからの脱出や関数またはブロック式からの早期強制脱出に使えます：<br />
	This form is useful for breaking out of iteration loops 
	and for forcing an early return 
	from a function or expression block:
</p>


<pre>
(define (foo x)
   &hellip;
  (if condition (throw 123))
    &hellip;
  456)

;; if condition is true

(catch (foo p))  <span class='arw'>&rarr;</span> 123

;; if condition is not true

(catch (foo p))  <span class='arw'>&rarr;</span> 456
</pre>



<p>第二構文の <tt>catch</tt> は、式 <em>exp</em> を評価して結果を <em>symbol</em> に収め、<tt>true</tt> を返します。
評価中にエラーが発生すれば、<tt>catch</tt> は<tt>nil</tt> を返してエラー・メッセージを <em>symbol</em> に収めます。 
この形式は、エラーが関数の可能性のある出力として予想される場合や、エラーがプログラム実行の一環として扱われる時に有効です。<br />
	In the second syntax, 
	<tt>catch</tt> evaluates the expression <em>exp</em>, 
	stores the result in <em>symbol</em>, 
	and returns <tt>true</tt>.  
	If an error occurs during evaluation, 
	<tt>catch</tt> returns <tt>nil</tt> 
	and stores the error message in <em>symbol</em>. 
	This form can be useful when errors are expected 
	as a normal potential outcome of a function 
	and are dealt with during program execution.
</p>

<!-- example -->

<pre>
(catch (func 3 4) 'result)  <span class='arw'>&rarr;</span> nil
result  
<span class='arw'>&rarr;</span> <span class='err'>"ERR: invalid function in function catch : (func 3 4)"</span>

(constant 'func +)          <span class='arw'>&rarr;</span> + &lt;4068A6&gt;
(catch (func 3 4) 'result)  <span class='arw'>&rarr;</span> true
result                      <span class='arw'>&rarr;</span> 7
</pre>


<p><em>exp</em> の評価中に <a href="#throw">throw</a> が実行されると、<tt>catch</tt> は <tt>true</tt> を返し、<tt>throw</tt> の引数が <em>symbol</em> に収められます：<br />
	When a <a href="#throw">throw</a> is executed during the evaluation of <em>exp</em>,
	<tt>catch</tt> will return <tt>true</tt>, 
	and the <tt>throw</tt> argument will be stored in <em>symbol</em>:
</p>


<pre>
(catch (dotimes (x 100) 
  (if (= x 50) (throw "fin"))) 'result)  <span class='arw'>&rarr;</span> true

result  <span class='arw'>&rarr;</span> "fin"
</pre>


<p>関数からの早期脱出や繰り返しループの中断に使えるように、第二構文の <tt>catch</tt> はエラー捕捉にも使うことができます。
ユーザ定義エラーを起こすためには、関数 <a href="#throw-error">throw-error</a> を使います。<br />
	As well as being used for early returns from functions and 
	for breaking out of iteration loops (as in the first syntax), 
	the second syntax of <tt>catch</tt> can also be used to catch errors. 
	The <a href="#throw-error">throw-error</a> function may be used 
	to throw user-defined errors.
</p>

<br/><br/>

<a name="ceil"></a>
<h2><span class="function">ceil</span></h2>
<h4>syntax: (ceil <em>number</em>)</h4>

<p>浮動小数点数 <em>number</em> より大きい最初の整数を返します。<br />
	Returns the next highest integer above <em>number</em> 
	as a floating point.
</p>

<!-- example -->

<pre>
(ceil -1.5)  <span class='arw'>&rarr;</span> -1
(ceil 3.4)   <span class='arw'>&rarr;</span> 4
</pre>


<p>関数 <a href="#floor">floor</a> も見てください。<br />
See also the <a href="#floor">floor</a> function.
</p>

<br/><br/>


<a name="change-dir"></a>
<h2><span class="function">change-dir</span></h2>
<h4>syntax: (change-dir <em>str-path</em>)</h4>

<p><em>str-path</em> で与えられるディレクトリにカレント･ディレクトリを変更します。
成功すれば <tt>true</tt> を、そうでなければ <tt>nil</tt> を返します。<br />
	Changes the current directory to be the one given in <em>str-path</em>.
	If successful, <tt>true</tt> is returned; otherwise <tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(change-dir "/etc")
</pre>


<p><tt>/etc</tt> をカレント･ディレクトリにします。<br />
	Makes <tt>/etc</tt> the current directory.
</p>

<br/><br/>

<a name="char"></a>
<h2><span class="function">char</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (char <em>str</em> [<em>int-index</em> [true]])<br/>
syntax: (char <em>int</em>)</h4>

<p>引数が文字列なら、引数の文字列 <em>str</em> から <em>int-index</em> 位置の文字を取り出し、その文字のアスキー･コードを返します。UTF-8 版 newLISP では Unicode 値を返します。<br />
Given a string argument, extracts the character at <em>int-index</em> from <em>str</em>,
returning either the ASCII value of that character or the Unicode value on UTF-8 enabled 
versions of newLISP.</p>

<p><em>int-index</em> を省略した場合は 0 (zero) として扱われます。
<em>int-index</em> に続けて論理値 <tt>true</tt> を指定すると、<em>str</em> は多バイトの UTF-8 文字列ではなく、８ビットバイト列として扱われます。<br />
If <em>int-index</em> is omitted, 0 (zero) is assumed. If <em>int-idx</em>
is followed by a boolean <tt>true</tt> value, than the index treats <em>str</em> as an 8-bit  byte
array instead of an array of multi-byte UTF-8 characters.</p>

<p>空文字列では <tt>nil</tt> を返しますが、<tt>(char 0)</tt> と <tt>(char nil)</tt> は、どちらも <tt>"\000"</tt> を返します。<br />
The empty string returns <tt>nil</tt>. Both <tt>(char 0)</tt> and <tt>(char nil)</tt> will 
return <tt>"\000"</tt>.</p>

<p><a href="#indexing">文字列、リスト、アレイの要素指定</a> を見てください。<br />
See <a href="#indexing">Indexing elements of strings and lists</a>.
</p>

<p>
引数が整数なら、 <tt>char</tt> は <em>int</em> 値のアスキー文字からなる文字列を返します。<br />
Given an integer argument, 
<tt>char</tt> returns a string containing the ASCII character 
with value <em>int</em>.
</p>

<p>
UTF-8 版の newLISP では、<em>int</em> の値にUnicode を取り、UTF-8 文字が返ります。<br />
On UTF-8&ndash;enabled versions of newLISP, the value in <em>int</em> 
is taken as Unicode and a UTF-8 character is returned.
</p>

<!-- example -->

<pre>
(char "ABC")         <span class='arw'>&rarr;</span> 65  ; ASCII code for "A"
(char "ABC" 1)       <span class='arw'>&rarr;</span> 66  ; ASCII code for "B"
(char "ABC" -1)      <span class='arw'>&rarr;</span> 67  ; ASCII code for "C"
(char "B")           <span class='arw'>&rarr;</span> 66  ; ASCII code for "B"
(char "Ω")           <span class='arw'>&rarr;</span> 937 ; UTF-8 code for "Ω"
(char "Ω" 1 true)    <span class='arw'>&rarr;</span> 169 ; byte value at offset 1

(char 65)  <span class='arw'>&rarr;</span> "A"
(char 66)  <span class='arw'>&rarr;</span> "B"

(char (char 65))  <span class='arw'>&rarr;</span> 65      ; two inverse applications

(map char (sequence 1 255))  ; returns current character set

; The Zen of UTF-8
(char (&amp; (char "生") (char "死"))) <span class='arw'>&rarr;</span> 愛 ; by @kosh_bot
</pre>

<br/><br/>

<a name="chop"></a>
<h2><span class="function">chop</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (chop <em>str</em> [<em>int-chars</em>])<br/>
syntax: (chop <em>list</em> [<em>int-elements</em>])</h4>

<p>
	第一引数が文字列に評価されたなら、<tt>chop</tt> は最後から <em>int-char</em> 個の文字を削除した <em>str</em> のコピーを返します。
引数<em>int-char</em> が無い時は、最後の一文字が削除されます。
<tt>chop</tt> は <em>str</em> を変えません。<br />
	If the first argument evaluates to a string, 
	<tt>chop</tt> returns a copy of <em>str</em> 
	with the last <em>int-char</em> characters omitted.
	If the <em>int-char</em> argument is absent, 
	one character is omitted.
	<tt>chop</tt> does not alter <em>str</em>.</p>


<p>第一引数がリストなら、（文字列と同じように）<em>int-elements</em> 個が削除された <em>list</em> のコピーを返します。<br>
（訳注：この場合、Common Lisp の butlast と同じ。Common Lisp の butlast は文字列に使えません。）<br />
	If the first argument evaluates to a list, 
	a copy of <em>list</em> is returned 
	with <em>int-elements</em> omitted 
	(same as for strings).
</p>

<!-- example -->

<pre>
(set 'str "newLISP")  <span class='arw'>&rarr;</span> "newLISP"
                      
(chop str)    <span class='arw'>&rarr;</span> "newLIS"
(chop str 2)  <span class='arw'>&rarr;</span> "newLI"
                      
str  <span class='arw'>&rarr;</span> "newLISP"

(set 'lst '(a b (c d) e))

(chop lst)    <span class='arw'>&rarr;</span> (a b (c d))
(chop lst 2)  <span class='arw'>&rarr;</span> (a b)
                      
lst  <span class='arw'>&rarr;</span> (a b (c d) e)
</pre>

<br/><br/>

<a name="clean"></a>
<h2><span class="function">clean</span></h2>
<h4>syntax: (clean <em>exp-predicate</em> <em>list</em>)</h4>

<p>述語 <em>exp-predicate</em> が <em>list</em> の各々の要素に適用されます。
返されるリストでは、述語が <tt>true</tt> となる全ての要素が除去されています。<br>
（訳注：CommonLisp の remove-if と同じ。ただし、newLISP の clean は文字列に使えません。
文字列に対しては、<a href="replace">replace</a> で代用します。）<br />
	The predicate <em>exp-predicate</em> is applied 
	to each element of <em>list</em>. 
	In the returned list, 
	all elements for which <em>exp-predicate</em> is <tt>true</tt> 
	are eliminated.
</p>

<p><tt>clean</tt> は、述語を否定形にした <a href="#filter">filter</a> のように動作します。<br />
	<tt>clean</tt> works like <a href="#filter">filter</a> 
	with a negated predicate.
</p>

<!-- example -->

<pre>
(clean symbol? '(1 2 d 4 f g 5 h))   <span class='arw'>&rarr;</span> (1 2 4 5)

(filter symbol? '(1 2 d 4 f g 5 h))  <span class='arw'>&rarr;</span> (d f g h)

(define (big? x) (&gt; x 5))        <span class='arw'>&rarr;</span> (lambda (x) (&gt; x 5))

(clean big? '(1 10 3 6 4 5 11))  <span class='arw'>&rarr;</span> (1 3 4 5)

(clean &lt;= '(3 4 -6 0 2 -3 0))  <span class='arw'>&rarr;</span> (3 4 2)

(clean (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
<span class='arw'>&rarr;</span>  ((b 5) (c 8))
</pre>


<p>述語には、組込述語、ユーザ定義関数、ラムダ式が使えます。<br />
	The predicate may be a built-in predicate 
	or a user-defined function or lambda expression.
</p>

<p>他のリストの数値を使ってリストから数値を除去したい時は、（<em>list</em> オプションで）<a href="#difference">difference</a> か <a href="#intersect">intersect</a> を使ってください。<br>
（訳注：<a href="#difference">difference</a> と <a href="#intersect">intersect</a> の <em>list</em> オプションで、第三引数に <tt>true</tt> を指定するということ）<br />
	For cleaning numbers from one list 
	using numbers from another, 
	use <a href="#difference">difference</a> 
	or <a href="#intersect">intersect</a> 
	(with the list mode option).
</p>

<p>関連する関数として、残る要素の位置を返す <a href="#index">index</a> や述語で true になる要素を返す <a href="#filter">filter</a> も見てください。<br />
	See also the related function <a href="#index">index</a>, 
	which returns the indices of the remaining elements, 
	and <a href="#filter">filter</a>, 
	which returns all elements for which a predicate returns true.
</p>

<br/><br/>


<a name="close"></a>
<h2><span class="function">close</span></h2>
<h4>syntax: (close <em>int-file</em>)</h4>

<p><em>int-file</em> のファイル・ハンドルで指定されたファイルを閉じます。
ハンドルは、先行する <a href="#open">open</a> 操作から得られます。
成功すれば <tt>close</tt> は <tt>true</tt> を返し、そうでなければ <tt>nil</tt> を返します。<br />
	Closes the file specified by the file handle in <em>int-file</em>. 
	The handle would have been obtained 
	from a previous <a href="#open">open</a> operation. 
	If successful, <tt>close</tt> returns <tt>true</tt>; otherwise  <tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(close (device))  <span class='arw'>&rarr;</span> true
(close 7)         <span class='arw'>&rarr;</span> true
(close aHandle)   <span class='arw'>&rarr;</span> true
</pre>


<p><a href="#device">device</a> に対して <tt>close</tt> を使うと、自動的に<tt>device</tt> を 0（ゼロ、スクリーン・デバイス）にリセットしますので注意してください。<br />
	Note that using <tt>close</tt> on <a href="#device">device</a> 
	automatically resets it to 0 (zero, the screen device).
</p>
	
<br/><br/>

<a name="collect"></a>
<h2><span class="function">collect</span></h2>
<h4>syntax: (collect <em>exp</em> [<em>int-max-count</em>])</h4>

<p><em>exp</em> の式を評価して <em>exp</em> の評価が <tt>nil</tt> を返すまで、結果をリストに集めます。<br />
Evaluates the expression in <em>exp</em>  and collects the results in a list
until evaluation of <em>exp</em> returns <tt>nil</tt>.</p>

<p>オプションとして、要素の最大数を <em>int-max-count</em> に指定できます。<br />
Optionally a maximum count of elements can be specified in <em>int-max-count</em>.</p>

<pre>
; collect results until nil is returned
(set 'x 0)
(collect (if (&lt;= (inc x) 10) x)) <span class='arw'>&rarr;</span> (1 2 3 4 5 6 7 8 9 10)

; collect results until nil is returned or 6 results are collected
(set 'x 0)
(collect (if (&lt;= (inc x) 10) x) 6) <span class='arw'>&rarr;</span> (1 2 3 4 5 6)
</pre>

<br/><br/>

<a name="command-event"></a>
<h2><span class="function">command-event</span></h2>
<h4>syntax: (command-event <em>sym-event-handler</em> | <em>func-event-handler</em>)
syntax: (command-event nil)</h4>

<p>newLISP コマンド･ラインで評価を得る前に事前処理（プリ・プロセス）するためのユーザ定義関数を指定します。
これは、インタラクティブ newLISP シェルのカスタマイズやサーバー･モードで動作している時の HTTP <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>の変更に使えます。<br />
Specifies a user defined function for pre-processing the newLISP command-line
before it gets evaluated. This can be used to write customized interactive
 newLISP shells and to transform HTTP requests when running in server mode.</p>

<p><tt>command-event</tt> は、ユーザ定義関数のシンボルかラムダ関数のどちらかを取ります。
イベント・ハンドラ関数が文字列を返さなければ、コマンド・ラインは未翻訳のまま newLISP に渡されます。<br />
<tt>command-event</tt> takes either a symbol of a user-defined function or a lambda 
function. The event-handler function must return a string or the command-line will be 
passed untranslated to newLISP.</p>

<p>強制的にプロンプトになってコマンド処理ができなくなると、関数は空文字列 <tt>""</tt> を返します。
<tt>command-event</tt> をリセットするには、第二構文を使ってください。<br />
To only force a prompt and disable command processing, the function should return 
the empty string <tt>""</tt>. To reset <tt>command-event</tt>, use the second syntax.</p>

<p>次の例では、コマンドが文字で始まる時、newLISP シェルは通常の Unix シェルのように動作します。
しかし、開き括弧やスペースで始まると newLISP の評価が始まります。<br />
The following example makes the newLISP shell work like a normal Unix
shell when the command starts with a letter. But starting the line with an open
parenthesis or a space initiates a newLISP evaluation.</p>

<!-- example -->

<pre>
(command-event (fn (s) 
	(if (starts-with s "[a-zA-Z]" 0) (append "!" s) s)))
</pre>


<p>
関連する <a href="#prompt-event">prompt-event</a> も見てください。
newLISP プロンプトをよりカスタマイズしたインタラクティブ・モードにできます。<br />
See also the related <a href="#prompt-event">prompt-event</a> which can be used
for further customizing interactive mode by modifying the newLISP prompt.</p>

<p>次のプログラムは、スタンド･アロンで使うことも、newLISP のスタート･アップ・ファイル <tt>init.lsp</tt> 内に入れることもできます：<br />
The following program can be used either stand-alone or included in newLISP's
<tt>init.lsp</tt> startup file:</p>

<pre>
#!/usr/local/bin/newlisp

; set the prompt to the current directory name
(prompt-event (fn (ctx) (append (real-path) "&gt; ")))

; pre-process the command-line
(command-event (fn (s) 
    (if 
        (starts-with s "cd") 
        (string " " (true? (change-dir (last (parse s " ")))))

        (starts-with s "[a-zA-Z]" 0)
        (append "!" s)

        true s)))
</pre> 

<p>コマンド･ライン翻訳関数の定義では、Unixコマンド <tt>cd</tt> が特別に扱われ、newLISP プロセスにとってもディレクトリが変更されます。
この方法なら、<tt>!</tt> でコマンド･シェルに出てから戻って来ても、newLISP はディレクトリの変更を保持します。<br>
（訳注：単純に、コマンド・シェルに出てからディレクトリを変更しても、newLISP には反映されません。上記スクリプトのように、<a href="change-dir">change-dir</a> の実行が必要です。）<br />
In the definition of the command-line translation function the Unix
command <tt>cd</tt> gets a special treatment, to make sure that the directory
is changed for newLISP process too. This way when shelling out with <tt>!</tt> and
coming back, newLISP will maintain the changed directory.</p>

<p>（訳注：上記例では）newLISP のコマンド入力には、最初にスペースか開き括弧が必要です。
Unix コマンドは、行の最初から入力する必要があります。<br />
Command lines for newLISP must start either with a space or an opening
parenthesis. Unix commands must start at the beginning of the line.</p>

<p>newLISP がオプションの <tt>-c</tt> や <tt>-http</tt> を使ってサーバー･モードで走っている時は、次のような HTTP <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を受け取ります：<br />
When newLISP is running in server mode either using the <tt>-c</tt> or
<tt>-http</tt> option, it receives HTTP requests similar to the following:</p>

<pre>
GET /index.html
</pre> 

<p>あるいは、関連入り<ruby>質問<rp>（</rp><rt>クエリ</rt><rp>）</rp></ruby>なら：<br />
Or if a query is involved:</p>

<pre>
GET /index.cgi?userid=joe&amp;password=secret
</pre> 

<p><tt>command-event</tt> で指定された関数は、<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>ラインをフィルタまたは変形します。すなわち、全ての<ruby>質問<rp>（</rp><rt>クエリ</rt><rp>）</rp></ruby>において、<tt>.exe</tt> で終わるファイルを使っている CGI の実行を試そうとする<ruby>質問<rp>（</rp><rt>クエリ</rt><rp>）</rp></ruby>を検索し、そういう<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>ならエラー･ページの<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>に変更します：<br />
A function specified by <tt>command-event</tt> could filter and transform 
these request lines, e.g.: discovering all queries trying to perform CGI using
a file ending in <tt>.exe</tt>.&nbsp; Such a request would be translated into a
request for an error page:</p>

<pre>
;; httpd-conf.lsp
;;
;; filter and translate HTTP requests for newLISP
;; -c or -http server modes
;; reject query commands using CGI with .exe files

(command-event (fn (s)
    (let (request s)
        (when (find "?" s) ; is this a query
            (set 'request (first (parse s "?")))
            ; discover illegal extension in queries
            (when (ends-with request ".exe")
                (set 'request "GET /errorpage.html")) )
        request)
))
</pre> 

<p><tt>newlisp httpd-conf.lsp -c -d80 -w ./httpdoc</tt> でサーバー･モードを開始した時に、newLISPの方で、入力<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>や<ruby>質問<rp>（</rp><rt>クエリ</rt><rp>）</rp></ruby>をフィルタするための <tt>command-event</tt> の定義をロードしておきます：<br />
When starting the server mode with <tt>newlisp httpd-conf.lsp -c -d80 -w ./httpdoc</tt>
newLISP will load the definition for <tt>command-event</tt> for filtering incoming
requests, and the query:</p>

<pre>
GET /cmd.exe?dir
</pre> 

<p>そうすれば、（訳注：上記<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>は）次のように変換されます：<br />Would be translated into:</p>

<pre>
GET /errorpage.html
</pre> 

<p>MS Windows ベースで設定の悪いウェブ･サーバーの制御を得るために、スパマーが過去において煩雑に使っていた技術を、この例は示しています。<br />
The example shows a technique frequently used in the past by spammers on MS Windows based, bad configured 
web servers to gain control over servers.</p>

<p><tt>httpd-conf.lsp</tt> ファイルは、インタラクティブ newLISP セッションへのファイルロードや手動の HTTP <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>入力を簡単にデバックできます。
newLISP はコマンド･ラインを翻訳し、それを組込ウェブ･サーバーに割り当てます。
サーバー出力はシェル･ウィンドウに現れます。<br />
<tt>httpd-conf.lsp</tt> files can easily be debugged loading the file into an interactive
newLISP session and entering the HTTP requests manually. newLISP will translate the command
line and dispatch it to the built-in web server. The server output will appear in the shell
window.</p>

<p>注記：コマンド・ラインの長さは、HTTP <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>・ヘッダの行の長さと同様に、newLISP では 512 文字に制限されます。<br />
Note, that the command line length as well as the line length in HTTP headers is limited to 512 characters for newLISP.</p>

<br/><br/>

<a name="cond"></a>
<h2><span class="function">cond</span></h2>

<h4>syntax: (cond (<em>exp-condition-1</em> <em>body-1</em>) [(<em>exp-condition-2</em> <em>body-2</em>) ... ])</h4>

<p><tt>cond</tt> は <tt>if</tt> のように、条件によって本体内の式を評価します。
<tt>nil</tt> や空リスト <tt>()</tt> 以外に評価される <em>exp-condition-i</em> が見つかるまで、<em>exp-condition</em>は順番に評価されます。
それから、<em>body-i</em> の評価結果を <em>cond-expression</em> 節全体の結果として返します。
全ての条件が <tt>nil</tt> か空リストなら、<em>cond</em> は最後の <em>cond-expression</em> の値を返します。<br />
	Like <tt>if</tt>, <tt>cond</tt> conditionally evaluates the expressions 
	within its body. 
	The <em>exp-condition</em>s are evaluated in turn, 
	until some <em>exp-condition-i</em> is found 
	that evaluates to anything other than <tt>nil</tt> 
	or an empty list <tt>()</tt>.
	The result of evaluating <em>body-i</em> 
	is then returned as the result of the entire <em>cond-expression</em>. 
	If all conditions evaluate to <tt>nil</tt> 
	or an empty list,
	<em>cond</em> returns the value of the last <em>cond-expression</em>.
</p>

<!-- example -->

<pre>
(define (classify x)
  (cond
    ((&lt; x 0) "negative")
    ((&lt; x 10) "small")
    ((&lt; x 20) "medium")
    ((&gt;= x 30) "big")))

(classify 15)   <span class='arw'>&rarr;</span> "medium"
(classify 22)   <span class='arw'>&rarr;</span> "nil"
(classify 100)  <span class='arw'>&rarr;</span> "big"
(classify -10)  <span class='arw'>&rarr;</span> "negative"
</pre>


<p><em>body-n</em> が見つからない時は、最後の <em>cond-expression</em> の評価値が返されます。
もし <tt>true</tt> に評価される条件がなければ、最後の条件式の値が返ります（つまり、<tt>nil</tt> か空リスト）。<br />
	When a <em>body-n</em> is missing, 
	the value of the last <em>cond-expression</em> evaluated 
	is returned. 
	If no condition evaluates to <tt>true</tt>, 
	the value of the last conditional expression is returned
	(i.e., <tt>nil</tt> or an empty list).
</p>


<pre>
(cond ((+ 3 4)))  <span class='arw'>&rarr;</span> 7
</pre>


<p>複数の引数を持つ関数 <a href="#if">if</a> は、条件・本体ペアを囲む余分な括弧を必要とせずに <tt>cond</tt> のように動作します。<br />
	When used with multiple arguments, 
	the function <a href="#if">if</a> 
	behaves like <tt>cond</tt>, 
	except it does not need extra parentheses 
	to enclose the condition-body pair 
	of expressions.
</p>

<br/><br/>

<a name="cons"></a>
<h2><span class="function">cons</span></h2>
<h4>syntax: (cons <em>exp-1</em> <em>exp-2</em>)</h4>

<p><em>exp-2</em> がリストとして評価されるなら、<em>exp-1</em> の評価結果がリストの第一要素として挿入されて返されます。
<em>exp-2 </em> がリスト以外に評価された時は、<em>exp-1</em> の評価結果と <em>exp-2</em> がリストになって返されます。
newLISP には、<em>ドット対</em> がないことに注意してください。
二つのアトムを <em>cons</em> することは、ドット対でないリストを作成します。<br />
	If <em>exp-2</em> evaluates to a list, 
	then a list is returned with the result of evaluating <em>exp-1</em> 
	inserted as the first element. 
	If <em>exp-2 </em>evaluates to anything other than a list, 
	the results of evaluating <em>exp-1</em> and <em>exp-2</em> 
	are returned in a list. 
	Note that there is no <em>dotted pair</em> in newLISP:
	<em>cons</em>ing two atoms constructs a list, not a dotted pair.
</p>

<!-- example -->

<pre>
(cons 'a 'b)            <span class='arw'>&rarr;</span> (a b)
(cons 'a '(b c))        <span class='arw'>&rarr;</span> (a b c)
(cons (+ 3 4) (* 5 5))  <span class='arw'>&rarr;</span> (7 25)
(cons '(1 2) '(3 4))    <span class='arw'>&rarr;</span> ((1 2) 3 4)
(cons nil 1)            <span class='arw'>&rarr;</span> (nil 1)
(cons 1 nil)            <span class='arw'>&rarr;</span> (1 nil)
(cons 1)                <span class='arw'>&rarr;</span> (1)
(cons)			<span class='arw'>&rarr;</span> ()
</pre>


<p>newLISP の <tt>cons</tt> は、式 <tt>(cons 's nil)</tt> の結果として <tt>(s)</tt> を返す他の Lisp と違い、<tt>(s nil)</tt> を返します。
newLISP において <tt>nil</tt> は論理値で、空リストと同じではありません。
一つの newLISP セルは、一つの値のみ保持します。<br />
	Unlike other Lisps that return <tt>(s)</tt>
	as the result of the expression <tt>(cons 's nil)</tt>, 
	newLISP's <tt>cons</tt> returns <tt>(s nil)</tt>. 
	In newLISP, <tt>nil</tt> is a Boolean value 
	and is not equivalent to an empty list, 
	and a newLISP cell holds only one value.
</p>

<p><tt>cons</tt> は、<a href="#first">first</a> と <a href="#rest">rest</a> の逆操作のように動作します（リストが一対なら、<a href="#first">first</a> と <a href="#last">last</a>）：<br />
	<tt>cons</tt> behaves like the inverse operation of <a href="#first">first</a>
and <a href="#rest">rest</a> 
	(or <a href="#first">first</a> and <a href="#last">last</a> if the list is a pair):
</p>


<pre>
(cons (first '(a b c)) (rest '(a b c)))  <span class='arw'>&rarr;</span> (a b c)

(cons (first '(x y)) (last '(x y)))      <span class='arw'>&rarr;</span> (x y)
</pre>

<br/><br/>

<a name="constant"></a>
<h2><span class="function">constant</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (constant <em>sym-1</em> <em>exp-1</em> [<em>sym-2</em> <em>exp-2</em>] ... )</h4>

<p>機能的には <a href="#set">set</a> と同等です。
その上で <tt>constant</tt> は、シンボルをプロテクトし、以降の変更をできなくします。
関数 <tt>constant</tt> でセットされたシンボルは、再び <tt>constant</tt> を使うことでのみ、変更できます。
<tt>constant</tt> でプロテクトされたシンボルの内容を変更しようとすると、newLISP はエラー・メッセージを出します。
現在のコンテキストのシンボルだけに、<tt>constant</tt> を使うことができます。
これにより、ホーム・コンテキストでプロテクトされたシンボルの書き換えが防止されます。
最後の <em>exp-n</em> 初期値は常にオプションです。<br />
	Identical to <a href="#set">set</a> in functionality,
	<tt>constant</tt> further protects the symbols from subsequent modification. 
	A symbol set with <tt>constant</tt> can only be modified 
	using the <tt>constant</tt> function again.  
	When an attempt is made to modify the contents of a symbol protected with <tt>constant</tt>, 
	newLISP generates an error message. 
	Only symbols from the current context can be used with <tt>constant</tt>. 
	This prevents the overwriting of symbols 
	that have been protected in their home context.
	The last <em>exp-n</em> initializer is always optional.

</p>

<p><a href="#set">set</a>、<a href="#define">define</a>、<a href="#define-macro">define-macro</a> で初期化されたシンボルも、関数 <tt>constant</tt> を使ってプロテクトできます：<br />
	Symbols initialized with <a href="#set">set</a>, <a href="#define">define</a>, 
	or <a href="#define-macro"> define-macro</a> can still be protected by using 
	the <tt>constant</tt> function:
</p>

<pre>
(constant 'aVar 123)  <span class='arw'>&rarr;</span> 123
(set 'aVar 999) 
<span class='err'>ERR: symbol is protected in function set: aVar</span>

(define (double x) (+ x x))

(constant 'double)

;; equivalent to

(constant 'double (fn (x) (+ x x)))
</pre>


<p>一番目の例は、他の <tt>constant</tt> 宣言文によってのみ変更できる定数 <tt>aVar</tt> を定義しています。
二番目の例は、（<tt>constant</tt> 以外による）変更から <tt>double</tt> をプロテクトします。
newLISP の関数定義はラムダ関数の割り当てと等価ですから、この二ステップは最後の行の宣言文のように一つにまとめられます。
これは重量なテクニックで、一つのファイルが複数回ロードされる時のプロテクション・エラーを避けることができます。<br />
	The first example defines a constant, <tt>aVar</tt>, 
	which can only be changed by using another <tt>constant</tt> statement. 
	The second example protects <tt>double</tt> from being changed
	(except by <tt>constant</tt>). 
	Because a function definition in newLISP 
	is equivalent to an assignment of a lambda function, 
	both steps can be collapsed into one, 
	as shown in the last statement line. 
	This could be an important technique 
	for avoiding protection errors 
	when a file is loaded multiple times.
</p>

<p>割り当てる最後の値は、省略可能です。
<tt>constant</tt> は最後にセットされ、プロテクトされたシンボルの内容を返します。<br />
	The last value to be assigned can be omitted. 
	<tt>constant</tt> returns the contents of
	the last symbol set and protected.
</p>

<p>組込関数をシンボルに割り当てたり、組込関数名に他の違う関数を割り当て再定義したりすることも可能です。
関数名を変更しても、性能は変わりません。<br />
	Built-in functions can be assigned to symbols 
	or to the names of other built-in functions, 
	effectively redefining them as different functions.
	There is no performance loss when renaming functions.
</p>


<pre>
(constant 'squareroot sqrt)  <span class='arw'>&rarr;</span> sqrt &lt;406C2E&gt;
(constant '+ add)            <span class='arw'>&rarr;</span> add &lt;4068A6&gt;
</pre>


<p><tt>squareroot</tt> は <tt>sqrt</tt> のように振舞います。
<tt>+</tt>（＋記号）は <tt>add</tt> の混合型浮動小数点数モードを使えるように再定義されます。
結果として表示される 16 進数は組込関数のバイナリ・アドレスで、プラットフォームや OS で異なる値になります。<br />
	<tt>squareroot</tt> will behave like <tt>sqrt</tt>. 
	The <tt>+</tt> (plus sign) is redefined 
	to use the mixed type floating point mode of <tt>add</tt>. 
	The hexadecimal number displayed in the result 
	is the binary address of the built-in function 
	and varies on different platforms and OSes.
</p>

<br/><br/>

<a name="context"></a>
<h2><span class="function">context</span></h2>
<h4>syntax: (context [<em>sym-context</em>])<br/>
syntax: (context <em>sym-context</em> <em>str | sym</em> [<em>exp-value</em>])</h4>

<p> 第一構文の <tt>context</tt> は異なる名前空間のコンテキストに切り替えます。
これに続く newLISPソースの <a href="#load">load</a> や <a href="#eval-string">eval-string</a> と <a href="#sym">sym</a> のような関数は、新たに生成するシンボルを新たなコンテキストに置きます。<br />
 In the first syntax, <tt>context</tt> is used to switch to a different context namespace. 
Subsequent <a href="#load">load</a>s of newLISP source or functions like 
<a href="#eval-string">eval-string</a> and <a href="#sym">sym</a> will put newly created 
symbols and function definitions in the new context.</p>

<p>コンテキストの生成が必要な場合には、新コンテキストのシンボル名を指定すべきです。
<tt>context</tt> に渡される引数が無い時は、現コンテキストのシンボル名が返ります。<br />
If the context still needs to be created, the symbol for the new context should be specified. 
When no argument is passed to <tt>context</tt>, then the symbol for the current context is returned. </p>

<p>コンテキストはそれ自身に評価されるので、異なるコンテキストに切り替える際、そのコンテキストが既に存在しているなら、クォートは必要ありません。<br />
Because contexts evaluate to themselves, a quote is not necessary 
to switch to a different context if that context already exists.
</p>

<!-- example -->

<pre>
(context 'GRAPH)          ; create / switch context GRAPH

(define (foo-draw x y z)  ; function resides in GRAPH
  (&hellip;))
                                
(set 'var 12345)
(symbols)  <span class='arw'>&rarr;</span> (foo-draw var)  ; GRAPH has now two symbols

(context MAIN)               ; switch back to MAIN (quote not required)

(print GRAPH:var) <span class='arw'>&rarr;</span> 12345    ; contents of symbol in GRAPH

(GRAPH:foo-draw 10 20 30)    ; execute function in GRAPH
(set 'GRAPH:var 6789)        ; assign to a symbol in GRAPH
</pre>


<p>コンテキストが存在する前に、そのコンテキストのシンボルが参照されると、暗黙の内にコンテキストが生成されます。<br />
	If a context symbol is referred to before the context exists, 
	the context will be created implicitly.
</p>


<pre>
(set 'person:age 0)       ; no need to create context first
(set 'person:address "")  ; useful for quickly defining data structures
</pre>


<p>コンテキストは（訳注：組込関数 <a href="#new">new</a> を使って）コピー可能です：<br />
	Contexts can be copied:
</p>


<pre>
(new person 'JohnDoe)  <span class='arw'>&rarr;</span>  JohnDoe

(set 'JohnDoe:age 99)
</pre>


<p>変数を使って、コンテキストを参照することもできます：<br />
	Contexts can be referred to by a variable:
</p>


<pre>
(set 'human JohnDoe)

human:age  <span class='arw'>&rarr;</span> 99

(set 'human:address "1 Main Street")

JohnDoe:address  <span class='arw'>&rarr;</span> "1 Main Street"
</pre>



<p>評価されたコンテキスト（クォート無し）を引数として与えることもできます：<br />
An evaluated context (no quote) can be given as an argument:
</p>


<pre>
<b>&gt;</b> (context 'FOO)
<b>FOO</b>
<b>FOO></b> (context MAIN)
<b>MAIN</b>
<b>&gt;</b> (set 'old FOO)
FOO
<b>&gt;</b> (context 'BAR)
<b>BAR</b>
<b>BAR></b> (context MAIN:old)
<b>FOO</b>
<b>FOO></b> 
</pre>



<p>同じシンボルが既に存在するなら、コンテキストとして再定義されます。<br />
	If an identifier with the same symbol already exists, 
	it is redefined to be a context.
</p>

<p>現コンテキスト内でのシンボルは、組込関数や <tt>nil</tt> と <tt>true</tt> のような特殊シンボルのように、それらの名前だけで参照されます。
現コンテキスト外でのシンボルは、コンテキストのシンボル名と <tt>:</tt>（コロン）を先頭に付加することで、参照できます。
異なるコンテキスト内のシンボルの引用には、コンテキスト名に <tt>'</tt>（シングル・クォート）を付加します。<br />
	Symbols within the current context 
	are referred to simply by their names, 
	as are built-in functions and special symbols 
	like <tt>nil</tt> and <tt>true</tt>. 
	Symbols outside the current context 
	are referenced by prefixing the symbol name 
	with the context name and a <tt>:</tt> (colon). 
	To quote a symbol in a different context, 
	prefix the context name with a <tt>'</tt> (single quote).
</p>

<p>与えられたコンテキスト内で、組込関数や MAIN のコンテキスト・シンボルと同じ名前を生成するかもしれません。
コンテキストを先付けしたシンボルは、（訳注：そのコンテキスト内で使われる）MAIN のシンボルを上書きします：<br />
	Within a given context, symbols may be created 
	with the same name as built-in functions 
	or context symbols in MAIN.
	This overwrites the symbols in MAIN 
	when they are prefixed with a context:
</p>


<pre>
(context 'CTX)
(define (CTX:new var)
    (&hellip;))
    
(context 'MAIN)
</pre>


<p><tt>CTX:new</tt> は、MAIN の new を上書きします。
（訳注：コンテキスト CTX 内で、new は組込関数の <a href="#new">new</a> ではなく、上記で定義した関数 new になります。この時、コンテキスト CTX 内で組込関数 <a href="#new">new</a> を使うには MAIN:new とします。）<br />
<tt>CTX:new</tt> will overwrite new in MAIN.</p>

<p> 第二構文の <tt>context</tt> は名前空間でのシンボルを生成に使えます。
ハッシュや辞書の生成では、これを使用すべきでないことに注意してください。
ハッシュのような辞書として名前空間を使う簡単な方法については、手始めに<a href="#hash">ハッシュ機能と辞書</a>の章を見てください。<br />
 In the second syntax, <tt>context</tt> can be used to create symbols in a namespace.
Note that this should not be used for creating hashes or dictionaries. For a shorter,
more convenient method to use namespaces as hash-like dictionaries, see the chapter 
<a href="#hash">Hash functions and dictionaries</a>.
</p>


<pre>
;; create a symbol and store data in it
(context 'Ctx "abc" 123)   <span class='arw'>&rarr;</span> 123
(context 'Ctx 'xyz 999)    <span class='arw'>&rarr;</span> 999

;; retrieve contents from  symbol
(context 'Ctx "abc")       <span class='arw'>&rarr;</span> 123
(context 'Ctx 'xyz)        <span class='arw'>&rarr;</span> 999
Ctx:abc                    <span class='arw'>&rarr;</span> 123
Ctx:xyz                    <span class='arw'>&rarr;</span> 999
</pre>


<p>最初の三つの宣言文は、シンボルを生成して何らかのデータ型の値を格納します。
最初の宣言文は、<tt>Ctx</tt> と命名されるコンテキストも生成します。
名前としてシンボルを指定すると、その名前がシンボルから取られ、コンテキスト <tt>Ctx</tt> に同じ名前のシンボルが生成されます。<br />
The first three statements create a symbol and store a value of any data type inside. 
The first statement also creates the context named <tt>Ctx</tt>.
When a symbol is specified for the name, the name is taken
from the symbol and creates a symbol with the same name
in the context <tt>Ctx</tt>.
</p>

<p>シンボルには、newLISPの変数名として使えるシンボルに許可されていないスペースや他の特殊文字を含めることができます。
<tt>context</tt> の第二構文は新しいシンボルのみ生成し、それに含まれる値を返します。新しい名前空間への切り替えはしません。<br />
Symbols can contain spaces or any other special characters 
not typically allowed in newLISP symbols being used as variable names. 
This second syntax of <tt>context</tt> only creates the new symbol 
and returns the value contained in it.  It does not switch to the new namespace.
</p>

<br/><br/>

<a name="contextp"></a>
<h2><span class="function">context?</span></h2>

<h4>syntax: (context? <em>exp</em>)<br/>
syntax: (context? <em>exp</em> <em>str-sym</em>)</h4>

<p>第一構文の <em>context?</em> は、<em>exp</em> がコンテキストに評価される時 <tt>true</tt>を、そうでない時 <tt>nil</tt> を返す述語です。<br />
	In the first syntax, 
	<em>context?</em> is a predicate that returns <tt>true</tt> 
	only if <em>exp</em> evaluates to a context; 
	otherwise, it returns <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(context? MAIN)  <span class='arw'>&rarr;</span> true
(set 'x 123)
(context? x)     <span class='arw'>&rarr;</span> nil

(set 'FOO:q "hola")  <span class='arw'>&rarr;</span> "hola"
(set 'ctx FOO)
(context? ctx)       <span class='arw'>&rarr;</span> true  ; ctx contains context foo
</pre>


<p>
	第二構文では、コンテキスト中のシンボルの存在をチェックします。
	シンボルは <em>str-sym</em> の文字列で指定します。<br />
	The second syntax checks for the existence of a symbol in a context. 
	The symbol is specified by its name string in <em>str-sym</em>.
</p>


<pre>
(context? FOO "q")  <span class='arw'>&rarr;</span> true
(context? FOO "p")  <span class='arw'>&rarr;</span> nil
</pre>


<p>名前空間の変更や生成、コンテキスト中のハッシュ･シンボルの生成には、<a href="#context">context</a> を使ってください。
<br />
	Use <a href="#context">context</a> to change and create namespaces 
	and to create hash symbols in contexts.
</p>

<br/><br/>

<a name="copy"></a>
<h2><span class="function">copy</span></h2>
<h4>syntax: (copy <em>exp</em>)<br/>
syntax: (copy <em>int-addr</em> [<em>bool-flag</em>])</h4>

<p>第一構文は評価した式をコピーを作ります。
組込関数には<a href="#destructive">破壊的</a>なものがあり、動作中に元のリストやアレイ、文字列の中身を変更します。
<tt>copy</tt> と一緒に使えば、その動作を非破壊にできます。<br />
The first syntax makes a copy from evaluating expression in <em>exp</em>. 
Some built-in functions are <a href="#destructice">destructive</a>, changing 
the original contents of a list, array or string they are working on. 
With <tt>copy</tt> their behavior can be made non-destructive.</p>

<pre>
(set 'aList '(a b c d e f))

(replace 'c (copy aList)) <span class='arw'>&rarr;</span> (a b d e f)

aList <span class='arw'>&rarr;</span> (a b c d e f)

(set 'str "newLISP") <span class='arw'>&rarr;</span> "newLISP"

(rotate (copy str)) <span class='arw'>&rarr;</span> "PnewLIS"

str <span class='arw'>&rarr;</span> "newLISP" 
</pre>

<p>関数 <a href="#replace">replace</a> や <a href="#rotate">rotate</a> に <tt>copy</tt> を使うことで、元データの変更が防がれます。
変更されたデータが返ります。<br />
Using <tt>copy</tt> the functions <a href="#replace">replace</a> and
<a href="#rotate">rotate</a> are prevented from changing the data.
A modified version of the data is returned.</p>

<p><em>bool-flag</em> を <tt>true</tt> にする第二構文では、メモリ・アドレスから newLISP 式をコピーします。次の二式は等価です：<br />
The second syntax, marked by the <tt>true</tt> in <em>bool-flag</em>,
copies a newLISP expression from a memory address.The following two
expressions are equivalent:</p>

<pre>
(set 'x "hello world")
(copy x)  <span class='arw'>&rarr;</span> "hello world"
(copy (first (dump x)) true) <span class='arw'>&rarr;</span> "hello world"
</pre>

<p>第二構文は newLISP 式を生成する C コードとのインターフェイスに役立ちます。<br />
The second syntax can be useful when interfacing with C-code generating
newLISP expressions.</p>


<br/><br/>

<a name="copy-file"></a>
<h2><span class="function">copy-file</span></h2>
<h4>syntax: (copy-file <em>str-from-name</em> <em>str-to-name</em>)</h4>

<p><em>str-from-name</em> で与えられたパス・ファイル名のファイルを <em>str-to-name</em> で与えられるパス・ファイル名のファイルにコピーします。
コピーが成功すれば <tt>true</tt> が返り、失敗すれば <tt>nil</tt> が返ります。<br />
	Copies a file from a path-filename given in <em>str-from-name</em> 
	to a path-filename given in <em>str-to-name</em>. 
	Returns <tt>true</tt> if the copy was successful or <tt>nil</tt>, 
	if the copy was unsuccessful.
</p>

<!-- example -->

<pre>
(copy-file "/home/me/newlisp/data.lsp" "/tmp/data.lsp")
</pre>

<br/><br/>

<a name="cos"></a>
<h2><span class="function">cos</span></h2>
<h4>syntax: (cos <em>num-radians</em>)</h4>

<p><em>num-radians</em> の余弦を計算し、結果を返します。<br />
	Calculates the cosine of <em>num-radians</em>
	and returns the result.
</p>

<!-- example -->

<pre>
(cos 1)                     <span class='arw'>&rarr;</span> 0.5403023059
(set 'pi (mul 2 (acos 0)))  <span class='arw'>&rarr;</span> 3.141592654
(cos pi)                    <span class='arw'>&rarr;</span> -1
</pre>

<br/><br/>

<a name="corr"></a>
<h2><span class="function">corr</span></h2>
<h4>syntax: (corr <em>list-vector-X</em> <em>list-vector-Y</em>)</h4>

<p><em>list-vector-X</em> と <em>list-vector-Y</em> の二変数間の測定値の直線相関について、<em>ピアソン</em> の累積相関係数を計算します。
双方のリストは同じ長さであることが必要です。<br />
Calculates the <em>Pearson</em> product-moment correlation coefficient as a measure
of the linear relationship between the two variables in  <em>list-vector-X</em>
and  <em>list-vector-Y</em>. Both lists must be of same length.</p>

<p><tt>corr</tt> は次の値からなるリストです:<br /><tt>corr</tt> returns a list containing the following values:</p>

<table>
<tr align="left"><th>name</th><th>description</th></tr>
<tr><td>r</td><td>相関係数<br />Correlation coefficient</td></tr>
<tr><td>b0</td><td>回帰切片係数<br />Regression coefficient offset</td></tr>
<tr><td>b1</td><td>回帰傾き係数<br />Regression coefficient slope</td></tr>
<tr><td>t</td><td>優位検定の（訳注:スチューデントの）t 統計値<br />t - statistic for significance testing</td></tr>
<tr><td>df</td><td>自由度<br />Degrees of freedom for t</td></tr>
<tr><td>p</td><td>帰無仮説下での（訳注:スチューデントの）t の尾部両側の確率<br />Two tailed probability of t under the null hypothesis</td></tr>
</table>
<br />
<!-- example -->

<pre>
(set 'study-time '(90 100 130 150 180 200 220 300 350 400))
(set 'test-errors '(25 28 20 20 15 12 13 10 8 6))

(corr study-time test-errors) <span class='arw'>&rarr;</span> (-0.926 29.241 -0.064 -6.944 8 0.0001190)
</pre>

<p>帰無仮説下での尾部両側の <tt>p</tt> が約 <tt>0.0001</tt> なので、<tt>study-time</tt> と <tt>test-errors</tt> の <tt>-0.926</tt> という負の相関係数は高い有意性があります。<br />
The negative correlation of <tt>-0.926</tt> between study time and test errors is 
highly significant with a two-tailed <tt>p</tt> of about <tt>0.0001</tt> under the null hypothesis.</p>

<p><tt>b0 = 29.241</tt> と <tt>b1 = -0.064</tt> の回帰係数を方程式 <tt><em><b>Y = b0 + b1 * X</b></em></tt> に使えば、X (study time) の値から変数 Y (test errors) の値を推定できます。<br />
The regression coefficients <tt>b0 = 29.241</tt> and <tt>b1 = -0.064</tt>
can be used to estimate values of the Y variable (test errors) from values in X (study time)
using the equation <tt><em><b>Y = b0 + b1 * X</b></em></tt>.</p>

<br/><br/>

<a name="cosh"></a>
<h2><span class="function">cosh</span></h2>
<h4>syntax: (cosh <em>num-radians</em>)</h4>

<p><em>num-radians</em> の双曲線余弦を計算します。
双曲線余弦は次の数式で定義されます： <em>(exp (x) + exp (-x)) / 2</em>。
<em>num-radians</em> が大きすぎるとオーバーフロー <tt>inf</tt> が発生します。<br />
Calculates the hyperbolic cosine of <em>num-radians</em>. 
The hyperbolic cosine is defined mathematically as: 
<em>(exp (x) + exp (-x)) / 2</em>.
An overflow to <tt>inf</tt> may occur 
if <em>num-radians</em> is too large.</p>

<!-- example -->

<pre>
(cosh 1)     <span class='arw'>&rarr;</span> 1.543080635
(cosh 10)    <span class='arw'>&rarr;</span> 11013.23292
(cosh 1000)  <span class='arw'>&rarr;</span> inf
(= (cosh 1) (div (add (exp 1) (exp -1)) 2))  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="count"></a>
<h2><span class="function">count</span></h2>
<h4>syntax: (count <em>list-1</em> <em>list-2</em>)</h4>

<p><em>list-2</em> 中の <em>list-1</em> の要素を数え、その計数値のリストを返します。<br />
	Counts elements of <em>list-1</em> in <em>list-2</em> 
	and returns a list of those counts.
</p>

<!-- example -->

<pre>
(count '(1 2 3) '(3 2 1 4 2 3 1 1 2 2))  <span class='arw'>&rarr;</span> (3 4 2)
(count '(z a) '(z d z b a z y a))        <span class='arw'>&rarr;</span> (3 2)

(set 'lst (explode (read-file "myFile.txt")))
(set 'letter-counts (count (unique lst) lst))
</pre>

<p>二番目の例は、<tt>myFile.txt</tt> に出現する異なる文字を全て計数します。<br />
	The second example counts all occurrences 
	of different letters in <tt>myFile.txt</tt>.
</p>

<p> <tt>count</tt> の二番目のリストで計数する要素を指定する <tt>count</tt> の最初のリストは、単一であるべきです。
単一でない要素（訳注：ダブっている要素）があると、最初の存在が計数値を持ち、後の要素は <tt>0</tt>（ゼロ）になります。<br />
	The first list in <tt>count</tt>, 
	which specifies the items to be counted in the second list, 
	should be unique. 
	For items that are not unique, 
	only the first instance will carry a count; 
	all other instances will display <tt>0</tt> (zero).
</p>

<br/><br/>

<a name="cpymem"></a>
<h2><span class="function">cpymem</span>&nbsp; 
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (cpymem <em>int-from-address</em> <em>int-to-address</em> <em>int-bytes</em>)</h4>


<p><em>int-from-address</em> から <em>int-bytes</em> のメモリを <em>int-to-address</em> にコピーします。
この関数はメモリを直接読み書きしたり、newLISP内部（例えば、newLISP セルのタイプ･ビットや組込関数のバイナリ実行コード）をハックするために使えます。<br />
Copies <em>int-bytes</em> of memory from <em>int-from-address</em> 
to <em>int-to-address</em>. This function can be used for 
direct memory writing/reading or for hacking newLISP internals
(e.g., type bits in newLISP cells, or building functions with binary 
executable code on the fly).</p>

<p>この関数は newLISP 内部をよく熟知した上で使うよう注意してください。
<tt>cpymem</tt> を誤って使うと、システムがクラッシュしたり、不安定になったりします。<br />
Note that this function should only be used when familiar with newLISP internals.
<tt>cpymem</tt> can crash the system or make it unstable if used incorrectly.</p>

<!-- example -->

<pre>
(set 's "0123456789")

(cpymem "xxx" (+ (address s) 5) 3)

s  <span class='arw'>&rarr;</span> "01234xxx89")
</pre>


<p>この例では、文字列変数に直接文字列をコピーしています。<br />
The example copies a string directly into a string variable.</p>

<p>次の例は、一からバイナリ･コードの新しい関数を作成し、その部品を走らせ、二つの数を足し算します。
示してあるアセンブリ言語の小品は、二つの数を足し算して結果を返す X86 (Intel CPU) コードです：<br />
he following example creates a new function from scratch, 
runs a piece of binary code, and adds up two numbers. 
This assembly language snippet shows the x86 (Intel CPU) code 
to add up two numbers and return the result:</p>


<pre>
 55       push ebp
 8B EC    mov  ebp, esp
 8B 45 08 mov  eax, [ebp+08]
 03 45 0C add  eax, [ebp+0c]
 5D       pop  ebp
 C3       ret

 ; for Win32/stdcall change last line
 C2 08 00 ret 
</pre>


<p>このバイナリ表現を newLISP で作成した新関数に貼り付けます：<br />
The binary representation is attached to a new function created 
in newLISP:</p>


<pre>
; set up 32-bit version of machine code
; on Windows use 32-bit version of newLISP
(set 'foo-code (append
     (pack "bbbbbbbbbb" 0x55 0x8B 0xEC 0x8B 0x45 0x08 0x03 0x45 0x0C 0x5D)
     (if (= ostype "Windows") (pack "bbb" 0xC2 0x08 0x00) (pack "b" 0xC3))))

; put a function cell template into foo, protect symbol from deletion
(constant 'foo print)

; put the correct type, either 'stdcall' or 'cdecl'
(cpymem (pack "ld" (if (= ostype "Windows") 8456 4360)) (first (dump foo)) 4)

; put the address of foo-code into the new function cell
(cpymem (pack "ld" (address foo-code)) (+ (first (dump foo)) 12) 4)

; take the name address from the foo symbol, copy into function cell
(set 'sym-name (first (unpack "lu" (+ (address 'foo) 8))))
(cpymem (pack "ld" sym-name) (+ (first (dump foo)) 8) 4)

; test the new function
(println "3 * 4 -> " (foo 3 4))
</pre>

<p>この例は、全てのハードウェア・プラットフォームや OS で動作するものではありません。<br />
The last example will not work on all hardware platforms and OSs.</p>

<p>newLISP セルからバイナリ･アドレスとその内容を取り出すのには、関数 <a href="#dump">dump</a> を使ってください。<br />
Use the <a href="#dump">dump</a> function to retrieve binary addresses 
and the contents from newLISP cells.</p>


<br/><br/>

<a name="crc32"></a>
<h2><span class="function">crc32</span></h2>
<h4>syntax: (crc32 <em>str-data</em>)</h4>

<p>
	<em>str-data</em> のバッファから、初期値が <tt>0xffffffff</tt> で始まる 32 ビット CRC（<a href="http://ja.wikipedia.org/wiki/%E5%B7%A1%E5%9B%9E%E5%86%97%E9%95%B7%E6%A4%9C%E6%9F%BB">巡回冗長検査</a>）値を計算します。 
<tt>crc32</tt> 計算には <a href="http://www.w3.org/">www.w3.org</a> で公開されているアルゴリズムを使っています。<br />
	Calculates a running 32-bit CRC (Circular Redundancy Check) sum 
	from the buffer in <em>str-data</em>, 
	starting with a CRC of <tt>0xffffffff</tt> for the first byte. 
	<tt>crc32</tt> uses an algorithm published 
	by <a href="http://www.w3.org">www.w3.org</a>.
</p>

<!-- example -->

<pre>
(crc32 "abcdefghijklmnopqrstuvwxyz")  <span class='arw'>&rarr;</span> 1277644989
</pre>


<p>安全でないデータ伝送において確実なベリファイを実施するために、<tt>crc32</tt> がよく使われます。<br />
	<tt>crc32</tt> is often used to verify data integrity 
	in unsafe data transmissions.
</p>

<br/><br/>

<a name="crit-chi2"></a>
<h2><span class="function">crit-chi2</span></h2>

<h4>syntax: (crit-chi2 <em>num-probability</em> <em>int-df</em>)</h4>

<p>統計的帰無仮説の有意を検定するために、
帰無仮説下で与えられた危険率（訳注:有意水準ともいう）<em>num-probability</em> と自由度 <em>int-df&nbsp;</em> により、最小限界の<em>カイ２乗値</em> を計算します。（訳注：EXCEL の CHIINV（確率, 自由度）に相当。<a href="http://ja.wikipedia.org/wiki/%E3%82%AB%E3%82%A4%E4%BA%8C%E4%B9%97%E5%88%86%E5%B8%83">カイ二乗分布</a>、<a href="http://ja.wikipedia.org/wiki/%E3%82%AB%E3%82%A4%E4%BA%8C%E4%B9%97%E6%A4%9C%E5%AE%9A">カイ二乗検定</a> も参考になります）<br />
Calculates the critical minimum <em>Chi&sup2;&nbsp;</em> for a given confidence probability 
<em>num-probability</em> under the null hypothesis and the degrees of freedom in
<em>int-df&nbsp;</em> for testing the significance of a statistical null hypothesis.</p>

<p>10.2.0 以前のバージョンでは、（訳注：引数として）確率 <em>p</em> のかわりに <em>(1.0 - p)</em> （訳注:信頼率）を取っていたことを記しておきます。<br />
Note that versions prior to 10.2.0 took <em>(1.0 - p)</em> for the probability
instead of <em>p</em>.</p>

<!-- example -->

<pre>
(crit-chi2 0.01 4)  <span class='arw'>&rarr;</span> 13.27670443
</pre>


<p>逆関数 <a href="#prob-chi2">prob-chi2</a> も見てください。<br />
	See also the inverse function <a href="#prob-chi2">prob-chi2</a>.
</p> 

<br/><br/>

<a name="crit-f"></a>
<h2><span class="function">crit-f</span></h2>

<h4>syntax: (crit-f <em>num-probability</em> <em>int-df1</em> <em>int-df2</em>)</h4>

<p><a href="http://ja.wikipedia.org/wiki/F%E6%A4%9C%E5%AE%9A"><em>F 検定</em></a> を用いて統計的帰無仮説の有意を検定するために、帰無仮説下で与えられた危険率（訳注:有意水準ともいう）<em>num-probability</em> と自由度 <em>int-df1</em> 、<em>int-df2</em> により、最小限界の <em>F&nbsp;</em>値を計算します。（訳注：EXCEL の FINV（確率, 自由度1, 自由度2）に相当。<a href="http://ja.wikipedia.org/wiki/F%E5%88%86%E5%B8%83">F分布</a>も参考になります）<br />
Calculates the critical minimum <em>F&nbsp;</em> for a given confidence probability
<em>num-probability</em> under the null hypothesis and the degrees of freedom 
given in <em>int-df1</em> and <em>int-df2</em> for testing the significance of a 
statistical null hypothesis using the <em>F-test</em>.</p>

<!-- example -->

<pre>
(crit-f 0.05 10 12)  <span class='arw'>&rarr;</span> 2.753386727
</pre>

<p>
逆関数の <a href="#prob-f">prob-f</a> も見てください。<br />
See also the inverse function <a href="#prob-f">prob-f</a>.
</p> 

<br/><br/>

<a name="crit-t"></a>
<h2><span class="function">crit-t</span></h2>

<h4>syntax: (crit-t <em>num-probability</em> <em>int-df</em>)</h4>

<p>統計的帰無仮説の有意を検定するために、帰無仮説下で与えられた危険率（訳注:有意水準ともいう）<em>num-probability</em> と自由度 <em>int-df&nbsp;</em>により、最小限界の<em>スチューデントの t</em> を計算します。（訳注：EXCEL の CHIINV（ 2 * 確率, 自由度）に相当。<a href="http://ja.wikipedia.org/wiki/T%E5%88%86%E5%B8%83">t 分布</a>、<a href="http://ja.wikipedia.org/wiki/T%E6%A4%9C%E5%AE%9A">t 検定</a>も参考になります）<br />
Calculates the critical minimum <em>Student's t</em> for a given confidence probability 
<em>num-probability</em> under the null hypothesis and the degrees of freedom in
<em>int-df&nbsp;</em> for testing the significance of a statistical null hypothesis.
</p>

<!-- example -->

<pre>
(crit-t 0.05 14)  <span class='arw'>&rarr;</span> 1.761310142
</pre>


<p>
逆関数の <a href="#prob-f">prob-t</a> も見てください。<br />
See also the inverse function <a href="#prob-t">prob-t</a>.
</p> 

<br/><br/>


<a name="crit-z"></a>
<h2><span class="function">crit-z</span></h2>
<h4>syntax: (crit-z <em>num-probability</em>)</h4>

<p>統計的有意と<a href="http://ja.wikipedia.org/wiki/%E4%BF%A1%E9%A0%BC%E5%8C%BA%E9%96%93">信頼区間</a>を検定するために、正規分布において与えられた累積確率 <em>num-probability</em> の最小となる Z 値を計算します。（訳注：EXCELのNORMSINV（確率）に相当。）<br />
Calculates the critical normal distributed Z value 
of a given cumulated probability <em>num-probability</em> 
for testing of statistical significance and confidence intervals.</p>
</p>

<!-- example -->

<pre>
(crit-z 0.999)  <span class='arw'>&rarr;</span> 3.090232372
</pre>


<p>逆関数 <a href="#prob-z">prob-z</a> も見てください。<br />
	See also the inverse function <a href="#prob-z">prob-z</a>.
</p> 

<br/><br/>

<a name="current-line"></a>
<h2><span class="function">current-line</span></h2>
<h4>syntax: (current-line)</h4>

<p><a href="#read-line">read-line</a> 操作の最後の内容を取り出します。
<tt>current-line</tt> の内容は、<a href="#write-line">write-line</a> を文字列パラメータ無しで使う場合にも暗黙的に使われます。<br />
	Retrieves the contents of the last 
	<a href="#read-line">read-line</a> operation. 
	<tt>current-line</tt>'s contents are also implicitly used 
	when <a href="#write-line">write-line</a> 
	is called without a string parameter.
</p>

<p>次に示すソースは、Unix コマンド･ラインのフィルタを作る時の典型的なコード･パターンです：<br />
	The following source shows the typical code pattern 
	for creating a Unix command-line filter:
</p>

<!-- example -->

<pre>
#!/usr/local/bin/newlisp
 
(set 'inFile (open (main-args 2) "read"))
(while (read-line inFile) 
  (if (starts-with (current-line) ";;")
    (write-line)))
(exit)
</pre>


<p>プログラムは次のようにして起動します：<br />
	The program is invoked:
</p>


<pre>
./filter myfile.lsp
</pre>


<p><tt>filter</tt> スクリプトを実行すると、コマンド･ライン引数で与えられたファイルから、<tt>;;</tt> で始まるコメント行が全て表示されます。<br />
	This displays all comment lines starting with <tt>;;</tt> 
	from a file given as a command-line argument 
	when invoking the script <tt>filter</tt>.
</p>

<br/><br/>

<a name="curry"></a>

<h2><span class="function">curry</span></h2>
<h4>syntax: (curry <em>func</em> <em>exp</em>)</h4>

<p><em>func</em> に与えられた二つの引数をとる関数<em>f(x, y)</em> を、一つの引数をとる関数<em>fx(y)</em> に変換します。
<tt>curry</tt> は、引数を評価しないマクロのように作用します。
その代わり、<em>func</em> の適用時に評価されます。（訳注：名前の由来は、<a href="http://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96">カレー化</a>でどうぞ）<br />
Transforms <em>func</em> from a function <em>f(x, y)</em> that takes 
two arguments into a function <em>fx(y)</em> that takes a single argument. 
<tt>curry</tt> works like a macro in that it does not evaluate its arguments. 
Instead, they are evaluated during the application of <em>func</em>.</p>


<!-- example -->

<pre>
(set 'f (curry + 10))  <span class='arw'>&rarr;</span> (lambda ($x) (+ 10 $x))

(f 7)  <span class='arw'>&rarr;</span> 17

(filter (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
<span class='arw'>&rarr;</span>  ((a 10) (a 3) (a 9))

(clean (curry match '(a *)) '((a 10) (b 5) (a 3) (c 8) (a 9)))
<span class='arw'>&rarr;</span>  ((b 5) (c 8))

(map (curry list 'x) (sequence 1 5))
<span class='arw'>&rarr;</span>  ((x 1) (x 2) (x 3) (x 4) (x 5))
</pre>


<p><tt>curry</tt> は全ての二変数関数に使えます。<br />
<tt>curry</tt> can be used on all functions taking two arguments.</p>

<br/><br/>

<a name="date"></a>

<h2><span class="function">date</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (date)<br/>
syntax: (date <em>int-secs</em> [<em>int-offset</em>])<br/>
syntax: (date <em>int-secs</em> <em>int-offset</em> <em>str-format</em>)</h4>

<p>
第一構文はローカル･タイム･ゾーンの現在の日付と時刻を文字列表現で返します。
<em>int-secs</em> が範囲外なら <tt>nil</tt> を返します。<br />
The first syntax returns the local time zone's 
current date and time as a string representation.
If <em>int-secs</em> is out of range, <tt>nil</tt> is returned.    
</p>

<p>
第二構文の <tt>date</tt> は <em>int-secs</em> の秒数をローカル･タイム・ゾーンの日付／時刻の文字列表現に変換します。 
<em>int-secs</em> の数値は、通常 <a href="#date-value">date-value</a> を使ってシステムから取り出します。
オプションとして、タイム･ゾーンのオフセットを（分単位で） <em>int-offset</em> に指定できます。
 <em>int-offset</em> は文字列に変換する前の <em>int-sec</em> から加算もしくは減算されます。
範囲外の <em>int-secs</em> または 無効な <em>str-format</em> が指定されると、空文字列 <tt>""</tt> を返します。<br />
In the second syntax, <tt>date</tt> translates the number of seconds 
in <em>int-secs</em> into its date/time string representation 
for the local time zone. 
The number in <em>int-secs</em> is usually retrieved from the system 
using <a href="#date-value">date-value</a>. 
Optionally, a time-zone offset (in minutes) can be specified 
in <em>int-offset</em>, which is added 
or subtracted before conversion of <em>int-sec</em> to a string.
If <em>int-secs</em> is out of range or an invalid <em>str-format</em>
is specified, an empty string <tt>""</tt> is returned.
</p>


<!-- example -->

<pre>
(date)                   <span class='arw'>&rarr;</span> "Fri Oct 29 09:56:58 2004"

(date (date-value))      <span class='arw'>&rarr;</span> "Sat May 20 11:37:15 2006" 
(date (date-value) 300)  <span class='arw'>&rarr;</span> "Sat May 20 16:37:19 2006"  ; 5 hours offset
(date 0)                 <span class='arw'>&rarr;</span> "Wed Dec 31 16:00:00 1969"
(date 0 (now 0 -2))      <span class='arw'>&rarr;</span> "Thu Jan  1 00:00:00 1970"  ; Unix epoch
</pre>

<p>日付と時刻の文字列による表示は基になっているオペレーティングシステムによります。<br />
The way the date and time are presented in a string 
depends on the underlying operating system.</p>

<p>二番目の例はグリニッジ・タイム･ゾーンで 1-1-1970 0:0 を示していますが、パシフィック･スタンダード･タイム (PST) の時、8時間前を表示します。
<tt>date</tt> は与えられた <em>int-secs</em> が協定世界時（UTC、以前はグリニッジ標準時(GMT)）だと仮定して、ローカル･タイム･ゾーンによる時刻に変換します。<br />
（訳注：<a href="http://ja.wikipedia.org/wiki/%E5%8D%94%E5%AE%9A%E4%B8%96%E7%95%8C%E6%99%82">協定世界時</a>、UTC - Universal Time, Coordinated）
<br/>
The second example would show 1-1-1970 0:0 when in the Greenwich time zone, 
but it displays a time lag of 8 hours when in Pacific Standard Time (PST).
<tt>date</tt> assumes the <em>int-secs</em> given are in Coordinated Universal 
Time (UTC; formerly Greenwich Mean Time (GMT)) and converts it according to the 
local time-zone.</p>

<p>三番目の構文は、<em>str-format</em> で指定されたフォーマットを使ってフル･カスタムな日付文字列を作ります。
これにより、日や月の名前をその土地柄に合わせた形へ変更できます：<br />
The third syntax makes the date string fully customizable by using a format 
specified in <em>str-format</em>.  This allows the day and month names to be 
translated into results appropriate for the current locale:</p>

<!-- example -->

<pre>
(set-locale "de_DE") <span class='arw'>&rarr;</span> ("de_DE" ",")      

; on Linux - no leading 0 on day with %-d
(date (date-value) 0 "%A %-d. %B %Y")  <span class='arw'>&rarr;</span> "Montag  7. M&auml;rz 2005" 

(set-locale "C")  ; default POSIX

(date (date-value) 0 "%A %B %d %Y")    <span class='arw'>&rarr;</span> "Monday March 07 2005"

; suppressing leading 0 on MS Windows using #
(date (date-value) 0 "%a %#d %b %Y")   <span class='arw'>&rarr;</span> "Mon 7 Mar 2005" 

(set-locale "de_DE") ; on macOS

(date (date-value) 0 "%x") <span class='arw'>&rarr;</span> "07.03.2005"   ; day month year

(set-locale "C")

(date (date-value) 0 "%x") <span class='arw'>&rarr;</span> "03/07/05"     ; month day year
</pre>


<p>次の表は、 MS Windows と Linux/Unix の両プラットフォームで利用可能な全てのフォーマット指定子の要約です。
Linux/Unix では、さらに多くのフォーマット･オプションが利用可能です。
詳細は、個々のプラットフォームの Cライブラリにある C関数 <tt>strftime()</tt> のマニュアル･ページを調べてください。<br />
The following table summarizes all format specifiers available 
on both MS Windows and Linux/Unix platforms.  More format options are 
available on Linux/Unix. For details, consult the manual page for 
the C function <tt>strftime()</tt> of the individual platform's C library.
</p>

<table width="98%"  summary="date formatting">
<tr align="left"><th>format</th><th>description</th></tr>
<tr><td>%a</td><td>現ロケールでの省略した曜日<br />abbreviated weekday name according to the current locale</td></tr>
<tr><td>%A</td><td>現ロケールでの完全な曜日<br />full weekday name according to the current locale</td></tr>
<tr><td>%b</td><td>現ロケールでの省略した月の呼び名<br />abbreviated month name according to the current locale</td></tr>
<tr><td>%B</td><td>現ロケールでの完全な月の呼び名<br />full month name according to the current locale</td></tr>
<tr><td>%c</td><td>現ロケールで好まれる日付と時刻の表現<br />preferred date and time representation for the current locale</td></tr>
<tr><td>%d</td><td>その月の日にち（範囲 01&ndash;31）<br />day of the month as a decimal number (range 01&ndash;31)</td></tr>
<tr><td>%H</td><td>24時間制で使われる時間（範囲 00-23）<br />hour as a decimal number using a 24-hour clock (range 00&ndash;23)</td></tr>
<tr><td>%I</td><td>12時間制で使われる時間（範囲 00-11）<br />hour as a decimal number using a 12-hour clock (range 01&ndash;12)</td></tr>
<tr><td>%j</td><td>年間通しての日数（範囲 001-366）<br />day of the year as a decimal number (range 001&ndash;366)</td></tr>
<tr><td>%m</td><td>月数（範囲 01-12）<br />month as a decimal number (range 01&ndash;12)</td></tr>
<tr><td>%M</td><td>分数<br />minute as a decimal number</td></tr>
<tr><td>%p</td><td>与えられた時間よって 'am' か 'pm' のどちらか、現ロケールに対応する文字列<br />either 'am' or 'pm' according to the given time value or the corresponding strings for the current locale</td></tr>
<tr><td>%S</td><td>0-61 の秒数（60 と 閏秒を考慮した 61 ）<br />second as a decimal number 0&ndash;61 (60 and 61 to account for occasional leap seconds)</td></tr>
<tr><td>%U</td><td>週の最初を日曜日とする今年の週数<br />week number of the current year as a decimal number, starting with the first Sunday as the first day of the first week</td></tr>
<tr><td>%w</td><td>日曜を 0 とする曜日数<br />day of the week as a decimal, Sunday being 0</td></tr>
<tr><td>%W</td><td>週の最初を月曜日とする今年の週数<br />week number of the current year as a decimal number, starting with the first Monday as the first day of the first week</td></tr>
<tr><td>%x</td><td>現ロケールで好まれる時刻無しの日付表現<br />preferred date representation for the current locale without the time</td></tr>
<tr><td>%X</td><td>現ロケールで好まれる日付無しの時刻表現<br />preferred time representation for the current locale without the date</td></tr>
<tr><td>%y</td><td>世紀を含まない年数（範囲 00-99）<br />year as a decimal number without a century (range 00&ndash;99)</td></tr>
<tr><td>%Y</td><td>世紀を含む年数<br />year as a decimal number including the century</td></tr>
<tr><td>%z</td><td>タイム・ゾーンの名前か省略形（MS Windows では %Z と同じ、Unix では異なる）<br />time zone or name or abbreviation (same as %Z on 
MS Windows, different on Unix)</td></tr>
<tr><td>%Z</td><td>タイム・ゾーンの名前か省略形（MS Windows では %z と同じ、Unix では異なる）<br />time zone or name or abbreviation (same as %z on MS Windows, different on Unix)</td></tr>
<tr><td>%%</td><td>文字 '%'<br />a literal '%' character</td></tr>
</table><br>

<p>
日付の表示の先頭のゼロは、Linux や FreeBSD では <tt>"%-d"</tt> を使って、
OpenBSD や SunOS/Solaris や macOS では <tt>"%e"</tt> を使って、省けます。MS Windowsでは <tt>"%#d"</tt> を使います。<br />
Leading zeroes in the display of decimal day numbers can be suppressed 
using <tt>"%-d"</tt> on Linux and FreeBSD and using <tt>"%e"</tt> 
on OpenBSD, SunOS/Solaris and macOS.  On MS Windows use <tt>"%#d"</tt>.
</p>

<p><a href="#date-value">date-value</a>、<a href="#date-list">date-list</a>、<a href="#date-parse">date-parse</a>、<a href="#time-of-day">time-of-day</a>、<a href="#time">time</a>、<a href="#now">now</a> も見てください。<br />
See also <a href="#date-value">date-value</a>, <a href="#date-list">date-list</a>,
<a href="#date-parse">date-parse</a>, 
<a href="#time-of-day">time-of-day</a>, 
<a href="#time">time</a>, and <a href="#now">now</a>.
</p>

<br/><br/>

<a name="date-list"></a>
<h2><span class="function">date-list</span></h2>
<h4>syntax: (date-list <em>int-seconds</em> [<em>int-index</em>])<br/>
syntax: (date-list)</h4>

<p>与えられた 1970年1月1日 00:00:00 からの秒数による
年、月、日、時、分、秒、年の始めからの日数、週の始めからの日数のリストを返します。
日付と時刻は UTC で与えられるので、ローカルのタイムゾーンとは違うかもしれません。<br />
Returns a list of year, month, date, hours, minutes, seconds, day of year 
and day of week from a time value given in seconds after January 1st, 1970 00:00:00.
The date and time values aren given as UTC, which may differ from the local timezone.
</p>
<p>パラメータなしの <tt>date-list</tt> は、<tt>(date-value)</tt> の戻り値である現在時間の秒数からリストを生成します。<br />
When no parameters are given <tt>date-list</tt> generates the list from the
number of seconds for the current time, return of <tt>(date-value)</tt>.</p>

<p>週の始めからの日数は、月曜日から日曜日に対して 1 から 7 の範囲です。<br />
The week-day value ranges from 1 to 7 for Monday thru Sunday.</p>

<pre>
(date-list 1282479244)      <span class='arw'>&rarr;</span> (2010 8 22 12 14 4 234 7)
(date-list 1282479244 0)    <span class='arw'>&rarr;</span> 2010 ; year
(date-list 1282479244 -2)   <span class='arw'>&rarr;</span> 234  ; day of year

(date-value (date-list 1282479244)) <span class='arw'>&rarr;</span> 1282479244

(date-list 0)   <span class='arw'>&rarr;</span> (1970 1 1 0 0 0 1 4) ; Thursday 1st, Jan 1970
</pre>

<p>リストから特定の数値を返させるために、第２オプション・パラメータ <em>int-index</em> が使えます。<br />
A second optional <em>int-index</em> parameter can be used to return
a specific member of the list.</p>

<p><tt>date-list</tt> は、<a href="#date-value">date-value</a> の逆操作です。<br />
<tt>date-list</tt> is the inverse operation of <a href="#date-value">date-value</a>.</p>
<br/><br/>

<a name="date-parse"></a>
<h2><span class="function">date-parse</span></h2>
<h4>syntax: (date-parse <em>str-date</em> <em>str-format</em>)</h4>

<p><a href="#date">date</a> で見つかるのと同じフォーマット規則を使った <em>str-format</em> で定義されたフォーマットを使って、テキスト文字列 <em>str-date</em> の日付を解析します。
関数 <tt>date-parse</tt> は、UTC 1970年1月1日 を 0 として経過した UTC 秒数を 2038年1月19日の 2147472000 まで返します。<br />
Parses a date from a text string in <em>str-date</em>
using a format as defined in <em>str-format</em>, which uses
the same formatting rules found in <a href="#date">date</a>.
The function <tt>date-parse</tt> returns the number of UTC seconds passed   
since January 1st, 1970 UTC starting with 0 and up to 2147472000 for a date 
of January 19th, 2038. </p>

<p>この関数は MS Windows プラットフォームでは利用できません（訳注：Windows 用には拙作 <a href="http://johu02.wordpress.com/2012/03/20/">date-parse</a> があります）。
以前のバージョンでは、<tt>parse-date</tt> と呼ばれていました。この古い名称は推奨しません。<br />
This function is not available on MS Windows platforms. The function was
named <tt>parse-date</tt> in previous versions. The old form is deprecated.</p>

<!-- example -->

<pre>
(date-parse "2007.1.3" "%Y.%m.%d")    <span class='arw'>&rarr;</span> 1167782400
(date-parse "January 10, 07" "%B %d, %y")    <span class='arw'>&rarr;</span> 1168387200

; output of date-parse as input value to date-list produces the same date 

(date-list (date-parse "2010.10.18 7:00" "%Y.%m.%d %H:%M"))
<span class='arw'>&rarr;</span> (2010 10 18 7 0 0 290 1)
</pre>

<p>利用できる全てのフォーマット<ruby>記述子<rp>（</rp><rt>デスクリプタ</rt><rp>）</rp></ruby>は、関数 <a href="#date">date</a> で見てください。<br />
See the <a href="#date">date</a> function for all possible format descriptors.</p>

<br/><br/>

<a name="date-value"></a>
<h2><span class="function">date-value</span></h2>

<h4>syntax: (date-value <em>int-year</em> <em>int-month</em> <em>int-day</em> [<em>int-hour</em> <em>int-min</em> <em>int-sec</em>])<br/> 
syntax: (date-value <em>list-date-time</em>)<br/> 
syntax: (date-value)</h4>

<p>
第一構文の <tt>date-value</tt> は、1970-1-1 00:00:00 から与えられた日付と時刻までの秒数を返します。
時、分、秒のパラメータはオプションです。
時間は協定標準時（UTC）を想定し、現タイム・ゾーンには合わせてはいません。<br />
In the first syntax, <tt>date-value</tt> returns the time 
in seconds since 1970-1-1 00:00:00 for a given date and time.  
The parameters for the hour, minutes and seconds are optional. 
The time is assumed to be Coordinated Universal Time (UTC), 
not adjusted for the current time zone.</p>
<p>第二構文では、同じデータをリストで与えることができます。
第一構文と同様、時、分、秒はオプションです。<br />
In the second syntax the same data can be given in a list.
As with the first syntax, numbers for the hour, minutes 
and seconds are optional.</p>

<p>第二構文の <tt>date-value</tt> は（訳注：1970-1-1 00:00:00 から）現時刻までの秒数を返します。<br />
In the second syntax, <tt>date-value</tt> returns the time value 
in seconds for the current time.</p>

<!-- example -->

<pre>
(date-value 2002 2 28)       <span class='arw'>&rarr;</span> 1014854400
(date-value '(2002 2 28))    <span class='arw'>&rarr;</span> 1014854400
(date-value 1970 1 1 0 0 0)  <span class='arw'>&rarr;</span> 0
                                 
(date (date-value (now)))    <span class='arw'>&rarr;</span> "Wed May 24 10:02:47 2006" 
(date (date-value))          <span class='arw'>&rarr;</span> "Wed May 24 10:02:47 2006"
(date)                       <span class='arw'>&rarr;</span> "Wed May 24 10:02:47 2006"
</pre>


<p>関数<a href="#date-list">date-list</a> は <tt>date-value</tt> をリストに戻すために使えます：<br />
The function <a href="#date-list">date-list</a> can be used to transform 
a <tt>date-value</tt> back into a list:</p>


<pre>
(date-list 1014854400)  <span class='arw'>&rarr;</span> (2002 2 28 0 0 0)
(date-value (date-list 1014854400))  <span class='arw'>&rarr;</span> 1014854400
</pre>


<p><a href="#date">date</a>、<a href="#date-list">date-list</a>、<a href="#date-parse">date-parse</a>、<a href="#time-of-day">time-of-day</a>、<a href="#time">time</a>、
<a href="#now">now</a> も見てください。<br />
See also <a href="#date">date</a>, 
<a href="#date-list">date-list</a>, <a href="#date-parse">date-parse</a>, 
<a href="#time-of-day">time-of-day</a>, <a href="#time">time</a>, and 
<a href="#now">now</a>.</p>

<br/><br/>

<a name="debug"></a>
<h2><span class="function">debug</span></h2>
<h4>syntax: (debug <em>func</em>)</h4>

<p>
<a href="#trace">trace</a> を呼び出してユーザ定義関数 <em>func</em> の評価を始めます。
<tt>debug</tt> は、<tt>(trace true)</tt> を実行してデバック・モードで関数に入るためのショート・カットです。<br />
Calls <a href="#trace">trace</a> and begins evaluating the user-defined 
function in <em>func</em>. <tt>debug</tt> is a shortcut for executing 
<tt>(trace true)</tt>, then entering the function to be debugged.</p>

<!-- example -->

<pre>
;; instead of doing
(trace true)
(my-func a b c)
(trace nil)

;; use debug as a shortcut
(debug (my-func a b c))
</pre>

<p><tt>debug</tt> あるいは <a href="#trace">trace</a> モード中に、エラー・メッセージが出力されることがあります。例外を起こした関数が <tt>0</tt> か <tt>nil</tt> を返して、プロセスを続けます。このようにデバック中は、変数とプログラムの現在の状態が監視されたままになります。<br />
When in <tt>debug</tt> or <a href="#trace">trace</a> mode, error messages
will be printed. The function causing the exception will return either
<tt>0</tt> or <tt>nil</tt> and processing will continue. This way, variables 
and the current state of the program can still be inspected while debugging.</p>

<p>関数<a href="#trace">trace</a> も見てください。<br />
	See also the <a href="#trace">trace</a> function.
</p>

<br/><br/>

<a name="dec"></a>
<h2><span class="function">dec</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (dec <em>place</em> [<em>num</em>])</h4>

<p>
<em>place</em> の数値から <tt>1.0</tt> か、オプション数値の <em>num</em> を減じて返します。
<tt>dec</tt> は浮動小数点演算を実行し、整数は浮動小数点型に変換されます。<br />
The number in <em>place</em> is decremented by <tt>1.0</tt> or the optional number 
<em>num</em> and returned.  <tt>dec</tt> performs float arithmetic and converts
integer numbers passed into floating point type.</p>

<p><em>place</em> はシンボル、リスト構造内の位置、式によって返される数値のいずれかです。<br />
<em>place</em> is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.</p>

<!-- example -->

<pre>
(set x 10)    <span class='arw'>&rarr;</span> 10
(dec x)       <span class='arw'>&rarr;</span> 9
x             <span class='arw'>&rarr;</span> 9
(dec x 0.25)  <span class='arw'>&rarr;</span> 8.75
x             <span class='arw'>&rarr;</span> 8.75
</pre>


<p><em>place</em> のシンボルが <tt>nil</tt> なら、<tt>0.0</tt> として扱われます：<br />
If the symbol for <em>place</em> contains <tt>nil</tt>, it is treated
as if containing <tt>0.0</tt>:</p>


<pre>
z             <span class='arw'>&rarr;</span> nil
(dec z)       <span class='arw'>&rarr;</span> -1

(set z nil)
(dec z 0.01)  <span class='arw'>&rarr;</span> -0.01
</pre>


<p>リスト構造内の位置や他の式の戻り値も更新されます：<br />
Places in a list structure or a number returned by another expression
can be updated too:</p>


<pre>
(set 'l '(1 2 3 4))

(dec (l 3) 0.1) <span class='arw'>&rarr;</span> 3.9

(dec (first l)) <span class='arw'>&rarr;</span> 0

l <span class='arw'>&rarr;</span> (0 2 3 3.9)

(dec (+ 3 4)) <span class='arw'>&rarr;</span> 6
</pre>

<p>整数モードの減算には、関数 <a href="#deci">--</a> を使ってください。
浮動小数点モードの加算には、関数 <a href="#inc">inc</a> を使ってください。<br />
Use the <a href="#deci">--</a> function to decrement in integer mode.
Use the <a href="#inc">inc</a> function to increment numbers floating point mode.</p>

<br/><br/>

<a name="def-new"></a>
<h2><span class="function">def-new</span></h2>
<h4>syntax: (def-new <em>sym-source</em> [<em>sym-target</em>])</h4>

<p>この関数は、<a href="#new">new</a> のように動作しますが、<em>sym-source</em> のシンボルからそのコンテキストとシンボル一個のみコピーします。
<em>sym-target</em> が無い時は、同じ名前のシンボルが現コンテキストに作られます。
<em>sym-source</em> 内で参照可能な全てのシンボルが現コンテキストで参照可能なシンボルとして移植されますが、そのコンテキストは MAIN 以外でなければなりません。（訳注：<em>sym-target</em> 無しをコンテキスト MAIN で使うとエラーになります。）<br />
	This function works similarly to <a href="#new">new</a>, 
	but it only creates a copy of one symbol 
	and its contents from the symbol in <em>sym-source</em>. 
	When <em>sym-target</em> is not given, 
	a symbol with the same name is created 
	in the current context. 
	All symbols referenced inside <em>sym-source</em> 
	will be translated into symbol references into the current context,
    which must not be MAIN.</p>
<p>引数に <em>sym-target</em> があれば、em>sym-target</em> のシンボルで参照できるシンボルとコンテキストのコピーが作られます。
名前の変更だけでなく、異なるコンテキストへの配置も可能です。
<em>sym-source</em> 内で参照できる全てシンボルが、目標コンテキストの参照シンボルとして移植されます。<br />
If an argument is present in <em>sym-target</em>, the copy will be made
into a symbol and context as referenced by the symbol in <em>sym-target</em>. 
In addition to allowing renaming of the function while copying, this also 
enables the copy to be placed in a different context.  All symbol references 
in <em>sym-source</em> with the same context as <em>sym-source</em> will 
be translated into symbol references of the target context.
</p>

<p><tt>def-new</tt> は生成したシンボルを返します：<br />
	<tt>def-new</tt> returns the symbol created:
</p>

<!-- example -->

<pre>
&gt; (set 'foo:var '(foo:x foo:y))
<b>(foo:x foo:y)</b>

&gt; (def-new 'foo:var 'ct:myvar)
<b>ct:myvar</b>

&gt; ct:myvar
<b>(ct:x ct:y)</b>

&gt; (context 'K)

K&gt; (def-new 'foo:var)
<b>var</b>

K&gt; var
<b>(x y)</b>
</pre>

<p>次の例は静的スコープ関数（訳注：<a href="#default_function">デフォルト・ファンクタ</a>）をその名前空間自身に作る方法を示しています：<br />
The following example shows how a statically scoped function can
be created by moving it its own namespace:</p>

<pre>
&gt; (set 'temp (lambda (x) (+ x x)))
<b>(lambda (x) (+ x x))</b>
&gt; (def-new 'temp 'double:double)
<b>double:double</b>
&gt; (double 10)
<b>20</b>
&gt; double:double
<b>(lambda (double:x) (+ double:x double:x))</b>
</pre>

<p>次で定義する <tt>def-static</tt> は、レキシカルに保護される名前空間に置かれる関数（訳注：<a href="#default_function">デフォルト・ファンクタ</a>）を作るために利用できます：<br />
The following definition of <tt>def-static</tt> can be used to
create functions living in their own lexically protected name-space:</p>
<pre>
(define (def-static s body) 
      (def-new 'body (sym s s)))

(def-static 'acc (lambda (x)
          (inc sum x)))

&gt; (acc 1)
<b>1</b>
&gt; (acc 1)
<b>2</b>
&gt; (acc 8)
<b>10</b>
&gt;
</pre>

<p>関数 <tt>def-new</tt> は、コンテキストを完全にコピーする <a href="#new">new</a> よりも簡単な方法で、コンテキストやコンテキスト・オブジェクトを構成するために使えます。<br />
	The function <tt>def-new</tt> can be used to configure contexts 
	or context objects in a more granular fashion than is possible 
	with <a href="#new">new</a>, which copies a whole context.
</p>

<br/><br/>

<a name="default"></a>
<h2><span class="function">default</span></h2>
<h4>syntax: (default <em>context</em>)</h4>

<p><em>context</em> のデフォルト・ファンクタの中身を返します。<br />
Return the contents of the default functor in <em>context</em>.</p>

<!-- example -->

<pre>
(define Foo:Foo 123)

(default Foo) <span class='arw'>&rarr;</span> 123

(setf (default Foo) 456)
(set 'ctx Foo)

(default ctx) <span class='arw'>&rarr;</span> 456
Foo:Foo       <span class='arw'>&rarr;</span> 456
</pre>


<p>多くの場合、newLISP はコンテキスト名を見ると、自動的にデフォルト・ファンクタにします。
そうならない場合に、関数 <tt>default</tt> を利用できます。<br />
In many situations newLISP defaults automatically to the default functor
when seeing a context name. In circumstances where this is not the case,
the <tt>default</tt> function can be used.</p>

<br/><br/>

<a name="define"></a>
<h2><span class="function">define</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (define (<em>sym-name</em> [<em>sym-param-1</em> ... ]) [<em>body-1</em> ... ])<br/>
syntax: (define (<em>sym-name</em> [(<em>sym-param-1</em> <em>exp-default</em>) ... ]) [<em>body-1</em> ... ])<br/>
syntax: (define <em>sym-name</em> <em>exp</em>)</h4>

<p><em>sym-param-1</em> 以下のオプション･パラメータを持つ新しい関数 <em>sym-name</em> を定義します。
<tt>define</tt> はラムダ式を <em>sym-name</em> に割り当てるのと等価です。
定義された関数が呼び出されると、引数全てが評価されて <em>sym-param-1</em> 以下の変数に割り当てられ、<em>body-1</em> 以下の式群が評価されます。
関数が定義されると、<em>sym-name</em> に束縛されたラムダ式が返ります。<br />
	Defines the new function <em>sym-name</em>, 
	with optional parameters <em>sym-param-1</em>&mdash;. 
	<tt>define</tt> is equivalent to assigning 
	a lambda expression to <em>sym-name</em>. 
	When calling a defined function, 
	all arguments are evaluated and assigned 
	to the variables in <em>sym-param-1</em>&mdash;, 
	then the <em>body-1&mdash;	</em> expressions are evaluated. 
	When a function is defined, the lambda expression 
	bound to <em>sym-name</em> is returned.
</p>

<p>全ての定義パラメータはオプションです。
ユーザ定義関数が引数無しで呼ばれると、パラメータには <tt>nil</tt> が入ります。
もし、パラメータが <em>exp-default</em> で指定されるデフォルト値を持っている場合は、その値をとります。<br />
	All parameters defined are optional. 
	When a user-defined function is called without arguments, 
	those parameters assume the value <tt>nil</tt>. 
<!-- 8.9.4 -->If those parameters have a default value 
	specified in <em>exp-default</em>,
	they assume that value.
</p>

<p><tt>define</tt> の戻り値は、割り当てられたラムダ式です。
ユーザ定義関数が呼ばれた時の戻り値は、関数本体で最後に評価された式です。<br />
	The return value of <tt>define</tt> 
	is the assigned <em>lambda</em> expression. 
	When calling a user-defined function, 
	the return value is the last expression evaluated 
	in the function body.
</p>

<!-- example -->

<pre>
(define (area x y) (* x y))  <span class='arw'>&rarr;</span> (lambda (x y) (* x y))
(area 2 3)                   <span class='arw'>&rarr;</span> 6
</pre>


<p><tt>define</tt> を使わず、<tt>area</tt> を関数に定義することも可能です。<br />
	As an alternative, <tt>area</tt> could be defined 
	as a function without using <tt>define</tt>.
</p>


<pre>
(set 'area (lambda (x y) (* x y))
</pre>


<p><em>lambda</em> や <em>fn</em> 式は、シンボルに定義されることなくそれ自身で<em>匿名</em >関数として使われることもあります：<br />
	<em>lambda</em> or <em>fn</em> expressions may be used by themselves 
	as <em>anonymous</em> functions without being defined as a symbol:
</p>


<pre>
((lambda ( x y) (* x y)) 2 3)  <span class='arw'>&rarr;</span> 6
((fn ( x y) (* x y)) 2 3)      <span class='arw'>&rarr;</span> 6
</pre>


<p><tt>fn</tt> は <tt>lambda</tt> 記述の短縮形です。<br />
	<tt>fn</tt> is just a shorter form of writing <tt>lambda</tt>.
</p>
	
<!-- 8.9.4 -->
<p>パラメータには、デフォルト値を指定できます：<br />
	Parameters can have default values specified:
</p>


<pre>
(define (foo (a 1) (b 2))
  (list a b))
    
(foo)      <span class='arw'>&rarr;</span> (1 2)
(foo 3)    <span class='arw'>&rarr;</span> (3 2)
(foo 3 4)  <span class='arw'>&rarr;</span> (3 4)
</pre>


<p><em>exp-default</em> の式は、関数の呼ばれた環境で評価されます。<br />
	Expressions in <em>exp-default</em> 
	are evaluated in the function's
	current environment.
</p>


<pre>
(define (foo (a 10) (b (div a 2))) 
  (list a b))

(foo)      <span class='arw'>&rarr;</span> (10 5)
(foo 30)   <span class='arw'>&rarr;</span> (30 15)
(foo 3 4)  <span class='arw'>&rarr;</span> (3 4)
</pre>


<p>第二形式の <tt>define</tt> は、関数 <a href="#set">set</a> のように動作します。<br />
	The second version of <tt>define</tt> 
	works like the <a href="#set">set</a> function.
</p>

<!-- example -->

<pre>
(define x 123)  <span class='arw'>&rarr;</span>   123
;; is equivalent to
(set 'x 123)    <span class='arw'>&rarr;</span>   123

(define area (lambda ( x y) (* x y)))
;; is equivalent to
(set 'area (lambda ( x y) (* x y)))
;; is equivalent to
(define (area x y) (* x y))
</pre>


<p>プロテクトされたシンボルを再定義すると、エラー・メッセージが発生します。<br />
	Trying to redefine a protected symbol will cause an error message.
</p>

<br/><br/>

<a name="define-macro"></a>
<h2><span class="function">define-macro</span></h2>
<h4>syntax: (define-macro (<em>sym-name</em> [<em>sym-param-1</em> ... ]) <em>body</em>)<br/>
syntax: (define-macro (<em>sym-name</em> [(<em>sym-param-1</em> <em>exp-default</em>) ... ]) <em>body</em>)</h4>

<p><tt>define-macro</tt> を使って定義された関数は、他のLISPのように変数を展開しない <i>fexpr</i> と呼ばれます（訳注： <a href="http://en.wikipedia.org/wiki/Fexpr">fexpr</a> とは、オペランドが評価されずに渡される関数）。
newLISP では、今まで通りマクロと呼んでいます。
というのも、標準的でない引数の評価形式を持つ特殊な構文形態を作るという同じ目的で書かれるからです。
<tt>define-macro</tt> を使って作られた関数は、<a href="#expand">expand</a> や <a href="#letex">letex</a> を使ったテンプレート展開式と結合できます。<br />
Functions defined using <tt>define-macro</tt> are called <i>fexpr</i>
in other LISPs as they don't do variable expansion. In newLISP they are still
called macros, because they are written with the same purpose of creating
special syntax forms with non-standard evaluation patterns of arguments. 
Functions created using <tt>define-macro</tt> can be combined with template 
expansion using <a href="#expand">expand</a> or <a href="#letex">letex</a>.</p>

<p>v.10.5.8 から newLISP には <a href="#macro">macro</a> を使った拡張マクロもあります。<br />
Since v.10.5.8, newLISP also has expansion macros using <a href="#macro">macro</a>.</p>

<p><em>sym-param-1</em> 以下をオプション引数として、新しい fexpr の <em>sym-name</em> を定義します。
<tt>define-macro</tt> は、ラムダ・マクロ式をシンボルに割り当てるのと等価です。
関数 <tt>define-macro</tt> が呼ばれると、評価されない引数が変数 <em>sym-param-1 ...</em> に割り当てられます。
その後、<em>body</em> の式群が評価されます。
関数<tt>define-macro</tt> が評価されると、ラムダ・マクロ式が返ります。<br />
Defines the new fexpr <em>sym-name</em>, with optional arguments <em>sym-param-1</em>. 
<tt>define-macro</tt> is equivalent to assigning a lambda-macro expression to a symbol. 
When a <tt>define-macro</tt> function is called, unevaluated arguments are assigned to 
the variables in <em>sym-param-1 ...</em>. Then the <em>body</em> expressions are evaluated.  
When evaluating the <tt>define-macro</tt> function, the lambda-macro expression is returned.
</p>
	

<!-- example -->

<pre>
(define-macro (my-setq p1 p2) (set p1 (eval p2))) 
<span class='arw'>&rarr;</span> (lambda-macro (p1 p2) (set p1 (eval p2)))

(my-setq x 123)  <span class='arw'>&rarr;</span> 123
x                <span class='arw'>&rarr;</span> 123
</pre>


<p>特定の引数の評価を先延ばしする組込関数のような新しい関数を作成できます。
<em>fexprs</em> はパラメーター・リスト内部の引数にもアクセスでき、すでに newLISP に組み込まれているようなフロー制御関数の作成に使えます。<br />
New functions can be created to behave like built-in functions
that delay the evaluation of certain arguments.  Because fexprs can 
access the arguments inside a parameter list, they can be used to 
create flow-control functions like those already built-in to newLISP.</p>

<p>定義された引数は、全てオプションです。
マクロが引数無しで呼ばれると、パラメータには <tt>nil</tt> が入ります。
パラメータが <em>exp-default</em> で指定されるデフォルト値を持つ場合は、それらが入ります。<br />
All parameters defined are optional.  When a macro is called without 
arguments, those parameters assume the value <tt>nil</tt>. 
If those parameters have a default value specified in <em>exp-default</em>,
they assume that default value.</p>
	

<pre>
(define-macro (foo (a 1) (b 2))
  (list a b))
    
(foo)      <span class='arw'>&rarr;</span> (1 2)
(foo 3)    <span class='arw'>&rarr;</span> (3 2)
(foo 3 4)  <span class='arw'>&rarr;</span> (3 4)
</pre>


<p><em>exp-default</em> の式は、関数が呼ばれた環境で評価されます。<br/>
Expressions in <em>exp-default</em> are evaluated in the function's 
current environment.</p>


<pre>
(define-macro (foo (a 10) (b (div a 2))) 
  (list a b))

(foo)      <span class='arw'>&rarr;</span> (10 5)
(foo 30)   <span class='arw'>&rarr;</span> (30 15)
(foo 3 4)  <span class='arw'>&rarr;</span> (3 4)
</pre>


<p><em>fexpr</em> には注記すべき危険性が存在します。<tt>define-macro</tt> の定義で使っているのと同じ変数名がパラメータとして渡されることです。
このような場合（訳注:下記の例）、<em>fexpr</em> の内部変数は意図した値と違って <tt>nil</tt> を受け取ってしまいます：<br />
Note that in <em>fexprs</em>, the danger exists of passing a parameter 
with the same variable name as used in the <tt>define-macro</tt> definition. 
In this case, the <em>fexpr's</em> internal variable would end up 
receiving <tt>nil</tt> instead of the intended value:</p>


<pre>
;; not a good definition!

(define-macro (my-setq x y) (set x (eval y)))  

;; symbol name clash for x

(my-setq x 123)  <span class='arw'>&rarr;</span> 123
x                <span class='arw'>&rarr;</span> nil
</pre>


<p><em>変数捕捉</em> として知られるこの問題を避けて、<em>安全な</em> <tt>define-macro</tt> を書く方法は、いくつかあります：<br />
There are several methods that can be used 
to avoid this problem, known as <em>variable capture</em>,
by writing <em>hygienic</em> <tt>define-macro</tt>s:</p>

<ul>
<li>定義それ自体をレキシカルに閉じた名前空間コンテキストに置きます。関数がコンテキストと同じ名前なら、コンテキスト名だけで呼び出せます。この特徴的な関数は、<a href="#default_function"><em>デフォルト・ファンクション</em></a> （訳注：この翻訳では、デフォルト・ファンクションまたはデフォルト・ファンクタと記述）と呼ばれます。これは、newLISP で <tt>define-macro</tt> を書く最善の方法です。<br />Put the definition into its own lexically closed namespace context. If the function has the same name as the context, it can be called by using the context name alone.  A function with this characteristic is called a <a href="#default_function"><em>default function</em></a>. This is the preferred method in newLISP to write <tt>define-macro</tt>s.</li>
<br/>
<li>関数に渡される引数をアクセスするために、<a href="#args">args</a> を使います。<br />Use <a href="#args">args</a> to access arguments passed by the function.</li>
</ul>

<!-- example -->

<pre>
;; a define-macro as a lexically isolated function
;; avoiding variable capture in passed parameters

(context 'my-setq)

(define-macro (my-setq:my-setq x y) (set x (eval y)))  

(context MAIN)

(my-setq x 123)  <span class='arw'>&rarr;</span> 123  ; no symbol clash
x                <span class='arw'>&rarr;</span> 123
</pre>


<p>例題の定義では、レキシカルに隔離されていて変数捕捉が起こりません。
<tt>(my-setq:my-setq &hellip;)</tt> を使って関数を呼び出す代わりに、<tt>(my-setq &hellip;)</tt> だけで呼び出せます。
それは、<a href="#default_function"><em>デフォルト・ファンクション</em></a> だからです。<br />
	The definition in the example is lexically isolated, 
	and no variable capture can occur. 
	Instead of the function being called using <tt>(my-setq:my-setq &hellip;)</tt>, 
	it can be called with just <tt>(my-setq &hellip;)</tt> 
	because it is a <a href="#default_function"><em>default function</em></a>.
</p>

<p>第２の可能性は、<a href="#args">args</a> を使って渡されるパラメータに参照することです：<br />
	The second possibility is to refer to passed parameters 
	using <a href="#args">args</a>:
</p>

<!-- example -->

<pre>
;; avoid variable capture in macros using the args function

(define-macro (my-setq) (set (args 0) (eval (args 1))))
</pre>

<p>変数補足に耐性のある拡張関数 <a href="#macro">macro</a> も見てください。<br />
See also the <a href="#macro">macro</a> expansion function not
susceptible to variable capture.</p>

<br/><br/>

<a name="delete"></a>
<h2><span class="function">delete</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (delete <em>symbol</em> [<em>bool</em>])<br/>

syntax: (delete <em>sym-context</em> [<em>bool</em>])</h4>

<p><em>symbol</em> のシンボルや <em>sym-context</em> のコンテキストと、それに含まれる全てのシンボルを newLISP シンボル･テーブルから削除します。
シンボルの参照値は <tt>nil</tt> に変わります。
Deletes a symbol <em>symbol</em>, or a context in <em>sym-context</em> 
with all contained symbols from newLISP's symbol table.
References to the symbol will be changed to <tt>nil</tt>. </p>

<p>第一構文では <em>symbol</em> のシンボルを削除します。
そのため、他の式でそのシンボルを参照しても、<tt>nil</tt> に変わっているでしょう。<br />
In the first syntax deletes a symbol <em>symbol</em> and references to 
the symbol in other expressions will be changed to <tt>nil</tt>.</p>

<p>第二構文では <em>sym-context</em> で参照される名前空間の全シンボルを削除します。
そのため、他の式でそれらを参照しても、<tt>nil</tt> に変わっているでしょう。
<em>sym-context</em> のコンテキスト・シンボルは通常のシンボルに変わり、<tt>nil</tt>が入ります。<br />
In the second syntax all symbols of the namespace referred to by 
<em>sym-context</em> will be deleted and references to them in other
espressions will be changed to <tt>nil</tt>. The context symbol 
<em>sym-context</em> will be changed to a normal symbol 
containing <tt>nil</tt>.</p>

<p><em>bool</em> の式が <tt>true</tt> に評価されると、シンボルが参照されていない時のみ、削除されます。<br />
When the expression in <em>bool</em> evaluates 
to <tt>true</tt>, symbols are only deleted when they are not referenced.
</p>

<p><em>bool</em> の式が <tt>nil</tt> に評価されると、シンボルは参照がチェックされずに削除されます。
名前空間の外でシンボルの存在を参照していない時のみ、このモードを使用すべきだということに、注意してください。
もし、外部参照があるのにこのモードを使えば、外部参照が <tt>nil</tt> にセットされず、システム・クラッシュを導きかねません。
ハッシュの名前空間の削除や変数が厳密に非公開として扱われるオブジェクト・システムの名前空間の削除に、このモードを使えます。<br />
When the expression in <em>bool</em> evaluates 
to <tt>nil</tt>, symbols will be deleted without any reference checking.
Note that this mode should only be used, if no references to the symbol
exist outside it's namespace. If external references exist, this mode
can lead to system crashes, as the external reference is not set to
<tt>nil</tt> when using this mode. This mode can be used to delete
namespace hashes and to delete namespaces in object systems, where variables are
strictly treated as private.</p>

<p>
組込関数のようなプロテクトされたシンボルとか、<tt>nil</tt> や <tt>true</tt> のような特殊シンボルは削除できません。<br />
Protected symbols of built-in functions and special symbols 
like <tt>nil</tt> and <tt>true</tt> cannot be deleted.
</p>

<p>シンボルの削除に成功すると、<tt>delete</tt> は <tt>true</tt> を返し、
失敗すると <tt>nil</tt> を返します。<br />
<tt>delete</tt> returns <tt>true</tt> if the symbol was deleted 
successfully or <tt>nil</tt> if the symbol was not deleted.
</p>

<p>コンテキスト・シンボルを削除する時、最初の <tt>delete</tt> はコンテキスト名前空間の中身を削除して、コンテキスト・シンボルを通常の単一変数シンボルに落とします。二回目の <tt>delete</tt> はシンボル・テーブルからシンボルを削除します。<br />
When deleting a context symbol, the first <tt>delete</tt> removes the context 
namespace contents and demotes the context symbol to a normal mono-variable symbol. 
A second <tt>delete</tt> will remove the symbol from the symbol table.</p>

<!-- example -->

<pre>
(set 'lst '(a b aVar c d))

(delete 'aVar)  ; aVar deleted, references marked nil

lst  <span class='arw'>&rarr;</span> (a b nil c d)

(set 'lst '(a b aVar c d))

(delete 'aVar true)  
<span class='arw'>&rarr;</span> nil ; protect aVar if referenced

lst  <span class='arw'>&rarr;</span> (a b aVar c d)

;; delete all symbols in a context
(set 'foo:x 123)
(set 'foo:y "hello")

(delete 'foo)  <span class='arw'>&rarr;</span> foo:x, foo:y deleted
</pre>


<p>最後の例では、コンテキスト <tt>foo</tt> 内のシンボルのみが削除されますが、コンテキスト･シンボル <tt>foo</tt> 自身は削除されません。
<tt>foo</tt> は通常のプロテクトされていないシンボルになり、<tt>nil</tt> が入ります。<br />
In the last example only the symbols inside context <tt>foo</tt>
will be deleted but not the context symbol <tt>foo</tt> itself. It
will be converted to a normal unprotected symbol and contain <tt>nil</tt>.
</p>

<p>実行中の関数の一部になっている式を削除すると、システムをクラッシュしたり、予期せぬ影響をもたらすことがあることに注意してください。<br />
Note that deleting a symbol that is part of an expression 
which is currently executing can crash the system 
or have other unforeseen effects.
</p>

<br/><br/>

<a name="delete-file"></a>
<h2><span class="function">delete-file</span></h2>
<h4>syntax: (delete-file <em>str-file-name</em>)</h4>

<p><em>str-file-name</em> で与えられたファイルを削除します。
ファイルの削除に成功すると、<tt>true</tt> が返ります。<br />
Deletes a file given in <em>str-file-name</em>. 
Returns <tt>true</tt> if the file was deleted 
successfully.</p>

<p>失敗した時、関数は <tt>nil</tt> を返します。
エラー情報については、ファイルに対して使った時は <a href="#sys-error">sys-error</a> を使ってください。
URL の場合は <a href="#net-error">net-error</a> が詳細なエラー情報を与えてくれます。<br />
On failure the function returns <tt>nil</tt>. For error information, 
use <a href="#sys-error">sys-error</a> when used on files. When used
on URLs <a href="#net-error">net-error</a> gives more error
information.</p>

<p>ファイル名に URL を与えることもできます。<br />
The file name can be given as a URL.</p>

<!-- example -->

<pre>
(delete-file "junk")

(delete-file "http://asite.com/example.html")

(delete-file "file://aFile.txt")
</pre>

<p>
最初の例はカレント･ディレクトリのファイル <tt>junk</tt> を削除します。
二番目の例はファイル指定に URL を使う方法を示しています。
この形式には追加のパラメータを与えることができます。
その詳細は、<a href="#delete-url">delete-url</a> で見てください。<br />
The first example deletes the file <tt>junk</tt> in the current directory.
The second example shows how to use a URL to specify the file. 
In this form, additional parameters can be given. 
See <a href="#delete-url">delete-url</a> for details.
</p>

<br/><br/>

<a name="delete-url"></a>
<h2><span class="function">delete-url</span></h2>
<h4>syntax: (delete-url <em>str-url</em>)</h4>

<p>この関数は、リモート HTTP サーバー上の <em>str-url</em> で指定されるファイルを削除します。
目的のウェブ･サーバー上で HTTP <tt>DELETE</tt> プロトコルが実行可能である必要がありますが、エラー･メッセージ文字列が返されるかもしれません。
目的のファイルにはアクセス許可も設定されていなければなりません。
タイムアウトやカスタム･ヘッダーのような追加のパラメータは、関数 <a href="#get-url">get-url</a> と同じく利用できます。<br />
This function deletes the file on a remote HTTP server specified in <em>str-url</em>.
The HTTP <tt>DELETE</tt> protocol must be enabled on the target web server, 
or an error message string may be returned. The target file must also have  
access permissions set accordingly. Additional parameters such as timeout and custom headers 
are available exactly as in the <a href="#get-url">get-url</a> function.</p>

<p><em>str-url</em> が <tt>file://</tt> で始まっていれば、ローカル･ファイル･システム上のファイルが削除されます。<br />
If <em>str-url</em> starts with <tt>file://</tt> a file on the local file system
is deleted.</p>

<p>この機能には関数 <a href="#delete-file">delete-file</a> が使われ、URL にファイル名を指定することもできます。<br />
This feature is also available when the <a href="#delete-file">delete-file</a>
function is used and a URL is specified for the filename.</p>

<!-- example -->

<pre>
(delete-url "http://www.aserver.com/somefile.txt")
(delete-url "http://site.org:8080/page.html" 5000)

; delete on the local file system
(delete-url "file:///home/joe/somefile.txt")
</pre>


<p>二番目の例は、5 秒のタイムアウト･オプションを指定しています。
特殊 HTTP プロトコル･ヘッダーのような他のオプションも指定可能です。
その詳細は、関数 <a href="#get-url">get-url</a> で見てください。<br />
The second example configures a timeout option of five seconds. 
Other options such as special HTTP protocol headers 
can be specified, as well. 
See the <a href="#get-url">get-url</a> function for details.</p>

<p><tt>delete-url</tt> <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>は newLISP のサーバー・モードで解釈されますが、サーバーが <tt>-http-safe</tt> モードで始まっている時は実行されません。<br />
<tt>delete-url</tt> requests are also understood by newLISP server nodes, but will
not be served when the server is started in <tt>-http-safe</tt> mode.</p>

<br/><br/>

<a name="destroy"></a>
<h2><span class="function">destroy</span></h2>
<h4>syntax: (destroy <em>int-pid</em>)<br/>
syntax: (destroy <em>int-pid</em> <em>int-signal</em>)</h4>

<p><em>int-pid</em> で指定するプロセス ID のプロセスを破棄し、成功すると <tt>true</tt>、失敗すると <tt>nil</tt> を返します。
プロセス ID は通常、macOS や 他の Unix 上で先に呼び出された <a href="#fork">fork</a> か、全プラットフォーム上での <a href="#process">process</a> 呼び出しで得られます。
Unix 上の <tt>destroy</tt> は、SIGKILL シグナルを使うシステム･ユーティリティ <em>kill</em> のように動作します。<br />
Destroys a process with process id in <em>int-pid</em> and returns <tt>true</tt>
on success or <tt>nil</tt> on failure. The process id is normally obtained from a 
previous call to <a href="#fork">fork</a> on macOS and other Unix or 
<a href="#process">process</a> on all platforms. On Unix, <tt>destroy</tt> works like 
the system utility <em>kill</em> using the SIGKILL signal.</p>

<p>注意！ <em>int-pid</em> が <tt>0</tt> ならば、送り側のプロセス･グループ ID と同じグループ ID の全てのプロセスにシグナルが送られます。
<em>int-pid</em> が <tt>-1</tt> ならば、カレント･ユーザ ID の全プロセスが終了され、newLISP がスーパー･ユーザ特権モードで開始されていたなら、システム・プロセス以外の全プロセスが破棄されます。<br />
CAUTION! If <em>int-pid</em> is <tt>0</tt> the signal is sent to all processes whose 
group ID is equal to the process group ID of the sender. If <em>int-pid</em> is <tt>-1</tt> 
all processes with the current user id will be killed, if newLISP is started with 
super user privileges, all processes except system processes are destroyed.
</p>

<p><em>int-signal</em> を指定した時、<tt>destroy</tt> は <em>int-pid</em> のプロセスに指定された Unix シグナルを送る Unix <tt>kill</tt> コマンドのように動作します。
この第二構文は MS Windows では利用できません。<br />
When specifying <em>int-signal</em>, <tt>destroy</tt> works like a Unix <tt>kill</tt> 
command sending the specified Unix signal to the process in <em>int-pid</em>. 
This second syntax is not available on MS Windows.</p>

<!-- example -->

<pre>
(set 'pid (process "/usr/local/bin/bc" bcin bcout)) 
(destroy pid)

(set 'pid (fork (dotimes (i 1000) (println i) (sleep 10))))
(sleep 100) (destroy pid)
</pre>

<br/><br/>

<a name="det"></a>
<h2><span class="function">det</span></h2>
<h4>syntax: (det <em>matrix</em> [<em>float-pivot</em>])</h4>

<p>正方行列の行列値を返します。行列は、入れ子リストと <a href="#array">アレイ</a> のどちらも可能です。<br />
Returns the determinant of a square matrix.  A matrix can either 
be a nested list or an <a href="#array">array</a>.</p>

<p>オプションで、<tt>0.0</tt> か非常に小さい値を <em>float-pivot</em> に指定できます。
特異行列（訳注:<a href="http://mathworld.wolfram.com/SingularMatrix.html">逆行列を持たない行列</a>）を処理するとゼロになる<a href="http://ja.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3">ＬＵ分解</a>アルゴリズムにおいて、この値はピボット要素の代わりになります。<br />
Optionally <tt>0.0</tt> or a very small value can be specified
in <em>float-pivot</em>. This value substitutes pivot elements in
the LU-decomposition algorithm, which result in zero when
the algorithm deals with a singular matrix.</p>

<!-- example -->

<pre>
(set 'A '((-1 1 1) (1 4 -5) (1 -2 0)))
(det A)  <span class='arw'>&rarr;</span> -1

; treatment of singular matrices
(det '((2 -1) (4 -2)))        <span class='arw'>&rarr;</span> nil
(det '((2 -1) (4 -2)) 0)      <span class='arw'>&rarr;</span> -0
(det '((2 -1) (4 -2)) 1e-20)  <span class='arw'>&rarr;</span> -4e-20
</pre>

<p>行列が特異行列（訳注:<a href="http://mathworld.wolfram.com/SingularMatrix.html">逆行列を持たない行列</a>）で <em>float-pivot</em> が指定されていなければ、<tt>nil</tt> が返ります。<br />
If the matrix is singular and <em>float-pivot</em> is not
specified, <tt>nil</tt> is returned.</p>

<p>他の行列操作 <a href="#invert">invert</a>、<a href="#mat">mat</a>、<a href="#multiply">multiply</a>、<a href="#transpose">transpose</a> も見てください。<br />
See also the other matrix operations 
<a href="#invert">invert</a>, <a href="#mat">mat</a>, 
<a href="#multiply">multiply</a> and <a href="#transpose">transpose</a>.
</p>

<br/>

<a name="device"></a>
<h2><span class="function">device</span></h2>
<h4>syntax: (device [<em>int-io-handle</em>])</h4>

<p><em>int-io-handle</em> は I/O デバイス番号で、デフォルトの標準 I/O ハンドル･ペア の 0（ゼロ）に設定されます。この場合、<i>stdin</i> が 0、<i>stdout</i> が 1 、<i>stderr</i> が 2 です。
<em>int-io-handle</em> は <a href="#open">open</a> を使って先に得られているファイル･ハンドルでもあります。
どちらの場合でも、このハンドルを通して入力と出力が割り当てられます。
引数がない時は、現在のI/Oデバイス番号が返ります。<br />
<em>int-io-handle</em> is an I/O device number, which is set to 0 (zero)
for the default STD I/O pair of handles, 0 for <i>stdin</i>, 1
for <i>stdout</i> and 2 for <i>stderr</i>. <em>int-io-handle</em> may also 
be a file handle previously obtained using <a href="#open">open</a>. In this 
case both, input and output are channeled through this handle.
When no argument is supplied, the current I/O device number is returned. 
</p>

<p><tt>device</tt> で指定される I/O チャンネルは、関数 <a href="#print">print</a>、<a href="#println">println</a>、<a href="#write">write</a>、<a href="#write-line">write-line</a>、<a href="#read-char">read-char</a>、<a href="#read-line">read-line</a> の内部で使われます。
現在の I/O デバイスが 0 か 1 の時は、<a href="#print">print</a> は出力をコンソール･ウィンドウに送り、<a href="#read-line">read-line</a> はキーボードから入力を受け取ります。
現在の I/O デバイスが開いているファイルに設定されているなら、<a href="#print">print</a> や <a href="#read-line">read-line</a> は、そのファイルに対して動作します。<br />
The I/O channel specified by <tt>device</tt> is used internally 
by the functions <a href="#print">print</a>, <a href="#println">println</a>,
<a href="#write">write</a>, <a href="#write-line">write-line</a> and
<a href="#read-char">read-char</a>, <a href="#read-line">read-line</a>. 
When the current I/O device is 0 or 1, <a href="#print">print</a> 
sends output to the console window and <a href="#read-line">read-line</a> 
accepts input from the keyboard. If the current I/O device has been set 
by opening a file, then <a href="#print">print</a> and <a href="#read-line">read-line</a> 
work on that file.</p>

<p>注記：Unix のようなオペレーティング・システムでは、標準入出力にチャンネル 0 を出力で、チャンネル 1 を入力で使うこともできます。
それに対し Windows では、標準入力が 0 で標準出力が 1 と厳密に決まっています。<br />
Note, that on Unix like operating systems, stdin channel 0 can also be used
for output and stdout channel 1 can also be used for reading input. This is
not the case on Windows, where 0 is strictly for input and stdout 1 strictly
for output.</p>

<!-- example -->

<pre>
(device (open "myfile" "write"))  <span class='arw'>&rarr;</span> 5
(print "This goes in myfile")     <span class='arw'>&rarr;</span> "This goes in myfile"
(close (device))                  <span class='arw'>&rarr;</span> true
</pre>


<p><tt>device</tt> に <a href="#close">close</a> を使うと、<tt>device</tt> は自動的に 0（ゼロ）にリセットされますので、注意してください。<br />
Note that using <a href="#close">close</a> on <tt>device</tt> 
automatically resets <tt>device</tt> to 0 (zero).
</p>

<br/><br/>

<a name="difference"></a>
<h2><span class="function">difference</span></h2>
<h4>syntax: (difference <em>list-A</em> <em>list-B</em>)<br/>
syntax: (difference <em>list-A</em> <em>list-B</em> <em>bool</em>)</h4>

<p>第一構文の <tt>difference</tt> は、<em>list-A</em> と <em>list-B</em> 間の<em>集合</em> 差を返します。
結果のリストは、<em>list-A</em> に在って、<em>list-B</em> に無い要素のみ持ちます。
結果のリストの全要素は単一（訳注：重複する要素が無い）ですが、<em>list-A</em> と <em>list-B</em> が単一である必要はありません。
リストの要素には Lisp 式のいかなる型もなれます。<br />
	In the first syntax, <tt>difference</tt> returns 
	the <em>set</em> difference between <em>list-A</em> and <em>list-B</em>. 
	The resulting list only has elements occurring in <em>list-A</em>, 
	but not in <em>list-B</em>. 
	All elements in the resulting list are unique, 
	but <em>list-A</em> and <em>list-B</em> need not be unique. 
	Elements in the lists can be any type of Lisp expression.
</p>

<!-- example -->

<pre>
(difference '(2 5 6 0 3 5 0 2) '(1 2 3 3 2 1))  <span class='arw'>&rarr;</span> (5 6 0)
</pre>


<p>第二構文の <tt>difference</tt> は<em>リスト</em> モードで動作します。
<em>bool</em> は <tt>true</tt> か <tt>nil</tt> 以外に評価される式です。
結果のリストでは、<em>list-A</em> から <em>list-B</em> の全要素が取り除かれますが、<em>list-A</em> で重複している要素は残ります。<br />
	In the second syntax, <tt>difference</tt> works in <em>list</em> mode. 
	<em>bool</em> specifies <tt>true</tt> 
	or an expression not evaluating to <tt>nil</tt>. 
	In the resulting list, all elements of <em>list-B</em> 
	are eliminated in <em>list-A</em>, 
	but duplicates of other elements in <em>list-A</em> are left.
</p>
<!-- example -->

<pre>
(difference '(2 5 6 0 3 5 0 2) '(1 2 3 3 2 1) true)  <span class='arw'>&rarr;</span> (5 6 0 5 0)
</pre>



<p>集合関数 <a href="#intersect">intersect</a>、<a href="#unique">unique</a>、<a href="#union">union</a> も見てください。<br />
	See also the set functions <a href="#intersect">intersect</a>,
	<a href="#unique">unique</a> and <a href="#union">union</a>.
</p>

<br/><br/>

<a name="directory"></a>
<h2><span class="function">directory</span></h2>
<h4>syntax: (directory [<em>str-path</em>])<br/>
syntax: (directory <em>str-path</em> <em>str-pattern</em> [<em>regex-option</em>])</h4>

<p><em>str-path</em> で与えたディレクトリ・パスのディレクトリ・エントリ名のリストが返ります。
失敗すると、<tt>nil</tt> が返ります。 
<em>str-path</em> が省略されると、カレント・ディレクトリのエントリのリストが返ります。<br />
	A list of directory entry names is returned 
	for the directory path given in <em>str-path</em>. 
	On failure, <tt>nil</tt> is returned. 
	When <em>str-path</em> is omitted, 
	the list of entries in the current directory is returned.
</p>

<!-- example -->

<pre>
(directory "/bin")

(directory "c:/")
</pre>


<p>最初の例は <tt>/bin</tt> のディレクトリを返し、二番目の例はドライブＣのルート・ディレクトリのディレクトリ・エントリのリストを返します。
MS Windows システムでも、フォーワード・スラッシュ (<tt>/</tt>) がパス名に使えることに注目してください。
バックスラッシュ (<tt>\</tt>) を使う時は、二つの目のバックスラッシュの前置きが必要です。<br />
	The first example returns the directory of <tt>/bin</tt>, 
	the second line returns a list of directory entries 
	in the root directory of drive C:. 
	Note that on MS Windows systems, 
	a forward slash (<tt>/</tt>) can be included in path names. 
	When used, a backslash (<tt>\</tt>) must be 
	preceded by a second backslash.
</p>

<p>第二構文の <tt>directory</tt> では、<em>str-pattern</em> の正規表現パターンをとることができます。
ディレクトリ・エントリのリスト中で、パターンに一致するファイル名だけが返ります。
<em>regex-option</em> で特殊正規表現オプションを指定できます。
（訳注：正規表現オプションの）詳細は <a href="#regex">regex</a> で見てください。<br />
	In the second syntax, <tt>directory</tt> can take 
	a regular expression pattern in <em>str-pattern</em>. 
	Only filenames matching the pattern will be returned 
	in the list of directory entries. 
	In <em>regex-option</em>, special regular expression options 
	can be specified; see <a href="#regex">regex</a> for details.
</p>

<!-- example -->

<pre>
(directory "." "\\.c")  <span class='arw'>&rarr;</span> ("foo.c" "bar.c")
;; or using braces as string pattern delimiters
(directory "." {\.c})  <span class='arw'>&rarr;</span> ("foo.c" "bar.c")

; show only hidden files (starting with dot)
(directory "." "^[.]")   <span class='arw'>&rarr;</span> ("." ".." ".profile" ".rnd" ".ssh")</pre>


<p>正規表現は <tt>directory</tt> に対して、ファイル名に <tt>".c"</tt> を持つもののみ返すことを強います。<br />
	The regular expression forces <tt>directory</tt> 
	to return only file names containing the string <tt>".c"</tt>.
</p>

<p>正規表現の使える他の関数には、<a href="#find">find</a>、<!-- 8.9.4 --><a href="#find-all">find-all</a>、<a href="#parse">parse</a>、<a href="#regex">regex</a>、<a href="#replace">replace</a>、<a href="#search">search</a> があります。<br />
	Other functions that use regular expressions 
	are <a href="#find">find</a>, <!-- 8.9.4 --><a href="#find-all">find-all</a>,
	<a href="#parse">parse</a>, 
	<a href="#regex">regex</a>, <a href="#replace">replace</a>, 
	and <a href="#search">search</a>.
</p>

<br/><br/>

<a name="directoryp"></a>
<h2><span class="function">directory?</span></h2>
<h4>syntax: (directory? <em>str-path</em>)</h4>

<p><em>str-path</em> がディレクトリかどうかをチェックします。
結果により、<tt>true</tt> か <tt>nil</tt> が返ります。<br />
	Checks if <em>str-path</em> is a directory. 
	Returns <tt>true</tt> or <tt>nil</tt> depending on the outcome.
</p>


<pre>
(directory? "/etc")             <span class='arw'>&rarr;</span> true
(directory? "/usr/local/bin/emacs/")  <span class='arw'>&rarr;</span> nil
</pre>

<br/><br/>

<a name="display-html"></a>
<h2><span class="function">display-html
<a href="#JS"><font size="-1">JS</font></a></span></h2>
<h4>syntax: (display-html <em>str-html</em>)<br/>
syntax: (display-html <em>str-html</em> <em>bool-flag</em>)</h4>

<p>この関数を第一構文で使うと、ブラウザの現在のページを <em>str-html</em> の中にある HTML のページで置き換えます。
HTML のページには、JavaScript を含めることもできます。<br />
Using the first syntax, the function replaces the current page in 
the browser with the HTML page found in <em>str-html</em>.</p>  

<p><em>bool-flag</em> が <tt>true</tt> に評価されると、ページ用に新しいブラウザ・タブが開かれので、現在のページは影響を受けません。<br />
If the <em>bool-flag</em> evaluates to <tt>true</tt>, the page gets
opened in a new browser tab and the current page is not affected.</p>

<p>この関数は JavaScript にコンパイルされた newLISP でのみ、利用できます。<br />
This function is only available on newLISP compiled to JavaScript.</p>

<pre>
(set 'page [text]
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Hello App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;Hello World&lt;/h2&gt;
&lt;/body&gt;
&lt;/html&gt;
[/text])

(display-html page true) <span class='arw'>&rarr;</span> "92"
</pre>

<p>この関数は HTML 文書の文字列としての長さとして返します。（訳注：バイト単位でなく、文字単位です。）<br />
The function returns the length of the HTML document displayed as a string.
</p>

<p>現在のページで JavaScript を評価する関数 <a href="#eval-string-js">eval-string-js</a> も見てください。<br />
See also the function <a href="#eval-string-js">eval-string-js</a> for
evaluation of JavaScript in the current page.</p>

<br/><br/>

<a name="div"></a>
<h2><span class="function">div</span></h2>
<h4>syntax: (div <em>num-1</em> <em>num-2</em> [<em>num-3</em> ... ])<br/>
syntax: (div <em>num-1</em>)</h4>

<p><em>num-1</em> を <em>num-2</em> 以下の数値で連続的に除算します。
<tt>div</tt> は（訳注：整数と浮動小数点数の）混在型算術が可能ですが、戻り値は常に浮動小数点数です。
<tt>NaN</tt>(not a number) になる浮動小数点計算には <tt>NaN</tt> を返します。<br />
	Successively divides <em>num-1</em>
	by the number in <em>num-2&mdash;</em>. 
	<tt>div</tt> can perform mixed-type arithmetic, 
	but it always returns floating point numbers. 
	Any floating point calculation 
	with <tt>NaN</tt> also returns <tt>NaN</tt>.
</p>
	

<!-- example -->

<pre>
(div 10 3)                 <span class='arw'>&rarr;</span> 3.333333333
(div 120 (sub 9.0 6) 100)  <span class='arw'>&rarr;</span> 0.4

(div 10)                   <span class='arw'>&rarr;</span> 0.1
</pre>


<p>引数が <em>num-1</em> のみの時、<tt>div</tt> は <em>num-1</em> の逆数を計算します。<br />
	When <em>num-1</em> is the only argument,
	<tt>div</tt> calculates the inverse of <em>num-1</em>.
</p>

<br/><br/>

<a name="do-until"></a>

<h2><span class="function">do-until</span></h2>
<h4>syntax: (do-until <em>exp-condition</em> [<em>body</em>])</h4>

<p><em>exp-condition</em> が評価される前に <em>body</em> 中の式群が評価されます。
<em>exp-condition</em> の評価が <tt>nil</tt> 以外なら <tt>do-until</tt> 式は終了し、そうでなければ <em>body</em> 中の式群が再び評価されます。
<a href="#until">until</a> が本体式群の<em>評価の前に</em> 条件式を評価するのに対して、<tt>do-until</tt> は本体の式群の<em>評価の後に</em> 条件式を評価しますので、注意してください。
<tt>do-until</tt> 式の戻り値は、本体式群の最後の評価です。
<em>body</em> が空なら、<em>exp-condition</em> の最後の結果が返ります。<br />
	The expressions in <em>body</em> are evaluated 
	before <em>exp-condition</em> is evaluated. 
	If the evaluation of <em>exp-condition</em> is not <tt>nil</tt>, 
	then the <tt>do-until</tt> expression is finished; 
	otherwise, the expressions in <em>body</em> get evaluated again. 
	Note that <tt>do-until</tt> evaluates the conditional expression 
	<em>after</em> evaluating the body expressions, 
	whereas <a href="#until">until</a> checks the condition 
	<em>before</em> evaluating the body. 
	The return value of the <tt>do-until</tt> expression 
	is the last evaluation of the <em>body</em> expression.
	If <em>body</em> is empty, the last result of <em>exp-condition</em>
    is returned.
</p>

<p><tt>do-until</tt> は、システムの反復シンボル <tt>$idx</tt> も更新します。<br />
<tt>do-until</tt> also updates the system iterator symbol <tt>$idx</tt>.</p>

<!-- example -->

<pre>
(set 'x 1)
(do-until (&gt; x 0) (inc x))
x  <span class='arw'>&rarr;</span> 2

(set 'x 1)
(until (&gt; x 0) (inc x))
x  <span class='arw'>&rarr;</span> 1
</pre>


<p>（訳注：上記例では、）<tt>do-until</tt> が最低一回はループを通るのに対して、<a href="#until">until</a> はループに入りません。<br />
	While <tt>do-until</tt> goes through the loop at least once, 
	<a href="#until">until</a> never enters the loop.
</p>

<p>関数<a href="#while">while</a> と <a href="#do-while">do-while</a> も見てください。<br />
	See also the functions <a href="#while">while</a> 
	and <a href="#do-while">do-while</a>.
</p>

<br/><br/>

<a name="do-while"></a>
<h2><span class="function">do-while</span></h2>
<h4>syntax: (do-while <em>exp-condition body</em>)</h4>

<p><em>exp-condition</em> が評価される前に <em>body</em> 中の式群が評価されます。
<em>exp-condition</em> の評価が <tt>nil</tt> なら <tt>do-while</tt> 式は終了し、そうでなければ <em>body</em> 中の式群が再び評価されます。
<a href="#while">while</a> が本体を<em>評価する前</em> に条件をチェックするのに対して、<tt>do-while</tt> は本体式群を<em>評価した後</em> に条件式を評価します。<br />
	The expressions in <em>body</em> are evaluated 
	before <em>exp-condition</em> is evaluated. 
	If the evaluation of <em>exp-condition</em> is <tt>nil</tt>, 
	then the <tt>do-while</tt> expression is finished; 
	otherwise the expressions in <em>body</em> get evaluated again. 
	Note that <tt>do-while</tt> evaluates the conditional expression 
	<em>after</em> evaluating the body expressions, 
	whereas <a href="#while">while</a> checks the condition 
	<em>before</em> evaluating the body. 
	The return value of the <tt>do-while</tt> expression 
	is the last evaluation of the <em>body</em> expression.
</p>

<p><tt>do-while</tt> は、システムの反復シンボル <tt>$idx</tt> も更新します。<br />
<tt>do-while</tt> also updates the system iterator symbol <tt>$idx</tt>.</p>

<!-- example -->

<pre>
(set 'x 10)
(do-while (&lt; x 10) (inc x))
x  <span class='arw'>&rarr;</span> 11

(set 'x 10)
(while (&lt; x 10) (inc x)) 
x  <span class='arw'>&rarr;</span> 10
</pre>


<p>（訳注：上記例では、）<tt>do-while</tt> が最低一回はループを通るのに対して、<a href="#while">while</a> はループに入りません。<br />
	While <tt>do-while</tt> goes through the loop at least once, 
	<a href="#while">while</a> never enters the loop.
</p>

<p>関数<a href="#until">until</a> と <a href="#do-until">do-until</a> も見てください。<br />
	See also the functions <a href="#until">until</a> 
	and <a  href="#do-until">do-until</a>.
</p>

<br/><br/>

<a name="doargs"></a>
<h2><span class="function">doargs</span></h2>
<h4>syntax: (doargs (<em>sym</em> [<em>exp-break</em>])<em> body</em>)</h4>

<p>ユーザ定義関数やマクロの中で引数リストの総数分、繰り返します。
このような関数やマクロは <a href="#define">define</a>、<a href="#define-macro">define-macro</a>、<a href="#lambda">lambda</a>、<a href="#lambda-macro">lambda-macro</a> を使って定義できます。
引数リストが空になるか、（<em>exp-break</em>に定義される）オプションの脱出条件が <tt>true</tt> か論理的真値に評価されるまで、<em>sym</em> の変数に引数リストの要素が次々にセットされます。
<tt>doargs</tt> 式は、最後の評価結果を返します。<br />
Iterates through all members of the argument list 
inside a user-defined function or macro. This function or macro can be defined using <a href="#define">define</a>, 
<a href="#define-macro">define-macro</a>, <a href="#lambda">lambda</a>, or
<a href="#lambda-macro">lambda-macro</a>.
The variable in <em>sym</em> is set sequentially to all members in the argument list 
until the list is exhausted or an optional break expression 
(defined in <em>exp-break</em>) evaluates to <tt>true</tt> or a logical true value. 
The <tt>doargs</tt> expression always returns the result of the last evaluation.</p>

<p><tt>doargs</tt> は、システムの反復シンボル <tt>$idx</tt> も更新します。<br />
<tt>doargs</tt> also updates the system iterator symbol <tt>$idx</tt>.</p>

<!-- example -->

<pre>
(define (foo)
    (doargs (i) (println i)))

<b>&gt;</b> (foo 1 2 3 4)
<b>1
2
3
4</b>
</pre>


<p>オプションの脱出条件は、<tt>doargs</tt> に引数操作の中断を引き起こします：<br />
The optional break expression causes <tt>doargs</tt> 
to interrupt processing of the arguments:</p>


<pre>
(define-macro (foo)
    (doargs (i (= i 'x)) 
        (println i)))

<b>&gt;</b> (foo a b x c d e)
<b>a
b
true</b>
</pre>


<p>引数リストの全てを一度にアクセスするためには、関数 <a href="#args">args</a> を使ってください。<br />
Use the <a href="#args">args</a> function to access the entire argument list at once.</p>

<br/><br/>

<a name="dolist"></a>
<h2><span class="function">dolist</span></h2>
<h4>syntax: (dolist (<em>sym</em>  <em>list</em>|<em>array</em> [<em>exp-break</em>])<em> body</em>)</h4>

<p><em>list</em> や <em>array</em> の各要素毎に <em>body</em> の式群が評価されます。
本体式群が評価される前に、変数 <em>sym</em> にはリストの各要素にセットされます。
ループ･インデックスとして使われる変数（訳注：変数 <em>sym</em> のこと）は、局所変数で<a href="#scoping">ダイナミック･スコープの規則</a>に従って振舞います。<br />
	The expressions in <em>body</em> are evaluated 
	for each element in <em>list</em> or <em>array</em>. 
	The variable in <em>sym</em> is set to each of the elements 
	before evaluation of the body expressions. 
	The variable used as loop index is local 
	and behaves according to the rules of dynamic scoping.
</p>

<p>オプションの <em>exp-break</em> に早期ループ脱出条件を定義できます。
中断式が <tt>nil</tt> 以外に評価されると、<tt>dolist</tt> ループは <em>exp-break</em> の値を返します。
中断条件は、<em>body</em> を評価する前に試されます。<br />
	Optionally, a condition for early loop exit 
	may be defined in <em>exp-break</em>. 
	If the break expression evaluates to any non-<tt>nil</tt> value, 
	the <tt>dolist</tt> loop returns with the value of <em>exp-break</em>. 
	The break condition is tested before evaluating <em>body.</em></p>

<!-- example -->

<pre>
(set 'x 123)
(dolist (x '(a b c d e f g))  ; prints: abcdefg
    (print x))  <span class='arw'>&rarr;</span> g          ; return value

(dolist (x '(a b c d e f g) (= x 'e))  ; prints: abcd
    (print x))

;; x is local in dolist
;; x has still its old value outside the loop

x  <span class='arw'>&rarr;</span> 123  ; x has still its old value
</pre>


<p>この例は、コンソール･ウィンドウに <tt>abcdefg</tt> を表示します。
<tt>dolist</tt> の <tt>x</tt> はローカル･スコープなので、<tt>dolist</tt> が実行された後で <tt>x</tt> の値は変化せずに残ります。
<tt>dolist</tt> の戻り値は、最後に評価される式の結果です。<br />
	This example prints <tt>abcdefg</tt> in the console window. 
	After the execution of <tt>dolist</tt>,
	the value for <tt>x</tt> remains unchanged 
	because the <tt>x</tt> in <tt>dolist</tt> has local scope. 
	The return value of <tt>dolist</tt> is the result 
	of the last evaluated expression.
</p>

<p>内部システム変数 <tt>$idx</tt> は、<tt>dolist</tt> に渡されたリストの現在のオフセットを保持し、実行中にアクセス可能です：<br />
	The internal system variable <tt>$idx</tt> 
	keeps track of the current offset 
	into the list passed to <tt>dolist</tt>,
	and it can be accessed during its execution:
</p>


<pre>
(dolist (x '(a b d e f g))
  (println $idx ":" x))  <span class='arw'>&rarr;</span> g

<b>0:a
1:b
2:d
3:e
4:f
5:g</b>
</pre>


<p>太字がコンソール･アウトプットです。
<tt>$idx</tt> はプロテクトされていて、ユーザが変更することはできません。<br />
	The console output is shown in boldface. 
	<tt>$idx</tt> is protected and cannot be changed by the user.
</p>

<br/><br/>

<a name="dostring"></a>
<h2><span class="function">dostring</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (dostring (<em>sym</em>  <em>string</em> [<em>exp-break</em>]) <em>body</em>)</h4>

<p><em>string</em> の各キャラクタ毎に <em>body</em> の式群が評価されます。
本体式群が評価される前に、変数 <em>sym</em> には 各 ASCII 値 か UTF-8 の整数値がセットされます。
ループ･インデックスとして使われる変数（訳注：変数 <em>sym</em> のこと）は、局所変数で<a href="#scoping">ダイナミック･スコープの規則</a>に従って振舞います。<br />
	The expressions in <em>body</em> are evaluated 
	for each character in <em>string</em>. 
	The variable in <em>sym</em> is set to each ASCII or UTF-8 integer value of the characters 
	before evaluation of the body expressions. 
	The variable used as loop index is local 
	and behaves according to the rules of dynamic scoping.
</p>

<p>オプションの <em>exp-break</em> に早期ループ脱出条件を定義できます。
中断式が <tt>nil</tt> 以外に評価されると、<tt>dostring</tt> ループは <em>exp-break</em> の値を返します。
中断条件は、<em>body</em> を評価する前に試されます。<br />
	Optionally, a condition for early loop exit 
	may be defined in <em>exp-break</em>. 
	If the break expression evaluates to any non-<tt>nil</tt> value, 
	the <tt>dolist</tt> loop returns with the value of <em>exp-break</em>. 
	The break condition is tested before evaluating <em>body.</em>
</p>

<!-- example -->

<pre>
; ASCII example
(set 'str "abcdefg")
(dostring (c str) (println c " - " (char c)))

<b>97 - a
98 - b
99 - c
100 - d
101 - e
102 - f
103 - g</b>

; UTF8 example
(set 'utf8str "我能吞下玻璃而不伤身体。")
(dostring (c utf8str) (println c " - " (char c)))

<b>25105 - 我
33021 - 能
21534 - 吞
 ...
20307 - 体
12290 - 。 </b>
</pre>


<p>この例では、コンソール･ウィンドウに各キャラクタの値が表示されます。
UTF-8 が使えるバージョンの newLISP では、個々のキャラクタが 1 バイトより大きくてループ変数の数値も 255 を超えるかもしれません。
<tt>dostring</tt> の戻り値は、最後に評価される式の結果です。<br />
	This example prints the value of each character
  in the console window. In UTF-8 enabled versions of newLISP,
  individual characters may be longer than one byte and the
  number in the loop variable may exceed 255.
	The return value of <tt>dostring</tt> is the result 
	of the last evaluated expression.
</p>

<p>内部システム変数 <tt>$idx</tt> は、<tt>dostring</tt> に渡された文字列の現在のオフセットを保持し、実行中にアクセス可能です。<br />
	The internal system variable <tt>$idx</tt> 
	keeps track of the current offset 
	into the string passed to <tt>dostring</tt>,
	and it can be accessed during its execution.
</p>

<br/><br/>

<a name="dotimes"></a>
<h2><span class="function">dotimes</span></h2>
<h4>syntax: (dotimes (<em>sym-var</em> <em>int-count</em> [<em>exp-break</em>]) <em>body</em>)</h4>

<p><em>body</em> の式群が <em>int</em> 回評価されます。
本体式（群）が評価される前に、変数<em>sym-var</em> には 0 (zero) から (<em>int</em> - 1) までがセットされます。
ループ･インデックスとして使われる変数（訳注：変数 <em>sym-var</em> のこと）は <tt>dotimes</tt> での局所変数で、<a href="#scoping">ダイナミック･スコープの規則</a>に従って振舞います。
ループ･インデックスは整数型です。
<tt>dotimes</tt> は、<em>body</em> 中、最後に評価された式の結果を返します。
<tt>dotimes</tt> 宣言文の評価が終わった後、<em>sym-var</em> は以前の値になります。<br />
	The expressions in <em>body</em> are evaluated <em>int</em> times. 
	The variable in <em>sym</em> is set from 0 (zero) to (<em>int</em> - 1) 
	each time before evaluating the body expression(s). 
	The variable used as the loop index is local to the <tt>dotimes</tt> 
	expression and behaves according the rules of dynamic scoping. 
	The loop index is of integer type. 
	<tt>dotimes</tt> returns the result of 
	the last expression evaluated in <em>body</em>.
	After evaluation of the <tt>dotimes</tt>
    statement <em>sym</em> assumes its previous
    value.
</p>

<p>オプションの <em>exp-break</em> に早期ループ脱出条件を定義できます。
中断式が <tt>nil</tt> 以外に評価されると、<tt>dotimes</tt> ループは <em>exp-break</em> の値を返します。
中断条件は、<em>body</em> を評価する前に試されます。<br />
	Optionally, a condition for early loop exit 
	may be defined in <em>exp-break</em>. 
	If the break expression evaluates to any non-<tt>nil</tt> value, 
	the <tt>dotimes</tt> loop returns with the value of <em>exp-break</em>. 
	The break condition is tested before evaluating <em>body</em>.
</p>

<!-- example -->

<pre>
(dotimes (x 10)
  (print x))  <span class='arw'>&rarr;</span> 9  ; return value
</pre>


<p>これは、コンソール･ウィンドウに <tt>0123456789</tt> を表示します。<br />
	This prints <tt>0123456789</tt> to the console window.
</p>

<br/><br/>

<a name="dotree"></a>
<h2><span class="function">dotree</span></h2>
<h4>syntax: (dotree (<em>sym</em> <em>sym-context</em> [<em>bool</em>]) <em>body</em>)</h4>

<p><em>sym-context</em> の全シンボルで、<em>body</em> の式群が評価されます。
シンボルはソート順にアクセスされます。
本体の式（群）が各々評価される前に、変数<em>sym</em> には <em>sym-context</em> からのシンボルが次々とセットされます。
ループ･インデックスとして使われる変数（訳注：変数 <em>sym</em> のこと）は <tt>dotree</tt> での局所変数で、<a href="#scoping">ダイナミック･スコープの規則</a>に従って振舞います。<br />
The expressions in <em>body</em> are evaluated for all symbols in <em>sym-context</em>. 
The symbols are accessed in a sorted order.  Before each evaluation of the body expression(s),
the variable in <em>sym</em> is set to the next symbol from <em>sym-context</em>. 
The variable used as the loop index is local to the <tt>dotree</tt> expression 
and behaves according the rules of dynamic scoping.</p>

<p>オプションの <em>bool</em> 式が <tt>nil</tt> 以外に評価されると、アンダースコア･キャラクタ <tt>_</tt> の付いたシンボル文字列のみがアクセスされます。
アンダースコア <tt>_</tt> で始まるシンボル名は、<a href="#hash">hash keys</a> や <a href="#bayes-train">bayes-train</a> で作られるシンボルです。<br />
When the optional <em>bool</em> expression evaluates to not <tt>nil</tt>, only symbols 
starting with an underscore character <tt>_</tt> are accessed. Symbol names starting with 
an <tt>_</tt> underscore are used for <a href="#hash">hash keys</a> and symbols created by 
<a href="#bayes-train">bayes-train</a>.</p>

<p><tt>dotree</tt> も、システム反復変数 <tt>$idx</tt> を更新します。<br />
<tt>dotree</tt> also updates the system iterator symbol <tt>$idx</tt>.</p>

<!-- example -->

<pre>
;; faster and less memory overhead
(dotree (s SomeCTX) (print s " "))

;; slower and higher memory usage
(dolist (s (symbols SomeCTX)) (print s " "))
</pre>


<p>
この例は、SomeCTX 内の全シンボル名をコンソール･ウィンドウに表示します。<br />
This example prints the names of all symbols inside SomeCTX to the console window.
</p>

<br/><br/>

<a name="dump"></a>
<h2><span class="function">dump</span></h2>
<h4>syntax: (dump [<em>exp</em>])</h4>

<p>newLISP セルのバイナリ･データを表示します。
この関数に引数を与えないと、全ての Lisp セルがコンソールにリスト表示されます。
<em>exp</em> が与えられると、それが評価され、その Lisp セルの中身が（訳注：バイナリ･データの）リストで返ります。<br />
	Shows the binary contents of a newLISP cell. 
	Without an argument, this function outputs 
	a listing of all Lisp cells to the console. 
	When <em>exp</em> is given, 
	it is evaluated and the contents 
	of a Lisp cell are returned in a list.
</p>

<!-- example -->

<pre>
(dump 'a)   <span class='arw'>&rarr;</span> (9586996 5 9578692 9578692 9759280)

(dump 999)  <span class='arw'>&rarr;</span> (9586996 130 9578692 9578692 999)
</pre>


<p>このリストには、下記に示すメモリ･アドレスと情報が含まれます：<br />
	The list contains the following memory addresses and information:
</p>

<table summary="dump data types">
<tr align="left"><th>offset</th><th>description（詳細）</th></tr>
<tr><td>0</td><td>newLIPセルのメモリ･アドレス<br />memory address of the newLISP cell</td></tr>
<tr><td>1</td><td>cell-&gt;type:<br>&nbsp;&nbsp;&nbsp;&nbsp;major/minor 型、詳細は newlisp.h を見てください。<br />&nbsp;&nbsp;&nbsp;&nbsp;major/minor type, see newlisp.h for details</td></tr>
<tr><td>2</td><td>cell-&gt;next:<br>&nbsp;&nbsp;&nbsp;&nbsp;リスト･ポインタへのリンク<br />&nbsp;&nbsp;&nbsp;&nbsp;linked list ptr</td></tr>
<tr><td>3</td><td>cell-&gt;aux:<br>&nbsp;&nbsp;&nbsp;&nbsp;文字列の長さ＋１か、<br>&nbsp;&nbsp;&nbsp;&nbsp;64ビット整数のロー（リトル・エンディアン）またはハイ（ビッグ・エンディアン）ワードか、<br>&nbsp;&nbsp;&nbsp;&nbsp;IEEE 754 倍精度浮動書数点数のロー・ワード<br />&nbsp;&nbsp;&nbsp;&nbsp;string length+1 or <br>&nbsp;&nbsp;&nbsp;&nbsp;low (little endian) or high (big endian) word of 64-bit integer or<br/>&nbsp;&nbsp;&nbsp;&nbsp;low word of IEEE 754 double float</td></tr>
<tr><td>4</td><td>cell-&gt;contents:<br>&nbsp;&nbsp;&nbsp;&nbsp;文字列／シンボルのアドレスか、<br>&nbsp;&nbsp;&nbsp;&nbsp;64ビット整数のハイ（リトル・エンディアン）またはロー（ビッグ・エンディアン）ワードか、<br>&nbsp;&nbsp;&nbsp;&nbsp;IEEE 754 倍精度浮動書数点数のハイ・ワード<br />&nbsp;&nbsp;&nbsp;&nbsp;string/symbol address or<br/> &nbsp;&nbsp;&nbsp;&nbsp;high (little endian) or low (big endian) word of 64-bit integer or<br/>&nbsp;&nbsp;&nbsp;&nbsp;high word of IEEE 754 double float</td></tr>
</table><br/>

<p>この関数は、セルの型ビットを変更したり、newLISP 内部をハックするのに役立ちます。
わかりやすい例として、関数 <a href="#cpymem">cpymem</a> を見てください。<br />
	This function is valuable for changing type bits in cells 
	or hacking other parts of newLISP internals. 
	See the function <a href="#cpymem">cpymem</a> 
	for a comprehensive example.
</p>

<br/><br/>

<a name="dup"></a>
<h2><span class="function">dup</span></h2>

<h4>syntax: (dup <em>exp</em> <em>int-n</em> [<em>bool</em>])<br/>
syntax: (dup <em>exp</em>)</h4>

<p><em>exp</em> の式が文字列に評価されたなら、その文字列を <em>int-n</em> 回複製して返します。
<tt>nil</tt> 以外に評価される式を <em>bool</em> に指定すると、文字列は複製されますが連結されず、他のデータ型と同じようにリストになります。<br />
	If the expression in <em>exp</em> evaluates to a string, 
	it will be replicated <em>int-n</em> times within a string and returned. 
	When specifying an expression evaluating 
	to anything other than <tt>nil</tt> in <em>bool</em>, 
	the string will not be concatenated 
	but replicated in a list like any other data type.
</p>

<p><em>exp</em> が文字列以外のデータ型の場合は、戻り値のリストには <em>exp</em> の評価値が <em>int-n</em> 個入ります。<br />
	If <em>exp</em> contains any data type other than string, 
	the returned list will contain <em>int-n</em> evaluations of <em>exp</em>.
</p>

<p>反復パラメータ無し時、<tt>dup</tt> は 2 を推定します。<br />
Without the repetition parameter, <tt>dup</tt> assumes 2.</p>

<!-- example -->

<pre>
(dup "A" 6)       <span class='arw'>&rarr;</span> "AAAAAA"
(dup "A" 6 true)  <span class='arw'>&rarr;</span> ("A" "A" "A" "A" "A" "A")
(dup "A" 0)       <span class='arw'>&rarr;</span> ""
(dup "AB" 5)      <span class='arw'>&rarr;</span> "ABABABABAB"
(dup 9 7)         <span class='arw'>&rarr;</span> (9 9 9 9 9 9 9)
(dup 9 0)         <span class='arw'>&rarr;</span> ()
(dup 'x 8)        <span class='arw'>&rarr;</span> (x x x x x x x x)
(dup '(1 2) 3)    <span class='arw'>&rarr;</span> ((1 2) (1 2) (1 2))
(dup "\000" 4)    <span class='arw'>&rarr;</span> "\000\000\000\000"

(dup "*")         <span class='arw'>&rarr;</span> "**"
</pre>


<p>最後のほうの例は、4つのバイナリ・ゼロで満たされる文字列を作るという、バイナリ・データの扱い方を示しています。<br />
	The last example shows handling of binary information, 
	creating a string filled with four binary zeroes.
</p>

<p>関数 <a href="#sequence">sequence</a> や <a href="#series">series</a> も見てください。<br />
	See also the functions <a href="#sequence">sequence</a> 
	and <a href="#series">series</a>.
</p>

<br/><br/>

<a name="emptyp"></a>
<h2><span class="function">empty?</span></h2>
<h4>syntax: (empty? <em>exp</em>)<br/>
syntax: (empty? <em>str</em>)</h4>


<p><em>exp</em> が空のリスト（あるいは、<em>str</em> が空の文字列）かどうかを試します。
引数に要素を含んでいるかどうかで、<tt>true</tt> か <tt>nil</tt> が返ります。<br />
	<em>exp</em> is tested for an empty list 
	(or <em>str</em> for an empty string). 
	Depending on whether the argument contains elements, 
	<tt>true</tt> or <tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(set 'var '())
(empty? var)         <span class='arw'>&rarr;</span> true
(empty? '(1 2 3 4))  <span class='arw'>&rarr;</span> nil
(empty? "hello")     <span class='arw'>&rarr;</span> nil
(empty? "")          <span class='arw'>&rarr;</span> true
</pre>


<p>最初の例はリストをチェックし、次の二つは文字列をチェックしています。<br />
	The first example checks a list, 
	while the second two examples check a string.
</p>

<br/><br/>

<a name="encrypt"></a>
<h2><span class="function">encrypt</span></h2>
<h4>syntax: (encrypt <em>str-source</em> <em>str-pad</em>)</h4>

<p><ruby><rb>暗号帳となる文字列</rb><rp>（</rp><rt>エンクリプション・パッド</rt><rp>）</rp></ruby> <em>str-pad</em> を使って、<a href="http://en.wikipedia.org/wiki/One-time_pad"><ruby><rb>一回限りの暗号帳</rb><rp>（</rp><rt>ワンタイム・パッド</rt><rp>）</rp></ruby></a> (OTP) で <em>str-source</em> を暗号化します。
<em>str-pad</em> が長くて、バイト列がランダムであればあるほど、暗号は安全になります。
<ruby><rb>暗号帳となる文字列</rb><rp>（</rp><rt>エンクリプション・パッド</rt><rp>）</rp></ruby>がソース・テキストより長ければ、完全にランダムに一回だけ使われることになります。
つまり、<ruby><rb>一回限りの暗号帳</rb><rp>（</rp><rt>ワンタイム・パッド</rt><rp>）</rp></ruby>で暗号化されたデータは一見ランダムなデータのように見えるので、ほとんど解読不可能になります。
オリジナルの復元には、同じ関数と<ruby><rb>暗号帳となる文字列</rb><rp>（</rp><rt>エンクリプション・パッド</rt><rp>）</rp></ruby>を暗号化されたテキストに適用します：<br />
Performs a <a href="http://en.wikipedia.org/wiki/One-time_pad">one-time pad</a> (OTP)
encryption of <em>str-source</em> using the encryption pad in <em>str-pad</em>. 
The longer <em>str-pad</em> is 	and the more random the bytes are, 
the safer the encryption. If the pad is as long as the source text, 
is fully random, and is used only once, then one-time&ndash;pad encryption 
is virtually impossible to break, since the encryption seems to contain only 
random data. To retrieve the original, the same function and pad 
are applied again to the encrypted text:
</p>

<!-- example -->

<pre>
(set 'secret 
  (encrypt "A secret message" "my secret key")) 
<span class='arw'>&rarr;</span> ",YS\022\006\017\023\017TM\014\022\n\012\030E"

(encrypt secret "my secret key")  <span class='arw'>&rarr;</span> "A secret message"
</pre>


<p>二番目の例は、ファイルを丸ごと暗号化しています：<br />
	The second example encrypts a whole file:
</p>



<pre>
(write-file "myfile.enc" 
  (encrypt (read-file "myfile") "29kH67*"))
</pre>


<br/><br/>

<a name="ends-with"></a>
<h2><span class="function">ends-with</span></h2>
<h4>syntax: (ends-with <em>str-data</em> <em>str-key</em> [<em>num-option</em>])<br/>
syntax: (ends-with <em>list</em> <em>exp</em>)</h4>

<p>第一構文の <tt>ends-with</tt> は、<em>str-data</em> の文字列が <em>str-key</em> で指定された文字列で終わるかどうかをテストします。
結果次第で、<tt>true</tt> か <tt>nil</tt> が返ります。<br />
In the first syntax, <tt>ends-with</tt> tests the string in <em>str-data</em> to see if it
ends with the string specified in <em>str-key</em>.  It returns <tt>true</tt> or <tt>nil</tt> 
depending on the outcome. </p>
	
<p>正規表現 <em>option</em> 番号が指定されると、<em>str-key</em> に正規表現パターンが使えます。
<em>option</em> で使える番号は <a href="#regex">regex</a> で見てください。<br />
If a regular expression <em>option</em> number is 
specified, <em>str-key</em> contains a regular expression pattern. See
<a href="#regex">regex</a> for valid numbers for <em>option</em>.
</p>

<!-- example -->

<pre>
(ends-with "newLISP" "LISP")         <span class='arw'>&rarr;</span> true
(ends-with "newLISP" "lisp")         <span class='arw'>&rarr;</span> nil
;; use regular expressions
(ends-with "newLISP" "lisp|york" 1)  <span class='arw'>&rarr;</span> true
</pre>


<p>第二構文の <tt>ends-with</tt> は、（訳注：<em>list</em> の）リストが <em>exp</em> のリスト要素で終わっているかどうかをチェックします。
結果次第で、<tt>true</tt> か <tt>nil</tt> が返ります。<br />
	In the second syntax, 
	<tt>ends-with</tt> checks if a list 
	ends with the list element in <em>exp</em>. 
	<tt>true</tt> or <tt>nil</tt> is returned depending on outcome.
</p>

<!-- example -->

<pre>
(ends-with '(1 2 3 4 5) 5)             <span class='arw'>&rarr;</span> true
(ends-with '(a b c d e) 'b)            <span class='arw'>&rarr;</span> nil
(ends-with '(a b c (+ 3 4)) '(+ 3 4))  <span class='arw'>&rarr;</span> true
</pre>


<p>最後の例は、<em>exp</em> にリスト自身も使えることを示しています。<br />
	The last example shows that <em>exp</em> could be a list by itself.
</p>

<p>関数 <a href="#starts-with">starts-with</a> も見てください。<br />
	See also the <a href="#starts-with">starts-with</a> function.
</p>

<br/><br/>

<a name="env"></a>

<h2><span class="function">env</span></h2>
<h4>syntax: (env)<br/>
syntax: (env <em>var-str</em>)<br/>
syntax: (env <em>var-str</em> <em>value-str</em>)</h4>

<p>第一構文（引数無し）は、オペレーティング・システム環境の各エントリーを連想リストとして取り出します。連想リストは、環境変数とその値がキー・値対になります。<br />
In the first syntax (without arguments), the operating system's environment is 
retrieved as an association list in which each entry is a key-value pair of
environment variable and value.</p>

<!-- example -->

<pre>
(env)  
<span class='arw'>&rarr;</span> (("PATH" "/bin:/usr/bin:/sbin") ("TERM" "xterm-color") ... ))
</pre>


<p>第二構文では、<em>var-str</em> を環境変数に与えます。
<tt>env</tt> は変数の値を返すか、変数が環境に無い場合の <tt>nil</tt> を返します。<br />
In the second syntax, the name of an environment variable 
is given in <em>var-str</em>. <tt>env</tt> returns the value 
of the variable or <tt>nil</tt> if the variable does not exist 
in the environment.</p>

<!-- example -->

<pre>
(env "PATH")  <span class='arw'>&rarr;</span> "/bin:/usr/bin:/usr/local/bin"
</pre>


<p>
第三構文（変数名 <em>var-str</em> と対になる値 <em>value-str</em>）は、環境変数を設定するか、新規に作成します。
<em>value-str</em> が空文字列 <tt>""</tt> なら、変数は環境から完全に削除されますが、Solaris 上で動作している時は、空の文字列が設定されます。<br />
The third syntax (variable name in <em>var-str</em> 
and value pair in <em>value-str</em>) sets or creates 
an environment variable. If <em>value-str</em> is the 
empty string <tt>""</tt>, then the variable is completely
removed from the environment except when running on Solaris,
where the variable stays with an empty string.</p>

<!-- example -->

<pre>
(env "NEWLISPBIN" "/usr/local/bin/")  <span class='arw'>&rarr;</span> true
(env "NEWLISPBIN")              <span class='arw'>&rarr;</span> "/usr/local/bin/"
(env "NEWLISPBIN" "")           <span class='arw'>&rarr;</span> true
(env "NEWLISPBIN")              <span class='arw'>&rarr;</span> nil
</pre>

<br/><br/>

<a name="erf"></a>
<h2><span class="function">erf</span></h2>
<h4>syntax: (erf <em>num</em>)</h4>

<p><tt>erf</tt> は、<em>num</em> の値の<a href="http://ja.wikipedia.org/wiki/%E8%AA%A4%E5%B7%AE%E9%96%A2%E6%95%B0">誤差関数</a>を計算します。
誤差関数は、次のように定義されます：<br />
	<tt>erf</tt> calculates the error function 
	of a number in <em>num</em>. 
	The error function is defined as:
</p>

<p><b><em>erf (x) = 2/sqrt(pi) * integral from 0 to x of exp(-t^2) dt</em></b></p>

<!-- example -->

<pre>
(map erf (sequence 0.0 6.0 0.5))
<span class='arw'>&rarr;</span> 
(0 0.5204998778 0.8427007929 0.9661051465 0.995322265 0.999593048 
 0.9999779095 0.9999992569 0.9999999846 0.9999999998 1 1 1) 
</pre>

<br/><br/>

<a name="error-event"></a>
<h2><span class="function">error-event</span></h2>
<h4>syntax: (error-event <em>sym-event-handler | func-event-handler</em>)<br/>
syntax: (error-event nil)</h4>

<p><em>sym-event-handler</em> には、エラー操作のためのユーザ定義関数が入ります。
エラーが発生するとシステムは <a href="#reset">reset</a> を実行し、ユーザ・エラー・ハンドラを実行します。
エラー・ハンドラでは、エラー番号とテキストを取り出すために、組込関数<a href="#last-error">last-error</a> が使えます。
イベント・ハンドラには、クォート付きのシンボルかラムダ関数を指定します。<br />
<em>sym-event-handler</em> contains a user-defined function for handling errors. 
Whenever an error occurs, the system performs a <a href="#reset">reset</a> 
and executes the user-defined error handler.  The error handler can use the 
built-in function <a href="#last-error">last-error</a> to retrieve the number 
and text of the error. The event handler is specified as either a quoted
symbol or a lambda function.</p>

<p><tt>error-event</tt> をキャンセルするには、第二構文を使ってください。<br />
To cancel <tt>error-event</tt>, use the second syntax.</p>

<!-- example -->

<pre>
(define (my-handler)    
  (print "error # " (first (last-error)) " has occurred\n") )

(error-event 'my-handler)  <span class='arw'>&rarr;</span> my-handler

;; specify a function directly

(error-event my-handler)  <span class='arw'>&rarr;</span> $error-event

(error-event 
  (fn () (print "error # " (first (last-error)) " has occurred\n")))

(error-event exit)  <span class='arw'>&rarr;</span> $error-event
</pre>


<p>エラーを扱う別の方法としては、<a href="#catch">catch</a> を見てください。
ユーザ定義エラーを起こすには、 <a href="#throw-error">throw-error</a> を使ってください。<br />
For a different way of handling errors, see the <a href="#catch">catch</a> function. 
Use <a href="#throw-error">throw-error</a> to throw user-defined errors.</p>

<br/><br/>

<a name="eval"></a>
<h2><span class="function">eval</span></h2>
<h4>syntax: (eval <em>exp</em>)</h4>

<p><em>eval</em> は <em>exp</em> の評価結果を現変数環境で評価します。<br />
<em>eval</em> evaluates the result of evaluating <em>exp</em> in the current 
variable environment.</p>

<!-- example -->

<pre>
(set 'expr '(+ 3 4))  <span class='arw'>&rarr;</span> (+ 3 4)
(eval expr)           <span class='arw'>&rarr;</span> 7
(eval (list + 3 4))   <span class='arw'>&rarr;</span> 7
(eval ''x)            <span class='arw'>&rarr;</span> x
(set 'y 123)          
(set 'x 'y)           
x            <span class='arw'>&rarr;</span> y
(eval x)     <span class='arw'>&rarr;</span> 123
</pre>


<p>通常、変数の評価は現変数環境下で起こります：<br />
As usual, evaluation of variables happens in the current variable environment:</p>


<pre>
; eval in global (top level) environment
(set 'x 3 'y 4)
(eval '(+ x y))          <span class='arw'>&rarr;</span> 7

; eval in local environment
(let ( (x 33) (y 44) ) 
    (eval '(+ x y)))     <span class='arw'>&rarr;</span> 77

; old environment after leaving local let environment
(eval '(+ x y))          <span class='arw'>&rarr;</span> 7
</pre>


<p>newLISP は全ての引数を値で渡します。
クォート付きシンボルを使うと、シンボルを通した参照として式を渡すことができます。
つまり、シンボルの元の内容にアクセスするために <tt>eval</tt> が使えます：<br>
（訳注：つまり、マクロを使わずに破壊的関数を書くことができる）<br />
	newLISP passes all arguments by value. 
	Using a quoted symbol, 
	expressions can be passed 
	by reference through the symbol. 
	<tt>eval</tt> can be used 
	to access the original contents of the symbol:
</p>


<pre>
(define (change-list aList) (push 999 (eval aList)))

(set 'data '(1 2 3 4 5))

(change-list 'data)  <span class='arw'>&rarr;</span> (999 1 2 3 4 5)
</pre>


<p>例では、パラメータ <tt>'data </tt> はクォート付ですので、<tt>push</tt> は元のリスト上で動作します。<br />
In the example, the parameter <tt>'data </tt> is quoted, 
so <tt>push</tt> can work on the original list.
</p>

<p>コンテキスト・オブジェクト内にデータを内包する newLISP で、これは参照により引数を渡す安全な方法です。
<a href="#pass_big">参照によるデータの受け渡し</a> の章を見てください。
名前空間を使ったユーザ定義関数に参照を渡すことは、渡されたシンボルが関数のパラメータとして使われている名前と同じ場合に起こりうるシンボル渡し時の<em>変数補足</em> を避けます。<br />
There is a safer method to pass arguments by reference in newLISP 
by enclosing the data inside context objects. 
See the chapter <a href="#pass_big">Passing data by reference</a>.
Passing references into user defined
function using namespace ids avoids <em>variable capture</em> of
the passed symbol, in case the symbol passed is the same used as a
parameter in the function.</p>

<br/><br/>

<a name="eval-string"></a>
<h2><span class="function">eval-string</span></h2>
<h4>syntax: (eval-string <em>str-source</em> [<em>sym-context</em> [<em>exp-error</em> [<em>int-offset</em>]]])</h4>

<p><em>str-source</em> の文字列が newLISP の内部形式にコンパイルされ、評価されます。
評価結果が返ります。
文字列が一つより多い式を含むなら、最後に評価された結果が返ります。<br />
The string in <em>str-source</em> is compiled into newLISP's internal format
and then evaluated. The evaluation result is returned. If the string contains 
more than one expression, the result of the last evaluation is returned.
</p>

<p>文字列が解析・翻訳される際のコンテキストを指定するために、オプションの第二引数が使えます。<br />
An optional second argument can be used to specify the context to which 
the string should be parsed and translated.</p>

<p><em>str-source</em> の解析・評価中にエラーが発生すると、<em>exp-error</em> が評価され、結果が返ります。<br />
If an error occurs while parsig and evaluating <em>str-source</em> then
<em>exp-error</em> will be evaluated and the result returned.</p>

<p><em>int-offset</em> はオプションで、<em>str-source</em> 内の評価を開始するオフセットを指定します。<br />
<em>int-offset</em> specifies an optional offset into <em>str-source</em>, 
where to start evaluation.</p>

<!-- example -->

<pre>
(eval-string "(+ 3 4)")  <span class='arw'>&rarr;</span> 7
(set 'X 123)             <span class='arw'>&rarr;</span> 123
(eval-string "X")        <span class='arw'>&rarr;</span> 123

(define (repl) ; read print eval loop
  (while true
    (println "=&gt; " (eval-string (read-line) MAIN (last-error)))
  )
)

(set 'a 10)
(set 'b 20)
(set 'foo:a 11)
(set 'foo:b 22)

(eval-string "(+ a b)")       <span class='arw'>&rarr;</span> 30
(eval-string "(+ a b)" 'foo)  <span class='arw'>&rarr;</span> 33
</pre>


<p>二番目の例は、簡単な newLISP インタープリタ評価ループを示しています。<br />
The second example shows a simple newLISP interpreter eval loop.</p> 

<p>最後の例は、翻訳時に使いたいコンテキストを指定する方法を示しています。
これにより、シンボル <tt>a</tt> と <tt>b</tt> は <tt>MAIN</tt> の代わりに、コンテキスト <tt>foo</tt> のシンボルとその値を参照します。<br />
The last example shows how to specify a target context for translation. The symbols 
<tt>a</tt> and <tt>b</tt> now refer to symbols and their values in context <tt>foo</tt> instead of 
<tt>MAIN</tt>.</p>
	
<p>評価せずに文字列を翻訳する関数 <a href="#read-expr">read-expr</a> も見てください。<br />
See also the function <a href="#read-expr">read-expr</a> which translates a string
without evaluating it.</p>

<br/><br/>

<a name="eval-string-js"></a>
<h2><span class="function">eval-string-js
<a href="#JS"><font size="-1">JS</font></a></span></h2>
<h4>syntax: (eval-string-js <em>str-JavaScript-source</em>)</h4>
<p>この関数は <em>str-JavaScript-source</em> にある（訳注：JavaScriput の）プログラム・ソースを受け取り、結果を文字列で返します。<br />
The function takes a program source in <em>str-JavaScript-source</em>
and returns the result in a string.</p>

<p>この関数は JavaScript にコンパイルされた newLISP でのみ、利用できます。<br />
This function is only available on newLISP compiled to JavaScript.</p>

<pre>
(eval-string-js "window.prompt('Enter some text:', '')")

; JavaScropt 関数に渡す文字列の中に
; シングル・クォートやダブル・クォートを含めるためには、
; 先付のバックスラッシュ \（訳注；日本語環境では円記号 &yen; ）が必要ですので、
; 文字列全体を [text], [/text] タグで囲って eval-string-js に渡します。
; for single and double quotes inside a string passed to a
; JavaScropt function, single and double quotes must be
; preceded by a backslash \ and the whole string passed
; to eval-string-js limited by [text], [/text] tags.

(eval-string-js [text]alert('A double quote: \" and a single quote: \' ')[/text])

(eval-string-js "6 * 7")
</pre>

<p>最初の式は、テキストを入力するダイアログをポップアップさせるでしょう。
そして、入力された文字列を返します。
二番目の式は、<tt>42</tt> の文字列を返します。<br />
The first expression will pop up a dialog box to enter text. The function
will return the text string entered. The second expression will return the
string <tt>42</tt>.</p>

<p>ブラウザに HTML ページを表示する関数 <a href="#display-html">display-html</a> も見てください。<br />
See also the function <a href="#display-html">display-html</a> for displaying
an HTML page in the browser.</p>

<br/><br/>

<a name="evenp"></a>
<h2><span class="function">even?</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (even? <em>int-number</em>)</h4>

<p>整数値が <tt>2</tt> で<em>ちょうど割り切れ</em> 、余りが無いことをチェックします。
浮動小数点が <em>int-number</em> に渡された時は、小数部分を切り捨てた整数として扱われます。<br />
Checks if an integer number is <em>even divisible</em> by <tt>2</tt>, without remainder. 
When a floating point number is passed for <em>int-number</em>, it will be converted to an
integer by cutting off its fractional part.</p>

<pre>
(even? 123)  <span class='arw'>&rarr;</span> nil
(even? 8)    <span class='arw'>&rarr;</span> true
(even? 8.7)  <span class='arw'>&rarr;</span> true
</pre>

<p>整数が <tt>2</tt> で割り切れないかどうかのチェックには、<a href="#oddp">odd?</a> を使ってください。<br />
Use <a href="#oddp">odd?</a> to check if an integer is not divisible by <tt>2</tt>.</p>

<br/><br/>


<a name="exec"></a>
<h2><span class="function">exec</span></h2>
<h4>syntax: (exec <em>str-process</em>)<br/>
syntax: (exec <em>str-process</em> [<em>str-stdin</em>])</h4>

<p>第一形式の <tt>exec</tt> は、<em>str-process</em> に記載されているプロセスを起動し、すべての標準出力を（標準出力（STDOUT）の各ライン毎に一つの）文字列のリストで返します。
プロセスを起動できなかった場合、<tt>exec</tt> は <tt>nil</tt> を返します。
プロセスが起動しても、改行のみやエラーや出力なしの場合は空リストが返ります。<br />
In the first form, <tt>exec</tt> launches a process described in <em>str-process</em>
and returns all standard output as a list of strings 
(one for each line in standard out (STDOUT)).  <tt>exec</tt> returns <tt>nil</tt>
if the process could not be launched. If the process could be launched but 
only returns and error and no valid output, the empty list will be returned.
</p> 


<!-- example -->

<pre>
(exec "ls *.c")  <span class='arw'>&rarr;</span> ("newlisp.c" "nl-math.c" "nl-string.c")
</pre>


<p>この例は、プロセスを開始してシェル・コマンド<tt>ls</tt> を実行し、文字列のアレイの出力を取り込みます。<br />
	The example starts a process and performs the shell command <tt>ls</tt>,
	capturing the output in an array of strings.
</p>

<p>第二形式の <tt>exec</tt> は、パイプ・プロセスを生成し、プロセスの標準入力を <em>str-stdin</em> から受け取る <em>str-process</em> のプロセスを開始します。
起動に成功すれば、戻り値は <tt>true</tt> となり、そうでなければ <tt>nil</tt> となります。<br />
	In the second form, 
	<tt>exec</tt> creates a process pipe, 
	starts the process in <em>str-process</em>, 
	and receives from <em>str-stdin</em> 
	standard input for this process.
	The return value is <tt>true</tt> 
	if the process was successfully launched; 
	otherwise it is <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(exec "cgiProc" query)
</pre>


<p>この例では、cgiProc は cgi プロセッサ（例えば、Perl や newLISP）で変数 query 内の文字列に供給される標準入力を受け取り、処理します。<br />
	In this example, 
	cgiProc could be a cgi processor (e.g., Perl or newLISP) 
	that receives and processes standard input supplied by a string 
	contained in the variable query.
</p>

<br/><br/>

<a name="exists"></a>
<h2><span class="function">exists</span></h2>
<h4>syntax: (exists <em>func-condition</em> <em>list</em>)</h4>

<p>
<em>func-condition</em> を <em>list</em> の要素に次々と適用して、<em>func-condition</em> の条件に合う最初の要素を返します。
条件に合う要素がなければ、<tt>nil</tt> が返ります。<br />
Successively applies <em>func-condition</em> 
to the elements of <em>list</em> 
and returns the first element 
that meets the condition in <em>func-condition</em>. 
If no element meets the condition, 
<tt>nil</tt> is returned.</p>

<!-- example -->

<pre>
(exists string? '(2 3 4 6 "hello" 7))       <span class='arw'>&rarr;</span> "hello"

(exists string? '(3 4 2 -7 3 0))            <span class='arw'>&rarr;</span> nil

(exists zero? '(3 4 2 -7 3 0))              <span class='arw'>&rarr;</span> 0 ; check for 0 or 0.0

(exists &lt; '(3 4 2 -7 3 0))                  <span class='arw'>&rarr;</span> -7 ; check for negative

(exists (fn (x) (&gt; x 3)) '(3 4 2 -7 3 0))   <span class='arw'>&rarr;</span> 4

(exists (fn (x) (= x 10)) '(3 4 2 -7 3 0))  <span class='arw'>&rarr;</span> nil 
</pre>


<p><em>func-condition</em> が <tt>nil?</tt> ならば、結果の <tt>nil</tt> はどちらにでも取れます。
このような場合に、<tt>nil</tt> を見つけるより良い方法は <a href="#index">index</a> か <a href="#find">find</a> です。<br />
If <em>func-condition</em> is <tt>nil?</tt>, the result <tt>nil</tt> is ambiguous.
In this case <a href="#index">index</a> or <a href="#find">find</a> are the better 
method when looking for <tt>nil</tt>.</p>

<p>リスト中の全ての要素が条件に合っているかどうかをチェックするには、関数 <a href="#for-all">for-all</a> を使います。<br />
Use the <a href="#for-all">for-all</a> function 
to check if a condition is met for all elements in a list.</p>

<br/><br/>

<a name="exit"></a>
<h2><span class="function">exit</span></h2>
<h4>syntax: (exit [<em>int</em>])</h4>

<p>newLISP を終了します。
オプションの終了コード <em>int</em> が与えられます。
このコードは、ホストのオペレーティングシステムでテストされます。
newLISP がコマンド・ライン・オプション <tt>-d</tt> を使って <a href="#daemon">デーモン・サーバー・モード</a> で走っている時は、ネットワーク接続のみが閉じられ、newLISP はそのまま残り、新しい接続を待ちます。<br />
	Exits newLISP. 
	An optional exit code, <em>int</em>, may be supplied. 
	This code can be tested by the host operating system. 
	When newLISP is run in <a href="#daemon">daemon server mode</a> 
 	using <tt>-d</tt> as a command-line option, 
	only the network connection is closed, 
	while newLISP stays resident, 
	listening for a new connection.
</p>

<!-- example -->

<pre>
(exit 5)
</pre>

<br/><br/>

<a name="exp"></a>
<h2><span class="function">exp</span></h2>
<h4>syntax: (exp <em>num</em>)</h4>

<p><em>num</em> の式が評価され、その結果のもとに（訳注：底が e の）指数関数を計算します。
<tt>exp</tt> は <tt>log</tt> の逆関数です。<br />
The expression in <em>num</em> is evaluated, and the exponential function 
is calculated based on the result.  <tt>exp</tt> is the inverse function of 
<a href="#log">log</a>.
</p>

<!-- example -->

<pre>
(exp 1)        <span class='arw'>&rarr;</span> 2.718281828
(exp (log 1))  <span class='arw'>&rarr;</span> 1
</pre>

<br/><br/>

<a name="expand"></a>
<h2><span class="function">expand</span></h2>

<h4>syntax: (expand <em>exp</em> <em>sym-1</em> [<em>sym-2</em> ... ])<br/>
syntax: (expand <em>exp</em> <em>list-assoc</em> [<em>bool</em>])<br/>
syntax: (expand <em>exp</em>)</h4>

<p>
第一構文では、<em>sym</em>（あるいは <em>sym-2</em> から <em>sym-n</em>の複数シンボル）の一シンボルが、単純な式もしくは入れ子の式 <em>exp</em> 内で検索されます。
そして、検索されたシンボルの現在の束縛に展開され（訳注：<em>exp</em> 中の <em>sym</em> と同名のシンボルが <em>sym</em> の内容に置き換わる）、展開された式が返ります。元のリストは変化せずに残ります。<br />
In the first syntax, one symbol in <em>sym</em> 
(or more in <em>sym-2</em> through <em>sym-n</em>) 
is looked up in a simple or nested expression <em>exp</em>. 
They are then expanded to the current binding of the symbol 
and the expanded expression is returned. The original list remains unchanged.
</p>

<!-- example -->

<pre>
(set 'x 2 'a '(d e))
(set 'foo 'a)
(expand foo 'a)               <span class='arw'>&rarr;</span> (d e)
(expand '(a x b) 'x)           <span class='arw'>&rarr;</span> (a 2 b)
(expand '(a x (b c x)) 'x)     <span class='arw'>&rarr;</span> (a 2 (b c 2))
(expand '(a x (b c x)) 'x 'a)  <span class='arw'>&rarr;</span> ((d e) 2 (b c 2))
</pre>


<p><tt>expand</tt> は、ラムダ式を構成する時や内部書換マクロで変数を展開する時に役立ちます。<br />
<tt>expand</tt> is useful when composing lambda expressions 
or doing variable expansion as in rewrite macros.
</p>


<pre>
(define (raise-to power)
  (expand (fn (base) (pow base power)) 'power))

(define square (raise-to 2))
(define cube (raise-to 3))

(square 5)  <span class='arw'>&rarr;</span> 25
(cube 5)    <span class='arw'>&rarr;</span> 125
</pre>


<p>一個以上のシンボルがある時、<tt>expand</tt> はインクリメンタルに作用します：<br />
	If more than one symbol is present, 
	<tt>expand</tt> will work in an incremental fashion:
</p>


<pre>
(set 'a '(b c))
(set 'b 1)

(expand '(a b c) 'a 'b)  <span class='arw'>&rarr;</span> ((1 c) 1 c) 
</pre>


<p>関数 <a href="#apply">apply</a> のように、<tt>expand</tt> は引数リストを<em>畳み込み</em> ます。<br />
	Like the <a href="#apply">apply</a> function, 
	<tt>expand</tt> <em>reduces</em> its argument list.
</p>

<h4>syntax: (expand <em>list</em> <em>list-assoc</em> [<em>bool</em>])</h4>

<p><tt>expand</tt> の第二構文は直接（訳注：連想リスト <em>list-assoc</em> で）指定された束縛の展開を許可しますので、関連する変数（訳注：連想リストの変数）において <a href="#set">set</a> を実行する必要はありません：<br />
The second syntax of <tt>expand</tt> allows expansion bindings to be specified 
on the fly, without performing a <a href="#set">set</a> on the participating variables:
</p>

<p><em>bool</em> が <tt>true</tt> に評価されると、連想リストの値部分は評価されます。<br />
If the <em>bool</em> evaluates to <tt>true</tt>, the value parts in the
association list are evaluated.</p>

<!-- example -->

<pre>
(expand '(a b c) '((a 1) (b 2)))                <span class='arw'>&rarr;</span> (1 2 c)
(expand '(a b c) '((a 1) (b 2) (c (x y z))))    <span class='arw'>&rarr;</span> (1 2 (x y z))
(expand '(a b) '((a (+ 1 2)) (b (+ 3 4))))      <span class='arw'>&rarr;</span> ((+ 1 2) (+ 3 4))
(expand '(a b) '((a (+ 1 2)) (b (+ 3 4))) true) <span class='arw'>&rarr;</span> (3 7)
</pre>


<p>（訳注：<em>bool</em> が <tt>true</tt> でない時、）連想リストの変数の内容が変化しないことに注意してください。
これが、連想部分の評価と割り当てで変数が設定される関数 <a href="#letex">letex</a> との違いです。<br />
	Note that the contents of the variables 
	in the association list will not change. 
	This is different from the <a href="#letex">letex</a> function, 
	where variables are set by evaluating 
	and assigning their association parts.
</p>

<p><tt>expand</tt> のこの形式は、関数 <a href="#unify">unify</a> との併用で論理プログラミングによく使われます。<br />
	This form of <tt>expand</tt> is frequently used 
	in logic programming, 
	together with the <a href="#unify">unify</a> function.
</p>

<h4>syntax: (expand <em>list</em>)</h4>

<p>第三構文は、大文字で始まる変数の内容を展開する時にのみ使われます。
この <a href="http://ja.wikipedia.org/wiki/Prolog">PROLOG</a> モードは、論理プログラミング環境でも使われます。
<tt>expand</tt> の第一構文のように、シンボルは予めセットされていなければなりません。
大文字で <tt>nil</tt> 以外に束縛される変数のみが展開されます：<br />
	A third syntax is used to expand only the contents 
	of variables starting with an uppercase character. 
	This PROLOG mode may also be used 
	in the context of logic programming. 
	As in the first syntax of <tt>expand</tt>, 
	symbols must be preset. 
	Only uppercase variables and those bound 
	to anything other than <tt>nil</tt> 
	will be expanded:
</p>


<!-- example -->

<pre>
(set 'A 1 'Bvar 2 'C nil 'd 5 'e 6)
(expand '(A (Bvar) C d e f))  <span class='arw'>&rarr;</span> (1 (2) C d e f)
</pre>


<p>大文字で始まり、<tt>nil</tt> でない中身を持つシンボル <tt>A</tt> と <tt>Bvar</tt> のみが展開されます。<br />
	Only the symbols <tt>A</tt> and <tt>Bvar</tt> are expanded 
	because they have capitalized names 
	and non-<tt>nil</tt> contents.
</p>

<p><tt>expand</tt> の第一構文を実演している例題の <em><a href="http://ja.wikipedia.org/wiki/%E3%82%AB%E3%83%AA%E3%83%BC%E5%8C%96">カリー化</a></em> 関数は、大文字変数を使ってより簡単になります：<br />
	The <em>currying</em> function in the example 
	demonstrating the first syntax of <tt>expand</tt> 
	can now be written even more simply 
	using an uppercase variable:
</p>


<pre>
(define (raise-to Power) 
  (expand (fn (base) (pow base Power))))

&gt; (define cube (raise-to 3))
<b>(lambda (base) (pow base 3))</b>

&gt; (cube 4)
<b>64</b>

&gt; _
</pre>


<p>展開機構を提供する関数 <a href="#letex">letex</a> や <tt>expand</tt> と一緒によく使われる関数 <a href="#unify">unify</a> も見てください。<br />
	See the <a href="#letex">letex</a> function, 
	which also provides an expansion mechanism, 
	and the function <a href="#unify">unify</a>, 
	which is frequently used together with <tt>expand</tt>.
</p>

<br/><br/>

<a name="explode"></a>
<h2><span class="function">explode</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (explode <em>str</em> [<em>int-chunk</em> [<em>bool</em>]])<br/>
syntax: (explode <em>list</em> [<em>int-chunk</em> [<em>bool</em>]])</h4>

<p>
第一構文の <tt>explode</tt> は、文字列 (<em>str</em>) を一文字ずつの文字列リストに変換します。
オプションで、文字列を複数個の文字の集合に分けるために、集合サイズを <em>int-chunk</em> に指定できます。
<em>bool</em> の値が <tt>nil</tt> 以外の時、<em>int-chunk</em> で指定された長さを満たさない最後の集合は削除されます。<br />
In the first syntax, 
<tt>explode</tt> transforms the string (<em>str</em>)
into a list of single-character strings. 
Optionally, a chunk size can be specified in <em>int-chunk</em> 
to break the string into multi-character chunks. 
When specifying a value for <em>bool</em> other than <tt>nil</tt>,
the last chunk will be omitted 
if it does not have the full length specified 
in <em>int-chunk</em>.
</p>

<!-- example -->

<pre>
(explode "newLISP")  <span class='arw'>&rarr;</span> ("n" "e" "w" "L" "I" "S" "P")

(join (explode "keep it together"))  <span class='arw'>&rarr;</span> "keep it together"

(explode "newLISP" 2)    <span class='arw'>&rarr;</span> ("ne" "wL" "IS" "P")

(explode "newLISP" 3)    <span class='arw'>&rarr;</span> ("new" "LIS" "P")

; omit last chunk if too short
(explode "newLISP" 3 true)    <span class='arw'>&rarr;</span> ("new" "LIS")
</pre>


<p>UTF8版でなければ、<tt>explode</tt> はバイナリ・データにも作用します：<br />
Only on non UTF8&ndash; enabled versions, <tt>explode</tt> also works on binary content:</p>


<pre>
(explode "\000\001\002\003") 
<span class='arw'>&rarr;</span> ("\000" "\001" "\002" "\003")
</pre>


<p>UTF-8 版 newLISP で呼ばれた <tt>explode</tt> は、バイト境界ではなくキャラクタ境界で動作します。
UTF-8 エンコード文字列で、文字は 1 バイト以上から成っています。
（訳注：UTF-8 版 newLISP は、）ゼロ・バイト・キャラクタ（訳注：<tt>"\000"</tt>）を見つけると処理を終了します。<br />
When called in UTF-8&ndash;enabled versions of newLISP, 
<tt>explode</tt> will work on character boundaries rather than byte boundaries. 
In UTF-8&ndash;encoded strings, characters may contain more than one byte.
Processing will stop when a zero byte character is found.
</p>

<p>UTF-8 版 newLISP でバイナリ・データを展開したい時は、次の例で示される <a href="#unpack">unpack</a> を使ってください：<br />
To explode binary contents on UTF-8&ndash;enabled versions of newLISP
use <a href="#unpack">unpack</a> as shown in the following example:</p>

<pre>
(set 'str "\001\002\003\004") <span class='arw'>&rarr;</span> "\001\002\003\004"

(unpack (dup "c" (length str)) str) <span class='arw'>&rarr;</span> (1 2 3 4)
(unpack (dup "s" (length str)) str) <span class='arw'>&rarr;</span> ("\001" "\002" "\003" "\004")
</pre>
<blockquote>
（訳例：<tt>unpack</tt> の <tt>"c"</tt> オプションは符号付です。符号無しには <tt>"b"</tt> オプションを使います。
<pre>
> (set 'str "\000\001\128\255")
"\000\001\128\255"
> (unpack (dup "c" (length str)) str)
(0 1 -128 -1)
> (unpack (dup "b" (length str)) str)
(0 1 128 255)
> 
</pre>
上記例は、UTF-8 版でない newLISPを使っていますが、
動作は <a href="set">set</a> 文の戻り値の表示以外は UTF-8 版 newLISPでも同じです。
）</blockquote>

<p>第二構文の <tt>explode</tt> は、<em>int-chunk</em> の集合サイズのサブ・リストにリストを分解します。
<em>int-chunk</em> のデフォルトは 1 です。<br />
In the second syntax, 
<tt>explode</tt> explodes a list (<em>list</em>)
into sublists of chunk size <em>int-chunk</em>, 
which is 1 (one) by default.
</p>

<p>次に示す例は、<em>bool</em> 値が <tt>nil</tt> 以外の時に、集合が <em>int-chunk</em> で指定された長さを満たさない最後の集合を削除するものです。<br />
The following shows an example of the last chunk being omitted 
when the value for <em>bool</em> is other than <tt>nil</tt>,
and the chunk does not have the full length specified 
in <em>int-chunk</em>.
</p>

<!-- example -->

<pre>
(explode '(a b c d e f g h))    <span class='arw'>&rarr;</span> ((a) (b) (c) (d) (e) (f) (g) (h))
(explode '(a b c d e f g) 2)  <span class='arw'>&rarr;</span> ((a b) (c d) (e f) (g))

; omit last chunk if too short
(explode '(a b c d e f g) 2 true)  <span class='arw'>&rarr;</span> ((a b) (c d) (e f))

(transpose (explode '(a b c d e f g h) 2)) 
<span class='arw'>&rarr;</span> ((a c e g) (b d f h))
</pre>


<p>
関数 <a href="#join">join</a> や <a href="#append">append</a> は <tt>explode</tt> 操作の逆操作です。<br />
The <a href="#join">join</a> and <a href="#append">append</a> functions
are inverse operations of <tt>explode</tt>.
</p>

<br/><br/>

<a name="extend"></a>
<h2><span class="function">extend</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (extend <em>list-1</em> [<em>list-2</em> ... ])<br/>
syntax: (extend <em>string-1</em> [<em>string-2</em> ... ])</h4>

<p>
<em>list-1</em> のリストに <em>list-2</em> が追加されて拡張されます。
一個以上のリストが追加されます。<br />
The list in <em>list-1</em> is extended by appending <em>list-2</em>. More
than one list may be appended.</p>

<p><em>string-1</em> の文字列に <em>string-2</em> が追加されて拡張されます。
一個以上の文字列が追加されます。
文字列には、バイナリ <tt>0</tt>（ゼロ）文字を含めることができます。<br />
The string in <em>string-1</em> is extended by appending <em>string-2</em>. More
than one string may be appended. The string can contain binary <tt>0</tt> (zero) 
characters.</p>

<p>第一パラメータには、初期化されていない変数も使えます。<br />The first parameter can be an un-initialized variable.</p>

<p>拡張されたリストまたは文字列を返します。<br />The extended list or string is returned.</p>

<!-- example -->

<pre>
; extending lists

(extend lst '(a b) '(c d)) <span class='arw'>&rarr;</span> (a b c d)
(extend lst '(e f g)) <span class='arw'>&rarr;</span> (a b c d e f)
lst <span class='arw'>&rarr;</span> (a b c d e f g)

; extending strings

(extend str "ab" "cd") <span class='arw'>&rarr;</span> "abcd"
(extend str "efg") <span class='arw'>&rarr;</span> "abcdefg"
str <span class='arw'>&rarr;</span> "abcdefg"

; extending in place

(set 'L '(a b "CD" (e f)))
(extend (L 2) "E")
L <span class='arw'>&rarr;</span> (a b "CDE" (e f))

(extend (L 3) '(g))
L <span class='arw'>&rarr;</span> (a b "CDE" (e f g))
</pre>

<p>リストや文字列の非破壊拡張には、<a href="#append">append</a> を見てください。<br />
For a non-destructive list or string extension see <a href="#append">append</a>.</p>

<br/><br/>

<a name="factor"></a>
<h2><span class="function">factor</span></h2>
<h4>syntax: (factor <em>int</em>)</h4>

<p><em>int</em> の数値を素因数分解します。
<em>num</em> が浮動小数点数なら、整数部分に切り捨てられます。<br />
	Factors the number in <em>int</em> 
	into its prime components. 
	Floating point numbers in <em>num</em> 
	are truncated to their integer part.
</p>

<!-- example -->

<pre>
(factor 123456789123456789)  <span class='arw'>&rarr;</span> (3 3 7 11 13 19 3607 3803 52579)

;; check correctness of factoring
(= (apply * (factor 123456789123456789)) 123456789123456789)
<span class='arw'>&rarr;</span> true

;; factor the biggest integer
(factor 9223372036854775807)  <span class='arw'>&rarr;</span> (7 7 73 127 337 92737 649657)

;; primes.lsp - return all primes in a list, up to n 

(define (primes n , p)
  (dotimes (e n) 
    (if (= (length (factor e)) 1) 
      (push e p -1))) p)
           
(primes 20)  <span class='arw'>&rarr;</span> (2 3 5 7 11 13 17 19)         
</pre>


<p><tt>factor</tt> は <tt>2</tt> より小さい数値で <tt>nil</tt> を返します。
浮動小数点数から変換された 9,223,372,036,854,775,807 (64ビット整数の最大値) より大きい数値は、整数の最大値で因数分解されます。<br />
	<tt>factor</tt> returns <tt>nil</tt> 
	for numbers smaller than <tt>2</tt>.
	For numbers larger than 9,223,372,036,854,775,807
	(the largest 64-bit integer)
	converted from floating point numbers, 
	the largest integer is factored.
</p>

<br/><br/>

<a name="fft"></a>
<h2><span class="function">fft</span></h2>
<h4>syntax: (fft <em>list-num</em>)</h4>

<p>FFT (Fast Fourier Transform) 法を使って、<em>list-num</em> の複素数リストを離散的フーリエ変換します。
各複素数は実数部とそれに続く虚数部で指定されます。
実数部のみを使う場合は、虚数部は <tt>0.0</tt> (zero) にセットされます。
<em>list-num</em> の要素数が 2の倍数でない時、<tt>fft</tt> はゼロでリストを埋めて要素数を増やします。
複素数の虚数部が <tt>0</tt> の時は、複素数の代わりに単なる数値が使えます。<br />
	Calculates the discrete Fourier transform 
	on the list of complex numbers in <em>list-num</em> 
	using the FFT method (Fast Fourier Transform). 
	Each complex number is specified by its real part 
	followed by its imaginary part. 
	If only real numbers are used, 
	the imaginary part is set to <tt>0.0</tt> (zero). 
	When the number of elements in <em>list-num</em> 
	is not a power of 2, 
	<tt>fft</tt> increases the number of elements 
	by padding the list with zeroes. 
	When the imaginary part of a complex number is <tt>0</tt>, 
	simple numbers can be used instead.
</p>

<!-- example -->

<pre>
(ifft (fft '((1 0) (2 0) (3 0) (4 0)))) 
<span class='arw'>&rarr;</span> ((1 0) (2 0) (3 0) (4 0))

;; when imaginary part is 0, plain numbers work, too
;; plain numbers and complex numbers can be intermixed

(fft '(1 2 3 4))      <span class='arw'>&rarr;</span> ((10 0) (-2 -2) (-2 0) (-2 2))
(fft '(1 2 (3 0) 4))  <span class='arw'>&rarr;</span> ((10 0) (-2 -2) (-2 0) (-2 2))
</pre>


<p><tt>fft</tt> の逆操作は関数 <a href="#ifft">ifft</a> です。<br />
	The inverse operation of <tt>fft</tt> 
	is the <a href="#ifft">ifft</a> function.
</p>

<br/><br/>

<a name="file-info"></a>
<h2><span class="function">file-info</span></h2>
<h4>syntax: (file-info <em>str-name</em> [<em>int-index</em> [<em>bool-flag</em>]])</h4>

<p><em>str_name</em> のファイルかディレクトリの情報をリストで返します。
オプションのインデックスで、戻り値のリスト番号を指定できます。
<em>bool-flag</em> が指定されないか、<tt>nil</tt>に評価されると、ファイルがオリジナル・ファイルにリンクしていても、リンクの情報が返ります。
<em>bool-flag</em> が <tt>nil</tt> 以外に評価されると、リンクで参照されるオリジナル・ファイルの情報が返されます。
（訳注：リンクは、MS Windows のショート・カットとは違います。
つまり、MS Windows で <em>bool-flag</em> オプションを使っても、何も変わりません。）<br />
Returns a list of information about the file or directory in <em>str_name</em>. 
The optional index specifies the list member to return.  When no <em>bool-flag</em>
is specified or when <em>bool-flag</em> evaluates to <tt>nil</tt> information about
the link is returned if the file is a link to an original file. If <em>bool-flag</em>
evaluates to anything else than <tt>nil</tt>, information about the original file
referenced by the link is returned.</p>

<table   summary="file attributes">
<tr align="left"><th>offset</th><th>contents</th></tr>
<tr><td>0</td><td>サイズ<br />size</td></tr>
<tr><td>1</td><td>mode (differs with <tt>true</tt> flag)</td></tr>
<tr><td>2</td><td>device mode</td></tr>
<tr><td>3</td><td>user ID</td></tr>

<tr><td>4</td><td>group ID</td></tr>
<tr><td>5</td><td>アクセス日時<br />access time</td></tr>
<tr><td>6</td><td>更新日時<br />modification time</td></tr>
<tr><td>7</td><td>作成日時<br />status change time</td></tr>
</table><br/>

<p><em>bool-flag</em> の状態次第で、関数はリンク（フラグ無し、または、<tt>nil</tt>）か、リンクしているオリジナル・ファイル（<tt>true</tt> フラグ）のどちらかを報告します。<br />
Depending on <em>bool-flag</em> set, the function reports on either
the link (no flag or <tt>nil</tt> flag) or on the original linked file 
(<tt>true</tt> flag).</p>

<!-- example -->

<pre>
(file-info ".bashrc")   
<span class='arw'>&rarr;</span> (124 33188 0 500 0 920951022 920951022 920953074)

(file-info ".bashrc" 0)  <span class='arw'>&rarr;</span> 124

(date (file-info "/etc" -1))  <span class='arw'>&rarr;</span> "Mon Mar 8 18:23:17 2005"
</pre>


<p>二番目の例では、最後のディレクトリ <em>/etc</em> の作成日時が取り出されています。<br />
 In the second example, the last status change date 
for the directory <em>/etc</em> is retrieved.</p>

<p><tt>file-info</tt> は <em>mode</em> 部を除いて、リンクではなく、リンクされているファイルのファイル統計値 (サイズ) を与えます。<br />
<tt>file-info</tt> gives file statistics (size) for a linked file,
not the link, except for the <em>mode</em> field.</p>

<br/><br/>

<a name="filep"></a>
<h2><span class="function">file?</span></h2>

<h4>syntax: (file? <em>str-path-name</em> [<em>bool</em>])</h4>

<p><em>str-name</em> のファイルの存在をチェックします。
ファイルが存在すれば <tt>true</tt> を、そうでなければ <tt>nil</tt> を返します。
この関数はディレクトリに対しても <tt>true</tt> を返します。
オプションの <em>bool</em> 値が <tt>true</tt> の場合、ファイルはディレクトリでなければ <em>str-path-name</em> が返り、ファイルがディレクトリなら <tt>nil</tt> が返ります。
ファイルの存在は、読み書き許可等の情報を含みませんので、カレント・ユーザによる読み書きの許可を持たない存在かもしれません。<br />
Checks for the existence of a file in <em>str-name</em>. Returns <tt>true</tt> 
if the file exists; otherwise, it returns <tt>nil</tt>.  This function will also return 
<tt>true</tt> for directories. If the optional <em>bool</em> value is <tt>true</tt>,
the file must not be a directory and <em>str-path-name</em> is returned or <tt>nil</tt>
if the file is a directory. The existence of a file does not imply anything about its 
read or write permissions for the current user.</p>

<!-- example -->

<pre>
(if (file? "afile") (set 'fileNo (open "afile" "read")))

(file? "/usr/local/bin/newlisp" true) <span class='arw'>&rarr;</span> "/usr/local/bin/newlisp"
(file? "/usr/local/bin/foo" true)     <span class='arw'>&rarr;</span> nil
</pre>

<br/><br/>

<a name="filter"></a>
<h2><span class="function">filter</span></h2>
<h4>syntax: (filter <em>exp-predicate</em> <em>exp-list</em>)</h4>

<p><em>exp-predicate</em> の述部を <em>exp-list</em> のリストの各要素に適用します。
<em>exp-predicate</em> が <tt>true</tt> となる要素の入ったリストが返ります。
<tt>filter</tt> は、述部を否定的に使った <a href="#clean">clean</a> のように動作します。<br />
	The predicate <em>exp-predicate</em> is applied 
	to each element of the list <em>exp-list</em>. 
	A list is returned containing the elements 
	for which <em>exp-predicate</em> is true. 
	<tt>filter</tt> works like <a href="#clean">clean</a>, 
	but with a negated predicate.
</p>

<!-- example -->

<pre>
(filter symbol? '(1 2 d 4 f g 5 h))  <span class='arw'>&rarr;</span> (d f g h)

(define (big? x) (&gt; x 5))  <span class='arw'>&rarr;</span> (lambda (x) (&gt; x 5))

(filter big? '(1 10 3 6 4 5 11))  <span class='arw'>&rarr;</span> (10 6 11)

; filter with comparison functor
(set 'L '((a 10 2 7) (b 5) (a 8 3) (c 8) (a 9)))

(filter (curry match '(a *)) L)   <span class='arw'>&rarr;</span> ((a 10 2 7) (a 8 3) (a 9))

(filter (curry match '(? ?)) L)   <span class='arw'>&rarr;</span> ((b 5) (c 8) (a 9))

(filter (curry match '(* 8 *)) L) <span class='arw'>&rarr;</span> ((a 8 3) (c 8))
</pre>


<p>述部は組込述語か、ユーザ定義関数か、ラムダ式です。<br />
The predicate may be a built-in predicate, a user-defined function, 
or a lambda expression.
</p>

<p>別のリストを使ってリストの要素をフィルタリングするのには、（<em>list</em>モードの）関数 <a href="#difference">difference</a> か、関数<a href="#intersect">intersect</a> を使います。<br />
For filtering a list of elements with the elements from another list, 
use the <a href="#difference"> difference</a> function or 
<a href="#intersect">intersect</a> (with the <em>list</em> option).
</p>

<p>同様の関数として、フィルタされた要素のインデックスを返す関数 <a href="#index">index</a> と述部が偽（訳注：<tt>nil</tt>）となるリストの要素を全て返す関数 <a href="#clean">clean</a> も見てください。<br />
See also the related function <a href="#index">index</a>, which returns the 
indices of the filtered elements and <a href="#clean">clean</a>, 
which returns all elements of a list for which a predicate is false.
</p>

<br/><br/>

<a name="find"></a>
<h2><span class="function">find</span></h2>
<h4>syntax: (find <em>exp-key</em> <em>list</em> [<em>func-compare</em> | <em>regex-option</em>])<br/>
syntax: (find <em>str-key</em> <em>str-data</em> [<em>regex-option</em> [<em>int-offset</em>]])</h4>

<h3>Find an expression in a list（リスト中に式を見つける）</h3>

<p>第二引数<em>list</em> がリストに評価されると、<tt>find</tt> は <em>exp-key</em> の評価値が得られる要素のインデックス位置（オフセット）を返します。<br />
If the second argument evaluates to a <em>list</em>, then <tt>find</tt> returns 
the index position (offset) of the element derived from evaluating <em>exp-key</em>.</p>

<p>オプションで、演算子かユーザ定義関数を <em>func-compare</em> に指定できます。
<em>exp-key</em> が文字列なら、正規表現オプションが <em>regex-option</em> パラメータとして指定できます。<br />
Optionally, an operator or user-defined function can be specified in <em>func-compare</em>. 
If the <em>exp-key</em> is a string, a regular expression option
can be specified with the <em>regex-option</em> parameter.</p>

<p>正規表現か、比較ファンクタ（関数オブジェクト）を使った時は、システム変数 <tt>$0</tt> に見つかった最後の要素がセットされます。<br />
When using regular expressions or comparison functors the system
variable <tt>$0</tt> is set to the last element found.</p>

<!-- example -->

<pre>
; find an expression in a list
(find '(1 2) '((1 4) 5 6 (1 2) (8 9)))  <span class='arw'>&rarr;</span> 3

(find "world" '("hello" "world"))       <span class='arw'>&rarr;</span> 1
(find "hi" '("hello" "world"))          <span class='arw'>&rarr;</span> nil

(find "newlisp" '("Perl" "Python" "newLISP") 1)  <span class='arw'>&rarr;</span> 2

; use the comparison functor
(find 3 '(8 4 3  7 2 6) &gt;)  <span class='arw'>&rarr;</span> 4
$0 <span class='arw'>&rarr;</span> 2

(find "newlisp" '("Perl" "Python" "newLISP") 
                 (fn (x y) (regex x y 1))) <span class='arw'>&rarr;</span> 2
$0 <span class='arw'>&rarr;</span> "newLISP"

(find 5 '((l 3) (k 5) (a 10) (z 22)) 
         (fn (x y) (= x (last y))))  <span class='arw'>&rarr;</span> 1
$0 <span class='arw'>&rarr;</span> (k 5)

(find '(a ?) '((l 3) (k 5) (a 10) (z 22)) match)  <span class='arw'>&rarr;</span> 2
$0 <span class='arw'>&rarr;</span> (a 10)

(find '(X X) '((a b) (c d) (e e) (f g)) unify)  <span class='arw'>&rarr;</span> 2
$0 <span class='arw'>&rarr;</span> (e e)

; define the comparison functor first for better readability
(define (has-it-as-last x y) (= x (last y)))

(find 22 '((l 3) (k 5) (a 10) (z 22)) has-it-as-last)  <span class='arw'>&rarr;</span> 3
$0 <span class='arw'>&rarr;</span> (z 22)
</pre>


<p><a href="#match">match</a> や <a href="#unify">unify</a> を使ったリスト検索は、文字列に対する正規表現のよりパワフルな定型化が可能になります。<br />
Using <a href="#match">match</a> and <a href="#unify">unify</a>, 
list searches can be formulated which are as powerful 
as regular expression searches are for strings.
</p>

<h3>Find a string in a string（文字列中に文字列を見つける）</h3>

<p>第二引数 <em>str-data</em> が文字列に評価されると、（第一引数 <em>str-data</em> で最初に見つかった）<em>str-key</em> 文字列のオプセット位置が返ります。
この場合、<tt>find</tt> はバイナリの <em>str-data</em> にも動作します。
返ってくるオフセット位置は、UTF-8 バージョンの newLISP であっても、常に 1 バイト単位で計数されます。<br />
If the second argument, <em>str-data</em>, 
evaluates to a string, then the offset position 
of the string <em>str-key</em> (found in the first argument, 
<em>str-data</em>) is returned.  In this case, <tt>find</tt> 
also works on binary <em>str-data</em>. The offset position
returned is always based on counting single byte characters
even when running the UTF-8 enabled version of newLISP.</p>

<p>第三パラメータの存在は、（例えば、大文字小文字を区別しない 1（一）か、区別する <tt>0</tt>（ゼロ）の）<em>regex-option</em> で指定されるオプション番号と共に <em>str-pattern</em> の正規表現パターンを使った検索を指定します。
<em>regex-option</em> が指定されると、文字列の先頭からでなく、与えられたオフセットからの検索を始めるために <em>int-offset</em> 引数も指定可能です。
いずれにせよ、<tt>find</tt> が返す位置は文字列の先頭から計算されます。<br />
The presence of a third parameter specifies a search 
using the regular expression pattern specified in <em>str-pattern</em>, 
as well as an option number specified in <em>regex-option</em>
(i.e., 1 (one) for case-insensitive search or <tt>0</tt> (zero) 
for no special options). If <em>regex-option</em> is specified
an optional <em>int-offset</em> argument can be specified too
to start the search not at the beginning but at the offset given.
In any case the position returned by <tt>find</tt> is calculated
relative to the beginning of the string.</p>

<p>正規表現を用いない単純な文字列検索で <em>int-offset</em> を指定するには、<em>regex-option</em> に <tt>nil</tt> を指定してください。<br />
To specify <em>int-offset</em> in a simple string search without regular
expressions, specify <tt>nil</tt> for <em>regex-option</em>.</p>

<p>newLISP では、正規表現は標準のPerl互換正規表現 (PCRE) 検索です。
見つかった式や部分式は、システム変数<tt>$0</tt>, <tt>$1</tt>, <tt>$2</tt>等々に入り、他のシンボルのように扱えます。
これらの変数の内容は <tt>($ 0)</tt>, <tt>($ 1)</tt>, <tt>($ 2)</tt>等々を代わりに使ってもアクセスできます。
この方法は、インデックスを使ったアクセスを許可します（例えば <tt>($ i)</tt>、ここで <tt>i</tt> は整数）。<br />
In newLISP, regular expressions are standard 
Perl Compatible Regular Expression (PCRE) searches. 
Found expressions or subexpressions are returned 
in the system variables <tt>$0</tt>, <tt>$1</tt>, <tt>$2</tt>, etc., 
which can be used like any other symbol. 
As an alternative, 
the contents of these variables 
can also be accessed 
by using <tt>($ 0)</tt>, <tt>($ 1)</tt>, <tt>($ 2)</tt>, etc. 
This method allows indexed access 
(i.e., <tt>($ i)</tt>, where <tt>i</tt> is an integer).
</p> 
	
<p>正規表現検索におけるオプション番号の意味や詳しい情報は、<a href="#regex">regex</a> を見てください。<br />
See <a href="#regex">regex</a> for the meaning of the  
option numbers and more information on regular expression searching.
</p> 
	
<!-- example -->

<pre>
; simple string search
(find "world" "Hello world")  <span class='arw'>&rarr;</span> 6
(find "WORLD" "Hello woRLd")  <span class='arw'>&rarr;</span> nil

; case-insensitive regex

(find "WorlD" "Hello woRLd" 1)  <span class='arw'>&rarr;</span> 6   
                                
(find "hi" "hello world")       <span class='arw'>&rarr;</span> nil
(find "Hello" "Hello world")    <span class='arw'>&rarr;</span> 0

; regex with default options

(find "cat|dog" "I have a cat" 0)  <span class='arw'>&rarr;</span> 9 
$0                                 <span class='arw'>&rarr;</span> "cat"
(find "cat|dog" "my dog" 0)        <span class='arw'>&rarr;</span> 3
$0                                 <span class='arw'>&rarr;</span> "dog"
(find "cat|dog" "MY DOG" 1)        <span class='arw'>&rarr;</span> 3
$0                                 <span class='arw'>&rarr;</span> "DOG"

; use an optional offset
(find "cat|dog" "I have a cat and a dog" 0)    <span class='arw'>&rarr;</span> 9
(find "cat|dog" "I have a cat and a dog" 0 12) <span class='arw'>&rarr;</span> 19

;; find with subexpressions in regular expression
;; and access with system variables

(set 'str  "http://nuevatec.com:80")

(find "http://(.*):(.*)" str 0)  <span class='arw'>&rarr;</span> 0
                                 
$0  <span class='arw'>&rarr;</span> "http://nuevatec.com:80"
$1  <span class='arw'>&rarr;</span> "nuevatec.com"
$2  <span class='arw'>&rarr;</span> "80"

;; system variables as an indexed expression (since 8.0.5)
($ 0)  <span class='arw'>&rarr;</span> "http://nuevatec.com:80"
($ 1)  <span class='arw'>&rarr;</span> "nuevatec.com"
($ 2)  <span class='arw'>&rarr;</span> "80"
</pre>


<p>他に正規表現を使う関数としては、
<a href="#directory">directory</a>、
 <a href="#find-all">find-all</a>、
<a href="#parse">parse</a>、
<a href="#regex">regex</a>、
<a href="#replace">replace</a>、
<a href="#search">search</a> を見てください。<br />
	For other functions using regular expressions, 
	see <a href="#directory">directory</a>, 
    <a href="#find-all">find-all</a>,
	<a href="#parse">parse</a>, 
	<a href="#regex">regex</a>, 
	<a href="#replace">replace</a>, 
	and <a href="#search">search</a>.
</p>

<p>入れ子になった式や多次元リストの検索には、<a href="#ref">ref</a> や <a href="#ref-all">ref-all</a> を使ってください。<br />
	To find expressions in nested 
	or multidimensional lists, 
	use the <a href="#ref">ref</a> and <a href="#ref-all">ref-all</a> functions.
</p>

<br/><br/>

<a name="find-all"></a>
<h2><span class="function">find-all</span></h2>
<h4>syntax: (find-all <em>str-regex-pattern</em> <em>str-text</em> [<em>exp</em> [<em>regex-option</em>]])<br/>
syntax: (find-all <em>list-match-pattern</em> <em>list</em> [<em>exp</em>])<br/>
syntax: (find-all <em>exp-key</em> <em>list</em> [<em>exp</em> [<em>func-compare</em>]])</h4>

<p>
第一構文の <tt>find-all</tt> は、テキスト<em>str-text</em> 中に <em>str-regex-pattern</em> の出現を全て見つけ、一致した全ての文字列のリストを返します。
一致するもが見つからない時は、空リスト <tt>()</tt> が返ります。
第一構文では、<em>regex-option</em> の指定がなくても、文字列検索は正規表現パターンを使って行われます。
システム変数 <tt>$count</tt> が検出された一致数で更新されます。<br />
In the first syntax, <tt>find-all</tt> finds all occurrences of <em>str-regex-pattern</em> 
in the text <em>str-text</em>, returning a list containing all matching strings. 
The empty list <tt>()</tt> is returned if no matches are found. In the first syntax
string searches are always done using regular expression patterns, even if no
<em>regex-option</em> is specified. The system variable <tt>$count</tt> is updated
with the number of matches found.</p>

<p>オプションで、戻りリストに入る前の見つかった文字列や正規表現部分式を処理する式が指定できます。
追加オプション <em>regex-option</em> は、特殊正規表現のオプションです（詳細は、<a href="#regex">regex</a> を見てください）。<br />
Optionally, an expression can be specified to process the found string or regular subexpressions 
before placing them into the returned list. An additional option, <em>regex-option</em>, 
specifies special regular expression options 
(see <a href="#regex">regex</a> for further details).
</p>


<!-- example -->

<pre>
(find-all {\d+} "lkjhkljh34ghfdhgfd678gfdhfgd9")
<span class='arw'>&rarr;</span> ("34" "678" "9")

$count <span class='arw'>&rarr;</span> 3

(find-all {(new)(lisp)} "newLISPisNEWLISP" (append $2 $1) 1)
<span class='arw'>&rarr;</span> ("LISPnew" "LISPNEW")

(unique (sort 
    (find-all {[a-zA-Z]+} 
        (replace "&lt;[^&gt;]+&gt;" (get-url "http://newlisp.org") "" 0) )
))
<span class='arw'>&rarr;</span> ("A" "ACC" "AI" "API" "About" "All" "Amazing" "Apps"
...
"where" "whole" "width" "wiki" "will" "with" "work" "written")

; use $count in evaluated expr
(find-all "a" "ababab" (string $count $it)) <span class='arw'>&rarr;</span> ("1a" "2a" "3a")
</pre>


<p>最初の例は、テキスト中の全ての数字を見つけています。
二番目の例は、正規表現パターン <em>str-pattern</em> で検索された部分式に、オプション式 <em>exp</em> がどのように動作するかを示しています。
最後の例は、ウェブ・ページを取り込み、HTMLタグを消去してから、全ての単語を単一（訳注：重複する単語がない）にして、ソートしたリストに集めています。<br />
The first example discovers all numbers in a text. 
The second example shows how an optional expression in <em>exp</em> 
can work on subexpressions found by the regular expression pattern 
in <em>str-pattern</em>. The last example retrieves a web page, 
cleans out all HTML tags, and then collects all words 
into a unique and sorted list.
</p>

<p>文字列に対しての <tt>find-all</tt> は、<em>regex-option</em> がなくても、常に正規表現検索を実行することに注意してください。<br />
Note that <tt>find-all</tt> with strings always performs a regular expression search, 
even if the option in <em>regex-option</em> is omitted.
</p>

<p>第二構文の <tt>find-all</tt> は、<em>list</em> 中でパターン <em>list-match-pattern</em> に <a href="#match">match</a> する全てのリストを探し出します。
文字列に対しての <tt>find-all</tt> のように、<em>list</em> で見つかる <a href="#match">match</a> した部分リストを処理する式が <em>exp</em> に指定できます。
システム変数 <tt>$count</tt> は検出された一致数で更新されます。<br />
In the second syntax, <tt>find-all</tt> searches for all list 
<a href="#match">match</a> patterns <em>list-match-pattern</em> in 
<em>list</em>. As in <tt>find-all</tt> for strings, an expression can 
be specified in <em>exp</em> to process further the matched sublist found in 
<em>list</em>. The system variable <tt>$count</tt> is updated with the number
 of matches found.</p>

<!-- example -->

<pre>
(find-all '(? 2) '((a 1) (b 2) (a 2) (c 4))) <span class='arw'>&rarr;</span> ((b 2) (a 2))

(find-all '(? 2) '((a 1) (b 2) (a 2) (c 4)) (first $it)) <span class='arw'>&rarr;</span> (b a)

$count <span class='arw'>&rarr;</span> 2
</pre>


<p>リスト合致用の <tt>find-all</tt> は、部分リスト検索時の比較に <a href="#match">match</a> を使い、常にパターン表現のリストを必要とします。<br />
<tt>find-all</tt> for list matches always uses <a href="#match">match</a> to compare when
searching for sublists and always needs a list for the pattern expression.</p>

<p>第三構文の <tt>find-all</tt> では、リスト要素とキーとなる <em>exp-key</em> 式の比較用に、組込かユーザ定義関数が指定できます：<br />
In the third syntax, <tt>find-all</tt> can specify a built-in or user-defined
function used for comparing list elements with the key expression in <em>exp-key</em>:</p>


<!-- example -->

<pre>
(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) $it &lt;) <span class='arw'>&rarr;</span> (7 9 9 7 8)

; process the found element available in $it

(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) (* 3 $it) &lt;) <span class='arw'>&rarr;</span> (21 27 27 21 24)
; same as
(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) (* 3 $it) (fn (x y) (&lt; x y))) <span class='arw'>&rarr;</span> (21 27 27 21 24)


(find-all 5 '(2 7 4 5 9 2 4 9 7 4 8) ("abcdefghijk" $it) &lt;) <span class='arw'>&rarr;</span> ("h" "j" "j" "h" "i")

$count <span class='arw'>&rarr;</span> 5

; use $count
(find-all 'a '(a b a b a b) (list $count $it)) <span class='arw'>&rarr;</span> ((1 a) (2 a) (3 a))
</pre>


<p>検索する式やリストに含める式は、どんな型も可能です。
この構文の <tt>find-all</tt> は <a href="#filter">filter</a> のように動作しますが、
追加の利点として、見つけた要素を処理する式が定義できます。<br />
Any type of expression can be searched for or can be contained in the list. <tt>find-all</tt>
in this syntax works similar to <a href="#filter">filter</a> but with the added benefit of
being able to define a processing expression for the found element.</p>

<p><em>func-compare</em> が定義されず、<em>exp-key</em> がリストなら、第二構文としての <a href="#match">match</a> が比較に使われるでしょう。<br />
If no <em>func-compare</em> is defined and <em>exp-key</em> is a list, then
<a href="#match">match</a> will be used for comparison, as in the second syntax.</p>

<br/><br/>

<a name="first"></a>
<h2><span class="function">first</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (first <em>list</em>)<br/>
syntax: (first <em>array</em>)<br/>
syntax: (first <em>str</em>)</h4>

<p>リストの最初の要素や文字列の最初の文字を返します。
引数は変わりません。
この関数は、他の Lisp方言の <em>car</em> や <em>head</em> と等価です。<br />
Returns the first element of a list or the first character of a string.
The operand is not changed.  This function is equivalent to <em>car</em>
or <em>head</em> in other Lisp dialects.</p>

<!-- example -->

<pre>
(first '(1 2 3 4 5))       <span class='arw'>&rarr;</span> 1
(first '((a b) c d))       <span class='arw'>&rarr;</span> (a b)
(set 'aList '(a b c d e))  <span class='arw'>&rarr;</span> (a b c d e)
(first aList)              <span class='arw'>&rarr;</span> a
aList                      <span class='arw'>&rarr;</span> (a b c d e)
(set 'A (array 3 2 (sequence 1 6)))
<span class='arw'>&rarr;</span>  ((1 2) (3 4) (5 6))
(first A)                  <span class='arw'>&rarr;</span> (1 2)

(first '())                <span class='arw'>&rarr;</span> <span class='err'>ERR: list is empty</span>
</pre>


<p>第三構文では、文字列 <em>str</em> から、最初の文字が文字列として返ります。<br />
In the third syntax, the first character is returned 
from the string in <em>str</em> as a string.</p>
</p>

<!-- example -->

<pre>
(first "newLISP")         <span class='arw'>&rarr;</span> "n"
(first (rest "newLISP"))  <span class='arw'>&rarr;</span> "e"
</pre>


<p>UTF-8 版の newLISP を使うと、<a href="#first">first</a> はバイト境界ではなく、キャラクタ境界で動作します。
関数 <a href="#last">last</a> や <a href="#rest">rest</a> も見てください。<br />
	Note that <a href="#first">first</a> works on character boundaries 
	rather than byte boundaries 
	when the UTF-8&ndash;enabled version of newLISP is used.
	See also the functions <a href="#last">last</a> 
	and <a href="#rest">rest</a>.
</p>

<br/><br/>

<a name="flat"></a>
<h2><span class="function">flat</span></h2>
<h4>syntax: (flat <em>list</em> [<em>int-level</em>])</h4>

<p>フラットなリストを返します（訳注：入れ子の括弧をなくしたリストになる）：<br/>
Returns a flattened list from a list:</p>

<!-- example -->

<pre>
(set 'lst '(a (b (c d))))
(flat lst)  <span class='arw'>&rarr;</span> (a b c d)

(map (fn (x) (ref x lst)) (flat lst))
<span class='arw'>&rarr;</span> ((0) (1 0) (1 1 0) (1 1 1))
</pre>

<p>オプションのパラメータ <em>int-level</em> は、リストをフラット化する時の入れ子レベルを制限します。<br />
The optional <em>int-level</em> parameter can be used to limit
the recursion level when flattening the list:</p>

<!-- example -->

<pre>
(flat '(a b (c d (e f)) (g h (i j))) )   <span class='arw'>&rarr;</span> (a b c d e f g h i j)

(flat '(a b (c d (e f)) (g h (i j))) 1)  <span class='arw'>&rarr;</span> (a b c d (e f) g h (i j))

(flat '(a b (c d (e f)) (g h (i j))) 2)  <span class='arw'>&rarr;</span> (a b c d e f g h i j)
</pre>

<p><em>int-level</em> が <tt>0</tt> の時、フラット化は行われません。<br />
If <em>int-level</em> is <tt>0</tt>, no flattening will occur.</p>

<p><tt>flat</tt> を使えば、入れ子リストでも繰り返しに使えるようになります。<br />
<tt>flat</tt> can be used to iterate through nested lists.</p>

<br/><br/>

<a name="float"></a>
<h2><span class="function">float</span></h2>
<h4>syntax: (float <em>exp</em> [<em>exp-default</em>])</h4>

<p><em>exp</em> の式が数値か文字列に評価されたなら、引数が浮動小数点数に変換され、返されます。
<em>exp</em> が浮動小数点数に変換できないなら、 <tt>nil</tt> か、指定された <em>exp-default</em> の評価が返されます。
この関数は、主にユーザ入力やテキストの読み取り・解析時の文字列の変換に使われます。
文字列は、数値か <tt>+</tt>（プラス記号）か <tt>-</tt>（マイナス記号）か <tt>.</tt>（ピリオド）で始まっている必要があります。
<em>exp</em> が無効なら、<tt>float</tt> はデフォルト値として <tt>nil</tt> を返します。<br />
	If the expression in <em>exp</em> 
	evaluates to a number or a string, 
	the argument is converted to a float 
	and returned. 
	If <em>exp</em> cannot be converted to a float 
	then <tt>nil</tt> or, if specified, 
	the evaluation of <em>exp-default</em> 
	will be returned.
	This function is mostly used to convert strings 
	from user input or when reading and parsing text. 
	The string must start with a digit 
	or the <tt>+</tt> (plus sign), <tt>-</tt> (minus sign), 
	or <tt>.</tt> (period). 
	If <em>exp</em> is invalid,
	<tt>float</tt> returns <tt>nil</tt> 
	as a default value.
</p>

<p>指数項が 1e308 より大きいか、-1e308 より小さい浮動小数点数は、それぞれ +INF か -INF に変換されます。
+INF と -INF の表示は、プラットフォームやコンパイラによって異なります。<br />
	Floats with exponents larger than 1e308 
	or smaller than -1e308 
	are converted to +INF or -INF, respectively. 
	The display of +INF and -INF 
	differs on different platforms and compilers.
</p>

<!-- example -->

<pre>
(float "1.23")       <span class='arw'>&rarr;</span> 1.23
(float " 1.23")      <span class='arw'>&rarr;</span> 1.23
(float ".5")         <span class='arw'>&rarr;</span> 0.50
(float "-1.23")      <span class='arw'>&rarr;</span> -1.23
(float "-.5")        <span class='arw'>&rarr;</span> nil
(float "#1.23")      <span class='arw'>&rarr;</span> nil
(float "#1.23" 0.0)  <span class='arw'>&rarr;</span> 0

(float? 123)          <span class='arw'>&rarr;</span> nil
(float? (float 123))  <span class='arw'>&rarr;</span> true

(float '(a b c))    <span class='arw'>&rarr;</span> nil
(float '(a b c) 0)  <span class='arw'>&rarr;</span> 0
(float nil 0)       <span class='arw'>&rarr;</span> 0

(float "abc" "not a number")  <span class='arw'>&rarr;</span> "not a number"
(float "1e500")               <span class='arw'>&rarr;</span> inf
(float "-1e500")              <span class='arw'>&rarr;</span> -inf

(print "Enter a float num:")
(set 'f-num (float (read-line)))
</pre>


<p>整数値の構文解析には、関数 <a href="#int">int</a> を使ってください。<br />
	Use the <a href="#int">int</a> function 
	to parse integer numbers.
</p>

<br/><br/>

<a name="floatp"></a>
<h2><span class="function">float?</span></h2>
<h4>syntax: (float? <em>exp</em>)</h4>

<p><em>exp</em> が浮動小数点数に評価される時のみ <tt>true</tt> が、そうでない時に <tt>nil</tt> が返ります。<br />
	<tt>true</tt> is returned only 
	if <em>exp</em> evaluates to a floating point number;
	otherwise, <tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(set 'num 1.23)
(float? num)  <span class='arw'>&rarr;</span> true
</pre>
<blockquote>
（訳例：
<pre>
> (sqrt -1)
nan
> (float? (sqrt -1))
true
> (div 1 0)
inf
> (float? (div 1 0))
true
</pre>
　<tt>NaN</tt> や <tt>INF</tt> の型は、浮動小数点数です。）
</blockquote>

<br/><br/>

<a name="floor"></a>
<h2><span class="function">floor</span></h2>
<h4>syntax: (floor <em>number</em>)</h4>

<p>浮動小数点数の <em>number</em> より、次に小さい整数値が返ります。<br />
	Returns the next lowest integer below <em>number</em> 
	as a floating point.
</p>

<!-- example -->

<pre>
(floor -1.5)  <span class='arw'>&rarr;</span> -2
(floor 3.4)   <span class='arw'>&rarr;</span> 3
</pre>


<p>関数 <a href="#ceil">ceil</a> も見てください。<br />
	See also the <a href="#ceil">ceil</a> function.
</p>

<br/><br/>

<a name="flt"></a>
<h2><span class="function">flt</span></h2>
<h4>syntax: (flt <em>number</em>)</h4>

<p><em>number</em> を32ビット浮動小数点数の整数表現に変換します。
この関数は、ライブラリ・ルーチンへ 32 ビット浮動小数点数を渡す時に使われます。
newLISP の浮動小数点数は 64 ビットで、導入した C ライブラリ・ルーチンを呼び出す時は、64ビット浮動小数点数が渡されます。<br />
	Converts <em>number</em> to a 32-bit float 
	represented by an integer. 
	This function is used when passing 32-bit floats 
	to library routines.
	newLISP floating point numbers 
	are 64-bit and are passed as 64-bit floats 
	when calling imported C library routines.
</p>


<!-- example -->

<pre>
(flt 1.23)  <span class='arw'>&rarr;</span> 1067282596

;; pass 32-bit float to C-function: foo(float value) 
(import "mylib.so" "foo")
(foo (flt 1.23))

(get-int (pack "f" 1.23))  <span class='arw'>&rarr;</span> 1067282596

(unpack "f" (pack "ld" (flt 1.2345)))  <span class='arw'>&rarr;</span> (1.234500051)
</pre>


<p>最後の二つの動作は、<tt>flt</tt> の内部動作を示しています。<br />
	The last two statements illustrate 
	the inner workings of <tt>flt</tt>.
</p>

<p>ライブラリの導入には、関数 <a href="#import">import</a> を使ってください。<br />
	Use the <a href="#import">import</a> function 
	to import libraries.
</p>

<br/><br/>

<a name="fn"></a>
<h2><span class="function">fn</span></h2> 
<h4>syntax: (fn (<em>list-parameters</em>) <em>exp-body</em>)</h4>

<p><tt>fn</tt> や <tt>lambda</tt> は無名関数の定義に使われ、関数を引数とする <a href="#map">map</a> や <a href="#sort">sort</a>等の多くの関数でよく使われます。
<tt>fn</tt> や <tt>lambda</tt> はそれ自体のシンボルは存在しませんが、特殊リスト型：<em>ラムダ・リスト</em> を指定します。
<tt>fn-macro</tt> と <tt>lambda-macro</tt> と共に、これらの用語はソース解析で認識され、リストの特殊型を指定しますので、関数や演算子のように使うことができます。<br />
<tt>fn</tt> or <tt>lambda</tt> are used to define anonymous functions, 
which are frequently used in <a href="#map">map</a>, <a href="#sort">sort</a>, 
and all other expressions where functions can be used as arguments.
The <tt>fn</tt> or <tt>lambda</tt> word does not exist on its own as a symbol,
but indicates a special list type: the <em>lambda list</em>. Together with <tt>fn-macro</tt>
and <tt>lambda-macro</tt> these terms are recognized during source parsing. They indicate a 
specialized type of list which can be used and applied like a function or operator. 
</p>

<p>無名関数を使えば、<a href="#define">define</a> を使う新しい関数の定義を省けます。
その代わりに、関数が直接定義されるのです：<br />
Using an anonymous function eliminates the need to define a new function with 
<a href="#define">define</a>. Instead, a function is defined on the fly:
</p>

<!-- example -->

<pre>
(map (fn (x) (+ x x)) '(1 2 3 4 5)) <span class='arw'>&rarr;</span> (2 4 6 8 10)

(sort '(".." "..." "." ".....") (fn (x y) (&gt; (length x) (length y))))
<span class='arw'>&rarr;</span> ("....." "..." ".." ".")
</pre>


<p>例では、整数 (<em>x</em>) を取って二倍にする関数 <em>fn(x)</em> を定義しています。
この関数は、<a href="#map">map</a> を使って、引数のリストに<em>展開されます</em> 。
二番目の例は、長さでソートされる文字列を示しています。<br />
The example defines the function <em>fn(x)</em>, which takes an integer 
(<em>x</em>) and doubles it.  The function is <em>mapped</em> onto a list of 
arguments using <a href="#map">map</a>. The second example shows strings being 
sorted by length.
</p>

<p> (長い間、伝統的形式であった) 関数 <a href="#lambda">lambda</a> は、<tt>fn</tt> に置き換えることができます。<br />
The <a href="#lambda">lambda</a> function (the longer, traditional form of writing)
can be used in place of <tt>fn</tt>.
</p>

<br/><br/>

<a name="for"></a>
<h2><span class="function">for</span></h2>
<h4>syntax: (for (<em>sym</em> <em>num-from</em> <em>num-to</em> [<em>num-step</em> [<em>exp-break</em>]]) <em>body</em>)</h4>

<p><em>num-from</em> と <em>num-to</em> により指定される範囲（<em>num-from</em> と <em>num-to</em>を含む）で、<em>body</em> の式群を繰り返し評価します。
刻み幅は <em>num-step</em> に指定できます。
刻み幅が指定されなければ、<tt>1</tt> になります。
（訳注：刻み幅の有無で <em>sym</em> の型が変わります。詳細は下に記述あり。）<br />
	Repeatedly evaluates the expressions in <em>body</em> 
	for a range of values specified
	in <em>num-from</em> and <em>num-to</em>, inclusive.  
	A step size may be specified with <em>num-step</em>.  
	If no step size is specified, <tt>1</tt> is assumed.
</p>

<p>オプションで、<em>exp-break</em> に早期脱出条件を定義できます。
中断式が <tt>nil</tt> 以外に評価されると、<tt>for</tt> ループは <em>exp-break</em> の値を返します。
中断条件は <em>body</em> を評価する前にテストされます。
中断条件を定義する際は、<em>num-step</em> も定義しなければなりません。<br />
	Optionally, a condition for early loop exit
	may be defined in <em>exp-break</em>. 
	If the break expression evaluates 
	to any non-<tt>nil</tt> value, 
	the <tt>for</tt> loop returns with 
	the value of <em>exp-break</em>. 
	The break condition is tested 
	before evaluating <em>body</em>. If a
	break condition is defined, <em>num-step</em>
	must be defined, too.
</p>

<p><tt>for</tt> 式にとって、シンボル <em>sym</em> はダイナミック・スコープのローカル変数で、刻み幅が指定されない時は整数となり、刻み幅がある時は浮動小数点数となって指定された範囲内の各値を連続して取ります。
<tt>for</tt> 宣言文の評価が終わった後、<em>sym</em> は以前の値になります。
（訳注：<a href="#scoping">15.ダイナミック スコープとレキシカル スコープ</a>の章を参照してください。）<br />
	The symbol <em>sym</em> 
	is local in dynamic scope 
	to the <tt>for</tt> expression.
	It takes on each value successively 
	in the specified range as an integer value 
	if no step size is specified, or
	as a floating point value when a step size is
	present. After evaluation of the <tt>for</tt>
    statement <em>sym</em> assumes its previous
    value.
</p>

<!-- example -->

<pre>
&gt; (for (x 1 10 2) (println x))
<b>1
3
5
7
9</b>

&gt; (for (x 8 6 0.5) (println x))
<b>8
7.5
7
6.5
6</b>

&gt; (for (x 1 100 2 (&gt; (* x x) 30)) (println x))
<b>1
3
5
true</b>
&gt; _
</pre>


<p>二番目の例は、大きい方から小さい方への数の範囲を使っています。
刻み幅は、常に正の数値であることに注意してください。
三番目の例では、中断条件がテストされています。<br />
	The second example uses 
	a range of numbers 
	from highest to lowest. 
	Note that the step size 
	is always a positive number. 
	In the third example, 
	a break condition is tested.
</p>

<p>連続した数値の生成には、関数 <a href="#sequence">sequence</a> を使ってください。<br />
	Use the <a href="#sequence">sequence</a> function
	to make a sequence of numbers.
</p>

<br/><br/>

<a name="for-all"></a>
<h2><span class="function">for-all</span></h2>

<h4>syntax: (for-all <em>func-condition</em> <em>list</em>)</h4>

<p>
<em>list</em> の全要素に <em>func-condition</em> の関数を適用します。
全要素が <em>func-condition</em> の条件に一致したなら、結果は <tt>true</tt> になり、そうでなければ <tt>nil</tt> が返ります。<br />
Applies the function in <em>func-condition</em> 
to all elements in <em>list</em>.
If all elements meet the condition in <em>func-condition</em>,
the result is <tt>true</tt>;
otherwise, <tt>nil</tt> is returned.</p>

<!-- example -->

<pre>
(for-all number? '(2 3 4 6 7))                 <span class='arw'>&rarr;</span> true

(for-all number? '(2 3 4 6 "hello" 7))         <span class='arw'>&rarr;</span> nil

(for-all (fn (x) (= x 10)) '(10 10 10 10 10))  <span class='arw'>&rarr;</span> true
</pre>


<p>リスト中の少なくとも一個が条件に合っているかどうかをチェックするには、関数 <a href="#exists">exists</a> を使ってください。<br />
Use the <a href="#exists">exists</a> function
to check if at least one element in a list 
meets a condition.</p>

<br/><br/>

<a name="fork"></a>
<h2><span class="function">fork</span></h2>

<h4>syntax: (fork <em>exp</em>)</h4>

<p><em>exp</em> の式がプラットフォーム OS の newLISP の子プロセス・スレッドとして、起動されます。
この新プロセスは全てのアドレス空間を継承しますが独立して走り、子プロセスで変化するシンボルや変数の内容は親プロセスに影響しませんし、その逆もしかりです。
子プロセスは <em>exp</em> の評価が終了した時点で終わります。<br />
The expression in <em>exp</em> is launched as a newLISP child process-thread 
of the platforms OS. The new process inherits the entire address space, 
but runs independently so symbol or variable contents changed in the child process 
will not affect the parent process or vice versa. The child process ends 
when the evaluation of <em>exp</em> finishes.
</p>

<p><tt>fork</tt> は成功すると子プロセスID を返し、失敗すると <tt>nil</tt> を返します。
子プロセスの終了を待つ関数 <a href="#wait-pid">wait-pid</a> も見てください。<br />
On success, <tt>fork</tt> returns with the child process ID; on failure, 
<tt>nil</tt> is returned. See also the <a href="#wait-pid">wait-pid</a> function, 
which waits for a child process to finish.
</p>

<p>この関数は Linux/Unix 版の newLISP で利用可能で、基盤となる OS に実装されている <tt>fork()</tt> をベースにしています。<br />
This function is only available on Linux/Unix versions of newLISP 
and is based on the <tt>fork()</tt> implementation of the underlying OS. </p>

<p>プロセスの起動や結果の収集をより簡単に自動化する方法として、<a href="#spawn">spawn</a> や <a href="#cilk">Cilk API</a> が利用可能です。<br />
A much simpler automated method to launch processes and collect
results is available with <a href="#spawn">spawn</a> and the <a href="#cilk">Cilk API</a>.</p>

<!-- example -->

<pre>
&gt; (set 'x 0)
<b>0</b>
&gt; (fork (while (&lt; x 20) (println (inc x)) (sleep 1000)))
<b>176</b>

&gt; <b>1
2
3
4
5
6</b>
</pre>


<p>
この例が示しているのは、子プロセス・スレッドがシンボル空間を継承している様子や、親プロセスと独立している様子です。
<tt>fork</tt> 宣言文は、すぐにプロセス ID <tt>176</tt> を返します。
子プロセスは、変数 <tt>x</tt> を一秒毎に一ずつ加算して標準出力に出力します（太字）。
親プロセスは、コマンド受付可能です。
親プロセスで、シンボル <tt>x</tt> がまだ値 <tt>0</tt> (zero) を保持していることを確かめるたに、<tt>x</tt> とタイプして見てください。
子プロセスの出力と混在した状態で宣言文を入力することになりますが、親プロセスには正しく入力されます。<br />
The example illustrates how the child process-thread inherits the symbol space 
and how it is independent of the parent process. The <tt>fork</tt> statement 
returns immediately with the process ID <tt>176</tt>. The child process increments 
the variable <tt>x</tt> by one each second and prints it to standard out (boldface). 
In the parent process, commands can still be entered. Type <tt>x</tt> to see that 
the symbol <tt>x</tt> still has the value <tt>0</tt> (zero) in the parent process. 
Although statements entered will mix with the display of the child process output, 
they will be correctly input to the parent process.</p>

<p>
次の例は、プロセス間の通信に <a href="#pipe">pipe</a> が使われる様子を示しています。<br />
The second example illustrates how <a href="#pipe">pipe</a> can be used 
to communicate between processes.</p>

<!-- example -->

<pre>
#!/usr/local/bin/newlisp

(define (count-down-proc x channel)
  (while (!= x 0)
      (write-line channel (string x))
      (dec x)))

(define (observer-proc channel)
  (do-until (= i "1")
    (println "process " (setq i (read-line channel)))))

(map set '(in out) (pipe))
(set 'observer (fork (observer-proc in)))
(set 'counter (fork (count-down-proc 5 out)))

; avoid zombies
(wait-pid observer)
(wait-pid counter)

(exit)
</pre>


<p>次のような出力が observer-proc によって生成されます。<br/>
The following output is generated by observer-proc</p>


<pre>
<b>process 5
process 4
process 3
process 2
process 1</b>
</pre>


<p><tt>count-down-proc</tt> は通信パイプに数を書き込み、それらは <tt>observer-process</tt> で拾われ、出力されます。<br />
The <tt>count-down-proc</tt> writes numbers to the communication pipe, 
where they are picked up by the <tt>observer-process</tt> and displayed.
</p>

<p>分岐したプロセスはそれ自身で終了することも、関数 <a href="#destroy">destroy</a> を使って破棄することもできます。<br />
A forked process can either exit by itself or it can be destroyed using
the <a href="#destroy">destroy</a> function.</p>


<pre>
(define (fork-destroy-demo)
    (set 'pid (fork (dotimes (i 1000) (println i) (sleep 10))))
    (sleep 50)
    (destroy pid) 
)

&gt; (fork-destroy-demo)
<b>0
1
2
3
4
true</b>
&gt; 
</pre>


<p><tt>fork-destroy-demo</tt> で開始されたプロセスは終了しませんが、開始 50 ミリ秒後に <a href="#destroy">destroy</a> が呼び出されて破棄されます。<br />
The process started by <tt>fork-destroy-demo</tt> will not finish but is
destroyed 50 milli-seconds after start by a call to <a href="#destroy">destroy</a>.
</p> 

<p>プロセスの同期には関数 <a href="#semaphore">semaphore</a> を、プロセス間のメモリの共有には <a href="#share">share</a> を使ってください。<br/>
Use the <a href="#semaphore">semaphore</a> function for synchronizing processes 
and <a href="#share">share</a> for sharing memory between processes.
</p>

<p>プロセスの同期や結果の収集をより簡単に、かつ自動化する <a href="#spawn">spawn</a> を見てください。<br />
See <a href="#spawn">spawn</a> for a much simpler and automated way to
synchronize processes and collect results.</p>

<br/><br/>

<a name="format"></a>
<h2><span class="function">format</span></h2>
<h4>syntax: (format <em>str-format exp-data-1</em> [<em>exp-data-2</em> ... ])<br/>
syntax: (format <em>str-format</em> <em>list-data</em>)</h4>

<p><em>str-format</em> の評価で指定されるフォーマットを使って、<em>exp-data-1</em> の整形した文字列を作成します。
指定する形式は ANSI C言語の関数 <tt>printf()</tt> で使われるフォーマットと同じです。
<em>str-format</em> に一個より多いフォーマット指定子を指定することで、二つ以上の引数 <em>exp-data</em> を取れます。<br />
Constructs a formatted string from <em>exp-data-1</em> 
using the format specified in the evaluation of <em>str-format</em>. 
The format specified is identical to the format used for the <tt>printf()</tt> 
function in the ANSI C language. Two or more <em>exp-data</em> arguments 
can be specified for more than one format specifier in <em>str-format</em>.</p>

<p>もう一つの構文では、整形されるデータは <em>list-data</em> のリストの中から渡されます。<br />
In an alternative syntax, the data to be formatted 
can be passed inside a list in <em>list-data</em>.</p>

<p><tt>format</tt> は、フォーマット文字列の有効性、データ型の一致、引数の数が合っているかをチェックします。
間違ったフォーマットやデータ型には、エラー・メッセージが返ります。
<a href="#int">int</a> や <a href="#float">float</a> や <a href="#string">string</a> を使えば、適正なデータ型が保証され、エラー・メッセージが回避されます。<br />
<tt>format</tt> checks for a valid format string, 
matching data type, and the correct number of arguments. 
Wrong formats or data types result in error messages. 
<a href="#int">int</a>, <a href="#float">float</a>, 
or <a href="#string">string</a> can be used 
to ensure correct data types and to avoid error messages.</p>

<p>フォーマット文字列は次のような一般形式を持ちます：<br />
The format string has the following general format:</p>


<b>"%w.pf"</b>

<p><tt>%</tt>（パーセント記号）でフォーマット指定が開始されます。
フォーマット文字列内で <tt>%</tt> を表したい時は二度書きします：<tt>%%</tt><br />
The <tt>%</tt> (percent sign) 	starts a format specification. 
To display a <tt>%</tt> inside a format string, double it: <tt>%%</tt></p>

<p>Linux では、パーセント記号の後にシングル・クォート <tt>%'</tt> を続けて、数値形式に千単位の区切りを入れることができます。<br />
On Linux the percent sign can be followed by a single quote <tt>%'</tt>
to insert thousand's separators in number formats.</p>


<p><tt>w</tt> は幅フィールドです。
データは、右詰めですが、<tt>-</tt> (マイナス符号) が先に付くと左詰めになります。
<tt>+</tt> (プラス符号) が付くと、正の数字は <tt>+</tt>（訳注：負の数字は <tt>-</tt> ）付きで表示されます。
先にゼロが付くと、使われないスペースがゼロで埋められます。
幅フィールドはオプションで、全データ型に提供されます。<br />
The <tt>w</tt> represents the width field. Data is right-aligned, except when 
preceded by a minus sign, in which case it is left-aligned. If preceded by a 
<tt>+</tt> (plus sign), positive numbers are displayed with a <tt>+</tt>.  
When preceded by a <tt>0</tt> (zero), the unused space is filled with leading zeroes. The width field is optional and serves all data types.</p>

<p><tt>p</tt> は（浮動小数点専用の）十進数桁数か文字列の桁数で、ピリオドで幅フィールドから切り分けられます。
桁数はオプションです。
文字列に桁フィールドを使うと、表示される文字数が <tt>p</tt> で制限されます。<br />
The <tt>p</tt> represents the precision number of decimals (floating point only) 
or strings and is separated from the width field by a period. Precision is 
optional. When using the precision field on strings, the number of characters 
displayed is limited to the number in <tt>p</tt>.</p>

<p>
<tt>f</tt> は型フラグで必須項目です。つまり、省略できません。<br />
The <tt>f</tt> represents a type flag and is essential; 
it cannot be omitted.
</p>

<p><tt>f</tt> には下記の型があります：<br />
Below are the types in <tt>f</tt>:</p>

<table summary="format characters">
<tr align="left"><th>形式<br />format</th><th>内容<br />description</th></tr>
<tr><td>s</td><td>文字列<br />text string</td></tr>
<tr><td>c</td><td>一文字（ 1 から 255 までの値）<br />character (value 1 - 255)</td></tr>
<tr><td>d</td><td>十進数（32ビット）<br />decimal (32-bit)</td></tr>
<tr><td>u</td><td>符号なし十進数（32ビット）<br />unsigned decimal (32-bit)</td></tr>
<tr><td>x</td><td>小文字による十六進数<br />hexadecimal lowercase</td></tr>
<tr><td>X</td><td>大文字による十六進数<br />hexadecimal uppercase</td></tr>
<tr><td>o</td><td>八進数（32ビット）<br />octal (32-bits) (not supported on all of newLISP flavors)</td></tr>
<tr><td>f</td><td>実数<br />floating point</td></tr>
<tr><td>e</td><td>小文字による指数<br />scientific floating point</td></tr>
<tr><td>E</td><td>大文字による指数<br />scientific floating point</td></tr>
<tr><td>g</td><td>汎用的実数（訳注：数値の応じて <tt>f</tt> か <tt>e</tt> ）<br />general floating point</td></tr>
<tr><td>G</td><td>汎用的実数（訳注：数値の応じて <tt>f</tt> か <tt>E</tt> ）<br />general floating point</td></tr>
</table><br/>

<p>32 ビット・フォーマット指定子を使って 64 ビット数値を定型化すると、切り詰められて64 ビット・システムでは下位 32 ビット数字に整形されます。32ビット・システムではオーバーフローして <tt>0xFFFFFFFF</tt> になります。<br />
Formatting 64-bit numbers using the 32-bit format specifiers from above table 
will truncate and format the lower 32 bits of the number on 64-bit systerms and overflow to
<tt>0xFFFFFFFF</tt> on 32-bit systems.</p>

<p>32 ビット数値及び 64 ビット数値には、下記のフォーマット文字列を使ってください。32 ビットのプラットフォームでは、64 ビット数値は32 ビットに切り詰められます：<br />
For 32-bit and 64-bit numbers use the following format 
strings. 64-bit numbers will be truncated to 32-bit on
32-bit platforms:</p>

<table summary="format characters">
<tr align="left"><th>format</th><th>description</th></tr>
<tr><td>ld</td><td>decimal (32/64-bit)</td></tr>
<tr><td>lu</td><td>unsigned decimal (32/64-bit)</td></tr>
<tr><td>lx</td><td>hexadecimal (32/64-bit)</td></tr>
<tr><td>lX</td><td>hexadecimal uppercase (32/64-bit)</td></tr>
</table><br/>

<p>Unixライクのオペレーティング・システムや MS Windows では、64ビット数値に下記のフォーマット文字列を使ってください（TRU64 ではサポートされません）：<br />
For 64-bit numbers use the following format strings on Unix-like 
operating systems and on MS Windows (not supported on TRU64):</p>

<table summary="format characters">
<tr align="left"><th>format</th><th>description</th></tr>
<tr><td>lld</td><td>decimal (64-bit)</td></tr>
<tr><td>llu</td><td>unsigned decimal (64-bit)</td></tr>
<tr><td>llx</td><td>hexadecimal (64-bit)</td></tr>
<tr><td>llX</td><td>hexadecimal uppercase(64-bit)</td></tr>
</table><br/>

<p>MS Windows プラットフォームでのみ、64ビット数値に下記の文字列を使ってください：<br />
On Windows platforms only the following characters apply 
for 64 bit numbers:</p>

<table summary="format characters">
<tr align="left"><th>format</th><th>description</th></tr>
<tr><td>I64d</td><td>decimal (64-bit)</td></tr>
<tr><td>I64u</td><td>unsigned decimal (64-bit)</td></tr>
<tr><td>I64x</td><td>hexadecimal (64-bit)</td></tr>
<tr><td>I64X</td><td>hexadecimal uppercase(64-bit)</td></tr>
</table><br/>

<p>他のテキストは、フォーマット指定子間かフォーマット指定子の前後に置けます。<br />
	Other text may occur between, 
	before, or after the format specs.
</p>
	
<p>Tru64 Unix では、フォーマット文字 <tt>i</tt> が <tt>d</tt> の代わりに使えることを記しておきます。<br />
Note that on Tru64 Unix the format character <tt>i</tt> can be used instead
of <tt>d</tt>.
</p>

<br/><br/>

<!-- example -->

<pre>
(format "&gt;&gt;&gt;%6.2f&lt;&lt;&lt;" 1.2345)     <span class='arw'>&rarr;</span> "&gt;&gt;&gt;  1.23&lt;&lt;&lt;"
(format "&gt;&gt;&gt;%-6.2f&lt;&lt;&lt;" 1.2345)    <span class='arw'>&rarr;</span> "&gt;&gt;&gt;1.23  &lt;&lt;&lt;"
(format "&gt;&gt;&gt;%+6.2f&lt;&lt;&lt;" 1.2345)    <span class='arw'>&rarr;</span> "&gt;&gt;&gt; +1.23&lt;&lt;&lt;"
(format "&gt;&gt;&gt;%+6.2f&lt;&lt;&lt;" -1.2345)   <span class='arw'>&rarr;</span> "&gt;&gt;&gt; -1.23&lt;&lt;&lt;"
(format "&gt;&gt;&gt;%-+6.2f&lt;&lt;&lt;" -1.2345)  <span class='arw'>&rarr;</span> "&gt;&gt;&gt;-1.23 &lt;&lt;&lt;"

(format "%e" 123456789)        <span class='arw'>&rarr;</span> "1.234568e+08"
(format "%12.10E" 123456789)   <span class='arw'>&rarr;</span> "1.2345678900E+08"

(format "%10g" 1.23)   <span class='arw'>&rarr;</span> "      1.23"
(format "%10g" 1.234)  <span class='arw'>&rarr;</span> "     1.234"

(format "Result = %05d" 2)  <span class='arw'>&rarr;</span> "Result = 00002"

(format "%14.2f" 12345678.12)   <span class='arw'>&rarr;</span> "   12345678.12"
; on UNIX glibc compatible platforms only (Linux, macOS 10.9) on some locales
(format "%'14.2f" 12345678.12) <span class='arw'>&rarr;</span> " 12,345,678.12"

(format "%8d" 12345)   <span class='arw'>&rarr;</span> "   12345"
; on UNIX glibc compatible platforms only (Linux, macOS 10.9) on some locales
(format "%'8d" 12345)  <span class='arw'>&rarr;</span> "  12,345"

(format "%-15s" "hello")        <span class='arw'>&rarr;</span> "hello          "
(format "%15s %d" "hello" 123)  <span class='arw'>&rarr;</span> "          hello 123"
(format "%5.2s" "hello")        <span class='arw'>&rarr;</span> "   he"
(format "%-5.2s" "hello")       <span class='arw'>&rarr;</span> "he   "

(format "%o" 80)    <span class='arw'>&rarr;</span> "120"
                                
(format "%x %X" -1 -1)  <span class='arw'>&rarr;</span> "ffffffff FFFFFFFF"

; 64 bit numbers on Windows
(format "%I64X" 123456789012345678)  <span class='arw'>&rarr;</span> "1B69B4BA630F34E"

; 64 bit numbers on Unix (except TRU64)
(format "%llX" 123456789012345678)   <span class='arw'>&rarr;</span> "1B69B4BA630F34E"
                                
(format "%c" 65)  <span class='arw'>&rarr;</span> "A"
</pre>


<p>整形するデータは、リストでも渡せます：<br />
	The data to be formatted 
	can be passed inside a list:
</p>


<pre>
(set 'L '("hello" 123))
(format "%15s %d" L)  <span class='arw'>&rarr;</span> "          hello 123"
</pre>


<p>newLISP の <tt>format</tt> は、フォーマット文字列が要求すれば、自動的に浮動小数点から整数、または、整数から浮動小数点への変換を行います：<br />
	If the format string requires it, 
	newLISP's <tt>format</tt> will 
	automatically convert integers 
	into floating points 
	or floating points into integers:
</p>


<pre>
(format "%f" 123)      <span class='arw'>&rarr;</span> 123.000000
                       
(format "%d" 123.456)  <span class='arw'>&rarr;</span> 123
</pre>

<br/><br/>

<a name="fv"></a>
<h2><span class="function">fv</span></h2>
<h4>syntax: (fv <em>num-rate</em> <em>num-nper</em> <em>num-pmt</em> <em>num-pv</em> [<em>int-type</em>])</h4>

<p>開始の元金 <em>num-pv</em> を固定支払い金額 <em>num-pmt</em> と固定利率 <em>num-rate</em> で <em>num-nper</em> 回支払った後のローン残高を計算します。支払いが期間の終わりなら <em>int-type</em> を <tt>0</tt>（ゼロ）にするか省略し、支払いが期間の始めなら <em>int-type</em> を 1 にします（訳注：期間の終わりなら残金に固定利率がかかった後での支払い、逆に期間の始めなら支払った後の残金に固定利率がかかる）。<br />
Calculates the future value of a loan with constant payment <em>num-pmt</em> 
and constant interest rate <em>num-rate</em> after <em>num-nper</em> period of 
time and a beginning principal value of <em>num-pv</em>.  If payment is at the 
end of the period, <em>int-type</em> is <tt>0</tt> (zero) or <em>int-type</em> is
omitted; for payment at the beginning of each period, <em>int-type</em> is 1. 
</p>

<!-- example -->

<pre>
(fv (div 0.07 12) 240 775.30 -100000)  <span class='arw'>&rarr;</span> -0.5544645052
</pre>


<p>例では、100,000 ドルのローンが年率7％で240月後に支払いが終了し、0.55ドル余ることを示しています。（訳注：毎月775.3ドルの支払った場合の計算。ちなみに、<em>int-type</em> が 1 なら、237月後に支払い終了で、3.28ドルの余りです。返済はお早めに！）<br />
The example illustrates how a loan of $100,000 is paid down to a residual 
of $0.55 after 240 monthly payments at a yearly interest rate of 7 percent.
</p>

<p>関数 <a href="#irr">irr</a>、<a href="#nper">nper</a>、<a href="#npv">npv</a>、<a href="#pmt">pmt</a>、<a href="#pv">pv</a> も見てください。<br />
	See also the functions <a href="#irr">irr</a>, 
	<a href="#nper">nper</a>, <a href="#npv">npv</a>, 
	<a href="#pmt">pmt</a>, and <a href="#pv">pv</a>.
</p>

<br/><br/>

<a name="gammai"></a>
<h2><span class="function">gammai</span></h2>
<h4>syntax: (gammai <em>num-a</em> <em>num-b</em>)</h4>

<p><em>num-a</em> と <em>num-b</em> で各々指定される値 <em>a</em> と <em>b</em> の不完全ガンマ関数を計算します。（訳注：<a href="http://ja.wikipedia.org/wiki/%E4%B8%8D%E5%AE%8C%E5%85%A8%E3%82%AC%E3%83%B3%E3%83%9E%E9%96%A2%E6%95%B0">第1種不完全ガンマ関数</a>（<a href="http://en.wikipedia.org/wiki/Incomplete_gamma_function">lower incomplete gamma function</a>）です。）<br />
	Calculates the incomplete Gamma function 
	of values <em>a</em> and <em>b</em> in <em>num-a</em> and <em>num-b</em>,
	respectively.
</p>

<!-- example -->

<pre>
(gammai 4 5)  <span class='arw'>&rarr;</span> 0.7349740847
</pre>


<p>与えられた自由度 df を超えるカイ二乗の確率を得るために不完全ガンマ関数を使うには、次のようにします：<br />
	The incomplete Gamma function is used to derive 
	the probability of Chi&sup2; to exceed a 
	given value for a degree of freedom, df, as follows:
</p>

<BLOCKQUOTE>
<em><b>Q(Chi&sup2;|df) = Q(df/2, Chi&sup2;/2) = gammai(df/2, Chi&sup2;/2)</b></em>
</BLOCKQUOTE>

<p>関数 <a href="#prob-chi2">prob-chi2</a> も見てください。<br />
	See also the <a href="#prob-chi2">prob-chi2</a> function.
</p>

<br/><br/>

<a name="gammaln"></a>
<h2><span class="function">gammaln</span></h2>
<h4>syntax: (gammaln <em>num-x</em>)</h4>

<p><em>num-x</em> の値 <em>x</em> の<a href="http://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%B3%E3%83%9E%E9%96%A2%E6%95%B0">ガンマ関数</a>の対数を計算します。<br />
	Calculates the log Gamma function of the value <em>x</em> in <em>num-x</em>.
</p>

<!-- example -->

<pre>
(exp (gammaln 6))  <span class='arw'>&rarr;</span> 120
</pre>


<p>例では、<em>n! = gamma(n + 1)</em> であることを使って 5 の階乗値を計算しています。<br />
	The example uses the equality of <em>n! = gamma(n + 1)</em> 
	to calculate the factorial value of 5.
</p>

<p>対数ガンマ関数は、そこから導出される<a href="http://ja.wikipedia.org/wiki/%E3%83%99%E3%83%BC%E3%82%BF%E9%96%A2%E6%95%B0">ベータ関数</a>とも関係しています：<br />
	The log Gamma function is also related to the Beta function, 
	which can be derived from it:
</p>

<BLOCKQUOTE>
<em><b>Beta(z,w) = Exp(Gammaln(z) + Gammaln(w) - Gammaln(z+w))</b></em>

</BLOCKQUOTE>

<br/><br/>

<a name="gcd"></a>
<h2><span class="function">gcd</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (gcd <em>int-1</em> [<em>int-2</em> ... ])</h4>

<p>整数のグループの最大公約数を計算します。
両方共ゼロでない二つの整数の最大公約数は、両方の数値を割りきれる最大整数値です。
<tt>gcd</tt> は、 <em>int-i</em> 中の最初の二つの整数値の最大公約数を計算し、その結果の最大公約数とパラメータ・リストの次の引数との最大公約数を計算していきます。<br />
Calculates the greatest common divisor 
of a group of integers.
The greatest common divisor of two integers 
that are not both zero 
is the largest integer that divides both numbers.
<tt>gcd</tt> will calculate the greatest common divisor 
for the first two integers in <em>int-i</em> 
and then further reduce the argument list 
by calculating the greatest common divisor of the result 
and the next argument in the parameter list.
</p>

<!-- example -->

<pre>
(gcd 0)        <span class='arw'>&rarr;</span> 0
(gcd 0 0)      <span class='arw'>&rarr;</span> 0
(gcd 10)       <span class='arw'>&rarr;</span> 10
(gcd 12 36)    <span class='arw'>&rarr;</span> 12
(gcd 15 36 6)  <span class='arw'>&rarr;</span> 3 
</pre>


<p>数学における gcd数の詳細と理論は、<a href="http://en.wikipedia.org/wiki/Greatest_common_divisor">Wikipedia</a>を見てください。（訳注：日本語版は、<a href="http://ja.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%B4%84%E6%95%B0">こちらです。</a>）<br />
See 
<a href="http://en.wikipedia.org/wiki/Greatest_common_divisor">Wikipedia</a>
for details and theory about gcd numbers in mathematics.
</p>

<br/><br/>

<a name="get-char"></a>
<h2><span class="function">get-char</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (get-char <em>int-address</em>)</h4>


<p><em>int-address</em> で指定されたアドレスから 8 ビット文字を取り出します。
この関数は、<a href="#import">import</a> で導入した共有ライブラリ関数を使う時に役立ちます。<br />
Gets an 8-bit character from an address 
specified in <em>int-address</em>. 
This function is useful when using 
imported shared library functions 
with <a href="#import">import</a>.
</p>

<!-- example -->

<pre>
char * foo(void)
{
char * result;
result = "ABCDEFG";
return(result);
}
</pre>


<p>キャラクタのポインタ（文字列のアドレス）を返す共有ライブラリの上記 C 関数で考えてみましょう。<br />
Consider the above C function 
from a shared library, which returns a 
character pointer (address to a string).
</p>


<pre>
(import "mylib.so" "foo")
(print (get-char (foo) ))       <span class='arw'>&rarr;</span>  65 ; ASCII "A"
(print (get-char (+ (foo) 1)))  <span class='arw'>&rarr;</span>  66 ; ASCII "B"
</pre>



<p><em>int-address</em> に間違ったアドレスを指定して、関数 <tt>get-char</tt> を使うことは安全でありませんので注意してください。
そうした場合、結果としてシステムがクラッシュしたり、不安定になったりします。<br />
Note that it is unsafe to use the <tt>get-char</tt> function 
with an incorrect address in <em>int-address</em>. Doing so 
could result in the system crashing or becoming unstable.
</p>

<p>関数<a href="#address">address</a>、<a href="#get-int">get-int</a>、 <a href="#get-long">get-long</a>、<a href="#get-float">get-float</a>、<a href="#get-string">get-string</a>、<a href="#pack">pack</a>、<a href="#unpack">unpack</a> も見てください。<br />
See also the <a href="#address">address</a>, 
<a href="#get-int">get-int</a>, 
<a href="#get-long">get-long</a>, 
<a href="#get-float">get-float</a>, 
<a href="#get-string">get-string</a>, 
<a href="#pack">pack</a>, and <a href="#unpack">unpack</a> functions.
</p>

<br/><br/>

<a name="get-float"></a>
<h2><span class="function">get-float</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (get-float <em>int-address</em>)</h4>

<p><em>int-address</em> で指定されたアドレスから、64ビット倍精度浮動小数点数を取り出します。
この関数は、(<tt>import</tt>を使って) 導入した倍精度浮動小数点数のアドレス・ポインタか、倍精度浮動小数点数を含む構造体のポインタを返す共有ライブラリ関数を使う時の助けになります。<br />
Gets a 64-bit double float from an address 
specified in <em>int-address</em>.
This function is helpful when using 
imported shared library functions (with <tt>import</tt>)
that return an address pointer to a double float 
or a pointer to a structure containing double floats.
</p>

<!-- example -->

<pre>
double float * foo(void)
{
double float * result;
&hellip;
*result = 123.456;
return(result);
}
</pre>


<p>前もって C 関数をコンパイルして、共有ライブラリに置きます。<br />
The previous C function is compiled 
into a shared library.
</p>


<pre>
(import "mylib.so" "foo")
(get-float (foo))  <span class='arw'>&rarr;</span> 123.456
</pre>


<p>	<tt>foo</tt> が導入されて呼び出されると、倍精度浮動小数点数のポインタを返します。
<em>int-address</em>に間違ったアドレスを指定して関数<tt>get-float</tt> を使うことは安全でなく、そうした場合、結果としてシステムがクラッシュしたり、不安定になったりしますので注意してください。<br />
<tt>foo</tt> is imported and returns a pointer 
to a double float when called.
Note that <tt>get-float</tt> is unsafe when used 
with an incorrect address in <em>int-address</em> 
and may result in the system crashing or becoming unstable.
</p>

<p>関数<a href="#address">address</a>、<a href="#get-int">get-int</a>、<a href="#get-long">get-long</a>、<a href="#get-char">get-char</a>、<a href="#get-string">get-string</a>、<a href="#pack">pack</a>、<a href="#unpack">unpack</a> も見てください。<br />
See also the <a href="#address">address</a>, 
<a href="#get-int">get-int</a>, 
<a href="#get-long">get-long</a>,
<a href="#get-char">get-char</a>, 
<a href="#get-string">get-string</a>,
<a href="#pack">pack</a>, 
and <a href="#unpack">unpack</a> functions.
</p>

<br/><br/>

<a name="get-int"></a>
<h2><span class="function">get-int</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (get-int <em>int-address</em>)</h4>

<p><em>int-address</em> で指定されたアドレスから 32ビット整数値を取り出します。
この関数は、整数値のアドレス・ポインタか整数値を含む構造体のポインタを返す、<tt>import</tt> で導入した共有ライブラリ関数を使う時に便利です。<br />
Gets a 32-bit integer from 
the address specified in <em>int-address</em>.
This function is handy when using 
imported shared library functions with <tt>import</tt>,
a function returning an address pointer 
to an integer, or a pointer to a structure containing integers.
</p>

<!-- example -->

<pre>
int * foo(void)
{
int * result;
&hellip;
*result = 123;
return(result);
}

int foo-b(void)
{
int result;
&hellip;
result = 456;
return(result);
}
</pre>


<p>整数ポインタ（整数のアドレス）を返す（共有ライブラリからの） C 関数 <tt>foo</tt> で考えてみましょう。<br />
Consider the C function <tt>foo</tt> (from a shared library), 
which returns an integer pointer (address of an integer).
</p>


<pre>
(import "mylib.so" "foo")
(get-int (foo))  <span class='arw'>&rarr;</span> 123
(foo-b)          <span class='arw'>&rarr;</span> 456
</pre>


<p><em>int-address</em> に間違ったアドレスを指定して <tt>get-int</tt> を使うことは、安全でなく、結果としてシステムがクラッシュしたり、不安定になったりしますので、注意してください。<br />
Note that using <tt>get-int</tt> with an incorrect address 
in <em>int-address</em> is unsafe and could result 
in the system crashing or becoming unstable.
</p>

<p>関数<a href="#address">address</a>、<a href="#get-char">get-char</a>、<a href="#get-float">get-float</a>、<a href="#get-long">get-long</a>、<a href="#get-string">get-string</a>、<a href="#pack">pack</a>、<a href="#unpack">unpack</a> も見てください。<br />
See also the <a href="#address">address</a>, 
<a href="#get-char">get-char</a>, 
<a href="#get-float">get-float</a>, 
<a href="#get-long">get-long</a>,
<a href="#get-string">get-string</a>,
<a href="#pack">pack</a>, 
and <a href="#unpack">unpack</a> functions.
</p>

<br/><br/>

<a name="get-long"></a>
<h2><span class="function">get-long</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (get-long <em>int-address</em>)</h4>

<p><em>int-address</em> で指定されたアドレスから 64 ビット整数値を取り出します。
この関数は、整数値のアドレス・ポインタか整数値を含む構造体のポインタを返す、<tt>import</tt> で導入した共有ライブラリ関数を使う時に便利です。<br />
Gets a 64-bit integer from 
the address specified in <em>int-address</em>.
This function is handy when using <tt>import</tt>
to import shared library functions, 
a function returning an address pointer to a long integer, 
or a pointer to a structure containing long integers.
</p>

<!-- example -->

<pre>
long long int * foo(void)
{
int * result;
&hellip;
*result = 123;
return(result);
}

long long int foo-b(void)
{
int result;
&hellip;
result = 456;
return(result);
}
</pre>


<p>整数ポインタ（整数のアドレス）を返す（共有ライブラリの）C 関数 <tt>foo</tt> で考えてみます。<br />
Consider the C function <tt>foo</tt> (from a shared library), 
which returns an integer pointer (address of an integer).
</p>


<pre>
(import "mylib.so" "foo")
(get-int (foo))  <span class='arw'>&rarr;</span> 123
(foo-b)          <span class='arw'>&rarr;</span> 456
</pre>


<p><em>int-address</em> に間違ったアドレスを指定して <tt>get-long</tt> を使うことは安全でなく、結果としてシステムがクラッシュしたり、不安定になったりしますので、注意してください。<br />
Note that using <tt>get-long</tt> with an incorrect address 
in <em>int-address</em> is unsafe and could result 
in the system crashing or becoming unstable.
</p>

<p>関数<a href="#address">address</a>、<a href="#get-char">get-char</a>、<a href="#get-float">get-float</a>、<a href="#get-int">get-int</a>、<a href="#get-string">get-string</a>、<a href="#pack">pack</a>、<a href="#unpack">unpack</a> も見てください。<br />
See also the <a href="#address">address</a>, 
<a href="#get-char">get-char</a>, 
<a href="#get-float">get-float</a>, 
<a href="#get-int">get-int</a>,
<a href="#get-string">get-string</a>,
<a href="#pack">pack</a>, 
and <a href="#unpack">unpack</a> functions.
</p>

<br/><br/>

<a name="get-string"></a>
<h2><span class="function">get-string</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (get-string <em>int-address</em> [<em>int-bytes</em> [<em>str-limit</em>])</h4>


<p><em>int-address</em> で指定されたアドレスから文字列を取り出します。
この関数は、<a href="#import">import</a>で導入した共有ライブラリ関数を使う時の助けになります。<br />
Gets a character string from the address 
specified in <em>int-address</em>.
This function is helpful when 
using imported shared library functions 
with <a href="#import">import</a>.
</p>

<!-- example -->

<pre>
char * foo(void)
{
char * result;
result = "ABCDEFG";
return(result);
}
</pre>


<p>文字ポインタ（文字列のアドレス）を返す共有ライブラリの上記 C 関数で考えてみます。<br />
Consider the above C function from a shared library, 
which returns a character pointer (address to a string).
</p>


<pre>
(import "mylib.so" "foo")
(print (get-string (foo)))  <span class='arw'>&rarr;</span> "ABCDEFG"
</pre>


<p>引数に文字列が渡されると、<tt>get-string</tt> はその引数のアドレスを取ります。
<tt>get-string</tt> は、最初に <tt>\000</tt> (null文字) と会った時、常に終了するので、バッファから文字列を取り出すのに使われます：<br />
When a string is passed as an argument, 
<tt>get-string</tt> will take its address as the argument. 
Because <tt>get-string</tt> always breaks off 
at the first first <tt>\000</tt> (null character) it encounters, 
it can be used to retrieve a string from a buffer:
</p>

<!-- example -->

<pre>
(set 'buff "ABC\000\000\000DEF")  <span class='arw'>&rarr;</span> "ABC\000\000\000DEF"

(length buff)  <span class='arw'>&rarr;</span> 9

(get-string buff)  <span class='arw'>&rarr;</span> "ABC"

(length (get-string buff))  <span class='arw'>&rarr;</span> 3

; get a string from offset into a buffer
(get-string (+ (address buff) 6)) <span class='arw'>&rarr;</span> "DEF"

; use unpack to get the whole buffer
(unpack "s9" buff)  <span class='arw'>&rarr;</span> ("ABC\000\000\000DEF")
</pre>

<p>関数<a href="#get-char">get-char</a>、<a href="#get-int">get-int</a>、<a href="#get-float">get-float</a>、<a href="#pack">pack</a>、<a href="#unpack">unpack</a> も見てください。<br />
See also the <a href="#get-char">get-char</a>, 
<a href="#get-int">get-int</a>,
<a href="#get-float">get-float</a>,
<a href="#pack">pack</a>,
and <a href="#unpack">unpack</a> functions.
</p>

<p><tt>get-string</tt> は、間違ったアドレスを指定されるとシステムがクラッシュしたり、不安定になったりしますので、注意してください。<br />
Note that <tt>get-string</tt> can crash the system 
or make it unstable if the wrong address is specified.
</p>

<br/><br/>

<a name="get-url"></a>
<h2><span class="function">get-url</span></h2>
<h4>syntax: (get-url <em>str-url</em> [<em>str-option</em>] [<em>int-timeout</em> [<em>str-header</em>]])</h4>

<p><em>str-url</em> の URL で指定されたウェブ・ページかファイルを、HTTP プロトコルを使って読み込みます。
<tt>http://</tt> と <tt>file://</tt> のどちらの URL も処理されます。
<tt>"header"</tt> は、ヘッダーだけを取り出すために <em>str-option</em> の引数オプションを指定可能です。
<tt>"list"</tt> オプションは、ヘッダーとページ情報を分離して文字列リストにして返し、リストの第三項目にはサーバー・ステータス・コードも含まれています（10.6.4 以降）。
オプション <tt>"raw"</tt>（10.6.4 以降）は、単独でも他のオプションと一緒にでも使用でき、ヘッダー・ロケーション・リダイレクトを抑制します。<br />
Reads a web page or file specified by the URL in <em>str-url</em> using 
the HTTP GET protocol.  Both <tt>http://</tt> and <tt>file://</tt>
URLs are handled.  <tt>"header"</tt> can be specified in the optional argument 
<em>str-option</em> to retrieve only the header.  The  option <tt>"list"</tt> 
causes header and page information to be returned as separate strings in a list
and also includes the server status code as the third list member (since 10.6.4).
The <tt>"raw"</tt> option (since 10.6.4), which can be used alone or combined
with other options, suppresses header location redirection.</p>

<p><tt>"debug"</tt>オプションは、単独あるいは <tt>"header"</tt> か <tt>"list"</tt> の後に一文字開けて指定します。
例えば、<tt>"header debug"</tt> か <tt>"list debug"</tt> という具合です。
"debug" を含めると、全ての送信情報がコンソール・ウィンドウに出力されます。<br />
A <tt>"debug"</tt> option can be specified either alone or after the
<tt>"header"</tt> or <tt>"list"</tt> option separated by one character, 
i.e. <tt>"header debug"</tt> or <tt>"list debug"</tt>. Including "debug" 
outputs all outgoing information to the console window.</p>

<p>引数オプション <em>int-timeout</em> にはミリ秒値を指定できます。
指定時間までにホストからデータを取得できない場合、<tt>get-url</tt> は文字列 <tt>ERR: timeout</tt> を返します。
他のエラーが発生した時、<tt>get-url</tt> は <tt>ERR:</tt> で始まる文字列とエラーの説明を返します。<br />
The optional argument <em>int-timeout</em> can specify a value in milliseconds.
If no data is available from the host after the specified timeout, <tt>get-url</tt> 
returns the string <tt>ERR: timeout</tt>. When other error conditions occur, 
<tt>get-url</tt> returns a string starting with <tt>ERR:</tt> and the description 
of the error.</p>

<p>
<tt>get-url</tt> が受信したヘッダーに <tt>Location:</tt> 指定子を検出したなら、リダイレクトを処理し、自動的に第二<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>します。
<tt>get-url</tt> は <tt>Transfer-Encoding: chunked</tt> フォーマットも理解し、データの<ruby>厚切り<rp>（</rp><rt>chunked</rt><rp>）</rp></ruby>フォーマットをアンパックします。（訳注：<tt>Transfer-Encoding: chunked</tt> については、<a href="http://www.cresc.co.jp/tech/java/Servlet_Tutorial/Att_01.htm">こちらを参照</a>）<br />
<tt>get-url</tt> handles redirection if it detects a <tt>Location:</tt> spec 
in the received header and automatically does a second request.
<tt>get-url</tt> also understands the <tt>Transfer-Encoding: chunked</tt> 
format and will unpack data into an unchunked format.</p>

<p>newLISP サーバーも <tt>get-url</tt> の<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を受け付けます。<br />
<tt>get-url</tt> requests are also understood by newLISP server nodes.
</p>

<!-- example -->

<pre>
(get-url "http://www.nuevatec.com")
(get-url "http://www.nuevatec.com" 3000)
(get-url "http://www.nuevatec.com" "header")
(get-url "http://www.nuevatec.com" "header" 5000)
(get-url "http://www.nuevatec.com" "list")

(get-url "file:///home/db/data.txt") ; access local file system

(env "HTTP_PROXY" "http://ourproxy:8080")
(get-url "http://www.nuevatec.com/newlisp/")
</pre>


<p><em>str-url</em> で指定されたサイトの表示ページは、文字列で返されます。
三行目は、HTTPヘッダーのみが文字列で返されます。
二行目と四行目では、タイム・アウト値が使われています。<br />
The index page from the site specified 
in <em>str-url</em> is returned as a string.
In the third line, 
only the HTTP header 
is returned in a string. 
Lines 2 and 4 show a 
timeout value being used.
</p>

<p>二番目の例は、ローカル・ファイル・システムの <tt>/home/db/data.txt</tt> をアクセスするために <tt>file://</tt> URL を使う方法を示しています。<br />
 The second example shows usage of a <tt>file://</tt> URL
to access <tt>/home/db/data.txt</tt> on the local file system.</p>

<p>三番目の例は、プロキシ・サーバーの使用例です。
プロキシ・サーバーの URL は、オペレーティング・システム環境変数内になければなりません。
そうするためには、例が示すように関数 <a href="#env">env</a> を使って追加できます。<br />
The third example illustrates 
the use of a proxy server. 
The proxy server's URL must be 
in the operating system's environment. 
As shown in the example, 
this can be added using 
the <a href="#env">env</a> 
function.
</p>

<p><em>int-timeout</em> には、<em>str-header</em> オプションのカスタム・ヘッダーを続けることができます。<br />
The <em>int-timeout</em> can be followed 
by an optional custom header in <em>str-header</em>:
</p>

<h3>Custom header（カスタム・ヘッダー）</h3>
 
<p>カスタム・ヘッダーには、ブラウザ・クッキーや他のサーバーへ指示がオプションとして入ります。
<em>str-header</em> が指定されない時、newLISP はデフォルトでヘッダー情報を送信します。
次の<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>の後に：<br />
The custom header may contain options 
for browser cookies or other directives to the server. 
When no <em>str-header</em> is specified, 
newLISP sends certain header information by default. 
After the following request:
</p>


<pre>
(get-url "http://somehost.com" 5000)
</pre>


<p>newLISP は、以下の<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>とヘッダーを構成して送ります：<br />
newLISP will configure and send 
the request and header below:
</p>


<pre>
GET / HTTP/1.1        
Host: somehost.com
User-Agent: newLISP v10603
Connection: close
</pre>


<p>他の選択肢として、<em>str-header</em> オプションを使えます：<br />
As an alternative, the <em>str-header</em> 
option could be used:
</p>


<pre>
(get-url "http://somehost.com" 5000 
"User-Agent: Mozilla/4.0\r\nCookie: name=fred\r\n")
</pre>


<p>これにより、newLISP は次の<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>とヘッダーを送信します：<br />
newLISP will now send the 
following request and header:
</p>


<pre>
GET / HTTP/1.1        
Host: somehost.com
User-Agent: Mozilla/4.o
Cookie: name=fred
Connection: close
</pre>


<p>カスタム・ヘッダーを使った時の newLISP は、<tt>Host:</tt> と <tt>Connection:</tt> のヘッダー・エントリーと共に <tt>GET</tt> <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>のみを提供することに注意してください。
newLISP は、<tt>Host:</tt> と <tt>Connection:</tt> エントリーの間にカスタム・ヘッダーで指定された他のエントリーを挿入します。
各エントリーは、改行・復帰ペア： <tt>\r\n</tt> で終わる必要があります。<br />
Note that when using a custom header, 
newLISP will only supply the <tt>GET</tt> request line, 
as well as the <tt>Host:</tt> and <tt>Connection:</tt> header entries. 
newLISP inserts all other entries supplied in the custom header 
between the <tt>Host:</tt> and <tt>Connection:</tt> entries. 
Each entry must end with a carriage return 
line-feed pair: <tt>\r\n</tt>.

</p>

<p>有効なヘッダー・エントリーは、HTTP 処理のリファレンスを見てください。<br />
See an HTTP transactions reference 
for valid header entries.
</p>

<p>カスタム・ヘッダーは、関数<a href="#put-url">put-url</a> や <a href="#post-url">post-url</a> でも使えます。<br />
Custom headers can also be used 
in the <a href="#put-url">put-url</a> 
and <a href="#post-url">post-url</a> functions.
</p>

<br/><br/>

<a name="global"></a>
<h2><span class="function">global</span></h2>

<h4>syntax: (global <em>sym-1</em> [<em>sym-2</em> ... ])</h4>

<p><em>sym-1</em> [<em>sym-2</em> ... ] の一つ以上のシンボルが MAIN とは別のコンテキストで普通にアクセスできるようにします。
この宣言文は、MAIN コンテキスト上で実行されなければなりません。
それに、MAIN に所属しているシンボルのみが global 化されます。
<tt>global</tt> は、最後に global 化されたシンボルを返します。<br />
One or more symbols in <em>sym-1</em> [<em>sym-2</em> ... ] 
can be made globally accessible from contexts other than MAIN. 
The statement has to be executed in the MAIN context, 
and only symbols belonging to MAIN can be made global. 
<tt>global</tt> returns the last symbol made global.
</p>

<!-- example -->

<pre>
(global 'aVar 'x 'y 'z)  <span class='arw'>&rarr;</span> z

(define (foo x) 
(&hellip;))

(constant (global 'foo))
</pre>


<p>二番目の例は、先に定義した関数を global 化して保護するために、一つの宣言文で <a href="#constant">constant</a> と <tt>global</tt> を使う方法を示しています。<br />
The second example shows how <a href="#constant">constant</a> 
and <tt>global</tt> can be combined into one statement, 
protecting and making a previous function definition global.
</p>

<br/><br/>

<a name="globalp"></a>
<h2><span class="function">global?</span></h2>

<h4>syntax: (global? <em>sym</em>)</h4>

<p><em>sym</em> が global かどうかをチェックします。
組込関数群、コンテキスト・シンボル群、<a href="#global">global</a> を使って global 化されたシンボル群が global です：<br />
Checks if symbol in <em>sym</em> is global. Built-in functions, context
 symbols, and all symbols made global using the function <a href="#global">global</a>
are global:</p>

<!-- example -->

<pre>
global? 'print)   <span class='arw'>&rarr;</span> true
(global 'var)     <span class='arw'>&rarr;</span> var
(global? 'var)    <span class='arw'>&rarr;</span> true

(constant (global 'foo))

(global? 'foo)    <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="history"></a>
<h2><span class="function">history</span></h2>

<h4>syntax: (history [<em>bool-params</em>])</h4>

<p><em>history</em> は、内包している関数の呼び出し履歴のリストを返します。
オプションの <em>bool-params</em> がなければ、関数シンボルのリストが返されます。
最初のシンボルは、内包している関数名です。オプションの <em>bool-params</em> が  <em>true</em> に評価されると、呼び出し引数がシンボルに含まれます。<br />
<em>history</em> returns a list of the call history of the enclosing function.
Without the optional <em>bool-params</em>, a list of function symbols is returned.
The first symbol is the name of the enclosing function. When the optional 
<em>bool-params</em> evaluates to <em>true</em>, the call arguments are included 
with the symbol.</p>
<br/><br/>

<pre>
(define (foo x y) 
    (bar (+ x 1) (* y 2)))

(define (bar a b) 
    (history))

; history returns names of calling functions
(foo 1 2) <span class='arw'>&rarr;</span> (bar foo)

; the addtional 'true' forces inclusion of callpatterns
(define (bar a b) 
    (history true))

(foo 1 2) <span class='arw'>&rarr;</span> ((bar (+ x 1) (* y 2)) (foo 1 2))
</pre>

<br/><br/>

<a name="if"></a>
<h2><span class="function">if</span></h2>

<h4>syntax: (if <em>exp-condition</em> <em>exp-1</em> [<em>exp-2</em>])<br/>

syntax: (if <em>exp-cond-1</em> <em>exp-1</em>  <em>exp-cond-2</em> <em>exp-2</em> [ ... ])</h4>

<p><em>exp-condition</em> の値が <tt>nil</tt> か空リストでないなら <em>exp-1</em> の評価結果が返ります
その逆では <em>exp-2</em> の値が返ります。
その時、<em>exp-2</em> がない場合は <em>exp-condition</em>（訳注：つまり <tt>nil</tt> か空リスト）が返ります。<br />
If the value of <em>exp-condition</em> is neither <tt>nil</tt> nor an empty list, 
the result of evaluating <em>exp-1</em> is returned; otherwise, the value of 
<em>exp-2</em> is returned.  If <em>exp-2</em> is absent, the value of 
<em>exp-condition</em> is returned.</p>

<p>同時に <tt>if</tt> は、アナフォリック・システム変数 <tt>$it</tt> に <tt>if</tt> の条件式の値をセットします。<br />
<tt>if</tt> also sets the anaphoric system variable <tt>$it</tt> to the value
of the conditional expression in <tt>if</tt>.</p>

<!-- example -->

<pre>
(set 'x 50)                   <span class='arw'>&rarr;</span> 50
(if (&lt; x 100) "small" "big")  <span class='arw'>&rarr;</span> "small"
(set 'x 1000)                 <span class='arw'>&rarr;</span> 1000
(if (&lt; x 100) "small" "big")  <span class='arw'>&rarr;</span> "big"
(if (&gt; x 2000) "big")         <span class='arw'>&rarr;</span> nil

; more than one statement in the true or false
; part must be blocked with (begin ...)
(if (= x y)
  (begin
    (some-func x)
    (some-func y))
  (begin
    (do-this x y)
    (do-that x y))
)

; if also sets the anaphoric system variable $it
(set 'lst '(A B C))
(if lst (println (last $it)))  <span class='arw'>&rarr;</span> C
</pre>


<p><tt>if</tt> の第二形式では、条件-本体ペアの式群を括弧で囲むことなしに、<a href="#cond">cond</a> のように動作します。
この形式の <tt>if</tt> は引数を無制限に持つことができます。<br />
The second form of <tt>if</tt> works similarly 
to <a href="#cond">cond</a>, except it does not take 
parentheses around the condition-body pair of expressions. 
In this form, <tt>if</tt> can have 
an unlimited number of arguments.
</p>

<!-- example -->

<pre>
(define (classify x)
(if
(&lt; x 0) "negative"
(&lt; x 10) "small"
(&lt; x 20) "medium"
(&gt;= x 30) "big"
"n/a"))

(classify 15)   <span class='arw'>&rarr;</span> "medium"
(classify 100)  <span class='arw'>&rarr;</span> "big"
(classify 22)   <span class='arw'>&rarr;</span> "n/a"
(classify -10)  <span class='arw'>&rarr;</span> "negative"
</pre>


<p>最後の式 <tt>"n/a"</tt> は、オプションです。
このオプション式が無い時は、式<tt>(&gt;= x 30)</tt> の評価が返ります。
この振る舞いは伝統的な <a href="#cond">cond</a> と厳密に同じですが、条件-式ペアの括弧は必要ありません。<br />
The last expression, <tt>"n/a"</tt>, is optional. When this option 
is omitted, the evaluation of <tt>(&gt;= x 30)</tt> is returned, behaving 
exactly like a traditional <a href="#cond">cond</a> but without requiring 
parentheses around the condition-expression pairs.</p>

<p>いずれにせよ、完全な <tt>if</tt> 式は、常に最後に評価された式か条件を返します。<br />
In any case, the whole <tt>if</tt> expression 
always returns the last expression or condition evaluated.</p>

<p>関数 <a href="#when">when</a> と <a href="#unless">unless</a> も見てください。<br />
See also the <a href="#when">when</a> and <a href="#unless">unless</a> functions.
</p>

<br/><br/>

<!--
<a name="if-not"></a>
<h2><span class="function">if-not</span></h2>
<h4>syntax: (if-not <em>exp-condition</em> <em>exp-1</em> [<em>exp-2</em>])</h4>

<p>
<tt>if-not</tt> は、
(<a href="#if">if</a> (<a href="#not">not</a> <em>exp-condition</em> <em>exp-1</em> [<em>exp-2</em>])) 
のように評価されます。
<em>exp-condition</em> の値が、<tt>nil</tt> か空リストなら、
<em>exp-1</em> が評価され、その逆なら、
オプションの <em>exp-2</em> が評価されます。

<br/>
<tt>if-not</tt> is equivalent to (<a href="#if">if</a> (<a href="#not">not</a> 
<em>exp-condition</em> <em>exp-1</em> [<em>exp-2</em>])).
If the value of <em>exp-condition</em> is <tt>nil</tt> 
or the empty list <tt>()</tt>, <em>exp-1</em> is evaluated;
otherwise, the optional <em>exp-2</em> is evaluated.
</p>	

<p>関数 <a href="#if">if</a> に対して、<tt>if-not</tt> では複数の結果や代替条項は許されません（訳注：<a href="#if">if</a> のような第二形式が無いということ）。<br />
Contrary to the <a href="#if">if</a> function, <tt>if-not</tt> does
not permit multiple consequent and alternative clauses.</p>

<pre>
(set 'x 50)                       <span class='arw'>&rarr;</span> 50 
(if-not (&lt; x 100) "big" "small")  <span class='arw'>&rarr;</span> "small"
(set 'x 1000)                     <span class='arw'>&rarr;</span> 1000 
(if-not (&lt; x 100) "big" "small")  <span class='arw'>&rarr;</span> "big" 
</pre>

<br/><br/>
-->

<a name="ifft"></a>
<h2><span class="function">ifft</span></h2>
<h4>syntax: (ifft <em>list-num</em>)</h4>

<p>FFT 法(高速フーリエ変換）を使って、複素数リスト <em>list-num</em> の離散的逆フーリエ変換を計算します。
各複素数は、実数部とそれに続く虚数部で指定されます。
実数部のみ使う場合は、虚数部に <tt>0.0</tt>（ゼロ）をセットします。
<em>list-num</em> の要素数が 2 のべき乗でない場合、<tt>ifft</tt> はリストをゼロで埋めて要素数を増やします。
複素数の虚数部が <tt>0</tt> の時は、単なる数値が使えます。<br />
Calculates the inverse discrete Fourier transform 
on a list of complex numbers in <em>list-num</em> 
using the FFT method (Fast Fourier Transform). 
Each complex number is specified by its real part, 
followed by its imaginary part. 
In case only real numbers are used, 
the imaginary part is set to <tt>0.0</tt> (zero). 
When the number of elements in <em>list-num</em> 
is not an integer power of 2, 
<tt>ifft</tt> increases the number of elements 
by padding the list with zeroes. 
When complex numbers are <tt>0</tt> in the imaginary part, 
simple numbers can be used.
</p>

<!-- example -->

<pre>
(ifft (fft '((1 0) (2 0) (3 0) (4 0)))) 
<span class='arw'>&rarr;</span> ((1 0) (2 0) (3 0) (4 0))

;; when imaginary part is 0, plain numbers work too

(ifft (fft '(1 2 3 4))) 
<span class='arw'>&rarr;</span> ((1 0) (2 0) (3 0) (4 0))
</pre>


<p><tt>ifft</tt> の逆操作は、関数 <a href="#fft">fft</a> です。<br />
The inverse operation of <tt>ifft</tt> 
is the <a href="#fft">fft</a> function.
</p>

<br/><br/>

<a name="import"></a>
<h2><span class="function">import</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2>
<h4>syntax: (import <em>str-lib-name</em> <em>str-function-name</em> ["cdecl"])<br/>
syntax: (import <em>str-lib-name</em> <em>str-function-name</em> <em>str-return-type</em> [<em>str-param-type</em> . . .])<br/>
syntax: (import <em>str-lib-name</em>)</h4>

<p><em>str-lib-name</em> の名前の共有ライブラリから <em>str-function-name</em> で指定された関数を導入します。
構文の使い方によっては、戻り値の文字列ラベルやパラメータ型を指定できます。<br />
Imports the function specified in <em>str-function-name</em> 
from a shared library named in <em>str-lib-name</em>. Depending on the syntax used, string 
labels for return and parameter types can be specified</p>

<p><em>str-lib-name</em> のライブラリがシステムのライブラリ・パスに無いなら、フル・パスを指定する必要があります。<br />
If the library in <em>str-lib-name</em> is not in the system's library path, the
full path name should be specified.</p>

<p>関数は一度だけで導入されます。同じ関数を繰り返して導入しても、ただ同じ関数の――すでに割り当てられた――アドレスが返るだけです。<br />
A function can be imported only once. A repeated import of the same function
will simply return the same - already allocated - function address.</p>

<p><em>libffi</em> が可能なバージョン――第二拡張構文が使える版――では、導入されたシンボルは変更から保護され、<a href="#constant">constant</a> による変更のみ許されます。<br />
On <em>libffi</em> enabled versions - capable of the second extended syntax -
imported symbols are protected against change and can only be modified using
<a href="#constant">constant</a>.</p>

<p>第三構文―― OSX、Linux、他の Unix 上でのみ――は導入関数を指定せずにライブラリを予め読み込みます。これは、他の導入ライブラリが内部的に必要とする関数へアクセスする時に必要です。<br />
The third syntax - on OSX, Linux and other Unix only -  allows pre-loading libraries
without importing functions. This is necessary when other library imports need access 
internally to other functions from pre-loaded libraries.</p>

<p><tt>import</tt> は正しく使わないと、システム・バス・エラーを引き起こし、newLISP をクラッシュさせるか、不安定な状態にします。<br />
Incorrectly using <tt>import</tt> can cause a system bus error or a segfault can occur 
and crash newLISP or leave it in an unstable state.</p>

<h3>The simple <tt>import</tt> syntax（単純 <tt>import</tt> 構文）</h3>
<p>ほとんどのライブラリ関数は単純な第一構文を使って導入できます。
この形式は<u>全ての</u> newLISP コンパイル派生品に有ります。
API は関数の引数全てを <em>cdecl</em> や <em>stdcall</em> 規則のスタックで渡されるものと期待しています。
32 ビットのプラットフォームでは、整数、文字列のポインタ、浮動小数点数値のバッファをパラメータとして渡すことができます。
64 ビットのプラットフォームでは、整数のみを渡すことができ、浮動小数点数値は渡すことができません。
戻り値としては、32 ビット値 か 64 ビット値とポインタのみが許されます。
浮動小数点数を戻すことはできません。
文字列は、<a href="#get-string">get-string</a> 補助関数を使って取り出す必要があります。
このような制限がありますが、配布中に含まれるほとんどのモジュールは、この単純 <tt>import</tt> API を使っています。<br />
Most library functions can be imported using the simpler first syntax. 
This form is present on <u>all</u> compile flavors of newLISP. The API expects
all function arguments to be passed on the stack in either <em>cdecl</em> or <em>stdcall</em> 
conventions. On 32-bit platforms, integers, pointers to strings and buffers sometimes floating 
point values can be passed as parameters. On 64-bit platforms only 
integers  can be passed but no floating point values. 
As return values only 32-bit or 64-bit values and pointers are allowed. 
No floating point numbers can be returned. Strings must be retrieved with the
<a href="#get-string">get-string</a> helper function. Regardless of these 
limitations, most  modules included in the distribution use 
this simple import API.</p>

<p>ポインタが文字列や構造体を指すなら、次の補助関数がデータの取り出しに使えます：<a href="#get-char">get-char</a>、<a href="#get-int">get-int</a>、<a href="#get-float">get-float</a>、<a href="#get-string">get-string</a>、<a href="#pack">pack</a>、<a href="#unpack">unpack</a><br />
If pointers are returned to strings or structures the following helper functions
can be used extract data:
<a href="#get-char">get-char</a>, 
<a href="#get-int">get-int</a>, 
<a href="#get-float">get-float</a>, 
<a href="#get-string">get-string</a>, 
<a href="#unpack">unpack</a> </p>

<p>構造体データのポインタを渡すためには、次の関数がデータのパックやアドレス計算の助けとなります：<a href="#address">address</a>、<a href="#pack">pack</a>。<br />
To pass pointers for data structures the following functions help to pack data
and calculate addresses:
<a href="#address">address</a>, 
<a href="#pack">pack</a>.</p>

<p>newLISP のデータ型を導入した関数で必要なデータ型に変換するには、64 ビット浮動小数点数には <a href="#float">float</a> を、32 ビット浮動小数点数には <a href="#flt">flt</a> を、32 ビット整数には <a href="#int">int</a> を使います。
デフォルトでは、newLISP 浮動小数点数には 64 ビット浮動小数点数を、整数には 32 ビット整数を、文字列には文字列アドレス（C 言語のポインタ）の 32 ビット整数を渡します。
浮動小数点数は 32 ビット版newLISP とライブラリでのみ使えます。
64 ビット環境で浮動小数点数を使うためには、<a href="#extended_import">拡張 <tt>import</tt> 構文</a>を使います。<br />
To transform newLISP data types into the data types needed by the 
imported function, use the functions 
<a href="#float">float</a> for 64-bit double floats, 
<a href="#flt">flt</a> for 32-bit floats, 
and <a href="#int">int</a> for 32-bit integers. 
By default, newLISP passes floating point numbers as 64-bit double floats, 
integers as 32-bit integers, and strings as 32-bit integers for string 
addresses (pointers in C). Floats can only be used with 32-bit versions
of newLISP and libraries. To use floating point numbers in a 64-bit
environment use the <a href="#extended_import">extended <tt>import</tt> syntax</a>. 
</p>

<!-- example -->

<pre>
;; define LIBC platform independent

(define LIBC (lookup ostype '(
("Windows" "msvcrt.dll")
("OSX" "libc.dylib")

(import LIBC "printf")
(printf "%g %s %d %c\n" 1.23 "hello" 999 65)
<b>1.23 hello 999 A</b>
<span class='arw'>&rarr;</span> 17 ; return value

;; import MS Windows DLLs in 32-bit versions 

(import "kernel32.dll" "GetTickCount")  <span class='arw'>&rarr;</span> GetTickCount
(import "user32.dll" "MessageBoxA")     <span class='arw'>&rarr;</span> MessageBoxA
(GetTickCount)                          <span class='arw'>&rarr;</span> 3328896
</pre>

<p>最初の例では、文字列 "1.23 hello 999 A" が副次効果で出力され、値 17（出力文字数）が返ります。
この方法で、どのような C 関数でも共有ライブラリから導入できます。<br />
In the first example, the string "1.23 hello 999 A" 
is printed as a side effect, and the value 17 (number of 
characters printed) is returned. Any C function can be imported 
from any shared library in this way.
</p>

<p>メッセージ・ボックスの例では、コンソール・ウィンドウの後ろに隠れているかもしれませんが、Windows ダイアログ・ボックスがポップ・アップします。
メッセージ・ボックスの 'OK' ボタンを押されるまで、コンソール・プロンプトに結果が返りません。<br />
The message box example pops up a Windows dialog box, which may be hidden 
behind the console window.  The console prompt does not return until the 
'OK' button is pressed in the message box.</p>

<pre>
;;this pops up a message box

(MessageBoxA 0 "This is the body" "Caption" 1) 
</pre>

<p>他の例は、MS Windows DLL 関数のいくつかの導入と <em>即値</em> や<em>参照</em> による引数の与え方を示します。
文字列や数を参照で渡す時は、事前に場所を用意しておく必要があります。<br />
The other examples show several imports of MS Windows DLL functions and 
the details of passing values <em>by value</em> or <em>by reference</em>. 
Whenever strings or numbers are passed by reference, space must be 
reserved beforehand.</p>


<pre>
(import "kernel32.dll" "GetWindowsDirectoryA")

;; allocating space for a string return value
(set 'str (dup "\000" 64))  ; reserve space and initialize

(GetWindowsDirectoryA str (length str))

str  <span class='arw'>&rarr;</span> "C:\\WINDOWS\000\000\000 ... "

;; use trim or get-string to cut of binary zeros
(get-string str)  <span class='arw'>&rarr;</span> "C:\\WINDOWS"
(trim str)        <span class='arw'>&rarr;</span> "C:\\WINDOWS"

(import "kernel32.dll" "GetComputerNameA")

;; allocate memory and initialize to zeros
(set 'str (dup "\000" 64))
(set 'len (length str)

;; call the function
;; the length of the string is passed as address reference 
;; string str is automatically past by address (C pointer)
(GetComputerNameA str (address len)) 

str  <span class='arw'>&rarr;</span> "LUTZ-PC\000\000 ... "

(trim str)  <span class='arw'>&rarr;</span> "LUTZ-PC"
</pre>

<p><tt>import</tt> は関数のアドレスを返し、導入した関数に別の名前を割り当てるのに使えます。<br />
<tt>import</tt> returns the address of the function, which can be 
used to assign a different name to the imported function.</p>

<pre>
(set 'imprime (import "libc.so.6" "printf")) 
<span class='arw'>&rarr;</span> printf@400862A0

(imprime "%s %d" "hola" 123)                 
<span class='arw'>&rarr;</span> "hola 123"
</pre>

<p>MS Windows や Cygwin 版の newLISP は、DLLライブラリ・ルーチンの呼び出しに、デフォルトで標準呼び出し <em>stdcall</em> 手続きを使います。
これは、MS Windows オペレーティング・システムに属する DLL (例えば、odbc32.dll) の呼び出しには必要なことです。
多くのサード・パーティの DLL は、C 宣言 <em>cdecl</em> 呼び出し手続きでコンパイルされ、関数を導入する時に追加する最後の引数に文字列 <tt>"cdecl"</tt> の指定を必要とするかもしれません。
macOS や Linux や 他の Unix システムでコンパイルされたnewLISP は、デフォルトで <em>cdecl</em> 呼び出し手続きを使いますので、追加の文字列は無視します。<br />
The MS Windows and Cygwin versions of newLISP uses standard call <em>stdcall</em> conventions 
to call DLL library routines by default.  This is necessary for calling DLLs that belong 
to the MS Windows operating system.  Most third-party DLLs are compiled for 
C declaration <em>cdecl</em> calling conventions and may need to specify the string 
<tt>"cdecl"</tt> as an additional last argument when importing functions. 
newLISP compiled for macOS, Linux and other Unix systems uses the 
<em>cdecl</em> calling conventions by default and ignores any additional string.</p>

<pre>
;; force cdecl calling conventions on MS Windows
(import "sqlite.dll" "sqlite_open" "cdecl")  <span class='arw'>&rarr;</span> sqlite_open &lt;673D4888&gt;
</pre>

<p>導入した関数は、14個の引数を取るかもしれません。
浮動小数点数の引数は、二つの場所を取ることに注意してください。
（例えば、十四個のパラメータの内、十個を取って五つの浮動小数点はを渡す）。<br />
Imported functions may take up to fourteen arguments. Note that 
floating point arguments take up two spaces each
(e.g., passing five floats takes up ten of the fourteen parameters).
</p>

<a name="extended_syntax"></a>
<a name="extended_import"></a>
<h3>The extended <tt>import</tt> syntax（拡張 <tt>import</tt> 構文）</h3>

<p>拡張 <tt>import</tt> API は第二構文で動作します。
それは、よく知られている <tt>libffi</tt> ライブラリに基づいており、ほとんどの OS プラットフォームに予めインストールされています。
この拡張 <tt>import</tt> API を使ってコンパイルされたバージョンの newLISP なら、newLISP 開始時の表示に <tt>libffi</tt> の単語が表示されているでしょう。
<ttt>libffi</tt> が使えるかどうかは、関数 <a href="#sys-info">sys-info</a> を使ってもチェックできます。<br />
The extended import API works with the second syntax. It is based on the popular 
<tt>libffi</tt> library which is pre-installed on most OS platforms. The startup banner
of newLISP should show the word <tt>libffi</tt> indicating the running version
of newLISP is compiled to use the extended <tt>import</tt> API. The function
<a href="#sys-info">sys-info</a> can also be used to check for <tt>libffi</tt>-support.</p>

<p>この API は、パラメータ渡しや戻り値に C言語のデータ型を使って動作します。
API は、パラメータの型が <tt>import</tt> 構文で指定されている必要があります。
型指定には、型の文字列ラベルを使います。
拡張 <tt>import</tt> API で書かれたプログラムは、32 ビットと 64 ビットの newLISP とライブラリで変更することなく、走るでしょう。
補助関数を使うことなしに、整数、浮動小数点数、文字列を戻せます。<br />
The API works with all atomic C data types for passed parameters and return values. 
The extended API requires that parameter types are specified in the <tt>import</tt> 
statement as string type labels. Programs written with extended import API will run 
without change on 32-bit and 64-bit newLISP and libraries. Integers, floating point 
values and strings can be returned without using helper functions.</p>

<p><em>str-return-type</em> の戻り値や <em>str-param-type</em> の関数パラメータには、次の型を指定できます：<br />
The following types can be specified for the return value in <em>str-return-type</em>
and for function parameters in <em>str-param-type</em>:</p>

<table summary="data types">
<tr align="left"><th>label</th><th>C type for return value and arguments</th><th>newLISP return and argument type</th></tr>
<tr><td>"void"</td><td>void</td><td><tt>nil</tt> is returned for return type</td></tr>
<tr><td>"byte"</td><td>byte unsigned 8 bit</td><td>integer</td></tr>
<tr><td>"char"</td><td>char signed 8 bit</td><td>integer</td></tr>
<tr><td>"unsigned short int"</td><td>unsigned short int 16 bit</td><td>integer</td></tr>
<tr><td>"short int"</td><td>short int signed 16 bit</td><td>integer</td></tr>
<tr><td>"unsigned int"</td><td>unsigned int 32 bit</td><td>integer</td></tr>
<tr><td>"int"</td><td>int signed 32 bit</td><td>integer</td></tr>
<tr><td>"long"</td><td>long signed 32 or 64 bit depending on platform</td><td>integer</td></tr>
<tr><td>"long long"</td><td>long long signed 64 bit</td><td>integer</td></tr>
<tr><td>"float"</td><td>float 32 bit</td><td>IEEE-754 64 bit float cut to 32-bit precision</td></tr>
<tr><td>"double"</td><td>double 64 bit</td><td>IEEE-754 64 bit float</td></tr>
<tr><td>"char*"</td><td>char* 32 or 64 bit ptr depending on platform</td><td>displayable string return (zero terminated)<br/>string buffer arg (no addr. since 10.4.2)</td></tr>
<tr><td>"void*"</td><td>void* 32 or 64 bit ptr depending on platform</td><td>integer address return<br/>either string buffer or integer address arg</td></tr>
</table>

<p><tt>"char*"</tt> 型と <tt>"void*</tt> 型は <tt>libffi</tt> 内で同等に扱われ、代替可能です。
渡される引数の型と戻り値の型次第で、どちらかが使われます。<br />
The types <tt>"char*"</tt> and <tt>"void*</tt> can be interchanged and are treated 
identical inside <tt>libffi</tt>. Depending on the type of arguments passed and the type
of return values, one or the other is used.</p>

<p>集合型は関数 <a href="#struct">struct</a> を使って構築でき、引数や戻り値に使うことができます。<br />
Aggregate types can be composed using the <a href="#struct">struct</a> function
and can be used for arguments and return values</p>

<p>次の例がしめしているのは、拡張 <tt>import</tt> 構文で浮動小数点数や文字列も戻り値をどのように処理できるかです：<br />
The following examples show how the extended <tt>import</tt> syntax can
handle return values of floating point values and strings:</p>

<pre>
;; return a float value, LIBC was defined earlier
;             name   return   arg
(import LIBC "atof" "double" "char*")
(atof "3.141") <span class='arw'>&rarr;</span> 3.141

;; return a copied string
;             name     return  arg-1   arg-2
(import LIBC "strcpy" "char*" "char*" "char*")
(set 'from "Hello World")

(set 'to (dup "\000" (length from))) ; reserve memory
(strcpy to from) <span class='arw'>&rarr;</span> "Hello World"
</pre>

<p><tt>"char*"</tt> 型は文字列バッファのみを取ります。
<tt>"void*</tt> 型は入力として、文字列バッファかメモリ・アドレスのどちらかを取ることができます。
戻り値の型として <tt>"void*"</tt> を使うと、結果のバッファ・アドレスが戻ります。
これは、構造体データへのポインタを返す時に役立ちます。
このポインタから構造体の中身を取り出すには、<a href="#unpack">unpack</a> と <a href="#struct">struct</a> を使います。
次の例では、戻り値の型を <tt>void*</tt> に変えています：<br />
The <tt>char*</tt> type takes a string buffer only. The <tt>"void*</tt> type can take either
a string buffer or a memory address number as input. When using <tt>"void*"</tt>
as a return type the address number of the result buffer will be returned. This is
useful when returning pointers to data structures. These pointers can then
be used with <a href="#unpack">unpack</a> and <a href="#struct">struct</a> for destructuring. 
In the following example the return type is changed to <tt>void*</tt>:</p>

<pre>
(import LIBC "strcpy" "void*" "char*" "char*")
(set 'from "Hello World")
(set 'to (dup "\000" (length from)))

(strcpy to from)       <span class='arw'>&rarr;</span> 2449424
(address to)           <span class='arw'>&rarr;</span> 2449424
(unpack "s11" 2449424) <span class='arw'>&rarr;</span> "Hello World"
(get-string 2449424)   <span class='arw'>&rarr;</span> "Hello World"
to                     <span class='arw'>&rarr;</span> "Hello World"
</pre>

<p>newLISP の文字列は常にアドレス参照で渡されます。<br />
A newLISP string is always passed by it's address reference.</p>


<p>もっと複雑な例は、この <a href="http://www.newlisp.org/syntax.cgi?code/opengl-demo-ffi-lsp.txt">OpenGL demo</a> を見てください。<br />
For a more complex example see this
<a href="http://www.newlisp.org/syntax.cgi?code/opengl-demo-ffi-lsp.txt">OpenGL demo</a>.</p>

<h3>Memory management</h3>

<p>導入した外部関数により実行された割り当ては、導入したAPIにその呼び出し（機能）がないなら、マニュアルで解除しなければなりません。
<a href="http://www.newlisp.org/CodePatterns-jp.html#toc-23">Code Patterns in newLISP</a> の例（訳注：Memory management の項）を見てください。<br />
Any allocation performed by imported foreign functions has to be 
de-allocated manually if there's no call in the imported API to do so.
See the <a href="http://www.newlisp.org/CodePatterns.html">Code Patterns in newLISP</a>
document for an example.</p>

<p>参照渡しで外部関数を呼び出す場合、
変数用のメモリを newLISP 側で予め割り当てておく必要がありますが、
&mdash;&mdash;（訳注：前記）<tt>GetWindowsDirectoryA</tt> の導入例を見てください&mdash;&mdash;それゆえ、メモリはマニュアルで解放する必要はありません。
newLISP によって自動的に管理されています。<br />
In case of calling foreign functions with passing by reference, 
memory for variables needs to be allocated beforehand by newLISP
&mdash; see import of <tt>GetWindowsDirectoryA</tt> above &mdash; 
and hence, memory needs not be deallocated manually, because it is
managed automatically by newLISP.</p>

<br/><br/>


<a name="inc"></a>
<h2><span class="function">inc</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (inc <em>place</em> [<em>num</em>])</h4>

<p>
<em>place</em> の数値を <tt>1.0</tt> かオプションの数値 <em>num</em> 分加算し、
結果を返します。
<tt>inc</tt> は浮動小数点数計算を実行し、渡された整数値を浮動小数点型に変換します。<br />
Increments the number in <em>place</em> by <tt>1.0</tt> or by the optional 
number <em>num</em> and returns the result. <tt>inc</tt> performs float 
arithmetic and converts integer numbers passed into floating point type.</p>

<p><em>place</em> はシンボルかリスト構造内の位置、式によって返される数値のいずれかです。<br />
<em>place</em> is either a symbol or a place in a list structure holding a
number, or a number returned by an expression.</p>

<!-- example -->

<pre>
(set 'x 0)    <span class='arw'>&rarr;</span> 0
(inc x)       <span class='arw'>&rarr;</span> 1
x             <span class='arw'>&rarr;</span> 1
(inc x 0.25)  <span class='arw'>&rarr;</span> 1.25
x             <span class='arw'>&rarr;</span> 1.25
(inc x)       <span class='arw'>&rarr;</span> 2.25
</pre>


<p>シンボル <em>place</em> に <tt>nil</tt> が入っているなら、<tt>0.0</tt> が入っているとして扱われます：<br/>
If a symbol  for <em>place</em> contains <tt>nil</tt>, it is treated
as if containing  <tt>0.0</tt>:</p>


<pre>
z             <span class='arw'>&rarr;</span> nil
(inc z)       <span class='arw'>&rarr;</span> 1

(set 'z nil)
(inc z 0.01)  <span class='arw'>&rarr;</span> 0.01
</pre>


<p>リスト構造内の位置や式によって返される数値も更新可能です：<br />
Places in a list structure or a number returned by another expression
can be updated too:</p>


<pre>
(set 'l '(1 2 3 4))

(inc (l 3) 0.1) <span class='arw'>&rarr;</span> 4.1

(inc (first l)) <span class='arw'>&rarr;</span> 2

l <span class='arw'>&rarr;</span> (2 2 3 4.1)

(inc (+ 3 4)) <span class='arw'>&rarr;</span> 8
</pre>


<p>整数モードでの数値の加算には、関数 <a href="#inci">++</a> を使ってください。
浮動小数点モードの減算には、<a href="#dec">dec</a> を使ってください。<br />
Use the <a href="#inci">++</a> function for incrementing numbers in
integer mode. Use <a href="#dec">dec</a> to decrement numbers in floating point mode.</p>


<br/><br/>

<a name="index"></a>
<h2><span class="function">index</span></h2>
<h4>syntax: (index <em>exp-predicate</em> <em>exp-list</em>)</h4>

<p>述部 <em>exp-predicate</em> をリスト <em>exp-list</em> の各要素に適用し、<em>exp-predicate</em> が true となる要素の位置のリストが返ります。<br />
Applies the predicate <em>exp-predicate</em> to each element of the 
list <em>exp-list</em> and returns a list containing the indices of the elements 
for which <em>exp-predicate</em> is true.</p>

<!-- example -->

<pre>
(index symbol? '(1 2 d 4 f g 5 h))  <span class='arw'>&rarr;</span> (2 4 5 7)

(define (big? x) (&gt; x 5))  <span class='arw'>&rarr;</span> (lambda (x) (&gt; x 5))

(index big? '(1 10 3 6 4 5 11))  <span class='arw'>&rarr;</span> (1 3 6)

(select '(1 10 3 6 4 5 11) '(1 3 6)) <span class='arw'>&rarr;</span> (10 6 11)
</pre>


<p>述部は、組込述語かユーザ定義関数かラムダ式です。<br />
The predicate may be a built-in predicate, 
a user-defined function, or a lambda expression.
</p>

<p>要素それ自体を返したい時は、関数 <a href="#filter">filter</a> を使ってください。<br />
Use the <a href="#filter">filter</a> function 
to return the elements themselves.
</p>

<br/><br/>

<a name="infp"></a>
<h2><span class="function">inf?</span></h2>
<h4>syntax: (inf? <em>float</em>)</h4>

<p>この関数は、<em>float</em> の値が無限大なら <tt>true</tt>を返し、そうでなければ <tt>nil</tt> を返します。<br />
If the value in <em>float</em> is infinite the function returns
<tt>true</tt> else <tt>nil</tt>.</p>

<!-- example -->

<pre>
(inf? (div 1 0)) <span class='arw'>&rarr;</span> true

(div 0 0) <span class='arw'>&rarr;</span> NaN
</pre>


<p>整数をゼロで割る、すなわち <tt>(/ 1 0)</tt> は "division by zero" エラーを引き起こして無限大にならないので、注意してください。
浮動小数点数が有効かどうかをチェックする <a href="#NaNp">NaN?</a> も見てください。<br />
Note that an integer division by zero e.g. <tt>(/ 1 0)</tt> will
throw an "division by zero" error and not yield infinity. See also
<a href="#NaNp">NaN?</a> to check if a floating point number is valid.</p>

<br/><br/>

<a name="int"></a>
<h2><span class="function">int</span></h2>

<h4>syntax: (int <em>exp</em> [<em>exp-default</em> [<em>int-base</em>]])</h4>

<p>
<em>exp</em> の式が数値か文字列なら、結果は整数に変換されて返されます。
<em>exp</em> が整数に変換できない時は、<tt>nil</tt> か <em>exp-default</em> の評価結果が返ります。
この関数は、ユーザ入力やテキスト解析による文字列の変換によく使われます。
<em>exp</em> が文字列に評価される場合、文字列は数字か一個以上のスペースか <tt>+</tt> か <tt>-</tt> サインで始まっていなければなりません。
16進数文字列は '<tt>0x</tt>'、8進数文字列は '<tt>0</tt>'（ゼロ）で始まっている必要があります。
特に指定が無く <em>exp</em> が有効でなければ、<tt>int</tt> はデフォルト値として <tt>nil</tt> を返します。<br />
If the expression in <em>exp</em> evaluates to a number or a string, the result 
is converted to an integer and returned.  If <em>exp</em> cannot be converted 
to an integer, then <tt>nil</tt> or the evaluation of <em>exp-default</em> will 
be returned.  This function is mostly used when translating strings from user 
input or from parsing text. If <em>exp</em> evaluates to a string, the string 
must start with a digit; one or more spaces; or the <tt>+</tt> or <tt>-</tt> sign.
The string must begin with '<tt>0x</tt>' for hexadecimal strings or '<tt>0</tt>' 
(zero) for octal strings.  If <em>exp</em> is invalid, <tt>int</tt> returns 
<tt>nil</tt> as a default value if not otherwise specified.
</p>

<p>第二オプション・パラメータには、変換基数を指定できます。<br />
A second optional parameter can be used to force the number base 
of conversion to a specific value.</p>

<p>9,223,372,036,854,775,807 より大きい整数は、9,223,372,036,854,775,807 に切り捨てられます。
-9,223,372,036,854,775,808 より小さい整数は、-9,223,372,036,854,775,808 に切り詰められます。<br />
Integers larger than 9,223,372,036,854,775,807 are truncated to 
9,223,372,036,854,775,807.  Integers smaller than -9,223,372,036,854,775,808 
are truncated to -9,223,372,036,854,775,808.</p>

<p>（<tt>int</tt> の第二形式として）浮動小数点からの変換の時、浮動小数点数が整数の最大値より大きい値か最小値より小さい値なら、それらは切り捨てられます。
<tt>NaN</tt> に評価される浮動小数点数は、<tt>0</tt>（ゼロ）に変換されます。<br />
When converting from a float (as in the second form of <tt>int</tt>), 
floating point values larger or smaller than the integer maximum or minimum 
are also truncated. A floating point expression evaluating to <tt>NaN</tt> 
is converted to <tt>0</tt> (zero).</p>


<!-- example -->

<pre>
(int "123")          <span class='arw'>&rarr;</span> 123
(int " 123")         <span class='arw'>&rarr;</span> 123
(int "a123" 0)       <span class='arw'>&rarr;</span> 0
(int (trim " 123"))  <span class='arw'>&rarr;</span> 123
(int "0xFF")         <span class='arw'>&rarr;</span> 255
(int "0b11111")      <span class='arw'>&rarr;</span> 31
(int "055")          <span class='arw'>&rarr;</span> 45
(int "1.567")        <span class='arw'>&rarr;</span> 1
(int 1.567)          <span class='arw'>&rarr;</span> 1

(integer? 1.00)        <span class='arw'>&rarr;</span> nil
(integer? (int 1.00))  <span class='arw'>&rarr;</span> true

(int "1111" 0 2)  <span class='arw'>&rarr;</span> 15   ; base 2 conversion
(int "0FF" 0 16)  <span class='arw'>&rarr;</span> 255  ; base 16 conversion

(int 'xyz)     <span class='arw'>&rarr;</span> nil
(int 'xyz 0)   <span class='arw'>&rarr;</span> 0
(int nil 123)  <span class='arw'>&rarr;</span> 123

(int "abc" (throw-error "not a number"))  
<span class='arw'>&rarr;</span> <span class='err'>ERR: user error : not a number</span>

(print "Enter a num:")
(set 'num (int (read-line)))

(int (bits 12345) 0 2) <span class='arw'>&rarr;</span> 12345
</pre>


<p>基数 <tt>2</tt> の時の <tt>int</tt> の逆関数は <a href="#bits">bits</a> です。<br />
The inverse function to <tt>int</tt> with base <tt>2</tt> is
<a href="#bits">bits</a>.</p>

<p>引数を浮動小数点数に変換する時は、関数 <a href="#float">float</a> を使ってください。<br />
Use the <a href="#float">float</a> function 
to convert arguments to floating point numbers.</p>

<br/><br/>

<a name="integerp"></a>
<h2><span class="function">integer?</span></h2>
<h4>syntax: (integer? <em>exp</em>)</h4>

<p><em>exp</em> の値が整数の時のみ <tt>true</tt> が返り、それ以外では <tt>nil</tt> が返ります。<br />
Returns <tt>true</tt> only if the value 
of <em>exp</em> is an integer; 
otherwise, it returns <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(set 'num 123)  <span class='arw'>&rarr;</span> 123
(integer? num)  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="intersect"></a>
<h2><span class="function">intersect</span></h2>
<h4>syntax: (intersect <em>list-A</em> <em>list-B</em>)<br/>

syntax: (intersect <em>list-A</em> <em>list-B</em> <em>bool</em>)</h4>

<p>第一構文の <tt>intersect</tt> は、<em>list-A</em> と <em>list-B</em> の両方で見つかる各要素の一つのコピーからなるリストを返します。<br />
In the first syntax, 
<tt>intersect</tt> returns a list 
containing one copy of each element 
found both in <em>list-A</em> and <em>list-B</em>.
</p>

<!-- example -->

<pre>
(intersect '(3 0 1 3 2 3 4 2 1) '(1 4 2 5))  
<span class='arw'>&rarr;</span> (2 4 1)
</pre>


<p>	第二構文の（訳注：<em>list</em> モードで動作する）<tt>intersect</tt> は、<em>list-B</em> に存在する <em>list-A</em> の全て要素からなるリストを返します。
<em>list-A</em> 内で重複している要素は削除されません。
<em>bool</em> は、<tt>true</tt> に評価される式か <tt>nil</tt> 以外の値です。<br />
In the second syntax, 
<tt>intersect</tt> returns a list of all elements 
in <em>list-A</em> that are also in <em>list-B</em>, 
without eliminating duplicates in <em>list-A</em>. 
<em>bool</em> is an expression evaluating to <tt>true</tt> 
or any other value not <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(intersect '(3 0 1 3 2 3 4 2 1) '(1 4 2 5) true)
<span class='arw'>&rarr;</span> (1 2 4 2 1)
</pre>


<p>集合関数の <a href="#difference">difference</a> や <a href="#unique">unique</a>、<a href="#union">union</a> も見てください。<br />
See also the set functions 
<a href="#difference">difference</a>, <a href="#unique">unique</a>
and <a href="#union">union</a>.
</p>

<br/><br/>

<a name="invert"></a>
<h2><span class="function">invert</span></h2>
<h4>syntax: (invert <em>matrix</em> [<em>float-pivot</em>])</h4>

<p>
<em>matrix</em> の二次元行列の逆行列を返します。
行列は行と列が同じ数である正方で、（逆行列を持つ）<em>非特異</em> でなければなりません（訳注：つまり、<a href="http://ja.wikipedia.org/wiki/%E6%AD%A3%E5%89%87%E8%A1%8C%E5%88%97">正則行列</a>）。
逆行列は、線型方程式のシステム（例えば、統計の重回帰）の解法に使うことができます。
newLISP は逆行列の検出に、行列の<a href="http://ja.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3">ＬＵ分解</a>を使っています。<br />
Returns the inversion of a two-dimensional matrix in <em>matrix</em>. 
The matrix must be square, with the same number 
of rows and columns, and <em>non-singular</em> (invertible). 
Matrix inversion can be used to solve systems of linear equations 
(e.g., multiple regression in statistics).  newLISP uses LU-decomposition of 
the matrix to find the inverse.</p>

<p>オプションで、<em>float-pivot</em> に <tt>0.0</tt> か非常に小さい値を指定できます。
この値は、<a href="http://ja.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3">ＬＵ分解</a>アルゴリズムで特異行列（訳注:<a href="http://mathworld.wolfram.com/SingularMatrix.html">逆行列を持たない行列</a>）を処理する時にゼロになるピボット要素の代わりになります。
<br />
Optionally <tt>0.0</tt> or a very small value can be specified
in <em>float-pivot</em>. This value substitutes pivot elements in
the LU-decomposition algorithm, which result in zero when
the algorithm deals with a singular matrix.</p>

<p>行列の次元は、行数と最初の行の要素数の積で定義されます。
非矩形行列上の見つからない要素は <tt>0.0</tt>（ゼロ）になります。
行列は、入れ子のリストでも <a href="#array">array</a> でも可能です。<br />
The dimensions of a matrix are defined by the number of rows 
times the number of elements in the first row.  For missing elements 
in non-rectangular matrices, <tt>0.0</tt> (zero) is assumed.  
A matrix can either be a nested list or an <a href="#array">array</a>.
</p> 

<!-- example -->

<pre>
(set 'A '((-1 1 1) (1 4 -5) (1 -2 0)))
(invert A)  <span class='arw'>&rarr;</span> ((10 2 9) (5 1 4) (6 1 5))
(invert (invert A)) <span class='arw'>&rarr;</span> ((-1 1 1) (1 4 -5) (1 -2 0))

; solve Ax = b for x
(multiply (invert A) '((1) (2) (3))) <span class='arw'>&rarr;</span> ((41) (19) (23))

; treatment of singular matrices
(invert '((2 -1) (4 -2)))        <span class='arw'>&rarr;</span> nil
(invert '((2 -1) (4 -2)) 0.0)    <span class='arw'>&rarr;</span> ((inf -inf) (inf -inf))
(invert '((2 -1) (4 -2)) 1e-20)  <span class='arw'>&rarr;</span> ((5e+19 -2.5e+19) (1e+20 -5e+19)) 
</pre>

<p>行列が <i>特異行列</i> で逆行列を持たず、<em>float-pivot</em> が指定されていなければ、<tt>invert</tt> は <tt>nil</tt> を返します。<br />
<tt>invert</tt> will return <tt>nil</tt> if the matrix is <i>singular</i> 
and cannot be inverted, and <em>float-pivot</em> is not specified. </p>


<p>ここで示されたリスト上の操作は全て、アレイに対しても有効です。<br />
All operations shown here on lists 
can be performed on arrays, as well.
</p>

<p>行列関数の <a href="#det">det</a>、<a href="#mat">mat</a>、<a href="#multiply">multiply</a>、 <a href="#transpose">transpose</a> も見てください。<br />
See also the matrix functions <a href="#det">det</a>,
<a href="#mat">mat</a>, <a href="#multiply">multiply</a>
and <a href="#transpose">transpose</a>.
</p>

<br/><br/>

<a name="irr"></a>
<h2><span class="function">irr</span></h2>
<h4>syntax: (irr <em>list-amounts</em> [<em>list-times</em> [<em>num-guess</em>]])</h4>

<p>期間あたりのキャッシュ・フローの内部収益率を計算します。
内部収益率は、キャシュ・フローの現在の価値を <tt>0.0</tt>（ゼロ）にする金利です。
流入（負数）と流出（正数）の総額を <em>list-amounts</em> に指定します。
<em>list-times</em> に期間倍率が指定されていない場合、<em>list-amounts</em> は1 ずつ( 1, 2, 3 &ndash;という風に)増加する期間倍率で合計されます。
使っているアルゴリズムは、初期推定値0.5 (50%) の反復法です。
オプションで、異なる初期推定値を指定できます。
アルゴリズムは、精度が 0.000001 (0.0001%) に達した時に戻ります。
アルゴリズムが 50 回で収束しなかった時は、<tt>nil</tt> が返ります。<br />
Calculates the internal rate of return 
of a cash flow per time period. 
The internal rate of return is the interest rate 
that makes the present value of a cash flow equal to <tt>0.0</tt> (zero). 
In-flowing (negative values) and out-flowing (positive values) 
amounts are specified in  <em>list-amounts</em>. 
If no time periods are specified in <em>list-times</em>, 
amounts in <em>list-amounts</em> correspond to 
consecutive time periods increasing by 1 (1, 2, 3&mdash;). 
The algorithm used is iterative, 
with an initial guess of 0.5 (50 percent). 
Optionally, a different 
initial guess can be specified. 
The algorithm returns when a precision 
of 0.000001 (0.0001 percent) is reached. 
<tt>nil</tt> is returned if the algorithm 
cannot converge after 50 iterations.
</p>

<p><em>irr</em> は、異なるタイプの投資間の決定によく使われます。<br />
<em>irr</em> is often used to decide 
between different types of investments.
</p>

<!-- example -->

<pre>
(irr '(-1000 500 400 300 200 100))  
<span class='arw'>&rarr;</span> 0.2027

(npv 0.2027 '(500 400 300 200 100)) 
<span class='arw'>&rarr;</span> 1000.033848 ; ~ 1000

(irr '(-1000 500 400 300 200 100) '(0 3 4 5 6 7)) 
<span class='arw'>&rarr;</span> 0.0998

(irr '(-5000 -2000 5000 6000) '(0 3 12 18)) 
<span class='arw'>&rarr;</span> 0.0321
</pre>


<p>1,000 の初期投資が一年後に 500 をもたらし、二年後に 400 と続き、5 年を過ぎると最終的に <tt>0.0</tt>（ゼロ）となるならば、それは年利約 20.2 ％の配当に相当します。
次の行（訳注：例題の二行目）は、 <tt>irr</tt> と <a href="#npv">npv</a> の関係を示しています。
（訳注：例題の三行目は、）三年後から回収を始めたいのであれば、たった 9.9 ％の配当で済みます。<br />
If an initial investment of 1,000 
yields 500 after the first year, 
400 after two years, and so on, 
finally reaching <tt>0.0</tt> (zero) after five years, 
then that corresponds to a yearly return 
of about 20.2 percent. 
The next line demonstrates the relation 
between <tt>irr</tt> and <a href="#npv">npv</a>. 
Only 9.9 percent returns are necessary when making 
the first withdrawal after three years.
</p>

<p>例題の最後では、証券を最初に 5,000 購入し、3 カ月後別に 2,000 購入したとしています。
一年後（訳注：12ヵ月後）、5,000 分の証券を売ったとします。
18ヵ月後に残りの証券を売って 6,000 を得たとします。
この場合の内部収益率は、一ヶ月あたり 3.2 ％となり、18ヶ月でおよそ 57 ％です。<br />
In the last example, securities 
were initially purchased for 5,000, 
then for another 2,000 three months later. 
After a year, securities for 5,000 are sold. 
Selling the remaining securities 
after 18 months renders 6,000. 
The internal rate of return is 3.2 percent per month, 
or about 57 percent in 18 months.
</p>

<p>関数 <a href="#fv">fv</a>、<a href="#nper">nper</a>、<a href="#npv">npv</a>、<a href="#pmt">pmt</a>、<a href="#pv">pv</a> も見てください。<br />
See also the <a href="#fv">fv</a>, 
<a href="#nper">nper</a>, 
<a href="#npv">npv</a>, 
<a href="#pmt">pmt</a>, 
and <a href="#pv">pv</a> functions.
</p> 

<br/><br/>

<a name="json-error"></a>
<h2><span class="function">json-error</span></h2>
<h4>syntax: (json-error)</h4>

<p><a href="#json-parse">json-parse</a> が JSON データの変換し失敗して <tt>nil</tt> を返す時、この関数でエラーの詳細と解析時の最終位置を引き出せます。<br />
When <a href="#json-parse">json-parse</a> returns <tt>nil</tt> due
to a failed JSON data translation, this function retrieves an error
description and the last scan position of the parser.</p>

<pre>
; failed parse returns nil
(json-parse [text]{"address" "http://example.com"}[/text]) <span class='arw'>&rarr;</span> nil

; inspect the error information
(json-error) <span class='arw'>&rarr;</span> ("missing : colon" 11)
</pre>

<br/><br/>

<a name="json-parse"></a>
<h2><span class="function">json-parse</span></h2>
<h4>syntax: (json-parse <em>str-json-data</em>)</h4>

<p>この関数は JSON形式のテキストを解析し、newLISP のＳ式に変換します。
ECMA-262 標準に従う全てのデータ型が変換されます。
JSON の <tt>false</tt> 値や <tt>null</tt> 値は、newLISP のシンボル式中では <tt>false</tt> シンボルや <tt>null</tt> シンボルで表現されます。JSON 中のアレイは newLISP 中ではリストで表現されます。JSON オブジェクト・データから結果として得られるリストは、<a href="#assoc">assoc</a> や <a href="#lookup">lookup</a>、<a href="#ref">ref</a> を使って処理することができます。<br />
This function parses JSON formatted text and translates it to newLISP S-expressions.
All data types conforming to the ECMA-262 standard are translated. The JSON values 
<tt>false</tt> and <tt>null</tt> will be represented by the symbols <tt>false</tt> 
and <tt>null</tt> in the symbolic newLISP expressions. Arrays in JSON will be represented 
by lists in newLISP. The resulting lists from JSON object data can be processed using 
<a href="#assoc">assoc</a>, <a href="#lookup">lookup</a> and <a href="#ref">ref</a>.</p>

<p><tt>json-parse</tt> は、認識されなかった JSON の属性値や誤った JSON 構文に対して <tt>nil</tt> を返し、そのエラー文の取り出しには <a href="#json-error">json-error</a> が使えます。<br />
For JSON attribute values not recognized or wrong JSON syntax, <tt>json-parse</tt> 
returns <tt>nil</tt> and <a href="#json-error">json-error</a> can be used to retrieve
the error text.</p>

<p>次の例は、<tt>person.json</tt> ファイルにある入れ子 JSON オブジェクトを表しています：<br />
The following example shows a nested JSON object from a file <tt>person.json</tt>:</p>

<!-- example -->

<pre>
{
"name": "John Smith",
"age": 32,
"employed": true,
"address": {
"street": "701 First Ave.",
"city": "Sunnyvale, CA 95125",
"country": "United States"
},
"children": [
{
    "name": "Richard",
    "age": 7
},
{
    "name": "Susan",
    "age": 4
},
{
    "name": "James",
    "age": 3
}
]
}
</pre>
<p>ファイルを読み込んで解析し、結果のＳ式を <tt>jsp</tt> に納めます：<br />
The file is read, parsed and the resulting S-expression stored in <tt>jsp</tt>:</p>

<pre>
(set 'jsp (json-parse (read-file "person.json")))
<span class='arw'>&rarr;</span>
( ("name" "John Smith") 
("age" 32) 
("employed" true) 
("address" ( ("street" "701 First Ave.") 
       ("city" "Sunnyvale, CA 95125") 
       ("country" "United States")) ) 
("children" (
(("name" "Richard") ("age" 7)) 
(("name" "Susan") ("age" 4)) 
(("name" "James") ("age" 3))) )
)
</pre>

<p>データは <a href="#assoc">assoc</a> や <a href="#lookup">lookup</a>、<a href="#ref">ref</a>  を使って取り出せます：<br />
Data can be extracted using <a href="#assoc">assoc</a>, <a href="#lookup">lookup</a> 
or <a href="#ref">ref</a>:</p>

<pre>
; the address
(lookup "address" jsp)
<span class='arw'>&rarr;</span> (("street" "701 First Ave.") ("city" "Sunnyvale, CA 95125") ("country" "United States"))

; the city of the address
(lookup "city" (lookup "address" jsp)) 
<span class='arw'>&rarr;</span> "Sunnyvale, CA 95125"

; a child named Susan
(ref '(( * "Susan") *) jsp match true) 
<span class='arw'>&rarr;</span> (("name" "Susan") ("age" 4))

; all names
(map last (ref-all '("name" *) jsp match true)) 
<span class='arw'>&rarr;</span> ("John Smith" "Richard" "Susan" "James")

; only names of children
(map last (ref-all '("name" *) (lookup "children" jsp) match true))
<span class='arw'>&rarr;</span>
("Richard" "Susan" "James")

; names of children other method
(map last (map first (lookup "children" jsp)))
<span class='arw'>&rarr;</span>
("Richard" "Susan" "James")
</pre>

<p>大抵の場合、JSON オブジェクト型は解析されますが、全 JSON データ型は JSON オブジェクトの一部としてではなく、直接解析されます。
次は、JSON 配列の解析例です：<br />
Although most of the time JSON object types are parsed, all JSON data
types can be parsed directly, without occurring as part of a JSON object.
The following examples show parsing of a JSON array:</p>

<pre>
; parse a JSON array data type

(json-parse "[1, 2, 3, 4, 5]") <span class='arw'>&rarr;</span> (1 2 3 4 5)
</pre>

<p>UTF-8 が有効な newLISP バージョンが使われているなら、JSON 形式のユニコードは UTF-8 に変換されます：<br />
When the UTF-8 capable version of newLISP is used, JSON formatted Unicode
gets translated into UTF-8:</p>

<pre>
; parse a JSON object data type ands Unicode
; the outer {,} are newLISP string delimiters [text],[/text] tags could also be used
; the inner {,} are JSON object delimiters

(json-parse { {"greek letters" : "\u03b1\u03b2\u03b3\u03b4"} }) <span class='arw'>&rarr;</span> (("greek letters" "αβγδ"))

; strings longer than 2047 bytes should be delimted with [text], [/text] tags

(json-parse [text]{"greek letters" : "\u03b1\u03b2\u03b3\u03b4"}[/text]) <span class='arw'>&rarr;</span> (("greek letters" "αβγδ"))
</pre>

<p>JSON でユニコード文字を表現する16進数表記は UTF-8 版 newLISP でも使えます。<br />
The hex-code representation of Unicoder characters in JSON is the same as can be used in
UTF-8 enabled newLISP.</p>

<p>JSON オブジェクトは <tt>{,},"</tt> を含むので、JSON データの区切りに引用符を使うべきではありませんし、JSON データ内の全ての引用符の前にはバックスラッシュ <tt>\</tt> を置く必要があります。
<tt>{,}</tt> 対は JSON データ内で対応が取れていれば、可能な限りの長さで使えます。
安全な区切りは <tt>[text], [/text]</tt> タグです &mdash;&mdash; 
これなら newLISP に読み取られる時の文字列特殊処理が全て抑制されるし、2047 バイトより大きいデータを区切るのにも適しています。<br />
Because JSON objects contain <tt>{,},"</tt> characters, quotes should not be used
to limit JSON data, or all quotes inside the JSON data would need a preceding backslash <tt>\</tt>.
<tt>{,}</tt> braces can be used as long as braces inside the JSON data are balanced.
The safest delimiter are <tt>[text], [/text]</tt> tags &mdash; they suppress all special processing
of the string when read by newLISP and are delimit to delimit large data sizes greater
2047 bytes.</p>

<br/><br/>

<a name="join"></a>
<h2><span class="function">join</span></h2>
<h4>syntax: (join <em>list-of-strings</em> [<em>str-joint</em> [<em>bool-trail-joint</em>]])</h4>

<p>与えられた <em>list-of-strings</em> の文字列のリストを（訳注：間にスペースを入れて）つなぎ合わせます。
<em>str-joint</em> があれば、（訳注：スペースの代わりに）結合時にそれが（訳注：接続文字として）各文字列間に挿入されます。
<em>bool-trail-joint</em> が <tt>true</tt> なら、接続文字が文字列の最後にも追加されます。<br />
Concatenates the given   
list of strings 
in <em>list-of-strings</em>. 
If <em>str-joint</em> is present, 
it is inserted between each string in the join.
If <em>bool-trail-joint</em> is <tt>true</tt>
then a joint string is also appended to the last string.
</p>

<!-- example -->

<pre>
(set 'lst '("this" "is" "a" "sentence"))

(join lst " ")  <span class='arw'>&rarr;</span> "this is a sentence"

(join (map string (slice (now) 0 3)) "-")  <span class='arw'>&rarr;</span> "2003-11-26"

(join (explode "keep it together"))  <span class='arw'>&rarr;</span> "keep it together"

(join '("A" "B" "C") "-")         <span class='arw'>&rarr;</span> "A-B-C"
(join '("A" "B" "C") "-" true)    <span class='arw'>&rarr;</span> "A-B-C-"
</pre>


<p>関数 <a href="#append">append</a> や <a href="#string">string</a> と <tt>join</tt> 操作と逆の <a href="#explode">explode</a> も見てください。<br />
See also the <a href="#append">append</a>, 
<a href="#string">string</a>, 
and <a href="#explode">explode</a> functions, 
which are the inverse of the <tt>join</tt> operation.
</p>

<br/><br/>

<a name="kmeans-query"></a>
<h2><span class="function">kmeans-query</span></h2>
<h4>syntax: (kmeans-query <em>list-data</em> <em>matrix-centroids</em>)<br/>
syntax: (kmeans-query <em>list-data</em> <em>matrix-data</em>)</h4>

<p>最初の使い方では、<tt>kmeans-query</tt> は <em>list-data</em> で与えられるベクトル・データから <em>matix-centroids</em> で与えられる重心までの<a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E7%A9%BA%E9%96%93#.E3.83.A6.E3.83.BC.E3.82.AF.E3.83.AA.E3.83.83.E3.83.89.E7.A9.BA.E9.96.93.E3.81.AE.E8.A8.88.E9.87.8F">ユークリッド距離</a>を計算します。
<em>list-data</em> のベクトル・データは <i>m</i> 個の要素からなります。
事前の <a href="#kmeans-train">kmeans-train</a> による区分けの結果である <em>matrix-centroids</em> の２次元リスト（訳注：リストのリストだから２次元）は <i>k</i> 行 <i>m</i> 列からなり、<i>k</i> 行の <i>m</i> 要素が重心を表しています。<br />
In the first usage, <tt>kmeans-query</tt> calculates the Euclidian distances
from the data vector given in <em>list-data</em> to the centroids given in
<em>matrix-centroids</em>. The data vector in <em>list-data</em> has <i>m</i> 
elements. The 2-dimensional list in <em>matrix-centroids</em>, result from a previous
<a href="#kmeans-train">kmeans-train</a> clustering, has <i>k</i> rows and <i>m</i> 
columns for <i>k</i> centroids measuring <i>m</i> features.</p>

<pre>
; centroids from previous kmeans-train
K:centroids <span class='arw'>&rarr;</span>
( (6.39 7.188333333 5.935) 
(7.925714286 3.845714286 9.198571429) 
(2.207142857 2.881428571 0.8885714286) )

(kmeans-query '(1 2 3) K:centroids) <span class='arw'>&rarr;</span>
(8.036487279 9.475994267 2.58693657) ; distances to cluster 1, 2 and 3
</pre>

<p>データ <tt>(1 2 3)</tt> は、３番目のクラスターと最も距離の近いことがわかり、そのクラスターに属するものとして分類されるでしょう。<br />
The data record <tt>(1 2 3)</tt> shows the smallest distance to the 3rd
cluster centroid and would be classified as belonging to that cluster.</p>

<p>二番目の利用法では、<tt>kmeans-query</tt> は重心ではない他のデータ・ポイントのリストまでの<a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E7%A9%BA%E9%96%93#.E3.83.A6.E3.83.BC.E3.82.AF.E3.83.AA.E3.83.83.E3.83.89.E7.A9.BA.E9.96.93.E3.81.AE.E8.A8.88.E9.87.8F">ユークリッド距離</a>を計算します。
次の例は、ベクトル・データ <tt>(1 2 3)</tt> から <a href="#kmeans-train">kmeans-train</a> によるデータ解析に使った元々のポイントまで距離を掲載しています。<br />
In the second application <tt>kmeans-query</tt> calculates Euclidian distances to a list
of other data points which are not centroids. The following example
calculates distances of the <tt>(1 2 3)</tt> data vector to all original points
from the original <a href="#kmeans-train">kmeans-train</a> data analysis.</p>

<p><em>matix-data</em> のデータには入れ子のリストも、二次元アレイも使えます。<br />
The data in <em>matrix-data</em> can be either a nested list or a 2-dimensional
array.</p>

<p>続けて行われる kNN（<a href="http://ja.wikipedia.org/wiki/K%E8%BF%91%E5%82%8D%E6%B3%95">k 近傍法</a>）解析のために、このベクトルを並べ替えることができます：<br />
This vector could be sorted for a subsequent kNN (k Nearest Neighbor)
analysis:</p>

<pre>
(kmeans-query '(1 2 3) data) <span class='arw'>&rarr;</span>
(10.91671196 3.190626898 9.19723328 3.014415366 9.079763213 
6.83130295 8.533111976 9.624816881 6.444261013 2.013107051 
3.186549858 9.475199206 9.32936761 2.874786949 7.084638311 
10.96221237 10.50080473 3.162419959 2.423674896 9.526436899)

; show distances to members in each cluster

; for cluster labeled 1
(select (kmeans-query '(1 2 3) data) (K:clusters 0)) <span class='arw'>&rarr;</span> 
(9.079763213 6.83130295 9.624816881 6.444261013 7.084638311 10.50080473)

; for cluster labeled 2
(select (kmeans-query '(1 2 3) data) (K:clusters 1)) <span class='arw'>&rarr;</span>
(10.91671196 9.19723328 8.533111976 9.475199206 9.32936761 10.96221237 9.526436899)

; for cluster labeled 3
(select (kmeans-query '(1 2 3) data) (K:clusters 2)) <span class='arw'>&rarr;</span>
(3.190626898 3.014415366 2.013107051 3.186549858 2.874786949 3.162419959 2.423674896)
</pre>


<p>最小距離が第３クラスターのオフセットが２（つまり３番目）のデータポイントにあることがわかります。<br />
We see that the smallest distances are shown for the data points in
the 3rd cluster at offset 2.</p>

<p><em>list-data</em> の要素の数がデータや重心行列の列数と異なる場合、<a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E7%A9%BA%E9%96%93#.E3.83.A6.E3.83.BC.E3.82.AF.E3.83.AA.E3.83.83.E3.83.89.E7.A9.BA.E9.96.93.E3.81.AE.E8.A8.88.E9.87.8F">ユークリッド距離</a>の計算のためにより小さい方が取られます。
これは、データ行列の最終列が意味のあるデータでない場合に役立ちます。<br />
If the numbers of elements - features - in records of <em>list-data</em> 
is different from the number of columns in the data or centroid matrix, 
then the smaller is taken for calculating the Euclidian distances. This 
is useful when the last column of the data matrix does not contain feature 
data, but labels identifying the cluster membership of a data point.</p>

<br/><br/>

<a name="kmeans-train"></a>
<h2><span class="function">kmeans-train</span></h2>
<h4>syntax: (kmeans-train <em>matrix-data</em> <em>int-k</em> <em>context</em> [<em>matrix-centroids</em>])</h4>

<p>この関数は、<em>matrix-data</em> に対して <a href="http://ja.wikipedia.org/wiki/K%E5%B9%B3%E5%9D%87%E6%B3%95">K 平均法</a>クラスター解析を行います。
 <i>n</i> 個のデータ全てが <em>int-k</em> 個のグループの中に別々に区分けされます。<br />
The function performs Kmeans cluster analysis on <em>matrix-data</em>. 
All <i>n</i> data records in <em>matrix-data</em> are partitioned into a number 
of <em>int-k</em> different groups. </p>

<p> <i>n * m</i> の <em>matrix-data</em> やオプションの <i>k * m</i> の <em>matrix-centroids</em> には、入れ子のリストも２次元アレイも使えます。<br />
Both, the <i>n * m</i> <em>matrix-data</em> and the optional <i>k * m</i>
<em>matrix-centroids</em> can be either nested lists or 2-dimensional arrays.</p>

<p>この <a href="http://ja.wikipedia.org/wiki/K%E5%B9%B3%E5%9D%87%E6%B3%95">K 平均法</a>アルゴリズムはクラスタ重心からの内部クラスター距離の二乗和（SSQ）を最小するように動作します。繰り返し動作する度に、重心は最終位置に近づきます。データ一式が同じでも、最終結果は最初の重心位置次第です。重心の初期値を適切に選択することで処理速度が早められ、望んでいない極小値も避けられます。<br />
The Kmeans algorithm tries to minimize the sum of squared inner cluster 
distances (SSQ) from the cluster centroid. With each iteration the centroids get 
moved closer to their final position. On some data sets, the end result can depend 
on the starting centroid points.  The right choice of initial centroids can speed 
up the process and avoid not wanted local minima.</p>

<p>オプションの <em>matrix-centroids</em> が与えられない時、各クラスターにはランダムデータ行が初期値として割り当てられ、重心の計算が始まります。<br />
When no optional <em>matrix-centroids</em> are given, <tt>kmeans-train</tt> will 
assign an initial random cluster membership to each data row and calculate starting 
centroids. </p>

<p><tt>kmeans-train</tt> は SSQ 全体のベクトルを返します。SSQ はクラスター内の重心からの全クラスターの内部距離の二乗和です。
繰り返しアルゴリズムは、 SSQ の変化が  1e-10 より小さくなった時に止まります。<br />
<tt>kmeans-train</tt> returns a vector of total SSQs, the sum of squared inner distances
from the centroid inside the cluster for all clusters. The Iterating algorithm stops when the
change of SSQ from one to the next iteration is less than 1e-10.</p>

<p>他の解析結果は、<em>コンテキスト</em> 変数の中にリストとして保存されています。<br />
Other results of the analysis are stored as lists in variables of <em>context</em>.</p>

<p>次の例は、 <i>m = 3</i> の 20 個のデータを解析し、 <i>k = 3</i> のクラスターに区分けします。
<i>k = 3</i> より大きい数を試すことができます。
平均内部クラスター距離で計測して高密度になるクラスターが目標となる結果です。<br />
The following example analyses 20 data records measuring <i>m = 3</i> features 
and tries to partition data into <i>k = 3</i> clusters. Other numbers than <i>k = 3</i> 
could be tried. The target is a result with few clusters of high density measured by the
average inner cluster distances.</p>

<pre>
(set 'data '(
(6.57 4.96 11.91) 
(2.29 4.18 1.06) 
(8.63 2.51 8.11) 
(1.85 1.89 0.11) 
(7.56 7.93 5.06) 
(3.61 7.95 5.11) 
(7.18 3.46 8.7) 
(8.17 6.59 7.49) 
(5.44 5.9 5.57) 
(2.43 2.14 1.59) 
(2.48 2.26 0.19) 
(8.16 3.83 8.93) 
(8.49 5.31 7.47) 
(3.12 3.1 1.4) 
(6.77 6.04 3.76) 
(7.01 4.2 11.9) 
(6.79 8.72 8.62) 
(1.17 4.46 1.02) 
(2.11 2.14 0.85) 
(9.44 2.65 7.37)))

(kmeans-train data 3 'MAIN:K) <span class='arw'>&rarr;</span> 
(439.7949357 90.7474276 85.06633163 82.74597619)

; cluster membership
K:labels <span class='arw'>&rarr;</span> (2 3 2 3 1 1 2 1 1 3 3 2 2 3 1 2 1 3 3 2)

; the centroid for each cluster
K:centroids <span class='arw'>&rarr;</span>
( (6.39 7.188333333 5.935) 
(7.925714286 3.845714286 9.198571429) 
(2.207142857 2.881428571 0.8885714286) )
</pre>

<p>戻り値は SSQ のリストで、各繰り返しで内部距離の二乗和が小さくなる様子を見せてくれます。
<tt>K:labels</tt> のリストは各データ点がどのクラスターにあるのかを示しています。データ点と同じ位置の数字がクラスターの番号です。<br />
The returned list of SSQs shows how in each iteration the sum of inner squared
distances decreases. The list in <tt>K:labels</tt> shows the membership fo each
data point in the same order as in the data.</p>

<p><tt>K:centroids</tt> の重心は、<a href="#kmeans-query">kmeans-query</a> を使う際に、新データの区分けに使うことができます。<br />
The centroids in <tt>K:centroids</tt> can be used for later classification
of new data records using <a href="#kmeans-query">kmeans-query</a>.</p>

<p>クラスターの要素からクラスター重心までの内部偏差 <tt>K:deviations</tt> は、クラスターの混み具合を示しています。
公式的には、<a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E7%A9%BA%E9%96%93#.E3.83.A6.E3.83.BC.E3.82.AF.E3.83.AA.E3.83.83.E3.83.89.E7.A9.BA.E9.96.93.E3.81.AE.E8.A8.88.E9.87.8F">ユークリッド距離</a>の計算や標準偏差の計算と似たような計算です。
偏差を二乗して各クラスターの大きさを掛けると各クラスターの内部 SSQ になります：<br />
The average inner <tt>K:deviations</tt> from cluster members to their centroid
show how dense a cluster is packed. Formally, deviations are calculated similarly
to Euclidian distances and to standard deviations in conventional statistics. 
Squaring the deviations and multiplying each with their cluster size 
(number of members in the cluster) shows the inner SSQ of each cluster:</p>

<pre>
; average inner deviations of cluster members to the centroid
; deviation = sqrt(ssq-of-cluster / n-of-cluster)
K:deviations  <span class='arw'>&rarr;</span> (2.457052209 2.260089397 1.240236975)

; calculating inner SSQs from cluster deviations
(map mul '(6 7 7) (map mul K:deviations K:deviations)) <span class='arw'>&rarr;</span>
(36.22263333 35.75602857 10.76731429) ; inner SSQs

; SSQ from last iteration as sum of inner SSQs
(apply add '(36.22263333 35.75602857 10.76731429)) <span class='arw'>&rarr;</span> 82.74597619
</pre>

<p><tt>K:clusters</tt> は、各クラスターのデータが元データではどの位置にあるかを与えてくれます。
これを使って、データのさらなる解析にのために、個々のクラスターを個別に取り出せます：<br />
<tt>K:clusters</tt> gives indices of data records into the original data
for each cluster. With these, individual clusters can be extracted from the
data for further analysis:</p>

<pre>
; ceach of the result clusters with indices into the data set
K:clusters <span class='arw'>&rarr;</span> 
( (4 5 7 8 14 16) 
(0 2 6 11 12 15 19) 
(1 3 9 10 13 17 18) )

; cluster of data records labeled 1 at offset 0
(select data (K:clusters 0)) <span class='arw'>&rarr;</span>
( (7.56 7.93 5.06) 
(3.61 7.95 5.11) 
(8.17 6.59 7.49) 
(5.44 5.9 5.57) 
(6.77 6.04 3.76) 
(6.79 8.72 8.62) )

; cluster of data records labeled 2 at offset 1
(select data (K:clusters 1)) <span class='arw'>&rarr;</span>
( (6.57 4.96 11.91) 
(8.63 2.51 8.11) 
(7.18 3.46 8.7) 
(8.16 3.83 8.93) 
(8.49 5.31 7.47) 
(7.01 4.2 11.9) 
(9.44 2.65 7.37) )

; cluster of data records labeled 3 at offset 2
(select data (K:clusters 2)) <span class='arw'>&rarr;</span>
( (2.29 4.18 1.06) 
(1.85 1.89 0.11) 
(2.43 2.14 1.59) 
(2.48 2.26 0.19) 
(3.12 3.1 1.4) 
(1.17 4.46 1.02) 
(2.11 2.14 0.85) )
</pre>


<p>次の最後の例では、データにクラスター・ラベル（1 から 3）を追加しています：<br />
In the last example the cluster labels (from 1 to 3) are added
to the data:</p>

<pre>
; append a cluster label to each data record
(set 'labeled-data (transpose (push K:labels (transpose data) -1)))

labeled-data: <span class='arw'>&rarr;</span>
( (6.57 4.96 11.91 2) 
(2.29 4.18 1.06 3) 
(8.63 2.51 8.11 2) 
(1.85 1.89 0.11 3) 
(7.56 7.93 5.06 1) 
(3.61 7.95 5.11 1) 
... ...
(2.11 2.14 0.85 3) 
(9.44 2.65 7.37 2) )
</pre>

<p>コードがある名前空間コンテキストで書かれる時は、結果の入るコンテキストには <tt>MAIN</tt> を先付けすべきです。
そのコンテキストが存在しない場合は、生成されます。<br />
The result context should be prefixed with <tt>MAIN</tt> when code is
written in a namespace context. If the context does not exists already, it
will be created.</p>

<p>先に <tt>kmeans-train</tt> を走らせ、<tt>K:labels</tt>、<tt>K:clusters</tt>、<tt>K:centroids</tt>、<tt>K:deviations</tt> の結果がすでに存在していても、上書きされます。<br />
Results in <tt>K:labels</tt>, <tt>K:clusters</tt>, <tt>K:centroids</tt>
and <tt>K:deviations</tt> will be overwritten, if already present from previous 
runs of <tt>kmeans-train</tt>.</p>

<br/><br/>


<a name="lambda"></a>

<h2><span class="function">lambda</span></h2>

<p><tt>lambda</tt> の省略形である <a href="#fn">fn</a> の説明を見てください。<br />
See the description of <a href="#fn">fn</a>, which is a shorter form of writing <tt>lambda</tt>.</p>

<br/><br/>

<a name="lambda-macro"></a>

<h2><span class="function">lambda-macro</span></h2>

<p><a href="#define-macro">define-macro</a> の説明を見てください。<br />
See the description of <a href="#define-macro">define-macro</a>.</p>

<br/><br/>

<a name="lambdap"></a>
<h2><span class="function">lambda?</span></h2>
<h4>syntax: (lambda? <em>exp</em>)</h4>

<p><em>exp</em> の値がラムダ式の場合のみ <tt>true</tt> を返し、それ以外では <tt>nil</tt> を返します。<br />
Returns <tt>true</tt> only if the value of <em>exp</em> is a lambda expression;
otherwise, returns <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(define (square x) (* x x)) <span class='arw'>&rarr;</span> (lambda (x) (* x x))

square <span class='arw'>&rarr;</span> (lambda (x) (* x x))

(lambda? square)  <span class='arw'>&rarr;</span> true
</pre>


<p><em>lambda</em> 式についてのさらなる情報は、<a href="#define">define</a> や <a href="#define-macro">define-macro</a> を見てください。<br />
See <a href="#define">define</a> and <a href="#define-macro">define-macro</a> for
more information about <em>lambda</em> expressions.
</p>
<br/><br/>

<a name="last"></a>

<h2><span class="function">last</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (last <em>list</em>)<br/>
syntax: (last <em>array</em>)<br/>
syntax: (last <em>str</em>)</h4>

<p>リストや文字列の最後の要素を返します。（訳注：Common Lisp の <em>last</em> は最後の要素をリストで返しますが、newLISP の <em>last</em> は要素のみを返します。）<br />
Returns the last element of a list or a string.
</p>

<!-- example -->

<pre>
(last '(1 2 3 4 5))  <span class='arw'>&rarr;</span> 5
(last '(a b (c d)))  <span class='arw'>&rarr;</span> (c d)

(set 'A (array 3 2 (sequence 1 6)))
<span class='arw'>&rarr;</span> ((1 2) (3 4) (5 6))
(last A)             <span class='arw'>&rarr;</span> (5 6)

(last '())           <span class='arw'>&rarr;</span> <span class='err'>ERR: list is empty</span>
</pre>
（訳注：最後の行は、Common Lispではエラーにならず <tt>nil</tt> が返ります。）


<p>第二形式では、文字列 <em>str</em> の最後の文字が文字列で返されます。<br />
In the second version the last character in the string <em>str</em> is returned as a
string.
</p>

<!-- example -->

<pre>
(last "newLISP")  <span class='arw'>&rarr;</span> "P"
</pre>


<p>UTF-8 版の newLISP では、<a href="#last">last</a> はバイト境界ではなく、キャラクタ境界で動作します。
<a href="#first">first</a>、<a href="#rest">rest</a>、<a href="#nth">nth</a> も見てください。<br />
Note that <a href="#last">last</a> works on character boundaries 
rather than byte boundaries 
when the UTF-8&ndash;enabled version of newLISP is used.
See also <a href="#first">first</a>, <a href="#rest">rest</a> and <a href="#nth">nth</a>.
</p>

<br/><br/>

<a name="last-error"></a>
<h2><span class="function">last-error</span></h2>
<h4>syntax: (last-error)<br/>
syntax: (last-error <em>int-error</em>)</h4>

<p>シンタックス・エラーやリソースの枯渇に起因する newLISP で生じた最後のエラーを報告します。
起こりうる全てのエラーのまとめは、付録の <a href="#error_codes">エラー コード</a> の章を見てください。<br />
Reports the last error generated by newLISP due to syntax errors or exhaustion of 
some resource. For a summary of all possible errors see the chapter 
<a href="#error_codes">Error codes</a> in the appendix.</p>

<p>newLISPセッションが始まってから一度もエラーが起こらなければ、<tt>nil</tt> が返ります。<br />
If no error has occurred since the newLISP session was started,
<tt>nil</tt> is returned.</p>

<p><em>int-error</em> が指定されると、その番号とエラー・テキストのリストが返ります。<br />
When <em>int-error</em> is specified, a list of the number and the error 
text is returned.</p>

<!-- example -->

<pre>
(last-error)  <span class='arw'>&rarr;</span> nil

(abc)

<span class='err'>ERR: invalid function : (abc)</span>

(last-error) <span class='arw'>&rarr;</span> (24 "ERR: invalid function : (abc)")

(last-error 24) <span class='arw'>&rarr;</span> (24 "invalid function")
(last-error 1) <span class='arw'>&rarr;</span> (1 "not enough memory")
(last-error 12345) <span class='arw'>&rarr;</span> (12345 "Unknown error")
</pre>


<p>エラー番号の範囲外では、<tt>"Unknown error"</tt> がエラー・テキストとして与えられます。<br />
For error numbers out of range the string <tt>"Unknown error"</tt> is
given for the error text.</p>

<p>エラーは、<a href="#error-event">error-event</a> とユーザ定義エラー・ハンドラで捕まえることができます。<br />
Errors can be trapped by <a href="#error-event">error-event</a> 
and user defined error handlers.</p>

<p>ネットワークの条件によって発生するエラー用の <a href="#net-error">net-error</a> やオペレーティング・システムによって発生するエラー用の <a href="#sys-error">sys-error</a> も見てください。<br />
See also <a href="#net-error">net-error</a> for errors generated by
networking conditions and <a href="#sys-error">sys-error</a> for errors
generated by the operating system.</p>

<br/><br/>

<a name="legalp"></a>
<h2><span class="function">legal?</span></h2>
<h4>syntax: (legal? <em>str</em>)</h4>

<p>
<em>str</em> の語句が newLISP シンボルとして適正かどうかを確かめます。
関数 <a href="#sym">sym</a> を使えば、適正でないシンボルをることが可能です（例えば、スペースやクォートを含むシンボルとか、その他、通常許可されない文字とか）。
連想データ・アクセスにそれらを使う時、非適正シンボルがよく生成されます。<br />
The token in <em>str</em> is verified as a legal newLISP symbol. 
Non-legal symbols can be created using the <a href="#sym">sym</a> function
(e.g. symbols containing spaces, quotes, or other characters not normally allowed). 
Non-legal symbols are created frequently 
when using them for associative data access:
</p>

<!-- example -->

<pre>
(symbol? (sym "one two"))  <span class='arw'>&rarr;</span> true

(legal? "one two")         <span class='arw'>&rarr;</span> nil  ; contains a space

(set (sym "one two") 123)  <span class='arw'>&rarr;</span> 123

(eval (sym "one two"))     <span class='arw'>&rarr;</span> 123
</pre>


<p>この例は、文字列 <tt>"one two"</tt> からシンボルが生成されて変数のように扱えたとしても、適正なシンボルとならない事を示しています。<br />
The example shows that the string <tt>"one two"</tt> does not contain a legal
symbol although a symbol can be created from this string and treated like a
variable.
</p>

<br/><br/>

<a name="length"></a>
<h2><span class="function">length</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (length <em>exp</em>)</h4>

<p>リストの要素数、アレイの行数、文字列やシンボル名のバイト数を返します。<br />
Returns the number of elements in a list, the number of rows in
an array and the number of bytes in a string or in a symbol name.</p>

<p><tt>length</tt> を数値に適用した場合、整数や大整数では桁数を返します。
浮動小数点では小数点より前の桁数（訳注：つまり、整数部の桁数）を返します。<br />
Applied to a number, <tt>length</tt> returns the number of digits for 
normal and big integers and the number of digits before the decimal 
separator for floats.</p>

<p>（訳注：上記以外の）他の型では、<tt>length</tt> は <tt>0</tt> を返します。<br />
<tt>length</tt> returns <tt>0</tt> on all other types.</p>

<p>バージョン 10.5.6 以前の <tt>length</tt> は、整数 (4 か 8) 、浮動小数点 (8) のように格納サイズをバイト数で返していました。<br />
Before version 10.5.6 <tt>length</tt> returned the storage size in bytes
for integers (4 or 8) and floats (8).</p>

<!-- example -->

<pre>
; number of top level elements in a list
(length '(a b (c d) e))         <span class='arw'>&rarr;</span> 4
(length '())                    <span class='arw'>&rarr;</span> 0
(set 'someList '(q w e r t y))  <span class='arw'>&rarr;</span> (q w e r t y)
(length someList)               <span class='arw'>&rarr;</span> 6

; number of top level elements in an array
(set 'ary (array 2 4 '(0)))  <span class='arw'>&rarr;</span> ((1 2 3 4) (5 6 7 8))
(length ary)                 <span class='arw'>&rarr;</span> 2

; number of bytes in a string or byte buffer
(length "Hello World")  <span class='arw'>&rarr;</span> 11
(length "")             <span class='arw'>&rarr;</span> 0
(length "\000\001\003") <span class='arw'>&rarr;</span> 3

; number of bytes in a symbol name string
(length 'someVar)  <span class='arw'>&rarr;</span> 7

; number of int digits in a number
(length 0)         <span class='arw'>&rarr;</span> 0
(length 123)       <span class='arw'>&rarr;</span> 3
(length 1.23)      <span class='arw'>&rarr;</span> 1
(length 1234567890123456789012345L) <span class='arw'>&rarr;</span> 25 
</pre>

<p>UTF-8 の文字数計算には <a href="#utf8len">utf8len</a> を使ってください。<br />
Use <a href="#utf8len">utf8len</a> to calculate the number of UTF-8 characters 
in a string.</p>

<br/><br/>

<a name="let"></a>
<h2><span class="function">let</span></h2>
<h4>syntax: (let ((<em>sym1</em> [<em>exp-init1</em>]) [(<em>sym2</em> [<em>exp-init2</em>]) ... ]) <em>body</em>)<br/>
syntax: (let (<em>sym1</em> <em>exp-init1</em> [<em>sym2</em> <em>exp-init2</em> ... ]) <em>body</em>)</h4>

<p>一個以上の変数 <em>sym1</em>, <em>sym2</em>, ... が、<em>exp-init1</em>, <em>exp-init2</em>, ... を初期値としてローカルに宣言されます。
完全に括弧で括られた第一構文では初期値がオプションとなり、見つからない場合は <tt>nil</tt> になります。<br />
One or more variables <em>sym1</em>, <em>sym2</em>, ... are declared locally and
initialized with expressions in <em>exp-init1</em>, <em>exp-init2</em>, etc.
In the fully parenthesized first syntax, initializers are optional and assumed 
<tt>nil</tt> if missing.</p>

<p>ローカル変数が初期化される時、初期化式は <tt>let</tt> 宣言文より前に束縛されたシンボルを使って評価されます。（訳注：つまり、<tt>let</tt> で初期化中の評価で束縛されたシンボルは使われません。そのため、）
<tt>let</tt> の初期化中の評価で束縛されたシンボルを順次使いたい時は、<a href="#letn">letn</a> を使ってください。<br />
When the local variables are initialized, the initializer expressions evaluate
 using symbol bindings as before the <tt>let</tt> statement. To incrementally use
symbol bindings as evaluated during the initialization of locals in <tt>let</tt>,
use <a href="#letn">letn</a>.</p>

<p><em>exp-body</em> の一個以上の式がローカルに定義された <em>sym1</em>, <em>sym2</em> 他を使って評価されます。
<tt>let</tt> は使われる場所が閉じているローカル変数を定義するので、複雑な式を分解するために役立ちます。
第二形式は機能的に変わらずに、変数式対周りの括弧を省略できます。
<br />
One or more expressions in <em>exp-body</em> are evaluated using the local
definitions of <em>sym1</em>, <em>sym2</em> etc. <tt>let</tt> is useful for
breaking up complex expressions by defining local variables close to the
place where they are used. The second form omits the parentheses around the
variable expression pairs but functions identically.</p>

<!-- example -->

<pre>
(define (sum-sq a b)
    (let ((x (* a a)) (y (* b b)))
        (+ x y)))

(sum-sq 3 4) <span class='arw'>&rarr;</span> 25

(define (sum-sq a b)           ; alternative syntax
    (let (x (* a a) y (* b b))
        (+ x y)))
</pre>


<p>変数 <tt>x</tt> と <tt>y</tt> が初期化されてから、式 <tt>(+ x y)</tt> が評価されます。
この let 形式は本当に効率的な形で、書くのが楽になる構文です：<br />
The variables <tt>x</tt> and <tt>y</tt> are initialized, then the expression

<tt>(+ x y)</tt> is evaluated. The let form is just an optimized version and syntactic
convenience for writing:
</p>

<pre>
((lambda (<em>sym1</em> [<em>sym2</em> ... ]) <em>exp-body</em> ) <em>exp-init1</em> [ <em>exp-init2</em> ])
</pre>

<p>入れ子構造的 <tt>let</tt> 用の <a href="#letn">letn</a> と <tt>nil</tt> に初期化する <a href="#local">local</a> も見てください。
<a href="#local">local</a> は変数を自動的に <tt>nil</tt> に初期化します。<br />
See also <a href="#letn">letn</a> for an incremental or nested form of
<tt>let</tt> and local for initializing to <tt>nil</tt>. See <a href="#local">local</a>
for automatic initialization of variables to <tt>nil</tt>.</p>

<blockquote>
（訳例：
<pre>
> (let ((x) (y) (z)) (setq x 1 y 2 z 3) (list x y z))
(1 2 3)
> (list x y z)
(nil nil nil)
> (let (x y z) (println (list x y z))(setq x 1 y 2 z 3) (list x y z))
(nil nil nil)
(1 2 3)
> (list x y z)
(nil 2 nil)
> 
</pre>
第二形式 の <tt>let</tt> で、変数を全て <tt>nil</tt> にしようとして二番目の例のように記述すると、不用意に（上記、y のような）グローバル変数を作ってしまいますので、ご注意を。（私だけかもしれませんが、、、汗）
<pre>
> (local (x y z) (println (list x y z))(setq x 1 y 2 z 3) (list x y z))
(nil nil nil)
(1 2 3)
> (list x y z)
(nil nil nil)
> 
</pre>
全て <tt>nil</tt> で初期化したい場合は、このように <a href="#local">local</a> が便利です。）
</blockquote>

<br/><br/>

<a name="letex"></a>
<h2><span class="function">letex</span></h2>
<h4>syntax: (letex ((<em>sym1</em> [<em>exp-init1</em>]) [(<em>sym2</em> [<em>exp-init2</em>]) ... ]) <em>body</em>)<br/>

syntax: (letex (<em>sym1</em> <em>exp-init1</em> [<em>sym2</em> <em>exp-init2</em> ... ]) <em>body</em>)</h4>

<p>この関数は、<a href="#let">let</a> と
ローカル変数を評価する前に式に展開する <a href="#expand">expand</a> との組み合わせです。
完全に括弧で括られた第一構文では初期値はオプションとなり、見つからない場合は <tt>nil</tt> になります。<br />
This function combines <a href="#let">let</a> and <a href="#expand">expand</a> to 
expand local variables into an expression before evaluating it. In the fully parenthesized 
first syntax initializers are optional and assumed <tt>nil</tt> if missing.</p>

<p>どちらの形式も機能的には同じですが、第二形式では（訳注：<a href="#let">let</a> と同じように）初期化周りの括弧が省略できます：<br />
Both forms provide the same functionality, but in the second form the parentheses 
around the initializers can be omitted:
</p>

<!-- example -->

<pre>
(letex (x 1 y 2 z 3) '(x y z))    <span class='arw'>&rarr;</span> (1 2 3)

(letex ( (x 1) (y '(a b c)) (z "hello") ) '(x y z)) 

<span class='arw'>&rarr;</span> (1 (a b c) "hello")
</pre>

<p>式 <tt>'(x y z)</tt> が評価を得る前に、<tt>x</tt>、<tt>y</tt>、<tt>z</tt>は <tt>letex</tt> の初期化リストの初期値で文字通り置き換えられます。
最終的に評価を得る式は <tt>'(1 2 3)</tt> となります。<br />
Before the expression <tt>'(x y z)</tt> gets evaluated, <tt>x, y</tt> and <tt>z</tt>
are literally replaced with the initializers from the <tt>letex</tt> initializer list.
The final expression which gets evaluated is <tt>'(1 2 3)</tt>.
</p>

<blockquote>（訳例：
<pre>
> (let (x 1 y 2 z 3) (print (list x y z)) '(x y z))
(1 2 3)(x y z)
> (letex (x 1 y 2 z 3) (print (list x y z)) '(x y z))
(1 2 3)(1 2 3)
> (let ( (x 1) (y '(a b c)) (z "hello") ) (print (list x y z))'(x y z))
(1 (a b c) "hello")(x y z)
> (letex ( (x 1) (y '(a b c)) (z "hello") ) (print (list x y z))'(x y z))

ERR: invalid function in function list : (a b c)
> 
</pre>このように、
<a href="#let">let</a> では、x、y、z に 1、2、3 が代入されるのに対して、
<a href="#letex">letex</a> では、文字通り置き換わります。<br>
置き換わる式は、評価された初期値です。そのため、
<pre>
> (let ( (x 1) (y '(a b c)) (z "hello") ) (print (list x y z))'(x y z))
(1 (a b c) "hello")(x y z)
> (letex ( (x 1) (y '(a b c)) (z "hello") ) (print (list x y z))'(x y z))

ERR: invalid function in function list : (a b c)
> (letex ( (x 1) (y '(a b c)) (z "hello") ) (print (list x 'y z))'(x y z))
(1 (a b c) "hello")(1 (a b c) "hello")
> 
</pre>
使い方によっては、この例の y のように先付けのクォートが必要なこともあります。）
</blockquote>

<p>二番目の例として、加算関数を作る関数 <tt>make-adder</tt> を定義します:<br />
In the second example a function <tt>make-adder</tt> is defined
for making adder functions:</p>

<pre>
(define (make-adder n)
    (letex (c n) (lambda (x) (+ x c))))

(define add3 (make-adder 3)) <span class='arw'>&rarr;</span> (lambda (x) (+ x 3))

(add3 10) <span class='arw'>&rarr;</span> 13

; letex can expand symbols into themselves
; the following form also works

(define (make-adder n)
     (letex (n n) (lambda (x) (+ x n))))
</pre>

<p><tt>letex</tt> は <tt>n</tt> を定数 <tt>3</tt> に評価して、ラムダ式内の <tt>c</tt> と置き換えます。二番目の例では、<tt>letex</tt> で同じ変数名で行うやり方を示しています。（訳注:言うまでもありませんが、<a href="#let">let</a> や <a href="#letn">letn</a> では、ラムダ式内の変数を置き換えることはできません。）<br />
<tt>letex</tt> evaluates <tt>n</tt> to the constant <tt>3</tt> and replaces <tt>c</tt>
with it in the lambda expression. The second examples shows, how a <tt>letex</tt>
variable can be expanded into itself.</p>

<br/><br/>

<a name="letn"></a>
<h2><span class="function">letn</span></h2>
<h4>syntax: (letn ((<em>sym1</em> [<em>exp-init1</em>]) [(<em>sym2</em> [<em>exp-init2</em>]) ... ]) <em>body</em>)<br/>
syntax: (letn (<em>sym1</em> <em>exp-init1</em> [<em>sym2</em> <em>exp-init2</em> ... ]) <em>body</em>)</h4>

<p><tt>letn</tt> は、<em>入れ子になった let</em> とも考えられ、<a href="#let">let</a> の様に動作します。
しかし、<a href="#let">let</a> を入れ子にしていったように、初期化式を評価する時、新たなシンボル束縛を順次使っていきます。
完全に括弧で括られる第一構文では初期値はオプションとなり、見つからない場合は <tt>nil</tt> になります。<br />
<tt>letn</tt> is like a <em>nested let</em> and works similarly to <a href="#let">let</a>, 
but will incrementally use the new symbol bindings when evaluating the initializer expressions 
as if several <a href="#let">let</a> were nested. In the fully parenthesized first syntax, 
initializers are optional and assumed <tt>nil</tt> if missing.</p>

<p>次の <a href="#let">let</a> と <tt>letn</tt> の比較が、その違いを示しています：<br />
The following comparison
of <a href="#let">let</a> and <tt>letn</tt> show the difference:
</p>

<!-- example -->

<pre>
(set 'x 10)
(let ((x 1) (y (+ x 1))) 
(list x y))           <span class='arw'>&rarr;</span> (1 11)

(letn ((x 1) (y (+ x 1))) 
(list x y))          <span class='arw'>&rarr;</span> (1 2)
</pre>


<p><a href="#let">let</a> を使っている最初の例で、変数 <tt>y</tt> は <a href="#let">let</a> 式より前に束縛された <tt>x</tt> を使って計算されます。
<tt>letn</tt> を使った二番目の例で、変数 <tt>y</tt> は新たにローカルで束縛された <tt>x</tt> を使って計算されます。<br />
While in the first example using <a href="#let">let</a> the variable <tt>y</tt> is
calculated using the binding of <tt>x</tt> before the <a href="#let">let</a> expression,
in the second example using <tt>letn</tt> the variable <tt>y</tt> is calculated using 
the new local binding of <tt>x</tt>.
</p>


<pre>
(letn  (x 1 y x) 
    (+ x y))     <span class='arw'>&rarr;</span>  2

;; same as nested let's

(let (x 1)
    (let (y x)
      (+ x y)))  <span class='arw'>&rarr;</span>  2
</pre>


<p><tt>letn</tt> は、<em>入れ子になった</em> <a href="#let">let</a> の様に動作します。
初期化周りの括弧は、省略できます。<br />
<tt>letn</tt> works like several <em>nested</em> <a href="#let">let</a>. The parentheses
around the initializer expressions can be omitted.
</p>

<br/><br/>

<a name="list"></a>
<h2><span class="function">list</span></h2>
<h4>syntax: (list <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p><em>exp</em> が評価され、その値が新しいリストを構成するために使われます。
アレイ型の引数は、リスト型に変換されますので注意してください。
多次元リストを処理する際は<a href="#arrays">アレイ</a>の章も見てください。<br />
The <em>exp</em> are evaluated and the values used to construct a new list.
Note that arguments of array type are converted to lists. See the chapter 
<a href="#arrays">Arrays</a> for dealing with multidimensional lists.
</p>

<!-- example -->

<pre>
(list 1 2 3 4 5)                <span class='arw'>&rarr;</span> (1 2 3 4 5)
(list 'a '(b c) (+ 3 4) '() '*) <span class='arw'>&rarr;</span> (a (b c) 7 () *)
</pre>


<p>
リストに束縛する他の形式として <a href="#cons">cons</a> や <a href="#push">push</a> も見てください。<br />
See also <a href="#cons">cons</a> and <a href="#push">push</a> for other
forms of building lists.
</p>

<br/><br/>

<a name="listp"></a>
<h2><span class="function">list?</span></h2>
<h4>syntax: (list? <em>exp</em>)</h4>

<p>
<em>exp</em> の値がリストの時のみ <tt>true</tt> が返り、それ以外では <tt>nil</tt> が返ります。
ラムダ式やラムダ-マクロ式もリスト式の特殊な形として認識されることに注意してください。<br />
Returns <tt>true</tt> only if the value of <em>exp</em> is a list; otherwise
returns <tt>nil</tt>.  Note that lambda and lambda-macro
expressions are also recognized as special instances of a list expression.
</p>

<!-- example -->

<pre>
(set 'var '(1 2 3 4))    <span class='arw'>&rarr;</span> (1 2 3 4)
(list? var)              <span class='arw'>&rarr;</span> true

(define (double x) (+ x x))

(list? double)           <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="load"></a>

<h2><span class="function">load</span></h2>
<h4>syntax: (load <em>str-file-name-1</em> [<em>str-file-name-2</em> ... ] [<em>sym-context</em>])</h4>

<p>一個以上の <em>str-file-name</em> で指定されるソール・ファイルをロードして newLISP に翻訳し、そのファイルに含まれる式群を評価します。
ロードに成功すると、<tt>load</tt> は最後のファイルの最後の式の結果を返し、ロードできなかった時はエラーを起こします。<br />
Loads and translates newLISP from a source file specified in one or more <em>str-file-name</em> 
and evaluates the expressions contained in the file(s). When loading is successful,
<tt>load</tt> returns the result of the last expression in the last file evaluated. If a file 
cannot be loaded, <tt>load</tt> throws an error.
</p>

<p>ロードしているファイル内にコンテキスト切り替えが存在しない限り、評価のコンテキスト用にオプションの <em>sym-context</em> が指定できます。
<a href="#context">context</a> 切り替えを含んでいないファイルは、デフォルトで <tt>MAIN</tt> コンテキストにロードされます。<br />
An optional <em>sym-context</em> can be specified, 
which becomes the context of evaluation, 
unless such a context switch is already present 
in the file being loaded. 
By default, 
files which do not contain <a href="#context">context</a> switches 
will be loaded into the <tt>MAIN</tt> context.
</p>

<p><em>str-file-name</em> の種類には URL も含まれます。
<tt>http://</tt> と <tt> file://</tt> のどちらの URL もサポートされます。<br />
The <em>str-file-name</em> specs can contain URLs. Both <tt>http://</tt> and <tt> file://</tt>
URLs are supported.
</p>

<!-- example -->

<pre>
(load "myfile.lsp")    

(load "a-file.lsp" "b-file.lsp") 

(load "file.lsp" "http://mysite.org/mypro")

(load "http://192.168.0.21:6000//home/test/program.lsp")

(load "a-file.lsp" "b-file.lsp" 'MyCTX)

(load "file:///usr/local/share/newlisp/mysql.lsp")
</pre>


<p><tt>load</tt> 中に評価される式が <a href="#context">context</a> を変える場合でも、<tt>load</tt> を実行しているプログラミング・モジュールに影響を与えません。<br />
In case expressions evaluated during the <tt>load</tt> are changing the 
<a href="#context">context</a>, this will not influence the programming
module doing the <tt>load</tt>. </p>

<p><tt>load</tt> 後の現在のコンテキストは、<tt>load</tt> 前と常に同じです。<br />
The current context after the <tt>load</tt> statement will always be 
the same as before the <tt>load</tt>.</p>

<p>通常のファイルの <ruby>類<rp>（</rp><rt>たぐい</rt><rp>）</rp></ruby>と URL は、同じロード・コマンド内に混在可能です。<br />
Normal file specs and URLs can be mixed in the same load command.</p>

<p><tt>HTTP</tt> URL の <tt>load</tt> は、Unix ライクなオペレーティングシステムで走っている newLISP サーバーからリモートでコードをロードするためにも使えます。
このモードで、<tt>load</tt> は目標とする URL に HTTP GET <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を出します。
パス名がルート・ディレクトリから相対的に指定されている時、二つのバックスラッシュが要求されることに気を付けてください。
<tt>HTTP</tt> モードの <tt>load</tt> は、60秒のタイムアウトを見ます。<br />
<tt>load</tt> with <tt>HTTP</tt> URLs can also be used to load code
remotely from newLISP server nodes running on a Unix-like operating system. 
In this mode, <tt>load</tt> will issue
an HTTP GET request to the target URL. Note that a double backslash is required 
when path names are specified relative to the root directory. <tt>load</tt>
in <tt>HTTP</tt> mode will observe a 60-second timeout.</p>

<p>最後から二つ目の行は、ファイルをコンテキスト <tt>MyCTX</tt> にロードします。
クォートは、そのコンテキストが存在しない時の生成を促します。<br />
The second to last line causes the files to be loaded into the context <tt>MyCTX</tt>.
The quote forces the context to be created if it did not exist.
</p>

<p><tt>file://</tt> URL は、三つ目の <tt>/</tt> の後にディレクトリの詳細を続けます。<br />
The <tt>file://</tt> URL is followed by a third <tt>/</tt> for the directory spec.
</p>

<br/><br/>

<a name="local"></a>
<h2><span class="function">local</span></h2>
<h4>syntax: (local (<em>sym-1</em> [<em>sym-2</em> ... ]) <em>body</em>)</h4>

<p>
一個以上のシンボル <em>sym-1&ndash;</em> を <tt>nil</tt> に初期化し、<em>body</em> の式群を評価します。<br />
Initializes one or more symbols 
in <em>sym-1&mdash;</em> to <tt>nil</tt>, 
evaluates the expressions in <em>body</em>, 
and returns the result of the last evaluation.
</p>

<p>local</tt> は <a href="#let">let</a> の様に動作しますが、ローカル変数は全て <tt>nil</tt> に初期化されます。<br />
<tt>local</tt> works similarly to <a href="#let">let</a>,
but local variables are all initialized to <tt>nil</tt>.
</p>

<p>
<tt>local</tt> は、明示的な初期化無しにローカル変数を提供する簡単な方法です。<br />
<tt>local</tt> provides a simple way 
to localize variables 
without explicit initialization.
</p>

<br/><br/>

<a name="log"></a>
<h2><span class="function">log</span></h2>
<h4>syntax: (log <em>num</em>)<br/>

syntax: (log <em>num</em> <em>num-base</em>)</h4>

<p>第一構文では、<em>num</em> の式が評価され、その結果から<a href="http://ja.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E5%AF%BE%E6%95%B0">自然対数</a>を計算します。<br />
In the first syntax, the expression in <em>num</em> is evaluated and the natural
logarithmic function is calculated from the result.
</p>

<!-- example -->

<pre>
(log 1)         <span class='arw'>&rarr;</span> 0
(log (exp 1))   <span class='arw'>&rarr;</span> 1
</pre>


<p>第二構文では、任意の底として <em>num-base</em> を指定できます。<br />
In the second syntax, an arbitrary base can be specified in <em>num-base</em>.
</p>

<!-- example -->

<pre>
(log 1024 2)             <span class='arw'>&rarr;</span> 10
(log (exp 1) (exp 1))    <span class='arw'>&rarr;</span>  1
</pre>


<p><b><em>e</em></b> (2.718281828) を底とする <tt>log</tt> の逆関数 <a href="#exp">exp</a> も見てください。<br />
See also <a href="#exp">exp</a>, which is the inverse function to <tt>log</tt> with
base <b><em>e</em></b> (2.718281828).</p>

<br/><br/>

<a name="lookup"></a>
<h2><span class="function">lookup</span></h2>
<h4>syntax: (lookup <em>exp-key</em> <em>list-assoc</em> [<em>int-index</em> [<em>exp-default</em>]])</h4>

<p>連想リスト <em>list-assoc</em> 中から <em>exp-key</em> と同じ値を持つキー要素を見つけ、その連想の <em>int-index</em> の要素を返します（<em>int-index</em> がない場合は、最後の要素) 。<br />
Finds in <em>list-assoc</em> an association, the key element of which
has the same value as <em>exp-key</em>, and returns the <em>int-index</em> element of
association (or the last element if <em>int-index</em> is absent).</p>

<p><em>exp-key</em> に一致する連想が見つからなかった時に返す <em>exp-default</em> を、オプションで指定できます。
<em>exp-default</em> がなくて、連想が見つからなかった時は <tt>nil</tt> が返ります。<br />
Optionally, <em>exp-default</em> can be specified, which is returned if an association matching
<em>exp-key</em> cannot be found. If the <em>exp-default</em> is absent and no association
has been found, <tt>nil</tt> is returned.</p>

<p><a href="#indexing">文字列、リスト、アレイの要素指定</a> も見てください。<br />
See also <a href="#indexing">Indexing elements of strings and lists</a>.
</p>

<p><tt>lookup</tt> は <a href="#assoc">assoc</a> に似ていますが、見つかったリストから要素を指定して取り出す手間が省けます。<br />
<tt>lookup</tt> is similar to <a href="#assoc">assoc</a> but goes one step further 
by extracting a specific element found in the list.
</p>

<!-- example -->

<pre>
(set 'params '(
    (name "John Doe") 
    (age 35) 
    (gender "M") 
    (balance 12.34)
))

(lookup 'age params)             <span class='arw'>&rarr;</span> 35

; use together with setf to modify and association list
(setf (lookup 'age params) 42)   <span class='arw'>&rarr;</span> 42
(lookup 'age params)             <span class='arw'>&rarr;</span> 42

(set 'persons '(
    ("John Doe" 35 "M" 12.34) 
    ("Mickey Mouse" 65 "N" 12345678)
))

(lookup "Mickey Mouse" persons 2)    <span class='arw'>&rarr;</span> "N"
(lookup "Mickey Mouse" persons -3)   <span class='arw'>&rarr;</span> 65
(lookup "John Doe" persons 1)        <span class='arw'>&rarr;</span> 35 
(lookup "John Doe" persons -2)       <span class='arw'>&rarr;</span> "M"

(lookup "Jane Doe" persons 1 "N/A")  <span class='arw'>&rarr;</span> "N/A"
</pre>

<p><a href="#assoc">assoc</a> も見てください。<br />
See also <a href="#assoc">assoc</a></p>

<br/><br/>

<a name="lower-case"></a>
<h2><span class="function">lower-case</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (lower-case <em>str</em>)</h4>

<p>
文字列 <em>str</em> 中の文字を小文字に変換します。
新しい文字列が作られ、オリジナルは変わずに残ります。<br />
Converts the characters of the string 
in <em>str</em> to lowercase. 
A new string is created, 
and the original is left unaltered.
</p> 


<!-- example -->

<pre>
(lower-case "HELLO WORLD")  <span class='arw'>&rarr;</span> "hello world"
(set 'Str "ABC")
(lower-case Str)  <span class='arw'>&rarr;</span> "abc"
Str               <span class='arw'>&rarr;</span> "ABC"
</pre>


<p>
関数 <a href="#upper-case">upper-case</a> や <a href="#title-case">title-case</a> も見てください。<br />
See also the <a href="#upper-case">upper-case</a> and 
<a href="#title-case">title-case</a> functions.
</p>

<br/><br/>

<a name="macro"></a>
<h2><span class="function">macro</span></h2>
<h4>syntax: (macro (<em>sym-name</em> [<em>sym-param-1</em> ... ]) [<em>body-1</em> ... ])</h4>

<p>この関数 <tt>macro</tt> は拡張マクロ（訳注：<em>macro</em>）の定義に使います。
<tt>macro</tt> の構文は <a href="#define-macro">define-macro</a> の構文と同一です。
けれども、<tt>define</tt> がランタイム中に評価される関数を定義するのに対して、<tt>macro</tt> はソースのロード時や読み込み処理中に使われる <em>fexpr</em> 関数（訳注： <a href="http://en.wikipedia.org/wiki/Fexpr">fexpr</a> とは、オペランドが評価されずに渡される関数）を定義して、特定の式が呼び出された時にそれを異なる形に変換します。<br />
The <tt>macro</tt> function is used to define expansion macros. The syntax 
of <tt>macro</tt> is identical to the syntax of <a href="#define-macro">define-macro</a>.
But while <tt>define-macro</tt> defines are <em>fexprs</em> functions to be evaluated 
at run-time, <tt>macro</tt> defines a function to be used during the source loading 
and reading process to transform certain expression call patterns into different call 
patterns.</p>

<pre>
(macro (double X) (+ X X)) <span class='arw'>&rarr;</span> (lambda-macro (X) (expand '(+ X X)))

(double 123) <span class='arw'>&rarr;</span> 246
</pre>

<p>シンボル呼び出し形式に定義された <tt>macro</tt> は、全て、読み出し時の内部処理で <a href="#expand">expand</a> 式を使って翻訳されます。
この様子を、<a href="#read-expr">read-expr</a> 関数を使って見ることができます：<br />
Internally all <tt>macro</tt> defined symbol call patterns are translated using
the <a href="#expand">expand</a> expression during source reading. This can be shown using
the <a href="#read-expr">read-expr</a> function:</p>

<pre>
(read-expr "(double 123)") <span class='arw'>&rarr;</span> (+ 123 123)
</pre>

<p>展開される変数名は全て大文字で始まらなければなりません。
<em>macro</em> の中に他の <em>macro</em> 定義を入れ子することができます。
しかしながら、同一 newLISP セッション内では <tt>macro</tt> による定義を同じシンボルに何度も繰り返し適用することはできません。
マクロを再定義したい場合（例えば、<tt>macro</tt> で定義された存在を別の定義でソース読み込みに使いたい時）は、下記のように関数 <a href="#constant">constant</a> を使ってください：<br />
All variable names to be expanded must start in upper-case. Macros can be nested containing 
other macros defined earlier. But <tt>macro</tt> definitions cannot be repeated for the same 
symbol during the same newLISP session. To redefine a macro, e.g. for reading source with a 
different definition of an exisiting <tt>macro</tt> definition, use the 
<a href="#constant">constant</a> function in the following way:</p>

<pre>
; change existing macro 'double' to allow floating point parameters
; use upper-case for variables for expansion

(constant 'double (lambda-macro (X) (expand '(add X X))))
<span class='arw'>&rarr;</span> (lambda-macro (X) (expand '(add X X)))

(double 1.23) <span class='arw'>&rarr;</span> 2.46
</pre>

<p><a href="#constant">constant</a> は <em>macro</em> の再定義に使えるだけで、新 <em>macro</em> の生成にも使えないことに注意してください。
newLISP 内部処理において、シンボルに定義された <tt>macro</tt> はソースの読み込み時に実行されますが、評価はしません。<br />
Note, that <a href="#constant">constant</a> can be used only to re-define macros, not
to create new macros. Internally newLISP knows that <tt>macro</tt> defined symbols
are executed during source reading, not evaluation.</p>

<p>再定義は、新たに読み込まれるコードにのみ影響を与えます。既にロードされたコードやリーダー・ルーチンで翻訳されたコードには影響を与えません。、<br />
The redefinition will only affect future read code, it will not affect
code already load and translated by the reader routines.</p>

<h3>Using <tt>map</tt> and <tt>apply</tt> with <tt>macro</tt>（<tt>map</tt> や <tt>apply</tt> での <tt>macro</tt> の使用）</h3>

<p><em>macro</em> に <tt>map</tt> や <tt>apply</tt> を使うと、拡張関数が展開されます：<br />
When mapping macros using <a href="#map">map</a> or <a href="#apply">apply</a>
the expansion function is mapped:</p>

<pre>
<b>&gt;</b> (macro (double X) (+ X X))
<b>(lambda-macro (X) (expand '(+ X X)))</b>

<b>&gt;</b> (map double '(1 2 3 4 5))
<b>((+ 1 1) (+ 2 2) (+ 3 3) (+ 4 4) (+ 5 5))

&gt;</b> (map eval (map double '(1 2 3 4 5)))
<b>(2 4 6 8 10)</b>

<b>&gt;</b> (apply double '(10))
<b>(+ 10 10)
&gt;</b>
</pre>
<p><tt>macro</tt> での定義がソース読み込み時にどのように動作するかを、この様子が教えてくれます。<br />
This is useful to find out how the expansion mechanism of our <tt>macro</tt>
definition works during source load time.</p>

<h3>Differences between <tt>macro</tt> and <tt>define-macro</tt> and potential problems.（<tt>macro</tt> と <tt>define-macro</tt> との相違点、及び潜在する問題点）</h3>

<p><tt>macro</tt> による定義は、<a href="define-macro">define-macro</a> で作られる <tt>fexpr</tt> に存在する<em>変数補足</em> に対して、耐性があります。<br />
<tt>macro</tt> definitions are not susceptible to <em>variable capture</em> as 
are fexprs made with <a href="define-macro">define-macro</a>:</p>

<pre>
(define-macro (fexpr-add A B) 
    (+ (eval A) (eval B)))

(macro (mac-add A B) 
    (+ A B))

(set 'A 11 'B 22)

; variable capture when using the same symbols 
; used as locals in define-macro for callling

(fexpr-add A B) <span class='arw'>&rarr;</span>
; or
(fexpr-add B A) <span class='arw'>&rarr;</span>
<span class="err">ERR: value expected : A
called from user defined function fexpr-add</span>

; no variable capture when doing the same with 
; expansion macros

(mac-add A B) <span class='arw'>&rarr;</span> 33

(mac-add B A) <span class='arw'>&rarr;</span> 33
</pre>

<p>とは言え、<tt>macro</tt> を使った拡張マクロにも、<tt>define-macro</tt> の時のような望んではいない二重評価が存在します：<br />
But expansion macros using <tt>macro</tt> are susceptible to unwanted double
evaluation, just like <tt>define-macro is</tt>:</p>

<pre>
(define-macro (fexpr-double X) 
    (+ (eval X) (eval X)))

(macro (mac-double X) 
    (+ X X))

(set 'a 10)
(fexpr-double (inc a)) <span class='arw'>&rarr;</span> 23 ; not 22 as expected

(set 'a 10)
(mac-double (inc a)) <span class='arw'>&rarr;</span> 23 ; not 22 as expected
</pre>

<p>どちらの場合も、内包する <tt>(inc a)</tt> 式が二回評価されています。
<tt>macro</tt> 式や <tt>define-macro</tt> 式を書く時は、このことを考量しておく必要があります。<br />
In both cases the incoming expression <tt>(inc a)</tt> gets evaulated twice.
This must be considered when writing both, <tt>macro</tt> or <tt>define-macro</tt>
expressions and symbols occur more than once in the body of the definition.</p> 

<p>ソース・コード読み取り中に式を一般処理する <a href="#reader-event">reader-event</a> も見てください。<br />
See also <a href="#reader-event">reader-event</a> for general preprocessing
of expressions during reading of source code.</p>

<br/><br/>

<a name="macrop"></a>
<h2><span class="function">macro?</span></h2>
<h4>syntax: (macro? <em>exp</em>)</h4>

<p><em>exp</em> がラムダ・マクロ式に評価される時に <tt>true</tt> を返し、それ以外では <tt>nil</tt> を返します。<br />
Returns <tt>true</tt> if <em>exp</em> evaluates 
to a lambda-macro expression; 
otherwise, <tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(define-macro (mysetq lv rv) (set lv (eval rv)))

(macro? mysetq)  <span class='arw'>&rarr;</span> true

(macro (my-setq Lv Rv) (set 'Lv Rv))

(macro? my-setq) <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="main-args"></a>
<h2><span class="function">main-args</span></h2>
<h4>syntax: (main-args)<br/>

syntax: (main-args <em>int-index</em>)</h4>

<p><tt>main-args</tt> は、プログラムの実行名とコマンド・ラインの引数を各々文字列にしたものをメンバーとするリストを返します。<br />
<tt>main-args</tt> returns a list 
with several string members, 
one for program invocation 
and one for each of 
the command-line arguments.
</p>

<!-- example -->

<pre>
newlisp 1 2 3

&gt; (main-args)
<b>("/usr/local/bin/newlisp" "1" "2" "3")</b>
</pre>


<p>コマンド・プロンプトで <tt>newlisp 1 2 3</tt> が実行された後、<tt>main-args</tt> は実施プログラム名とコマンド・ラインの引数の入ったリストを返します。<br />
After <tt>newlisp 1 2 3</tt> is executed at the command prompt, 
<tt>main-args</tt> returns a list containing the name of 
the invoking program and three command-line arguments.
</p>

<p><tt>main-args</tt> はオプションで、リストの要素指定用 <em>int-index</em> を取ることができます。
要素位置が範囲外なら、戻り値はリストの最後の要素ではなく、リストの要素指定のように <tt>nil</tt> になることに注意してください。<br />
Optionally, <tt>main-args</tt> can take 
an <em>int-index</em> for indexing into the list.
Note that an index out of range will cause <tt>nil</tt>
to be returned, not the last element of the list like
in list-indexing.
</p>


<pre>
newlisp a b c

&gt; (main-args 0)   
<b>"/usr/local/bin/newlisp"</b>
&gt; (main-args -1)  
<b>"c"</b>
&gt; (main-args 2)   
<b>"b"</b>
&gt; (main-args 10)
<b>nil</b>
</pre>


<p>newLISP がスクリプトから実行される場合は、<tt>main-args</tt> がスクリプトの <em>名前</em>も二番目の引数として返すことに注意してください：<br />
Note that when newLISP is executed from a script, 
<tt>main-args</tt> also returns the <em>name</em> 
of the script as the second argument:
</p>


<pre>
#!/usr/local/bin/newlisp
# 
# script to show the effect of 'main-args' in script file

(print (main-args) "\n")
(exit)

# end of script file

;; execute script in the OS shell:

script 1 2 3

<b>("/usr/local/bin/newlisp" "./script" "1" "2" "3")</b>
</pre>


<p>このスクリプトを異なるコマンド・ライン・パラメータで試してみてください。<br />
Try executing this script with different 
command-line parameters.
</p>

<br/><br/>

<a name="make-dir"></a>
<h2><span class="function">make-dir</span></h2>
<h4>syntax: (make-dir <em>str-dir-name</em> [<em>int-mode</em>])</h4>

<p>
<em>str-dir-name</em> で指定されたディレクトリをオプションのアクセス・モード <em>int-mode</em> で作ります。
結果次第で <tt>true</tt> か <tt>nil</tt> が返ります。
アクセス・モードの指定がなければ、ほとんどの Unix システムでは <tt>drwxr-xr-x</tt> がデフォルトです。<br />
Creates a directory as specified in <em>str-dir-name</em>, 
with the optional access mode <em>int-mode</em>. 
Returns <tt>true</tt> or <tt>nil</tt> 
depending on the outcome. 
If no access mode is specified, 
most Unix systems default to <tt>drwxr-xr-x</tt>.
</p>

<p>Unix システム上で指定されるアクセス・モードは、OS の <em>user-mask</em> による設定でシステム管理者によってもマスクされます。
Unixシステム上での <em>user-mask</em> は、<tt>umask</tt>コマンドを使って取り出せ、
通常、ファイルの所有者以外の書き込み（と生成）許可をマスクする <tt>0022</tt>（8進数）となっています。<br />
On Unix systems, the access mode specified 
will also be masked by the OS's <em>user-mask</em> 
set by the system administrator. 
The <em>user-mask</em> can be retrieved 
on Unix systems using the command <tt>umask</tt> 
and is usually <tt>0022</tt> (octal),
which masks write (and creation) permission 
for non-owners of the file.
</p>

<!-- example -->

<pre>
;; 0 (zero) in front of 750 makes it an octal number

(make-dir "adir" 0750)  
</pre>


<p>この例では、カレント・ディレクトリに <tt>adir</tt> という名前のディレクトリを <tt>0750</tt>（8進数 750 = <tt>drwxr-x---</tt>）のアクセス・モードで作っています。<br />
This example creates a directory named <tt>adir</tt> 
in the current directory with an access mode of 
<tt>0750</tt> (octal 750 = <tt>drwxr-x---</tt>).
</p>
<br/><br/>

<a name="map"></a>

<h2><span class="function">map</span></h2>
<h4>syntax: (map <em>exp-functor</em> <em>list-args-1</em> [<em>list-args-2</em> ... ])</h4>

<p>組込関数か（訳注：ユーザ）定義関数かラムダ式の <em>exp-functor</em> を <em>list-args-1, list-args-2&ndash;&ndash;</em> で指定される引数に連続的に適用し、結果の全てをリストにして返します。
バージョン 10.5.5 からは、<em>list-args</em> にベクトル・アレイも使えますが、返り値はリストになります。<br />
Successively applies the primitive function, defined function, or lambda expression 
<em>exp-functor</em> to the arguments specified in <em>list-args-1 list-args-2&mdash;</em>, 
returning all results in a list. Since version 10.5.5 <em>list-args</em>
can also be array vectors, but the returned result will always be a list. </p>

<!-- example -->

<pre>
(map + '(1 2 3) '(50 60 70))  <span class='arw'>&rarr;</span> (51 62 73)

(map if '(true nil true nil true) '(1 2 3 4 5) '(6 7 8 9 10))
<span class='arw'>&rarr;</span> '(1 7 3 9 5)

(map (fn (x y) (* x y)) '(3 4) '(20 10))
<span class='arw'>&rarr;</span> (60 40)
</pre>

<p>次の例が示しているのは、<tt>map</tt> 用の関数を動的に生成する方法です：<br />
The second example shows how to dynamically 
create a function for <tt>map</tt>:
</p>

<pre>
(define (foo op p) 
    (append (lambda (x)) (list (list op p 'x))))
</pre>

<p>短縮形の <tt>fn</tt> も使えます：<br />
We can also use the shorter <tt>fn</tt>:</p>

<pre>
(define (foo op p) 
    (append (fn (x)) (list (list op p 'x))))
</pre>

<p>これで <tt>foo</tt> が関数生成器のように動作します：<br />
<tt>foo</tt> now works like a function-maker:</p>

<pre>
(foo 'add 2)  <span class='arw'>&rarr;</span> (lambda (x) (add 2 x))

(map (foo add 2) '(1 2 3 4 5))  <span class='arw'>&rarr;</span> (3 4 5 6 7)

(map (foo mul 3) '(1 2 3 4 5))  <span class='arw'>&rarr;</span> (3 6 9 12 15)
</pre>

<p>オペランドの前のクォートを省略できることに着目してください。
というのも、newLISP の組込はそれ自身に評価されるからです。
（訳注：ユーザ定義関数でも、クォートは省略できます。）<br />
Note that the quote before the operand can be omitted 
because primitives evaluate to themselves in newLISP.
</p>

<p>
<tt>map</tt> を関数定義と組み合わせると、次のようなことが可能です：
<br/>
By incorporating <tt>map</tt> into the function definition, 
we can do the following:</p>

<pre>
(define (list-map op p lst) 
    (map (lambda (x) (op p x)) lst))

(list-map + 2 '(1 2 3 4))  <span class='arw'>&rarr;</span> (3 4 5 6)

(list-map mul 1.5 '(1 2 3 4))  <span class='arw'>&rarr;</span> (1.5 3 4.5 6)
</pre>

<p><tt>map</tt> には内部リスト・インデックス値 <tt>$idx</tt> も配置できます。<br />
<tt>map</tt> also sets the internal list index <tt>$idx</tt>.</p>


<pre>
(map (fn (x) (list $idx x)) '(a b c)) <span class='arw'>&rarr;</span> ((0 a) (1 b) (2 c))
</pre>

<p>使われる引数の数は第一引数のリストの長さで決まります。
残りのリストで引数が見つからない時、<tt>map</tt> はその引数の段階でパラメータ収集を止めます。
これは、置換中の n 番目のパラメータ・リストが、n 番目の行に変換されることを確実にします。
引数リストが多くの要素を含んでも、余分な要素は無視されます。
<blockquote>(訳例：
<pre>
> (map (fn (x y z) (list $idx x y z)) '(a b c) '(1 2) '(A B C D E))
((0 a 1 A) (1 b 2 B) (2 c nil nil))
> 
</pre>）
</blockquote>
<br />
The number of arguments used is determined by the length of the first argument list.
Arguments missing in other argument lists cause map to stop collecting parameters
for that level of arguments. This ensures that the nth parameter list gets converted
to the nth column during the transposition occurring. If an argument list contains too 
many elements, the extra ones will be ignored.
</p>

<p>構文に括弧を使うような<em>特殊形式</em>（例えば <a href="#case">case</a>とか）は、 <tt>map</tt> に使えません。<br />
Special forms which use parentheses as syntax cannot be mapped 
(i.e. <a href="#case">case</a>).</p>

<br/><br/>

<a name="mat"></a>
<h2><span class="function">mat</span></h2>
<h4>syntax: (mat <em>+</em> | <em>-</em> | <em>*</em> | <em>/</em> <em>matrix-A matrix-B</em>)<br/>
syntax: (mat <em>+</em> | <em>-</em> | <em>*</em> | <em>/</em> <em>matrix-A number</em>)</h4>

<p>この関数を第一構文で使うと、<em>matrix-A</em> と <em>matrix-B</em> の二次元行列に対して、高速浮動小数点スカラ演算を実行します。
演算の型には、四つの数値演算子 <tt>+</tt>, <tt>-</tt>, <tt>*</tt>,  <tt>/</tt> の中から一つを指定します。
newLISP では、通常これら数値演算子型は整数演算に使われますが、<tt>mat</tt> ではこれらの演算子全てが浮動小数点演算 (<tt>add</tt>, <tt>sub</tt>, <tt>mul</tt>, <tt>div</tt>) を実行します。<br />
Using the first syntax, this function performs fast floating point 
scalar operations on two-dimensional matrices in <em>matrix-A</em> or <em>matrix-B</em>. 
The type of operation is specified by one of the four arithmetic operators 
<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, or <tt>/</tt>. 
This type of arithmetic operator is typically used for integer 
operations in newLISP. In the case of <tt>mat</tt>, however,
all operations will be performed as floating point operations
(<tt>add</tt>, <tt>sub</tt>, <tt>mul</tt>, <tt>div</tt>).</p>

<p>newLISP における行列は二次元のリストかアレイです。
newLISP はリストとアレイを内部的に高速アクセス可能な C 言語データ・オブジェクトに変換します。
このことが newLISP での行列演算を高速にしていて、C で直接コード化したものと同じくらいです。
同じことが、行列演算 <a href="#multiply">multiply</a> や <a href="#invert">invert</a> にも言えます。<br />
Matrices in newLISP are two-dimensional lists or arrays. 
Internally, newLISP translates lists and arrays into fast, accessible 
C-language data objects. 
This makes matrix operations in newLISP 
as fast as those coded directly in C. 
The same is true for the matrix operations 
<a href="#multiply">multiply</a> and <a href="#invert">invert</a>.</p>

<!-- example -->

<pre>
(set 'A '((1 2 3) (4 5 6)))
(set 'B A)

(mat + A B)    <span class='arw'>&rarr;</span> ((2 4 6) (8 10 12))
(mat - A B)    <span class='arw'>&rarr;</span> ((0 0 0) (0 0 0))
(mat * A B)    <span class='arw'>&rarr;</span> ((1 4 9) (16 25 36))
(mat / A B)    <span class='arw'>&rarr;</span> ((1 1 1) (1 1 1))

; specify the operator in a variable

(set 'op +)
(mat op A B)    <span class='arw'>&rarr;</span> ((2 4 6) (8 10 12)) 
</pre>


<p>第二構文を使うと、<em>matrix-A</em> の全てのセルが <em>number</em> のスカラ値で処理されます：<br />
Using the second syntax, all cells in <em>matrix-A</em> 
are operated on with a scalar in <em>number</em>:</p>


<pre>
(mat + A 5)    <span class='arw'>&rarr;</span> ((6 7 8) (9 10 11))
(mat - A 2)    <span class='arw'>&rarr;</span> ((-1 0 1) (2 3 4))
(mat * A 3)    <span class='arw'>&rarr;</span> ((3 6 9) (12 15 18))
(mat / A 10)   <span class='arw'>&rarr;</span> ((.1 .2 .3) (.4 .5 .6))
</pre>


<p>他の行列演算 <a href="#det">det</a>、<a href="#invert">invert</a>、<a href="#multiply">multiply</a>、<a href="#transpose">transpose</a> も見てください。<br />
See also the other matrix operations <a href="#det">det</a>, 
<a href="#invert">invert</a>, <a href="#multiply">multiply</a>,
and <a href="#transpose">transpose</a>.</p>

<br/><br/>

<a name="match"></a>
<h2><span class="function">match</span></h2>
<h4>syntax: (match <em>list-pattern</em> <em>list-match</em> [<em>bool</em>])</h4>

<p><em>list-pattern</em> のパターンを <em>list-match</em> のリストに対して合致判定し、合致した式をリストで返します。
<em>list-pattern</em> には、三つのワイルド・カード文字 <tt>?</tt>, <tt>+</tt>, <tt>*</tt> が 使われます。<br />
The pattern in <em>list-pattern</em> is matched 
against the list in <em>list-match</em>, 
and the matching expressions are returned in a list. 
The three wildcard characters <tt>?</tt>, <tt>+</tt>, 
and <tt>*</tt> can be used in <em>list-pattern</em>.
</p>

<p>ワイルド・カード文字は入れ子が可能です。
<tt>match</tt> は合致した式のリストを返します。
各 <tt>?</tt>（疑問符）に対しては、合致している式要素が返ります。
各 <tt>+</tt> (プラス符号) または <tt>*</tt>（アスタリスク）に対しては、合致した要素からなるリストが返ります。
パターンが <em>list-match</em> のリストに対して合致しなかった時、<tt>match</tt> は <tt>nil</tt> を返します。
ワイルド・カード文字がパターンに無い時は、空リストが返ります。<br />
Wildcard characters may be nested. 
<tt>match</tt> returns a 
list of matched expressions. 
For each <tt>?</tt> (question mark), 
a matching expression element is returned. 
For each <tt>+</tt> (plus sign) or 
<tt>*</tt> (asterisk), a list containing 
the matched elements is returned. 
If the pattern cannot be matched 
against the list in <em>list-match</em>, 
<tt>match</tt> returns <tt>nil</tt>.
If no wildcard characters are present
in the pattern an empty list is returned.
</p>

<p>第三引数はオプションで、論理値 <tt>true</tt> (あるいは、<tt>nil</tt> 以外に評価される式) を与えることができます。
これにより、（訳注：合致した時の）<tt>match</tt> の戻り値が（訳注：<em>list-match</em> の）全要素になります。<br />
Optionally, the Boolean value <tt>true</tt> (or any other expression not 
evaluating to <tt>nil</tt>) can be supplied as a third argument.  This 
causes <tt>match</tt> to show all elements in the returned result.</p>

<p><a href="#find">find</a> や <a href="#ref">ref</a> や <a href="#ref-all">ref-all</a>  や <a href="#replace">replace</a> において、
<tt>match</tt> はファンクタ（関数オブジェクト）のパラメータとして使われます。
また、リストに対する <a href="#find-all">find-all</a> の内部で使われます。<br />
<tt>match</tt> is frequently employed as a functor parameter
in <a href="#find">find</a>, <a href="#ref">ref</a>,
<a href="#ref-all">ref-all</a> and <a href="#replace">replace</a> and
is internally used by <a href="#find-all">find-all</a> for lists.</p>

<!-- example -->

<pre>
(match '(a ? c) '(a b c))  <span class='arw'>&rarr;</span> (b)

(match '(a ? ?) '(a b c))  <span class='arw'>&rarr;</span> (b c)

(match '(a ? c) '(a (x y z) c))  <span class='arw'>&rarr;</span> ((x y z))

(match '(a ? c) '(a (x y z) c) true)  <span class='arw'>&rarr;</span> (a (x y z) c)

(match '(a ? c) '(a x y z c))  <span class='arw'>&rarr;</span> nil


(match '(a * c) '(a x y z c))  <span class='arw'>&rarr;</span> ((x y z))

(match '(a (b c ?) x y z) '(a (b c d) x y z))  <span class='arw'>&rarr;</span> (d)

(match '(a (*) x ? z) '(a (b c d) x y z))  <span class='arw'>&rarr;</span> ((b c d) y)


(match '(+) '())  <span class='arw'>&rarr;</span> nil

(match '(+) '(a))  <span class='arw'>&rarr;</span> ((a))

(match '(+) '(a b))  <span class='arw'>&rarr;</span> ((a b))

(match '(a (*) x ? z) '(a () x y z))  <span class='arw'>&rarr;</span> (() y)

(match '(a (+) x ? z) '(a () x y z))  <span class='arw'>&rarr;</span> nil 
</pre>


<p><tt>match</tt> における <tt>*</tt> 演算子は、可能な限り少ない要素を捕まえようとしますが、合致しないとバックトラックして、より多くの要素を捕まえようとするので注意してください。<br />
Note that the <tt>*</tt> operator tries to grab the fewest number of 
elements possible, but <tt>match</tt> backtracks and grabs more elements 
if a match cannot be found.</p>

<p><tt>+</tt> は <tt>*</tt> と似た動作をしますが、少なくとも一つのリスト要素を必要とします。<br />
The <tt>+</tt> operator works similarly to the <tt>*</tt> operator, 
but it requires at least one list element.</p>

<p>次の例は、合致式が変数をどのように束縛するかを示しています。<br />
The following example shows how the matched expressions can be bound 
to variables.</p>


<pre>
(map set '(x y) (match '(a (? c) d *) '(a (b c) d e f)))

x  <span class='arw'>&rarr;</span> b
y  <span class='arw'>&rarr;</span> (e f)
</pre>


<p>文字列に対して、<tt>match</tt> は使えません。
より強力な文字列合致には、<a href="#regex">regex</a>、<a href="#find">find</a>、<a href="#find-all">find-all</a>、<a href="#parse">parse</a> を使ってください。<br />
Note that <tt>match</tt> for strings has been eliminated. 
For more powerful string matching, use <a href="#regex">regex</a>, 
<a href="#find">find</a>, <a href="#find-all">find-all</a> 
or <a href="#parse">parse</a>.
</p>

<p><a href="#unify">unify</a> は別の合致表現用関数で、PROLOG のように振る舞います。<br />
 <a href="#unify">unify</a> is another function for matching 
expressions in a PROLOG like manner.</p>

<br/><br/>

<a name="max"></a>
<h2><span class="function">max</span></h2>
<h4>syntax: (max <em>num-1</em> [<em>num-2</em> ... ])</h4>

<p><em>num-1</em> 以下の式を評価して、最大数を返します。<br />
Evaluates the expressions <em>num-1</em>&mdash; and returns 
the largest number.</p>

<!-- example -->

<pre>
(max 4 6 2 3.54 7.1)  <span class='arw'>&rarr;</span> 7.1
</pre>


<p>関数 <a href="#min">min</a> も見てください。<br />
See also the <a href="#min">min</a> function.
</p>

<br/><br/>

<a name="member"></a>
<h2><span class="function">member</span></h2>
<h4>syntax: (member <em>exp</em> <em>list</em>)<br/>
syntax: (member <em>str-key</em> <em>str</em> [<em>num-option</em>])</h4>
<p>第一構文の <tt>member</tt> は、リスト <em>list</em> で要素 <em>exp</em> を検索します。
要素がリストのメンバなら、元のリストで見つかった要素からの残りを新しいリストとして構成して、返します。
見つからなかった場合は <tt>nil</tt> が返ります。
<em>num-option</em> を指定された <tt>member</tt> は、正規表現検索を実行します。<br />
In the first syntax, 
<tt>member</tt> searches 
for the element <em>exp</em> 
in the list <em>list</em>. 
If the element is a member of the list, 
a new list starting with the element found 
and the rest of the original list 
is constructed and returned. 
If nothing is found, 
<tt>nil</tt> is returned. 
When specifying <em>num-option</em>,
<tt>member</tt> performs a regular expression search.
</p>

<!-- example -->

<pre>
(set 'aList '(a b c d e f g h))  <span class='arw'>&rarr;</span> (a b c d e f g h)
(member 'd aList)                <span class='arw'>&rarr;</span> (d e f g h)
(member 55 aList)                <span class='arw'>&rarr;</span> nil
</pre>


<p>第二構文の <tt>member</tt> は、<em>str</em> 中の <em>str-key</em> を検索します。
<em>str-key</em> が見つかれば、 (<em>str-key</em> から始まる) <em>str</em> の全てが返ります。
見つからなければ、 <tt>nil</tt> が返ります。<br />
In the second syntax, 
<tt>member</tt> searches 
for <em>str-key</em> in <em>str</em>. 
If <em>str-key</em> is found, all of <em>str</em> 
(starting with <em>str-key</em>) is returned. 
<tt>nil</tt> is returned if nothing is found.
</p>

<!-- example -->

<pre>
(member "LISP" "newLISP")  <span class='arw'>&rarr;</span> "LISP"
(member "LI" "newLISP")    <span class='arw'>&rarr;</span> "LISP"
(member "" "newLISP")      <span class='arw'>&rarr;</span> "newLISP"
(member "xyz" "newLISP")   <span class='arw'>&rarr;</span> nil
(member "li" "newLISP" 1)  <span class='arw'>&rarr;</span> "LISP"
</pre>


<p>
関連する関数 <a href="#slice">slice</a> と <a href="#find">find</a> も見てください。<br />
See also the related functions 
<a href="#slice">slice</a> and 
<a href="#find">find</a>.
</p>

<br/><br/>

<a name="min"></a>
<h2><span class="function">min</span></h2>
<h4>syntax: (min <em>num-1</em> [<em>num-2</em> ... ])</h4>

<p><em>num-1</em> 以下を評価して、一番小さい数値を返します。
<br/>
Evaluates the expressions <em>num-1</em>&mdash; 
and returns the smallest number.
</p>

<!-- example -->

<pre>
(min 4 6 2 3.54 7.1)  <span class='arw'>&rarr;</span> 2
</pre>

<p>関数 <a href="#max">max</a> も見てください。<br />
See also the <a href="#max">max</a> function.
</p>

<br/><br/>

<a name="mod"></a>
<h2><span class="function">mod</span></h2>
<h4>syntax: (mod <em>num-1</em> <em>num-2</em> [<em>num-3</em> ... ])</h4>

<p><em>num-1</em> と <em>num-2</em> から <ruby>余り<rp>（</rp><rt>モジュラ・バリュー</rt><rp>）</rp></ruby>を計算します。
つまり、<tt>mod</tt> が計算するのは、分子 <em>num-i</em> を 分母 <em>num-i + 1</em> で割った時の残りです。
具体的には、戻り値は<em>分子 - n * 分母</em> で、この時の <tt>n</tt> は分子を分母で割った商でゼロに近い方に丸めた整数です。
その結果、分子と同じ符合で、大きさが分母よりも小さくなります。<br />
Calculates the modular value of the 
numbers in <em>num-1</em> and <em>num-2</em>. 
<tt>mod</tt> computes the remainder 
from the division of the numerator <em>num-i</em> 
by the denominator <em>num-i + 1</em>. 
Specifically, the return value is 
<em>numerator - n * denominator</em>, 
where <tt>n</tt> is the quotient 
of the numerator divided by the denominator, 
rounded towards zero to an integer. 
The result has the same sign as 
the numerator and its magnitude 
is less than the magnitude 
of the denominator.
</p>

<!-- example -->

<pre>
(mod 10.5 3.3)   <span class='arw'>&rarr;</span>  0.6
(mod -10.5 3.3)  <span class='arw'>&rarr;</span> -0.6
</pre>


<p>整数に対してのみ動作させたい時は、関数 <a href="#arithmetic">%</a>（パーセント記号）を使ってください。<br />
Use the <a href="#arithmetic">%</a> (percent sign) 
function when working with integers only.
</p>

<br/><br/>

<a name="mul"></a>
<h2><span class="function">mul</span></h2>
<h4>syntax: (mul <em>num-1</em> <em>num-2</em> [<em>num-3</em> ... ])</h4>

<p>式 <em>num-1</em> 以下の全てを評価し、その積を計算して返します。
<tt>mul</tt> は（訳注：整数と浮動小数点数の）混在型算術を実行しますが、常に浮動小数点数で返します。
<tt>NaN</tt> となる浮動小数点数に対しては、<tt>NaN</tt> が返ります。<br />
Evaluates all expressions <em>num-1</em>&mdash;, 
calculating and returning the product. 
<tt>mul</tt> can perform mixed-type arithmetic, 
but it always returns floating point numbers. 
Any floating point calculation with 
<tt>NaN</tt> also returns <tt>NaN</tt>.
</p>

<!-- example -->


<pre>
(mul 1 2 3 4 5 1.1)  <span class='arw'>&rarr;</span> 132
(mul 0.5 0.5)        <span class='arw'>&rarr;</span> 0.25
</pre>

<br/><br/>

<a name="multiply"></a>
<h2><span class="function">multiply</span></h2>
<h4>syntax: (multiply <em>matrix-A</em> <em>matrix-B</em>)</h4>

<p>行列 <em>matrix-A</em> と <em>matrix-B</em> の行列積を返します。
<em>matrix-A</em> が <em>n</em> 行 <em>m</em> 列で、<em>matrix-B</em> が <em>k</em> 行 <em>l</em> 列なら（<em>m</em> と <em>k</em> は等しい）、結果は <em>n</em> 行 <em>l</em> 列になります。 
<tt> multiply</tt> は（訳注：整数と浮動小数点数の）混在型算術を実行しますが、整数の値があったとしても、結果は常に倍精度浮動小数点数です。<br />
Returns the matrix multiplication of matrices 
in <em>matrix-A</em> and <em>matrix-B</em>. 
If <em>matrix-A</em> has the dimensions <em>n</em> by <em>m</em> 
and <em>matrix-B</em> the dimensions <em>k</em> by <em>l</em> 
(<em>m</em> and <em>k</em> must be equal), 
the result is an <em>n</em> by <em>l</em> matrix. 
<tt> multiply</tt> can perform mixed-type arithmetic, 
but the results are always double precision floating points, 
even if all input values are integers.
</p>

<p>行列の次元は、行数と最初の行の要素数で決まります。
非正方行列で見つからない要素は、<tt>0.0</tt> になります。
行列は、入れ子のリストでも <a href="#array">array</a>でも可能です。<br />
The dimensions of a matrix are determined 
by the number of rows and the number 
of elements in the first row. 
For missing elements 
in non-rectangular matrices, 
<tt>0.0</tt> is assumed. 
A matrix can either be a nested list 
or <a href="#array">array</a>.
</p>

<!-- example -->

<pre>
(set 'A '((1 2 3) (4 5 6)))
(set 'B '((1 2) (1 2) (1 2)))
(multiply A B)  <span class='arw'>&rarr;</span> ((6 12) (15 30))

(set 'v '(10 20 30))
(multiply A (transpose (list v))) <span class='arw'>&rarr;</span> ((140) (320))
</pre>

<p>行列と <tt>n</tt> 要素のベクトル積をとる時、ベクトルは <a href="#transpose">transpose</a> を使って <tt>n</tt> 行 <tt>1</tt> 列の行列に変換しておく必要があります。<br />
When multiplying a matrix with a vector of <tt>n</tt> elements, the vector
must be transformed into <tt>n</tt> rows by <tt>1</tt> column matrix using
 <a href="#transpose">transpose</a>.</p>

<p>ここで示す演算は全てリストに対してですが、アレイに対しても同じように実行できます。<br />
All operations shown here on lists 
can be performed on arrays, as well.
</p>

<p>
行列演算子 <a href="#det">det</a>、<a href="#invert">invert</a>、<a href="#mat">mat</a>、<a href="#transpose">transpose</a> も見てください。<br />
See also the matrix operations <a href="#det">det</a>,
<a href="#invert">invert</a>, <a href="#mat">mat</a> 
and <a href="#transpose">transpose</a>.
</p>

<br/><br/>

<a name="name"></a>
<h2><span class="function">name</span></h2>
<p>この機能は推奨されません、代わりに <a href="#term">term</a> を使ってください。（訳注：この関数は V10.2 から使えませんので、name がシンボル名に使えます。以前のバージョンと互換性を持たせたい時は、 
<blockquote>
<pre>
; make new code compatible with older newLISP versions
(when (&lt; (sys-info -2) 10111)
(constant (global 'term) name)) 
</pre>
</blockquote>
という方法が使えます。
この例は、以前のマニュアルからの抜粋です。）
<br />
This function is deprecated, use <a href="#term">term</a> instead.</p>

<br/><br/>

<a name="NaNp"></a>
<h2><span class="function">NaN?</span></h2>
<h4>syntax: (NaN? <em>float</em>)</h4>

<p>浮動小数点演算の結果が <tt>NaN</tt> であるかどうかをテストします。
信頼できる浮動小数点演算は、'Not a Number' に対して <tt>NaN</tt> と呼ばれる IEEE 754 の特殊数値形式を返します。<br />
Tests if the result of a floating point math operation is a <tt>NaN</tt>.  
Certain floating point operations return a special IEEE 754 number format 
called a <tt>NaN</tt> for 'Not a Number'.</p>

<!-- example -->

<pre>
; floating point operation on NaN yield NaN
(set 'x (sqrt -1))  <span class='arw'>&rarr;</span> NaN
(NaN? x)            <span class='arw'>&rarr;</span> true
(add x 123)         <span class='arw'>&rarr;</span> NaN
(mul x 123)         <span class='arw'>&rarr;</span> NaN

; integer operations treat NaN as zero
(+ x 123)  <span class='arw'>&rarr;</span> 123
(* x 123)  <span class='arw'>&rarr;</span> 0

; comparisons with NaN values yield nil
(&gt; x 0)   <span class='arw'>&rarr;</span> nil
(&lt;= x 0)  <span class='arw'>&rarr;</span> nil
(= x x)   <span class='arw'>&rarr;</span> nil

(set 'infinity (mul 1.0e200 1.0e200)) <span class='arw'>&rarr;</span> inf
(NaN? (sub infinity infinity)) <span class='arw'>&rarr;</span> true
</pre>


<p><tt>NaN</tt> を伴なう全ての浮動小数点計算が <tt>NaN</tt> となることに注意してください。
つまり、<tt>NaN</tt> との比較では全て <tt>nil</tt> が返ります。自身との比較では <tt>true</tt> のはずですが、
ANSI C 使用時には <em>not</em> <tt>true</tt> の結果となるからです。
整数演算では、 <tt>NaN</tt> は <tt>0</tt>（ゼロ）として扱われます。<br />
Note that all floating point arithmetic operations 
with a <tt>NaN</tt> yield a <tt>NaN</tt>. 
All comparisons with <tt>NaN</tt> return <tt>nil</tt>, 
but <tt>true</tt> when comparing to itself. 
Comparison with itself, however, 
would result in <em>not</em> <tt>true</tt> when using ANSI C.  Integer operations 
treat <tt>NaN</tt> as <tt>0</tt> (zero) values.</p>

<p>無限大の浮動小数点数値をテストする <a href="#infp">inf?</a> も見てください。<br />
See also <a href="#infp">inf?</a> for testing a floating point value for infinity.</p>

<br/><br/>

<a name="net-accept"></a>
<h2><span class="function">net-accept</span></h2>
<h4>syntax: (net-accept <em>int-socket</em>)</h4>

<p>前もって待ち受け（listen）モードに置かれたソケット上の接続を受け入れます。
この接続の受信及び送信データ用に作成された新規ソケット・ハンドルが返ります。<br />
Accepts a connection on a socket 
previously put into listening mode. 
Returns a newly created socket handle 
for receiving and sending data 
on this connection.
</p>

<!-- example -->

<pre>
(set 'socket (net-listen 1234))
(net-accept socket)
</pre>


<p>Unixライクのオペレーティング・システムで 1024 より小さいポートを使うためには、newLISP がスーパーユーザ・モードで開始されなければならないことに注意してください。<br />
Note that for ports less than 1024, 
newLISP must be started in superuser mode
on Unix-like operating systems.
</p>

<p>配布ソースのディレクトリ <tt>examples/</tt> にあるファイル <tt>server</tt> と <tt>client</tt> の例も見てください。<br />
 See also the files <tt>server</tt> and <tt>client</tt> examples
in the <tt>examples/</tt> directory of the source distribution.</p>

<br/><br/>

<a name="net-close"></a>
<h2><span class="function">net-close</span></h2>
<h4>syntax: (net-close <em>int-socket</em> [<em>true</em>])</h4>

<p>
関数 <a href="#net-connect">net-connect</a> か <a href="#net-accept">net-accept</a> で、前もって作成された <em>int-socket</em> のネットワーク・ソケットを閉じます。
成功すれば <tt>true</tt> を、失敗すれば <tt>nil</tt> を返します。<br />
Closes a network socket in <em>int-socket</em> that 
was previously created by a 
<a href="#net-connect">net-connect</a> 
or <a href="#net-accept">net-accept</a> function. 
Returns <tt>true</tt> on success and 
<tt>nil</tt> on failure.
</p>

<!-- example -->

<pre>
(net-close aSock)
</pre>


<p>オプションの <em>true</em> フラグは、ソケットの即時遮断を抑えて、実行中のデータ送信が終わるまで待ちます。<br />
The optional <em>true</em> flag suppresses immediate shutdown
of sockets by waiting for pending data transmissions to finish.</p>

<br/><br/>

<a name="net-connect"></a>
<h2><span class="function">net-connect</span></h2>
<h4>syntax: (net-connect <em>str-remote-host</em> <em>int-port</em> [<em>int-timeout-ms</em>])<br/>
syntax: (net-connect <em>str-remote-host</em> <em>int-port</em> [<em>str-mode</em> [<em>int-ttl</em>]])<br/>
syntax: (net-connect <em>str-file-path</em>)</h4>

<p>
第一構文では、<em>str-remote-host</em> で指定されたリモート・ホスト・コンピュータと <em>int-port</em>で指定されたポートを接続します。
成功裏に接続した後はソケット・ハンドルが返り、それ以外では、<tt>nil</tt> が返ります。<br />
In the first syntax, connects to a remote host computer specified in 
<em>str-remote-host</em> and a port specified in <em>int-port</em>. 
Returns a socket handle after having connected successfully; 
otherwise, returns <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(set 'socket (net-connect "example.com" 80))
(net-send socket "GET /\r\n\r\n")
(net-receive socket buffer 10000)
(println buffer)
(exit)
</pre>

<p>例では、HTTP GET <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>が送られ、その後にウェブ・ページが受信されます。
newLISP は、この例と同じ機能を提供する組込関数 <a href="#get-url">get-url</a> を持っていることに注意してください。<br />
In the example a HTTP GET request is sent and subsequently a web page
received. Note that newLISP has already a built-in function 
<a href="#get-url">get-url</a> offering the same functionality.</p>

<p>オプションで、タイムアウト値 <em>int-timeout</em> をミリ秒単位で指定できます。
タイムアウト値が無い時、関数はポートを開くために 10 秒待ちます。
タイムアウト値があれば、関数は利用できないポートからの戻りを早めたり、遅くしたりできます。
次の例は、開いているポートを探すポート・スキャナーを示します：<br />
Optionally a timeout value <em>int-timeout</em> in milliseconds
can be specified. Without a timeout value the function will wait up
to 10 seconds for an open port. With a timeout value the function can
be made to return on an unavailable port much earlier or later. The
following example shows a port scanner looking for open ports:</p>

<!-- example -->
<pre>
(set 'host (main-args 2))
(println "Scanning: " host)
(for (port 1 1024)
    (if (set 'socket (net-connect host port 500))
        (println "open port: " port " " (or (net-service port "tcp") ""))
        (print port "\r"))
)
</pre>

<p>プログラムは、ドメイン名かドット表記の IP 番号どちらかのホストの文字列をシェル・コマンド・ラインから取り、1 から 1024 までの各ポートでオープンを試みます。
各オープン・ポートでは、ポート番号とサービス・ディスクリプション文字列が出力されます。
利用できるディスクリプションが無いなら、空文字列 "" が出力されます。
ポートが閉じている時、関数はシェル・ウィンドウで同一ライン上に留まり、番号を出力します。<br />
The programs takes the host string from the shell command line as
either a domain name or an IP number in dot notation then tries to 
open each port from 1 to 1024. For each open port the port number and 
the service description string is printed. If no description is available,
an empty string "" is output. For closed ports the function outputs 
numbers in the shell window staying on the same line.</p>

<p>Unix では、<tt>net-connect</tt> がポートを利用できない時、タイムアウト終了前に <tt>nil</tt> を返すかもしれません。
MS Windows では、<tt>net-connect</tt> は <tt>nil</tt> で失敗する際も、常にタイムアウトするまで待ちます。<br />
On Unix <tt>net-connect</tt> may return with <tt>nil</tt> before
the timeout expires, when the port is not available. On MS Windows 
<tt>net-connect</tt> will always wait for the timeout to expire before
failing with <tt>nil</tt>.</p>

<h3>UDP communications（UDP 通信）</h3>

<p>第二構文では、第三パラメータとしてのオプション <em>str-mode</em> に、文字列 <tt>"udp"</tt> または <tt>"u"</tt> が指定でき、UDP（ユーザ・データグラム・プロトコル）通信に適したソケットを作成します。
UDP モードの <tt>net-connect</tt> はリモート・ホストへの接続を<em>試みません</em> が、アドレスが指定されれば、ソケットを作成し、そのリモート・アドレスに束縛します。
その後の <a href="#net-send">net-send</a> が、目標アドレスを含む UDP パケットを送信します。
<a href="#net-send-to">net-send-to</a> を使う時は、関数 <tt>net-connect</tt> か <tt>net-send-to</tt> のどちらかだけが、目標アドレスを提供すべきです。
つまり、片方の関数は目標アドレスとして空文字 <tt>""</tt> を指定しなければなりません。<br />
In the second syntax, a third parameter, the string <tt>"udp"</tt>
or <tt>"u"</tt> can be specified in the optional <em>str-mode</em> 
to create a socket suited for UDP (User Datagram Protocol) communications.
In UDP mode, <tt>net-connect</tt> does <em>not</em> try to connect 
to the remote host, but creates the socket and binds it to the
remote address, if an address is specified. 
A subsequent <a href="#net-send">net-send</a> will send a UDP packet 
containing that target address. 
When using <a href="#net-send-to">net-send-to</a>, only one of the
two functions <tt>net-connect</tt> or <tt>net-send-to</tt> should 
provide a target address. The other function should specify and empty
string <tt>""</tt> as the target address.</p>

<pre>
;; example server
(net-listen 4096 "226.0.0.1" "udp") &rarr; 5
(net-receive-from 5 20)

;; example client I
(net-connect "226.0.0.1" 4096 "udp") &rarr; 3
(net-send 3 "hello")

;; example client II
(net-connect "" 4096 "udp") &rarr; 3
(net-send-to "226.0.0.1" 4096 "hello" 3)
</pre>

<p><tt>net-listen</tt> か <tt>net-connect</tt> で <tt>"udp"</tt> オプションが使われた時、関数 <a href="#net-receive">net-receive</a> と <a href="#net-receive-from">net-receive-from</a> の両方が使え、UDP 通信を実行します。
<a href="#net-select">net-select</a> と <a href="#net-peek">net-peek</a> が、ノン・ブロッキング状態での受信データ・チェックに使えます。<br />
The functions <a href="#net-receive">net-receive</a> and 
<a href="#net-receive-from">net-receive-from</a>
can both be used and will perform UDP communications when the <tt>"udp"</tt>
option as been used in <tt>net-listen</tt> or <tt>net-connect</tt>. 
<a href="#net-select">net-select</a> and <a href="#net-peek">net-peek</a> 
can be used to check for received data in a non-blocking fashion.</p>

<p><a href="#net-listen">net-listen</a> は、特定のローカル・アドレスとポートをソケットに束縛します。
<tt>net-connect</tt> が使われる時、ローカル・アドレスとポートはホスト OS のソケット・スタック関数によって選ばれます。<br />
<a href="#net-listen">net-listen</a> binds a specific 
local address and port to the socket. When <tt>net-connect</tt> is used,
the local address and port will be picked by the socket-stack 
functions of the host OS.</p>

<h3>UDP multicast communications（UDP マルチキャスト通信）</h3>
<p>
第三パラメータ <em>str-mode</em> に <tt>"multi"</tt> か <tt>"m"</tt> を指定すると、UDP マルチキャスト通信用ソケットを生成します。
オプションの第四パラメータ <tt>int-ttl</tt> に TTL (<a href="http://ja.wikipedia.org/wiki/Time_to_live">time to live</a>) 値を指定できます。
<em>int-ttl</em> 値が指定されない時、その値は 3 になります。<br />
When specifying <tt>"multi"</tt> 
or <tt>"m"</tt> as a third parameter for <em>str-mode</em>,
a socket for UDP multicast communications 
will be created. 
Optionally, the fourth parameter
<tt>int-ttl</tt> can be specified 
as a TTL (time to live) value. 
If no <em>int-ttl</em> value is specified, 
a value of 3 is assumed.
</p>

<p>
<tt>net-connect</tt> の UDP マルチキャスト・モード指定は、ソケットを UDP マルチキャスト・モードに置くだけで、実際には目標のマルチキャスト・アドレスとの接続を確立しないことに注意してください。
受信側では、<a href="#net-listen">net-listen</a> を UDP マルチキャスト・オプションで使ってください。<br />
Note that specifying UDP multicast mode 
in <tt>net-connect</tt> does not actually establish 
a connection to the target multicast address 
but only puts the socket into UDP multicasting mode. 
On the receiving side, 
use <a href="#net-listen">net-listen</a> 
together with the UDP multicast option.
</p>

<!-- example -->

<pre>
;; example client I
(net-connect "" 4096 "multi")  <span class='arw'>&rarr;</span> 3
(net-send-to "226.0.0.1" 4096 "hello" 3)

;; example client II
(net-connect "226.0.0.1" 4096 "multi")  <span class='arw'>&rarr;</span> 3
(net-send 3 4096 "hello")

;; example server
(net-listen 4096 "226.0.0.1" "multi")  <span class='arw'>&rarr;</span> 5
(net-receive-from 5 20)               
<span class='arw'>&rarr;</span> ("hello" "192.168.1.94" 32769)
</pre>


<p>サーバー側では、ノン・ブロッキング通信に <a href="#net-peek">net-peek</a> か <a href="#net-select">net-select</a> が使えます。
上の例では、<a href="http://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B0%E3%83%A9%E3%83%A0">データグラム</a>が受信されるまでサーバーはブロックしています。<br />
On the server side, <a href="#net-peek">net-peek</a> or <a href="#net-select">net-select</a>
can be used for non-blocking communications.  In the above example, the server would block
until a datagram is received.</p>

<p>アドレス <tt>226.0.0.1</tt> は、<tt>224.0.0.0</tt> から <tt>239.255.255.255</tt> までのクラス D 範囲マルチキャスト・アドレス内の一マルチキャスト・アドレスです。<br />
The address <tt>226.0.0.1</tt> is just one multicast address 
in the Class D range of multicast addresses from <tt>224.0.0.0</tt> 
to <tt>239.255.255.255</tt>.</p>

<p><a href="#net-send-to">net-send-to</a> や <a href="#net-receive-from">net-receive-from</a> の代わりに、関数 <a href="#net-send">net-send</a> と <a href="#net-receive">net-receive</a> が使えます。<br />
The <a href="#net-send">net-send</a> and 
<a href="#net-receive">net-receive</a> functions
can also be used instead of <a href="#net-send-to">net-send-to</a> 
and <a href="#net-receive-from">net-receive-from</a>.
</p>


<h3>UDP broadcast communications（UDP ブロードキャスト通信）</h3>

<p>第三パラメータ <em>str-mode</em> に文字列 <tt>"broadcast"</tt> か <tt>"b"</tt> を指定すると、UDP ブロードキャスト通信が設定されます。
この場合、ブロードキャスト・アドレスの最後には 255 が使われます。<br />
Specifying the string <tt>"broadcast"</tt> or <tt>"b"</tt> 
in the third parameter, <em>str-mode</em>, causes
UDP broadcast communications to be set up. 
In this case, the broadcast address 
ending in 255 is used.
</p>

<!-- example -->

<pre>
;; example client
(net-connect "192.168.2.255" 3000 "broadcast")  <span class='arw'>&rarr;</span> 3
(net-send 3 "hello")

;; example server
(net-listen 3000 "" "udp")  <span class='arw'>&rarr;</span> 5

(net-receive 5 buff 10)
buff  <span class='arw'>&rarr;</span> "hello"
;; or
(net-receive-from 5 10)
<span class='arw'>&rarr;</span> ("hello" "192.168.2.1" 46620)
</pre>


<p>
受信側では、<a href="#net-listen">net-listen</a> が <tt>""</tt> (空文字列) で指定されるデフォルト・アドレスで使われるべきだということに注意してください。
ブロードキャストは、特定のアドレスでは受信できません。
全ての UDP 通信において、<a href="#net-listen">net-listen</a> は実際に受信側を待ち受け（listen）モードに置きません。
どちらかというと、ソケットを特殊 UDP モードに設定します。<br />
Note that on the receiving side, 
<a href="#net-listen">net-listen</a> should be used 
with the default address 
specified with an <tt>""</tt> (empty string). 
Broadcasts will not be received 
when specifying an address. 
As with all UDP communications, 
<a href="#net-listen">net-listen</a> does not actually put 
the receiving side in listen mode, 
but rather sets up the sockets 
for the specific UDP mode.
</p>

<p>ノン・ブロッキング状態で通信が来たかどうかをチェックするために、関数<a href="#net-select">net-select</a> か <a href="#net-peek">net-peek</a> が使えます。<br />
The <a href="#net-select">net-select</a> 
or <a href="#net-peek">net-peek</a> functions 
can be used to check for 
incoming communications 
in a non-blocking fashion.
</p>

<h3>Local domain Unix sockets（ローカル ドメイン Unix ソケット）</h3>

<p>第三構文の <tt>net-connect</tt> は、<em>str-file-path</em> を使って名付けられた <em>ローカル <a href="http://ja.wikipedia.org/wiki/UNIX%E3%83%89%E3%83%A1%E3%82%A4%E3%83%B3%E3%82%BD%E3%82%B1%E3%83%83%E3%83%88">ドメイン Unix ソケット</a></em> を通して、ローカル・ファイル・システム上のサーバーに接続します。
成功裏に接続を持った後にソケット・ハンドルを返し、それ以外では <tt>nil</tt> を返します。<br />
In the third syntax, <tt>net-connect</tt> connects to a server on the 
local file system via a <em>local domain Unix socket</em> named using 
<em>str-file-path</em>.	Returns a socket handle after having connected 
successfully; otherwise, returns <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(net-connect "/tmp/mysocket")  <span class='arw'>&rarr;</span> 3

; on OS/2 use "\\socket\\" prefix

(net-connect "\\socket\\mysocket")
</pre>


<p>
<em>ローカル・ドメイン</em> のファイル・システム・ソケットが生成され、返されます。
サーバー側では、<em>ローカル・ドメイン</em> のソケット が <a href="#net-listen">net-listen</a> と <a href="#net-accept">net-accept</a> を使って生成されています。
接続が確立された後は、通常 TCP/IP ストリーム通信に関数 <a href="#net-select">net-select</a>、<a href="#net-send">net-send</a>、<a href="#net-receive">net-receive</a> を使います。
この形の接続は、同じファイル・システム上のプロセス間高速双方向通信チャンネルとして使われます。
この形の接続は、MS Windows プラットフォーム では利用できません。<br />
A <em>local domain</em> file system socket is created and returned.
On the server side, <em>local domain</em> sockets have been created
using <a href="#net-listen">net-listen</a> and <a href="#net-accept">net-accept</a>.
After the connection has been established the functions <a href="#net-select">net-select</a>,
<a href="#net-send">net-send</a> and <a href="#net-receive">net-receive</a> can be used
as usual for TCP/IP stream communications. This type of connection can be used as a fast
bi-directional communications channel between processes on the same file system.
This type of connection is not available on MS Windows platforms.</p>

<br/><br/>

<a name="net-error"></a>
<h2><span class="function">net-error</span></h2>
<h4>syntax: (net-error)<br/>
syntax: (net-error <em>int-error</em>)</h4>

<p>関数 <a href="#net-accept">net-accept</a>、
<a href="#net-connect">net-connect</a>、
<a href="#net-eval">net-eval</a>、
<a href="#net-listen">net-listen</a>、
<a href="#net-lookup">net-lookup</a>、
<a href="#net-receive">net-receive</a>、
<a href="#net-receive-udp">net-receive-udp</a>、
<a href="#net-select">net-select</a>、
<a href="#net-send">net-send</a>、
<a href="#net-send-udp">net-send-udp</a>、
<a href="#net-service">net-service</a> のいずれかを呼び出した時に発生した最後のエラーを取り出します。
これらの関数が失敗した時はいつも <tt>nil</tt> を返すので、より多くの情報を取り出すために <tt>net-error</tt> が使われます。<br />
Retrieves the last error that occurred when calling a any of the
following functions: <a href="#net-accept">net-accept</a>,
<a href="#net-connect">net-connect</a>,
<a href="#net-eval">net-eval</a>,
<a href="#net-listen">net-listen</a>,
<a href="#net-lookup">net-lookup</a>,
<a href="#net-receive">net-receive</a>,
<a href="#net-receive-udp">net-receive-udp</a>,
<a href="#net-select">net-select</a>,
<a href="#net-send">net-send</a>,
<a href="#net-send-udp">net-send-udp</a>,
and <a href="#net-service">net-service</a>. 
Whenever one of these functions fails, it returns <tt>nil</tt> and <tt>net-error</tt>
can be used to retrieve more information.</p>

<p>ソケット使用通信を行う関数はソケットを自動的に閉じて、 <a href="#net-sessions">net-sessions</a> のリストからソケットを削除します。<br />
Functions that communicate using sockets close the socket automatically and 
remove it from the <a href="#net-sessions">net-sessions</a> list.</p>

<p><a href="#socket_tcpip">net-*</a> が成功裏に終了した場合は、エラー番号を消去します。<br />
Each successful termination of a <a href="#socket_tcpip">net-*</a> 
function clears the error number.</p>

<p>（訳注：エラーが有る場合は）次のメッセージが返ります：<br />The following messages are returned:</p>

<table summary="net-error">
<tr align="left"><th>no</th><th>description</th></tr>
<tr><td>1</td><td>Cannot open socket</td></tr>
<tr><td>2</td><td>DNS resolution failed</td></tr>
<tr><td>3</td><td>Not a valid service</td></tr>
<tr><td>4</td><td>Connection failed</td></tr>
<tr><td>5</td><td>Accept failed</td></tr>
<tr><td>6</td><td>Connection closed</td></tr>
<tr><td>7</td><td>Connection broken</td></tr>
<tr><td>8</td><td>Socket send() failed</td></tr>
<tr><td>9</td><td>Socket recv() failed</td></tr>
<tr><td>10</td><td>Cannot bind socket</td></tr>
<tr><td>11</td><td>Too many sockets in net-select</td></tr>
<tr><td>12</td><td>Listen failed</td></tr>
<tr><td>13</td><td>Badly formed IP</td></tr>
<tr><td>14</td><td>Select failed</td></tr>
<tr><td>15</td><td>Peek failed</td></tr>
<tr><td>16</td><td>Not a valid socket</td></tr>
<tr><td>17</td><td>Cannot unblock socket</td></tr>
<tr><td>18</td><td>Operation timed out</td></tr>
<tr><td>19</td><td>HTTP bad formed URL</td></tr>
<tr><td>20</td><td>HTTP file operation failed</td></tr>
<tr><td>21</td><td>HTTP transfer failed</td></tr>
<tr><td>22</td><td>HTTP invalid response from server</td></tr>
<tr><td>23</td><td>HTTP no response from server</td></tr>
<tr><td>24</td><td>HTTP no content</td></tr>
<tr><td>25</td><td>HTTP error in header</td></tr>
<tr><td>26</td><td>HTTP error in chunked format</td></tr>
</table><br/>


<br/><br/>
<!-- example -->

<pre>
(net-error) <span class='arw'>&rarr;</span> nil

(net-connect "jhghjgkjhg" 80)  <span class='arw'>&rarr;</span>  nil

(net-error)  <span class='arw'>&rarr;</span>  (2 "ERR: "DNS resolution failed") 
</pre>

<p><em>int-error</em> が指定された時は、その番号とエラー番号のエラー・テキストを返します。<br />
When <em>int-error</em> is specified the number and error text for
that error number is returned.</p>


<pre>
(net-error 10) <span class='arw'>&rarr;</span> (10 "Cannot bind socket")
</pre>


<p><a href="#last-error">last-error</a> と <a href="#sys-error">sys-error</a> も見てください。<br />
See also <a href="#last-error">last-error</a> and <a href="#sys-error">sys-error</a>.</p>

<br/><br/>

<a name="net-eval"></a>
<h2><span class="function">net-eval</span></h2> 
<h4>syntax: (net-eval <em>str-host</em> <em>int-port</em> <em>exp</em> [<em>int-timeout</em> [<em>func-handler</em>]])<br/>
syntax: (net-eval '((<em>str-host</em> <em>int-port</em> <em>exp</em>) ... )  [<em>int-timeout</em> [<em>func-handler</em>]])</h4>

<p>一つ以上の newLISP サーバー上において、リモートでソースを評価するために使われます。
この関数は、リモート・サーバーへの接続に必要な全ての通信を処理し、評価用のソースを送信し、<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>を待って収集します。<br />
Can be used to evaluate source remotely on one or more newLISP servers. 
This function handles all communications necessary to connect to the remote servers, 
send source for evaluation, and wait and collect responses.</p>

<p><em>exp</em> 式は、目標ノードの環境下でリモートに評価されます。
<em>exp</em> はクォート式か文字列区切りに内包される式のどちらかです。
より大きな式には、ダブル・クォート <tt>" ... "</tt> の代わりに、 <tt>[text] ... [/text]</tt> 区切りを使うことができます。
一個より多い式を指定した時、目標ノードで全て評価されますが、最初の結果のみが返ります。<br />
The expression in <em>exp</em> will be evaluated remotely in the environment 
of the target node. The <em>exp</em> is either a quoted expression, or it is 
enclosed in string delimiters. For bigger expressions <tt>[text] ... [/text]</tt> 
delimiters can be used instead of double quotes <tt>" ... "</tt>.  Only one 
expression should be enclosed in the string. When more than one are specified,
all will get evaluated in the target node, but only the result of the first 
will be returned.</p>

<p>リモート TCP/IP サーバーは、次のような方法で開始されます：<br />
The remote TCP/IP servers are started in the following way:</p>


<pre>
newlisp -c -d 4711 &amp;

; preloading function definitions

newlisp preload.lsp -c -d 12345 &amp;

; logging connections

newlisp -l -c -d 4711 &amp;

; communicating via Unix local domain sockets

newlisp -c /tmp/mysocket
</pre>

<p>newLISP がプロンプトを出すのを抑制するには、<tt>-c</tt> オプションが必要です。<br />
The <tt>-c</tt> option is necessary to suppress newLISP emitting
prompts.</p>

<p>デーモン・モード <tt>-d</tt> は、newLISP の接続間の状態保持を許可します。
接続間の状態保持を望まない時は、<a href="#inetd_daemon">inetd デーモン モード</a> の方が有利です。
インターネットの <tt>inetd</tt> あるいは  <tt>xinetd</tt> サービス・デーモンは、各クライアント接続毎に一つの新規 newLISP プロセスを開始します。
これは、複数の接続において、より高速なサービスを作り出します。
<tt>-d</tt> デーモン・モードでは、各クライアントの<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>は先行している<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>が終わるのを待たなければなりません。
このモードの正しい設定方法は、<a href="#inetd_daemon">inetd デーモン モード</a> の章で見てください。<br />
The <tt>-d</tt> daemon mode allows newLISP to maintain state between 
connections.  When keeping state between connections is not desired, 
the <a href="#inetd_daemon">inetd daemon mode</a> offers more advantages. 
The Internet <tt>inetd</tt> or <tt>xinetd</tt> services daemon 
will start a new newLISP process for each client connection. 
This makes for much faster servicing of multiple connections. 
In <tt>-d</tt> daemon mode, each new client request 
would have to wait for the previous request to be finished. 
See the chapter <a href="#inetd_daemon">inetd daemon mode</a> 
on how to configure this mode correctly.</p>

<p><tt>4711</tt> の代わりに、他のポート番号も使えます。
異なるホストにおいて、同じか違うポート番号で、複数のノードを始められます。
通信やリモート・コマンドのログを取るために、ロギング・オプションの <tt>-l</tt> あるいは <tt>-L</tt> を指定できます。<br />
Instead of <tt>4711</tt>, any other port number can be used. 
Multiple nodes can be started on different hosts and with the same 
or different port numbers.  The <tt>-l</tt> or <tt>-L</tt> logging options
can be specified to log connections and remote commands.</p>


<p>第一構文の <tt>net-eval</tt> は、一つのリモート newLISP サーバー・ノードとだけ <ruby>会話<rp>（</rp><rt>トーク</rt><rp>）</rp></ruby>し、<em>str-host</em> ホストの <em>int-port</em> ポートに式 <em>exp</em> を評価する<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を送ります。
<em>int-timeout</em> がない時、<tt>net-eval</tt> は接続後に <ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>があるまで 60 秒待ちます。
一方で（訳注：<em>int-timeout</em> がある時）、そのミリ秒のタイム・アウト時間が経過すると <tt>nil</tt> を返します。
そうでなければ、<em>exp</em> の評価結果が返ります。<br />
In the first syntax, <tt>net-eval</tt> talks to only one 
remote newLISP server node, sending the host in <em>str-host</em>
on port <em>int-port</em> a request to evaluate the expression 
<em>exp</em>.  If <em>int-timeout</em> is not given, 
<tt>net-eval</tt> will wait up to 60 seconds for a response
after a connection is made.
Otherwise, if the timeout in milliseconds has expired, 
<tt>nil</tt> is returned; else, the evaluation result of <em>exp</em> 
is returned.</p>

<!-- example -->

<pre>
; the code to be evaluated is given in a quoted expression
(net-eval "192.168.1.94" 4711 '(+ 3 4))       <span class='arw'>&rarr;</span> 7

; expression as a string (only one expression should be in the string)
(net-eval "192.168.1.94" 4711 "(+ 3 4)")      <span class='arw'>&rarr;</span> 7

; with timeout
(net-eval "192.168.1.94" 4711 '(+ 3 4) 1)     <span class='arw'>&rarr;</span> nil  ; 1ms timeout too short
(net-error)                                   <span class='arw'>&rarr;</span> (17 "ERR: Operation timed out")

(net-eval "192.168.1.94" 4711 '(+ 3 4) 1000)  <span class='arw'>&rarr;</span> 7

; program contained in a variable
(set 'prog '(+ 3 4))
(net-eval "192.168.1.94" 4711 prog)           <span class='arw'>&rarr;</span> 7

; specify a local-domain Unix socket (not available on MS Windows)
(net-eval "/tmp/mysocket" 0 '(+ 3 4))         <span class='arw'>&rarr;</span> 7
</pre>


<p><tt>net-eval</tt> の第二構文は、<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>の全てが集められるかタイム・アウトが起こると、結果のリストを返します。
タイム・アウト時の<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>には、<tt>nil</tt> が返ります。
例の最後の行は、ソケット・パスとポート番号 <tt>0</tt> を指定してローカル・ドメイン Unix ソケットを指定する方法を示しています。
接続エラーもしくはノードに情報を送信した時に起こるエラーが、エラー番号と詳細エラー文字列のリストとして返っています。
返される可能性のあるエラー・メッセージのリストは、関数 <a href="#net-error">net-error</a> で見てください。<br />
The second syntax of <tt>net-eval</tt> returns a list of the results
after all of the responses are collected or timeout occurs. Responses that 
time out return <tt>nil</tt>.  The last example line shows how to specify
a local-domain Unix socket specifying the socket path and a port number of 
<tt>0</tt>.  Connection errors or errors that occur when sending information 
to nodes are returned as a list of error numbers and descriptive error 
strings.  See the function <a href="#net-error">net-error</a> for a list of 
potential error messages.</p>

<!-- example -->

<pre>
; two different remote nodes different IPs
(net-eval '(
    ("192.168.1.94" 4711 '(+ 3 4)) 
    ("192.168.1.95" 4711 '(+ 5 6))
    ) 5000)
<span class='arw'>&rarr;</span> (7 11)

; two persistent nodes on the same CPU different ports
(net-eval '(
    ("localhost" 8081 '(foo "abc")) 
    ("localhost" 8082 '(myfunc 123)') 
    ) 3000)

; inetd or xinetd nodes on the same server and port
; nodes are loaded on demand
(net-eval '(
    ("localhost" 2000 '(foo "abc")) 
    ("localhost" 2000 '(myfunc 123))
    ) 3000)
</pre>


<p>最初の例は、二つの異なるリモート・ノードで評価される二つの式を示しています。
二番目の例は、ローカル・コンピュータ上の二つのノードに対してです。
コンピュータ上のマルチCPUのデバックや優位性を語る上で、これが役立つかもしれません。
ポート番号に <tt>0</tt> を指定すると、<tt>net-eval</tt> はホスト名としてローカル・ドメイン Unix ソケットへのフルパスを取ります。<br />
The first example shows two expressions evaluated on two different remote 
nodes. In the second example, both nodes run on the local computer. This may 
be useful when debugging or taking advantage of multiple CPUs on the same 
computer.  When specifying <tt>0</tt> for the port number , <tt>net-eval</tt> 
takes the host name as the file path to the local-domain Unix socket.</p>

<p><tt>foo</tt> や <tt>myfunc</tt> の定義が両方共、目標環境に存在しなければならないことに注意してください。
これは、前もって <tt>define</tt> 宣言文を送信して <tt>net-eval</tt> を使えば可能です。
リモート・ノードの開始時に、コードをロードして置くことでも可能です。<br />
Note that definitions of <tt>foo</tt> and <tt>myfunc</tt> must both
exist in the target environment. This can be done using a <tt>net-eval</tt>
sending <tt>define</tt> statements before. It also can be done by
preloading code when starting remote nodes.</p>

<p>ノードが、inetd か xinetd の制御下であれば、いくつかのノードが同じ IP アドレスとポートを持てるかもしれません。
この場合、Unix のデーモン inetd または xinetd が <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>に応じて複数の newLISP を開始します。
これは、たった一つしかないマシンで配布プログラムをテストする時に役立ちます。
最後の例が、その状況を示しています。
プラットフォーム OS が異なる CPU コアに異なるプロセスを配置できるマルチ・コア CPU 上でも役立ちます。<br />
When nodes are inetd or xinetd-controlled, several nodes may have the 
same IP address and port number. In this case, the Unix 
daemon inetd or xinetd will start multiple newLISP servers on demand. 
This is useful when testing distributed programs on just one machine. 
The last example illustrates this case. It is also useful on multi core
CPUs, where the platform OS can distribute different processes on to different
CPU cores.</p>

<p>評価のために送るソースには、複数ラインのプログラムを含めることができます。
この方法では、リモート・ノードは最初にプログラムをロードし、その後に特定の関数を呼び出せます。
大規模プログラム・ファイルのプログラム転送には、関数 <a href="#put-url">put-url</a> や <a href="#save">save</a>（URL ファイル名を使用）を使えます。
<tt>net-eval</tt> 宣言文がこれらのプログラムをロードできます。<br />
The source sent for evaluation can consist of entire multiline programs. 
This way, remote nodes can be loaded with programs first, then specific 
functions can be called.  For large program files, the functions 
<a href="#put-url">put-url</a> or <a href="#save">save</a> (with a URL 
file name) can be used to transfer programs. The a <tt>net-eval</tt>
statement could load these programs.</p>

<p>オプションでハンドラ関数を指定できます。
この関数は、待ち時間毎に繰り返し呼び出され、リモート評価が全て終了した時にも一回呼び出されます。<br />
Optionally, a handler function can be specified. This function will be 
repeatedly called while waiting and once for every remote evaluation completion.</p>

<!-- example -->

<pre>
(define (myhandler param)
    (if param
        (println param))
)

(set 'Nodes '(
    ("192.168.1.94" 4711)
    ("192.168.1.95" 4711)
))

(set 'Progs '(
    (+ 3 4)
    (+ 5 6)
))

(net-eval (map (fn (n p) (list (n 0) (n 1) p)) Nodes Progs) 5000 myhandler)
<span class='arw'>&rarr;</span>
("192.168.1.94" 4711 7)
("192.168.1.95" 4711 11)
</pre>

<p>例では、ノード指定のリストがノードのリストと評価用ソースから組み立てられる様子を示しています。
これは、多数のリモート・ノードとの接続時に役立つかもしれません。<br />
The example shows how the list of node specs can be assembled from a list 
of nodes and sources to evaluate. This may be useful when connecting to a 
larger number of remote nodes.</p>

<pre>
(net-eval (list 
  (list (Nodes 0 0) (Nodes 0 1) (Progs 0)) 
  (list (Nodes 1 0) (Nodes 1 1) (Progs 1)) 
 ) 3000 myhandler)
</pre>

<p>リモート・ノードからの入力を待っている間、<tt>myhandler</tt> は引数 <tt>param</tt> を <tt>nil</tt> にして呼び出されます。
リモート・ノードの結果が全て受信されると、リモート・ホスト名か IP 番号 かポートと結果の式からなるリストにセットされた <tt>param</tt> で <tt>myhandler</tt> が呼び出されます。
<tt>net-eval</tt> は、タイム・アウト前に <tt>true</tt> を返し、タイム・アウトに達するか過ぎた時に <tt>nil</tt> を返します。
タイム・アウトを過ぎた全てのリモート・ホストは、結果のリストに <tt>nil</tt> を含みます。<br />
While waiting for input from remote hosts, <tt>myhandler</tt> will be called 
with <tt>nil</tt> as the argument to <tt>param</tt>.  When a remote node result 
is completely received, <tt>myhandler</tt> will be called with <tt>param</tt> 
set to a list containing the remote host name or IP number, the port, and the 
resulting expression. <tt>net-eval</tt> will return <tt>true</tt> before a 
timeout or <tt>nil</tt> if the timeout was reached or exceeded.  All remote hosts 
that exceeded the timeout limit will contain a <tt>nil</tt> in their results list.
</p>

<p>より長い例には、このプログラムを見てください：<a href="http://www.newlisp.org/syntax.cgi?code/mapreduce.txt">mapreduce</a>。
この例は、単語計数タスクを三つのリモート・ノードに配布する方法を示しています。
三つのノードは異なるテキストの単語を計数し、マスター・ノードが結果を受け取り、まとめます。<br />
For a longer example see this program:
<a href="http://www.newlisp.org/syntax.cgi?code/mapreduce.txt">mapreduce</a>.
The example shows how a word counting task gets distributed to three remote
nodes. The three nodes count words in different texts and the master node
receives and consolidates the results.</p>

<br/><br/>

<a name="net-interface"></a>
<h2><span class="function">net-interface</span></h2>
<h4>syntax: (net-interface <em>str-ip-addr</em>)<br/>
syntax: (net-interface)</h4>

<p>ネットワーク通信に使われるデフォルトのローカル・インターフェイス・アドレスを設定します。
設定していなければ、<a href="#net-listen">net-listen</a> に与えられるインターフェイス・アドレスで上書きされていない限り、ネットワーク関数は内部デフォルト・アドレスをデフォルトにします。<br />
Sets the default local interface address to be used for network connections.
If not set then network functions will default to an internal default address,
except when overwritten by an optional interface address given in 
<a href="#net-listen">net-listen</a>.</p>

<p><em>str-ip-addr</em> を指定しない時には、現行のデフォルト値が返ります。
その以前に、<tt>net-interface</tt> を IP アドレス指定に使っていなければ、アドレス <tt>0.0.0.0</tt> が返ります。
これは、ネットワーク・ルーチン全てがオペレーティング・システム下で予め設定されたデフォルト・アドレスを使うことを意味します。<br />
When no <em>str-ip-addr</em> is specified, the current default is returned.
If the <tt>net-interface</tt> has not been used yet to specify an IP address,
the address <tt>0.0.0.0</tt> is returned. This means that all network routines
will use the default address preconfigured by the underlying operating system.</p>

<p>複数のネットワーク・インターフェイス・ハードウェアを持つか、複数のIP番号を用意しているマルチ・ホーム・サーバでのみ、この関数を使います。
ネットワーク関数は他の機器において、インストールされている単一ネットワークを自動的に選択するからです。<br />
This function has only usage on multihomed servers with either multiple network 
interface hardware or otherwise supplied multiple IP numbers. On all other machines 
network functions will automatically select the single network interface installed.</p>

<p>関数はエラー発生時に <tt>nil</tt> を返し、エラー内容を報告させるために <a href="#net-error">net-error</a> を使えます。<br />
On error the function returns <tt>nil</tt> and <a href="#net-error">net-error</a>
can be used to report the error.</p>

<!-- example -->

<pre>
(net-interface "192.168.1.95")  <span class='arw'>&rarr;</span> "192.168.1.95"
(net-interface "localhost")     <span class='arw'>&rarr;</span> "127.0.0.1"
</pre>


<p>インターフェイス・アドレスには、IP アドレスか名前を指定できます。
戻り値は <em>str-ip-addr</em> に与えられたアドレスです。<br />
An interface address can be defined as either an IP address or a name. The
return value is the address given in <em>str-ip-addr</em></p>

<br/><br/>

<a name="net-ipv"></a>
<h2><span class="function">net-ipv</span></h2>
<h4>syntax: (net-ipv <em>int-version</em>)<br/>
syntax: (net-ipv)</h4>

<p>インターネット・プロトコル・バージョンの IPv4 と IPv6 間を切り替えます。
<em>int-version</em> は、IPv4 の 4 か IPv6 の 6 が入ります。
パラメータが無い時、<tt>net-ipv</tt> は現在の設定を返します。<br />
Switches between IPv4 and IPv6 internet protocol versions. 
<em>int-version</em> contains either a 4 for IPv4 or a 6 for IPv6. When no 
parameter is given, <tt>net-ipv</tt> returns the current setting.</p>

<!-- example -->

<pre>
(net-ipv)      <span class='arw'>&rarr;</span> 4
(net-ipv 6)    <span class='arw'>&rarr;</span> 6
</pre>

<p>デフォルトの newLISP は IPv4 モードで開始します。
newLISP スタート時は、コマンド・ラインから IPv6 プロトコル・モードを指定できます：<br />
By default newLISP starts up in IPv4 mode. The IPv6 protocol mode can also 
be specified from the commandline when starting newlisp:</p>

<pre>
newlisp -6
</pre>

<p>ソケットを <a href="#net-connect">net-connect</a> で接続するか、<a href="#net-listen">net-listen</a> で待ち受け（listen）するなら、関数<a href="#net-accept">net-accept</a>、
<a href="#net-select">net-select</a>、<a href="#net-send">net-send</a>、<a href="#net-receive">net-receive</a>、<a href="#net-receive-from">net-receive-from</a> は、ソケットを生成した時に使わるアドレス・プロトコルに自動的に合わせます。
IPv4/6 設定の異なる接続を同時に開くことができます。<br />
Once a socket is connected with either 
<a href="#net-connect">net-connect</a> 
or listened on with 
<a href="#net-listen">net-listen</a>, the 
<a href="#net-accept">net-accept</a>, <a href="#net-select">net-select</a>, 
<a href="#net-send">net-send</a>, <a href="#net-receive">net-receive</a> and 
<a href="#net-receive-from">net-receive-from</a> 
functions automatically adjust to the address protocol used when creating the sockets.

Different connections with different IPv4/6 settings can be open at the same time.</p>

<p>現行の <a href="#net-packet">net-packet</a> は IPv6 をサポートせず、設定にかかわらず IPv4 で動作することに注意してください。<br />
Note, that currently <a href="#net-packet">net-packet</a> does not support IPv6 and will 
work in IPv4 mode regardless of settings.</p>

<br/><br/>

<a name="net-listen"></a>
<h2><span class="function">net-listen</span></h2>
<h4>syntax: (net-listen <em>int-port</em> [<em>str-ip-addr</em> [<em>str-mode</em>]])<br/>
syntax: (net-listen <em>str-file-path</em>)</h4>

<p><em>int-port</em> で指定されたポートを待ち受け（listen）ます。
<tt>net-listen</tt> の呼び出しは直ちにソケット番号を返し、その番号は後で接続を待つブロッキング関数 <a href="#net-accept">net-accept</a> で使われることになります。
<a href="#net-accept">net-accept</a> は接続が受け入れられるとすぐに、接続しているクライアントとの通信に使われるソケット番号を返します。<br />
Listens on a port specified in <em>int-port</em>.  A call to <tt>net-listen</tt>
returns immediately with a socket number, which is then used by 
the blocking <a href="#net-accept">net-accept</a> function 
to wait for a connection.  As soon as a connection is accepted, 
<a href="#net-accept">net-accept</a> returns a socket number 
that can be used to communicate with the connecting client.</p>


<!-- example -->

<pre>
(set 'port 1234)
(set 'listen (net-listen port))
(unless listen (begin
    (print "listening failed\n")
    (exit)))

(print "Waiting for connection on: " port "\n")

(set 'connection (net-accept listen))
(if connection
    (while (net-receive connection buff 1024 "\n")
        (print buff)
        (if (= buff "\r\n") (exit)))
    (print "Could not connect\n"))
</pre>


<p>例では、ポート 1234 の接続を待って、それから、空のラインを受け取るまで入力ラインを読み込みます。
Unix システムで 1024 より小さいポートを待ち受け（listen）ることは、スーパー・ユーザ・アクセスを要求する事に注意してください。<br />
The example waits for a connection on port 1234, then reads incoming lines 
until an empty line is received.  Note that listening on ports lower than 1024
may require superuser access on Unix systems.</p>

<p>一個より多いインターフェイス・カードを持つコンピュータ上では、<em>str-ip-addr</em> オプションにインターフェイス IP アドレスか名前を指定して、<tt>net-listen</tt> に指定したアドレスの待ち受け（listen）を指示します。<br />
On computers with more than one interface card, specifying an optional 
interface IP address or name in <em>str-ip-addr</em> directs <tt>net-listen</tt> 
to listen on the specified address.</p>


<pre>
;; listen on a specific address
(net-listen port "192.168.1.54") 
</pre>


<h3>Local domain Unix sockets（ローカル ドメイン Unix ソケット）</h3>

<p>第二構文の <tt>net-listen</tt> は、<em>str-file-path</em> を使って名前付けられた<em>ローカル・ドメイン Unix ソケット</em> を通して、ローカル・ファイル・システム上のクライアントを待ち受け（listen）ます。
成功すればソケット・ハンドルを返し、それを使って <a href="#net-accept">net-accept</a> がクライアントとの接続を受け入れることができます。成功しなければ <tt>nil</tt> を返します。<br />
In the second syntax, <tt>net-listen</tt> listens for a client on the 
local file system via a <em>local domain Unix socket</em> named using 
<em>str-file-path</em>.	If successful, returns a socket handle that can be 
used with <a href="#net-accept">net-accept</a> to accept a client connection; 
otherwise, returns <tt>nil</tt>.</p>

<!-- example -->

<pre>
(net-listen "/tmp/mysocket")  <span class='arw'>&rarr;</span> 5

; on OS/2 use "\\socket\\" prefix

(net-listen "\\socket\\mysocket")

(net-accept 5)
</pre>


<p><em>ローカル・ドメイン</em>・ファイル・システム・ソケットが生成され、待ち受け（listen）状態になっています。
クライアントは、同じ <em>str-file-path</em> を使って接続を試みます。
接続が関数 <a href="#net-select">net-select</a> に受け入れられた後、通常の TCP/IP ストリーム通信に <a href="#net-send">net-send</a> と <a href="#net-receive">net-receive</a> を使うことができます。
この形の接続は、同じファイル・システム上のプロセス間高速双方向通信チャンネルとして使えます。
この形の接続は、MS Windows プラットフォームでは使えません。<br />
A <em>local domain</em> file system socket is created and listened on.
A client will try to connect using the same <em>str-file-path</em>.
After a connection has been accepted the functions <a href="#net-select">net-select</a>,
<a href="#net-send">net-send</a> and <a href="#net-receive">net-receive</a> can be used 
as usual for TCP/IP stream communications. This type of connection can be used as a fast
 bi-directional communications channel between processes on the same file system.
This type of connection is not available on MS Windows platforms.</p>


<h3>UDP communications（UDP 通信）</h3>

<p>第三パラメータとして、<em>str-mode</em> にオプション文字列 <tt>"udp"</tt> または <tt>"u"</tt> を指定でき、UDP（ユーザ・データグラム・プロトコル）通信に適したソケット一式を生成します。
TCP 通信にのみ使われる <tt>net-accept</tt> を使うこと<em>無し</em> に、この方法で作られたソケットを <a href="#net-receive-from">net-receive-from</a> に直接使うことができ、入力 UDPデータを待ちます。
<a href="#net-receive-from">net-receive-from</a> 呼び出しは、UDP データ・パケットを受信するまでブロックします。
代わりの方法として、ノン・ブロッキング状態でデータが準備できたかどうかのチェックするために、<a href="#net-select">net-select</a> か <a href="#net-peek">net-peek</a> を使うことができます。
<a href="#net-receive-from">net-receive-from</a> で受け取ったアドレスとポートへのデータ返送には、<a href="#net-send-to">net-send-to</a> を使ってください。<br />
As a third parameter, 
the optional string <tt>"udp"</tt> or <tt>"u"</tt> 
can be specified in <em>str-mode</em> 
to create a socket suited for UDP 
(User Datagram Protocol) communications.
A socket created in this way 
can be used directly with 
<a href="#net-receive-from">net-receive-from</a>
to await incoming UDP data 
<em>without</em> using <tt>net-accept</tt>, 
which is only used in TCP communications. 
The <a href="#net-receive-from">net-receive-from</a> call 
will block until a UDP data packet is received. 
Alternatively, <a href="#net-select">net-select</a> 
or <a href="#net-peek">net-peek</a> can be used 
to check for ready data in a non-blocking fashion. 
To send data back to the address and port received 
with <a href="#net-receive-from">net-receive-from</a>, 
use <a href="#net-send-to">net-send-to</a>.
</p>

<p>UDP 通信は、アドレス情報としての接続ソケットを保持しないので、<a href="#net-peer">net-peer</a> が動作しないことに注意してください。<br />
Note that <a href="#net-peer">net-peer</a> will not work, 
as UDP communications do not maintain 
a connected socket with address information.
</p>


<pre>
(net-listen 10002 "192.168.1.120" "udp") 

(net-listen 10002 "" "udp") 
</pre>


<p>
一番目の例は、指定したネットワーク・アダプタを待ち受け（listen）ます。
一方で、二番目の例はデフォルト・アダプタを待ち受け（listen）ます。
どちらの呼び出しもソケット番号を返し、引き続く関数 <a href="#net-receive">net-receive</a>、<a href="#net-receive-from">net-receive-from</a>、<a href="#net-send-to">net-send-to</a>、<a href="#net-select">net-select</a>、<a href="#net-peek">net-peek</a> の呼び出しに使われます。<br />
The first example listens on a specific network adapter, 
while the second example listens on the default adapter. 
Both calls return a socket number 
that can be used in subsequent <a href="#net-receive">net-receive</a>,
<a href="#net-receive-from">net-receive-from</a>, 
<a href="#net-send-to">net-send-to</a>,
<a href="#net-select">net-select</a>, 
or <a href="#net-peek">net-peek</a> function calls.
</p>

<p>UDP サーバー <em>と</em> UDP クライアントのどちらも、<tt>net-listen</tt> に <tt>"udp"</tt> オプションを使って設定されます。
このモードでは、<tt>net-listen</tt> が実際に TCP/IP 通信を<em>待ち受け（listen）</em> ることはありません。
ローカル・インターフェイスのアドレスとポートにソケットを束縛するだけです。<br />
Both a UDP server <em>and</em> UDP client 
can be set up using <tt>net-listen</tt> 
with the <tt>"udp"</tt> option. 
In this mode, <tt>net-listen</tt> 
does not really <em>listen</em>
as in TCP/IP communications; 
it just binds the socket 
to the local interface address and port.
</p>

<p>動作例としては、newLISP 配布ソースにあるファイル <tt>examples/client</tt> と <tt>examples/server</tt> を見てください。<br />
For a working example, see the files 
<tt>examples/client</tt> and <tt>examples/server</tt>
in the newLISP source distribution.
</p>

<p>一つのデータ・パケットだけような短い処理には、<tt>"udp"</tt> オプションの <tt>net-listen</tt> の代わりに、関数 <a href="#net-receive-udp">net-receive-udp</a> と <a href="#net-send-udp">net-send-udp</a> を使うことができます。<br />
Instead of <tt>net-listen</tt> 
and the <tt>"udp"</tt> option,
the functions <a href="#net-receive-udp">net-receive-udp</a>  
and <a href="#net-send-udp">net-send-udp</a>
can be used for short transactions 
consisting only of one data packet.
</p>

<p><tt>net-listen</tt>、<a href="#net-select">net-select</a>、<a href="#net-peek">net-peek</a> は、ノン・ブロッキング読み出しを簡単にするために使われます。
待ち受け（listen）／読み出しソケットが閉じらないだけでなく、引き続き読み出しに使えるからです。
対照的に、<a href="#net-receive-udp">net-receive-udp</a> と <a href="#net-send-udp">net-send-udp</a> のペアの使用は、どちらのサイドも送受信終了後、ソケットを閉じます。<br />
<tt>net-listen</tt>, <a href="#net-select">net-select</a>, 
and <a href="#net-peek">net-peek</a> can be used 
to facilitate non-blocking reading. 
The listening/reading socket is not closed 
but is used again for subsequent reads. 
In contrast, when the 
<a href="#net-receive-udp">net-receive-udp</a> 
and <a href="#net-send-udp">net-send-udp</a> pair is used, 
both sides close the sockets after sending and receiving.
</p>


<h3>UDP multicast communications（UDP マルチキャスト通信）</h3>

<p>オプション文字列 <em>str-mode</em> に <tt>"multi"</tt> か <tt>"m"</tt> を指定すると、<tt>net-listen</tt> はマルチキャストに適切なソケットを返します。
この場合、<em>str-ip-addr</em> にはマルチキャスト・アドレス範囲 <tt>224.0.0.0</tt> ～ <tt>239.255.255.255</tt> 中の一つが入ります。
<tt>net-listen</tt> は <em>str-ip-addr</em> をマルチキャスト伝送受信用アドレスとして登録します。
このアドレスをサーバー・ホストの IP アドレス と混同してはいけません。<br />
If the optional string <em>str-mode</em> is specified as 
<tt>"multi"</tt> or <tt>"m"</tt>, 
<tt>net-listen</tt> returns a socket suitable for multicasting. 
In this case, <em>str-ip-addr</em> contains one 
of the multicast addresses in the range <tt>224.0.0.0</tt> 
to <tt>239.255.255.255</tt>.
<tt>net-listen</tt> will register <em>str-ip-addr</em> 
as an address on which to receive multicast transmissions. 
This address should not be confused with the IP address 
of the server host.
</p>


<!-- example -->

<pre>
;; example client

(net-connect "226.0.0.1" 4096 "multi")  <span class='arw'>&rarr;</span> 3

(net-send-to "226.0.0.1" 4096 "hello" 3)


;; example server

(net-listen 4096 "226.0.0.1" "multi")  <span class='arw'>&rarr;</span> 5

(net-receive-from 5 20)               
<span class='arw'>&rarr;</span> ("hello" "192.168.1.94" 32769)
</pre>


<p>サーバー側では、ノン・ブロッキング通信に <a href="#net-peek">net-peek</a> か <a href="#net-select">net-select</a> が使われます。
上記例のサーバーは、データが受信されるまでブロックします。<br />
On the server side, 
<a href="#net-peek">net-peek</a> or <a href="#net-select">net-select</a>
can be used for non-blocking communications.  In the example above, 
the server would block until a datagram is received.</p>

<p>関数 <a href="#net-send-to">net-send-to</a> と <a href="#net-receive-from">net-receive-from</a> の代わりに、<a href="#net-send">net-send</a> と <a href="#net-receive">net-receive</a> が使えます。<br />
The <a href="#net-send">net-send</a> 
and <a href="#net-receive">net-receive</a> functions 
can be used instead of <a href="#net-send-to">net-send-to</a> 
and <a href="#net-receive-from">net-receive-from</a>.
</p>


<h3>Packet divert sockets and ports（パケット迂回ソケットとポート）</h3>

<p>BSD ライクのプラットフォーム上で、<em>str-mode</em> に <tt>"divert"</tt> が指定されると、<em>int-port</em> を迂回ポートとする迂回ソケットが生成されます。
IP アドレスの内容 <em>str-ip-addr</em> は無視されます。
<em>int-port</em> だけが有効で、返される生のソケットに束縛されます。<br />
If <em>str-mode</em> is specified as <tt>"divert"</tt>, a divert socket 
can be created for a divert port in <em>int-port</em> on BSD like platforms.
The content of IP address in <em>str-ip-addr</em> is ignored 
and can be specified as an empty string. Only the <em>int-port</em> is
relevant and will be bound to the raw socket returned.</p>

<p><tt>net-listen</tt> で迂回オプションを使うには、newLISP が特権モードで走っていなければなりません。
このオプションは、 Unix ライクのプラットフォームでのみ利用可能です。<br />
To use the divert option in <tt>net-listen</tt>, newLISP must run in
super-user mode. This option is only available on Unix like platforms.</p>

<p><tt>divert</tt> ソケットは、迂回ポートに迂回された生ソケットを全て受け取ります。
また、パケットは迂回ソケットに書き戻されるかもしれず、その場合のパケットは OS カーネルの IP パケット処理に再び入ります。<br />
The divert socket will receive all raw packets diverted 
to the divert port. Packets may also be written back to a divert socket, 
in which case they re-enter OS kernel IP packet processing.</p>

<p>迂回ポートへのパケット迂回ルールは、BSD の <em>ipfw</em> か Linux の <em>ipchains</em> かどちらかの設定ユーティリティで定義されていなければなりません。<br />
Rules for packet diversion to the divert port must be defined using 
either the <em>ipfw</em> BSD or <em>ipchains</em> Linux configuration
utilities.</p>

<p><tt>net-listen</tt> 宣言文で生成され、返された迂回ソケット上の生パケットの読み書きには、関数 <a href="#net-receive-from">net-receive-from</a> と <a href="#net-send-to">net-send-to</a> が使われます。
パケット再入の際、<a href="#net-receive-from">net-receive-from</a> で受け取ったのと同じアドレスが <a href="#net-send-to">net-send-to</a> 呼び出しに使われます：<br />
The <a href="#net-receive-from">net-receive-from</a> and
<a href="#net-send-to">net-send-to</a> functions are used to read
and write raw packets on the divert socket created and returned by the
<tt>net-listen</tt> statement. The same address received by
<a href="#net-receive-from">net-receive-from</a> is used in the 
<a href="#net-send-to">net-send-to</a> call when re-injecting the 
packet:</p>

<pre>
; rules have been previously configured for a divert port
(set 'divertSocket (net-listen divertPort "" "divert"))

(until (net-error)
    (set 'rlist (net-receive-from divertSocket maxBytes))
    (set 'buffer (rlist 1))
    ; buffer can be processed here before reinjecting
    (net-send-to (rlist 0) divertPort buffer divertSocket)
)
</pre>

<p>詳細な情報は、Unix man ページで <em>divert</em> の項か、設定ユーティリティ <em>ipfw</em> (BSDs) か <em>ipchains</em> (Linux) を見てください。<br />
For more information see the Unix man pages for <em>divert</em>
and the <em>ipfw</em> (BSDs) or <em>ipchains</em> (Linux) configuration 
utilities.</p>

<br/><br/>

<a name="net-local"></a>
<h2><span class="function">net-local</span></h2>
<h4>syntax: (net-local <em>int-socket</em>)</h4>

<p>ローカル・コンピュータの <em>int-socket</em> で指定された接続用 IP 番号とポートを返します。<br />
Returns the IP number and port of the local computer 
for a connection on a specific <em>int-socket</em>.</p>

<!-- example -->

<pre>
(net-local 16)  <span class='arw'>&rarr;</span> ("204.179.131.73" 1689)
</pre>

<p>リモート・コンピュータの IP 番号とボートへのアクセスには、関数 <a href="#net-peer">net-peer</a> を使ってください。<br />
Use the <a href="#net-peer">net-peer</a> 
function to access the remote computer's 
IP number and port.
</p>

<br/><br/>

<a name="net-lookup"></a>
<h2><span class="function">net-lookup</span></h2>

<h4>syntax: (net-lookup <em>str-ip-number</em>)<br/>
syntax: (net-lookup <em>str-hostname</em> [<em>bool</em>])</h4>


<p>IP ドット形式の <em>str-ip-number</em> からホスト名の文字列を返すか、<em>str-hostname</em> からドット形式の IP 番号を返します。<br />
Returns either a hostname string 
from <em>str-ip-number</em> 
in IP dot format or the IP number 
in dot format from <em>str-hostname</em>:
</p>

<!-- example -->

<pre>
(net-lookup "209.24.120.224")    <span class='arw'>&rarr;</span> "www.nuevatec.com"
(net-lookup "www.nuevatec.com")  <span class='arw'>&rarr;</span> "209.24.120.224"

(net-lookup "216.16.84.66.sbl-xbl.spamhaus.org" true)
<span class='arw'>&rarr;</span> "216.16.84.66"
</pre>


<p>第二構文では、オプションの <em>bool</em> フラグを指定できます。
<em>bool</em> の式が <tt>nil</tt> 以外に評価されると、（訳注：引数の）名前文字列が IP 番号で始まっていたとしても、ホスト名からの検索になります。<br />
Optionally, a <em>bool</em> flag 
can be specified in the second syntax. 
If the expression in <em>bool</em> 
evaluates to anything other than <tt>nil</tt>,
host-by-name lookup will be forced, 
even if the name string starts 
with an IP number.
</p>

<br/><br/>

<a name="net-packet"></a>
<h2><span class="function">net-packet</span></h2>
<h4>syntax: (net-packet <em>str-packet</em>)</h4>

<p>この関数は、<em><a href="http://ja.wikipedia.org/wiki/Raw_socket">raw sockets</a></em> インターフェイスを通して送信されるカスタム構成のネットワーク・パケットを許可します。
<em>str-packet</em> のパケットは、TCP か UDP か ICMP ヘッダーのいずれかとオプション・データが続く IP（インターネット・プロトコル）ヘッダーで始まっていなければなりません。
newLISP はスーパー・ユーザ特権で走っている必要があります。
また、この関数は macOS、Linux、その他の Unix オペレーティングシステムにおいて、IPv4 でのみ利用可能です。
現在の <tt>net-packet</tt> は IPv4 用のみであり、macOS、Linux、OpenBSD で試してあります。<br />
The function allows custom configured network packets to be sent via
a <em>raw sockets</em> interface. The packet in <em>str-packet</em> must
start with an IP (Internet Protocol) header followed by either
a TCP, UDP or ICMP header and optional data. newLISP must be run with
super user privileges, and this function is only available on macOS,
Linux and other Unix operating systems and only for IPv4.
Currently <tt>net-packet</tt> is IPv4 only and has been tested on
macOS, Linux and OpenBSD.</p> 

<p>この関数は、成功時に送信バイト数を返します。
失敗時には <tt>nil</tt> を返しますので、<a href="#net-error">net-error</a> と <a href="#sys-error">sys-error</a> の両方で調べたほうがよいでしょう。<br />
On success the function returns the number of bytes sent. On failure
the function returns <tt>nil</tt> and both, <a href="#net-error">net-error</a>
and <a href="#sys-error">sys-error</a>, should be inspected.</p>

<p>カスタム構成のパケットのチェックサム・フィールドにゼロが入っている時は、
<tt>net-packet</tt> が正しいチェックサムを計算して挿入します。
すでにチェックサムがある時は触らず、そのままにます。<br />
When custom configured packets contain zeros in the checksum fields,
<tt>net-packet</tt> will calculate and insert the correct checksums. 
Already existing checksums stay untouched.</p>

<p>次の例は、IP 番号 <tt>192.168.1.92</tt> に UDP パケットを送り込みます。
IP ヘッダーは、目標 IP 番号で終わる 20 バイトからなります。
続く UDP ヘッダーは 8 バイトの長さを持ち、データ文字列 <tt>Hello World</tt> が続きます。
両ヘッダーのチェックサム・バイトである <tt>0x00 0x00</tt> は破棄され、内部で再計算されます。<br />
The following example injects a UDP packet for IP number <tt>192.168.1.92</tt>.
The IP header consists of 20 bytes ending with the target IP number. The following
UDP header has a length of 8 bytes and is followed by the data string
<tt>Hello World</tt>. The checksum bytes in both headers are left as 
<tt>0x00 0x00</tt> and will be recalculated internally.</p>

<!-- example -->

<pre>
; packet as generated by: (net-send-udp "192.168.1.92" 12345 "Hello World")

(set 'udp-packet (pack (dup "b" 39) '(
    0x45 0x00 0x00 0x27 0x4b 0x8f 0x00 0x00 0x40 0x11 0x00 0x00 192  168  1    95
    192  168  1    92   0xf2 0xc8 0x30 0x39 0x00 0x13 0x00 0x00 0x48 0x65 0x6c 0x6c
    0x6f 0x20 0x57 0x6f 0x72 0x6c 0x64)))

(unless (net-packet udp-packet)
    (println "net-error: " (net-error))
    (println "sys-error: " (sys-error)))
</pre>

<p>関数 <tt>net-packet</tt> は、ネット・セキュリティのテスト時に使われます。
その際の不正なアプリケーションは、ネットワーク・ルーターやネットワークに繋がった他のデバイスの正しい機能を阻害しかねません。
そのため、この関数はうまく隔離されたプライベート・イントラ・ネット上で使用すべきであり、使用者もネットワークの専門家に限定すべきです。<br />
The <tt>net-packet</tt> function is used when testing net security. 
Its wrong application can upset the correct functioning of network routers and 
other devices connected to a network. For this reason the function should only 
be used on well isolated, private intra-nets and only by network professionals.</p>

<p>他のパケット構成の例は、newLISP 配布ソースにあるファイル <tt>qa-specific-tests/qa-packet</tt> を見てください。<br />
For other examples of packet configuration, see the file 
<tt>qa-specific-tests/qa-packet</tt> in the newLISP source distribution.</p>

<br/><br/>

<a name="net-peek"></a>
<h2><span class="function">net-peek</span></h2>
<h4>syntax: (net-peek <em>int-socket</em>)</h4>

<p>
<em>int-socket</em> のネットワーク・ソケット上で読み取り可能なバイト数を返します。
エラーが起こっているか、接続が閉じている時は <tt>nil</tt> を返します。<br />
Returns the number of bytes 
ready for reading 
on the network socket <em>int-socket</em>.
If an error occurs 
or the connection is closed,
<tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(set 'aSock (net-connect "aserver.com" 123))

(while ( = (net-peek aSock) 0) 
    (do-something-else))

(net-receive aSock buff 1024)
</pre>


<p>このプログラムは接続後、<tt>aSock</tt> が読み込み可能になるまで while ループで待ちます。<br />
After connecting, the program 
waits in a while loop 
until <tt>aSock</tt> can be read.
</p>

<p><a href="http://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E8%A8%98%E8%BF%B0%E5%AD%90">ファイル<ruby>記述子<rp>（</rp><rt>デスクリプタ</rt><rp>）</rp></ruby></a>や <tt>stdin</tt> のチェックには、関数 <a href="#peek">peek</a> を使ってください。<br />
Use the <a href="#peek">peek</a> function
to check file descriptors and <tt>stdin</tt>.
</p>

<br/><br/>

<a name="net-peer"></a>
<h2><span class="function">net-peer</span></h2>
<h4>syntax: (net-peer <em>int-socket</em>)</h4>

<p><em>int-socket</em> で接続しているリモート・コンピュータの IP 番号とポートを返します。<br />
Returns the IP number and port number 
of the remote computer 
for a connection on <em>int-socket</em>.
</p>

<!-- example -->

<pre>
(net-peer 16)  <span class='arw'>&rarr;</span> ("192.100.81.100" 13)
</pre>


<p>ローカル・コンピュータの IP アドレスとポート番号のアクセスには、関数 <a href="#net-local">net-local</a> を使ってください。<br />
Use the <a href="#net-local">net-local</a> function
to access the local computer's IP number and port number.
</p>

<br/><br/>

<a name="net-ping"></a>

<h2><span class="function">net-ping</span></h2>
<h4>syntax: (net-ping <em>str-address</em> [<em>int-timeout</em> [<em>int-count</em> <em>bool</em>]]])<br/>
syntax: (net-ping <em>list-addresses</em> [<em>int-timeout</em> [<em>int-count</em> <em>bool</em>]]])</h4>

<p>この関数は Unix ベースのシステム上でのみ利用可能で、（訳注：newLISPが）スーパー・ユーザ・モードで走っていなければなりません。
例えば、macOS か 他の BSD での newLISP 開始時に <tt>sudo newlisp</tt> を使うとか、Linux の root ユーザで使うとかです。
IPv6 アドレス・モードでは、ブロードキャスト・モードや <tt>-</tt>（ハイフン）または <em>*</em>（アスタリスク）を使った範囲指定が使えません。<br />
 This function is only available on Unix-based systems 
and must be run in superuser mode, i.e. using: <tt>sudo newlisp</tt> to
start newLISP on macOS or other BSD's, or as the root user on Linux.
 Broadcast mode and specifying ranges with the <tt>-</tt> (hyphen) or
<em>*</em> (star) are not available on IPv6 address mode.</p>

<p>macOS では、スーパー・ユーザ・モードが要求されません。<br />
Superuser mode is not required on macOS.</p>

<p>第一構文の <tt>net-ping</tt> は、ICMP 64バイトのエコー<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を <em>str-address</em> で指定されたアドレスに送ります。
アドレスがブロードキャスト・アドレスなら、ICMP パケットは全てのサブネットで受信されます。
セキュリティ上の理由から、多くのコンピュータは ICMP ブロードキャスト ping（ICMP_ECHO）<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>に返信しないので、注意してください。
オプションのタイムアウト・パラメータを <em>int-timeout</em> に指定できます。
タイムアウトが指定されていなければ、1000ミリ秒（1秒）になります。<br />
 In the first syntax, <tt>net-ping</tt> sends a ping 
ICMP 64-byte echo request to the address specified in <em>str-address</em>. 
If it is a broadcast address, the ICMP packet will be received 
by all addresses on the subnet.  Note that for security reasons, 
many computers do not answer ICMP broadcast ping (ICMP_ECHO) requests. 
An optional timeout parameter can be specified in <em>int-timeout</em>.
If no timeout is specified, a waiting time of 1000 milliseconds 
(one second) is assumed.</p> 

<p><tt>net-ping</tt> は、
IP 文字列と<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>が返るまでのミリ秒単位の往復の時間のリスト群をリストしたものか、<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>が返らなかった時の空のリストのどちらかを返します。<br />
 <tt>net-ping</tt> returns either a list of lists of IP strings 
and round-trip time in microseconds for which a response was received 
or an empty list if no response was received.</p>

<p>
<tt>nil</tt> の戻り値は失敗を意味します。
エラー・メッセージを取り出すためには、関数 <a href="#net-error">net-error</a> を使ってください。
メッセージが <tt>Cannot open socket</tt> なら、おそらく newLISP は root 権限無しで動作しています。
（訳注：その場合は、）newLISP を次のような使い方で開始します：<br />
A return value of <tt>nil</tt> 
indicates a failure. 
Use the <a href="#net-error">net-error</a> function 
to retrieve the error message.  If the message reads <tt>Cannot open socket</tt>, 
it is probably because newLISP is running without root permissions. 
newLISP can be started using:
</p>

<pre>
sudo newlisp
</pre>

<p>あるいは、スーパーユーザ・モードで走らせる set-user-ID bit を設定して、newLISP をインストールすることもできます。<br />
Alternatively, newLISP can be installed 
with the set-user-ID bit set to run 
in superuser mode.
</p>

<!-- example -->

<pre>
(net-ping "newlisp.org")     <span class='arw'>&rarr;</span> (("66.235.209.72" 634080))
(net-ping "127.0.0.1")       <span class='arw'>&rarr;</span> (("127.0.0.1" 115))
(net-ping "yahoo.com" 3000)  <span class='arw'>&rarr;</span> nil
</pre>


<p>第二構文の <tt>net-ping</tt> は <em>バッチ・モード</em> で走ります。
このモードでは一つのソケットのみが開かれますが、複数の ICMP パケットがリストまたは範囲で指定される複数のアドレスに各々一個ずつ送られます。
パケットはできる限り早く送信されます。
この場合、複数の<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>が受信されます。
同じアドレスを複数回指定すると、受信 IP アドレスが ICMP パケットで溢れることになります。<br />
In the second syntax, <tt>net-ping</tt> is run in <em>batch mode</em>. 
Only one socket is opened in this mode, but multiple ICMP packets are sent out&mdash;one 
each to multiple addresses specified in a list or specified by range.
Packets are sent out as fast as possible.  In this case, multiple answers can be received.
If the same address is specified multiple times, the receiving IP address will be flooded
with ICMP packets.</p>

<p>ブロードキャストやバッチ・モードで待っている<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>の数を制限するために、受信<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>の最大数を指示する追加の引数を <em>int-count</em> に指定できます。
このパラメータの使えば、指定したタイムアウトより早く関数を戻せます。
与えられた<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>数を受信すると、<tt>net-ping</tt> はタイムアウト前でも戻ります。
 em>int-count</em> を指定しないか <tt>0</tt> を指定した時、<em>int-count</em> は送り出したパケット数になります。<br />
To limit the number of responses to be waited for in broadcast or batch mode,
an additional argument indicating the maximum number of responses to receive
can be specified in <em>int-count</em>.  Usage of this parameter can cause 
the function to return sooner than the specified timeout. 
When a given number of responses has been received, <tt>net-ping</tt> will return  
before the timeout has occurred. Not specifying <em>int-count</em> or specifying <tt>0</tt>
assumes an <em>int-count</em> equal to the number of packets sent out.</p>

<p>第３オプション・パラメータとして <tt>true</tt> 値を指定できます。
この設定は、ホストが返答しない場合、<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>時間の代わりにエラー文字列を返します。
<br />
As third optional parameter, a <tt>true</tt> value can be specified. This setting will
return an error string instead of the response time, if the host does not answer.</p>

<!-- example -->

<pre>
(net-ping '("newlisp.org" "192.168.1.255") 2000 20)
<span class='arw'>&rarr;</span> (("66.235.209.72" 826420) ("192.168.1.1" 124) ("192.168.1.254" 210))

(net-ping "192.168.1.*" 500) ; from 1 to 254
<span class='arw'>&rarr;</span> (("192.168.1.1" 120) ("192.168.1.2" 245) ("192.168.2.3" 180) ("192.168.2.254" 234))

(net-ping "192.168.1.*" 500 2) ; returns after 2 responses
<span class='arw'>&rarr;</span> (("192.168.1.3" 115) ("192.168.1.1" 145))

(net-ping "192.168.1.1-10" 1000) ; returns after 1 second
<span class='arw'>&rarr;</span> (("192.168.1.3" 196) ("192.168.1.1" 205))

(net-ping '("192.168.1.100-120" "192.168.1.124-132") 2000) ; returns after 2 seconds
<span class='arw'>&rarr;</span> ()
</pre>



<p>一つの <tt>net-ping</tt> 文の中に、ブロードキャストやバッチ・モードを&mdash;&mdash;通常のアドレスや IP 番号またはホスト名と同様に&mdash;&mdash;リスト中に IP の種類全てを置くことで混在可能です。<br />
Broadcast or batch mode&mdash;as well as normal addresses 
and IP numbers or hostnames&mdash; can be mixed in one <tt>net-ping</tt> statement by 
putting all of the IP specs into a list.</p> 

<p>
第二、第三行は、<tt>net-ping</tt> のバッチ・モードが IP 番号の最後のサブネット・オクテットにワイルドカード文字の <tt>*</tt>（アスタリスク）を指定して始められることを示しています。
第四、第五行は、IP 番号最後のサブネット・オクテットに IP 範囲を指定できることを示しています。
<tt>net-ping</tt> は、<tt>*</tt> の 1～254 までか指定された範囲のどちらかの番号全てで、各アドレスへの ICMP パケット送信を繰り返します。
これは、IP オクテットに <tt>255</tt> を指定した <em>ブロードキャスト</em>・モードとは異なることに注意してください。
ブロードキャスト・モードでは、<tt>net-ping</tt> は一パケットのみを送出し、それが複数のアドレスで受信されます。
バッチ・モードは明示的に複数のパケットを生成し、それらは各ターゲット・アドレス毎に一個ずつです。
ブロードキャスト・モードを指定した時も <em>int-count</em> を指定すべきです。<br />
The second and third lines show how the batch mode of <tt>net-ping</tt> 
can be initiated by specifying the <tt>*</tt> (asterisk) 
as a wildcard character for the last subnet octet
in the IP number. The fourth and fifth lines show how an IP
range can be specified for the last subnet octet in the IP number.
<tt>net-ping</tt> will iterate through all numbers 
from either 1 to 254 for the star <tt>*</tt> or the range specified, 
sending an ICMP packet to each address. 
Note that this is different from the <em>broadcast</em> mode 
specified with an IP octet of <tt>255</tt>. 
While in broadcast mode, <tt>net-ping</tt> sends out only one packet, 
which is received by multiple addresses.  Batch mode explicitly generates 
multiple packets, one for each target address. When specifying broadcast
mode, <em>int-count</em> should be specified, too.</p>

<p>バッチ・モードで、一つのソケットに大規模な IP リストを送る時は、
全パケットを一つのソケットに送出する時間を十分与えるために、より長いタイムアウトが必要となります。
タイムアウトが短過ぎると、関数 <tt>net-ping</tt> は不完全なリストか空リスト <tt>()</tt> を返すかもしれません。
このような場合、 <a href="#net-error">net-error</a> はタイムアウト・エラーを返すでしょう。
エラー時は <tt>nil</tt> が返り、 <a href="#net-error">net-error</a>をエラー・メッセージの取り出しに使えます<br />
When sending larger lists of IPs in batch mode over one socket, 
a longer timeout may be necessary to allow enough time for all of the packets 
to be sent out over one socket.  If the timeout is too short, 
the function <tt>net-ping</tt> may return an incomplete list or the empty list <tt>()</tt>.
In this case, <a href="#net-error">net-error</a> will return a timeout error.
On error, <tt>nil</tt> is returned and  <a href="#net-error">net-error</a>
can be used to retrieve an error message.</p>

<p>いくつかのシステムでは、タイムアウト指定に関わらず、決められた長さのリストしか扱えないかもしれません。
この場合、範囲をいくつかに分けて、複数の<tt>net-ping</tt> を実施すべきです。
いずれにせよ、<tt>net-ping</tt> はできる限り早くパッケージを送出します。<br />
On some systems only lists up to a specific length can be handled 
regardless of the timeout specified. In this case, the range should
 be broken up into sub-ranges and used with multiple <tt>net-ping</tt>
invocations. In any case, <tt>net-ping</tt> will send out packages 
as quickly as possible.
</p>

<br/><br/>

<a name="net-receive"></a>
<h2><span class="function">net-receive</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (net-receive <em>int-socket</em> <em>sym-buffer</em> <em>int-max-bytes</em> [<em>wait-string</em>])</h4>

<p>ソケット <em>int-socket</em> 上のデータを受信し、<em>sym-buffer</em> の文字列に入れます。
<em>sym-buffer</em> には、ユーザ定義関数に参照を渡すコンテキスト・シンボルで指定されたデフォルト・ファンクタも使えます。<br />
Receives data on the socket <em>int-socket</em> into a string contained in <em>sym-buffer</em>. 
<em>sym-buffer</em> can also be a default functor specified by a context symbol 
for reference passing in and out of user-defined functions.</p>

<p><em>int-max-bytes</em> の最大値まで受信します。
<tt>net-receive</tt> は読み取ったバイト数を返します。
接続が切断されると <tt>nil</tt> を返します。
<em>sym-buffer</em> で用意された領域は、読み取ったバイト数の大きさになります。<br />
 A maximum of 
<em>int-max-bytes</em> is received. <tt>net-receive</tt> returns the number of 
bytes read.  If there is a break in the connection, <tt>nil</tt> is returned. 
The space reserved in <em>sym-buffer</em> is exactly the size of bytes read.</p>

<p><tt>net-receive</tt> はブロッキング呼び出しなので、<em>int-socket</em> にデータが届くまで戻らないことに注意してください。
ソケットが読み出し可能かどうかを知るには、 <a href="#net-peek">net-peek</a> や <a href="#net-select">net-select</a> を使ってください。<br />
Note that <tt>net-receive</tt> is a blocking call 
and does not return until the data arrives at <em>int-socket</em>. 
Use <a href="#net-peek">net-peek</a> 
or <a href="#net-select">net-select</a> to find out 
if a socket is ready for reading.
</p>

<p>オプションで、第四パラメータに <em>wait-string</em> を指定できます。
その際、<tt>net-receive</tt> は <em>wait-string</em> に一致した文字か文字列を受信した後で返ります。
<em>wait-string</em> は <em>sym-buffer</em> に入るデータの一部となります。<br />
Optionally, a <em>wait-string</em> 
can be specified 
as a fourth parameter. 
<tt>net-receive</tt> then returns after 
a character or string of characters 
matching <em>wait-string</em>
is received. 
The <em>wait-string</em> will be part 
of the data contained in <em>sym-buffer</em>.
</p>

<!-- example -->

<pre>
(define (gettime)
    (set 'socket (net-connect "netcom.com" 13))
    (net-receive socket buf 256)
    (print buf "\n")
    (net-close socket))
</pre>


<p><tt>gettime</tt> を呼び出すと、プログラムは netcom.com サーバーのポート 13 に接続します。
ポート 13 は、ほとんどのサーバーに用意されている日時サービスです。
接続すると、サーバーは日付と時刻からなる文字列を送ってきます。<br />
When calling <tt>gettime</tt>, 
the program connects to port 13 
of the server netcom.com. 
Port 13 is a date-time service 
on most server installations. 
Upon connection, the server sends 
a string containing the date and time of day.
</p>


<pre>
(define (net-receive-line socket sBuff)
    (net-receive socket sBuff 256 "\n"))

(set 'bytesReceived (net-receive-line socket 'sm))
</pre>


<p>二番目の例では、（この例では、一文字からなる文字列の）改行文字か256文字を受信後に戻る関数 <tt>net-receive-line</tt> を新たに定義しています。
文字列 "\n" は、sBuff の中身の一部です。<br />
The second example defines a new function 
<tt>net-receive-line</tt>, 
which returns after receiving a newline character 
(a string containing one character in this example) 
or 256 characters. 
The "\n" string is part of the contents of sBuff.
</p>

<p>第四パラメータを指定した時、<tt>net-receive</tt> は情報を一文字ずつ読み取るので、通常より遅くなることに注意してください。
多くの場合、速度の違いは無視できる程度かもしれません。<br />
Note that when the fourth parameter is specified, 
<tt>net-receive</tt> is slower than the normal version 
because information is read character-by-character. 
In most situations, the speed difference can be neglected.
</p>

<br/><br/>

<a name="net-receive-from"></a>
<h2><span class="function">net-receive-from</span></h2>
<h4>syntax: (net-receive-from <em>int-socket</em> <em>int-max-size</em>)</h4>

<p><tt>net-receive-from</tt> は、ノン・ブロッキング通信の設定に使われます。
<em>int-socket</em> のソケットは、（<tt>"udp"</tt> オプションと共に）<a href="#net-listen">net-listen</a> か <a href="#net-connect">net-connect</a> で予め開かれていなければなりません。
<em>int-max-size</em> は、受信する最大バイト数を指定します。
それ以上受信は、Linux/BSD 上では破棄され、MS Windows 上では <tt>net-receive-from</tt> が <tt>nil</tt> を返してソケットを閉じます。<br />
<tt>net-receive-from</tt> can be used to set up 
non-blocking UDP communications. 
The socket in <em>int-socket</em> 
must previously have been opened 
by either <a href="#net-listen">net-listen</a> 
or <a href="#net-connect">net-connect</a> 
(both using the <tt>"udp"</tt> option).
<em>int-max-size</em> specifies 
the maximum number of bytes that will be received. 
On Linux/BSD, if more bytes are received, 
those will be discarded; on MS Windows, <tt>net-receive-from</tt>
returns <tt>nil</tt> and closes the socket.
</p>

<p><tt>net-receive</tt> は、成功時にデータ文字列、リモート IP 番号、使用されたリモート・ポートのリストを返します。
失敗時には <tt>nil</tt> を返します。<br />
On success <tt>net-receive</tt> returns a list of the data string, remote 
IP number and remote port used. On failure it returns <tt>nil</tt>.</p>

<!-- example -->

<pre>
;; bind port 1001 and the default address
(net-listen 1001 "" "udp")  <span class='arw'>&rarr;</span> 1980 

;; optionally poll for arriving data with 100ms timeout
(while (not (net-select 1980 "r" 100000)) (do-something ... ))

(net-receive-from 1980 20)  <span class='arw'>&rarr;</span> ("hello" "192.168.0.5" 3240)

;; send answer back to sender
(net-send-to "192.168.0.5" 3240 "hello to you" 1980)

(net-close 1980) ; close socket
</pre>


<p>この例の二行目は、任意の行です。
この行が無くても、<tt>net-receive-from</tt> 呼び出しはデータが届くまでブロックします。
UDP サーバーは、幾つかのポートを待ち受け（listen）てポーリングするように設定されており、ポートが受け取るデータを配給します。<br />
The second line in this example is optional.  Without it, the 
<tt>net-receive-from</tt> call would block until data arrives. 
A UDP server could be set up by listening and polling several ports, 
serving them as they receive data.</p>

<p>受信側と送信側の両方とも、UDP モードの <a href="#net-listen">net-listen</a> をっ発行しなけれななりません。
TCP/IP プロトコル通信で待ち受け（listen）るためではなく、ポートやアドレスに束縛されたソケットを生成するためです。
例題の完全版は、配布ソースの <tt>newlisp-x.x.x/examples/</tt> ディレクトリにある <tt>udp-server.lsp</tt> と <tt>udp-client.lsp</tt> を見てください。<br />
Both, the sender and the receiver have to issue 
<a href="#net-listen">net-listen</a> commands for UDP mode. Not for listening
as in TCP/IP protocol communications, but to create the socket bound to
the port and address. For a complete example see the files
<tt>udp-server.lsp</tt> and <tt>udp-client.lsp</tt> in the 
<tt>newlisp-x.x.x/examples/</tt> directory of the source distribution.</p>

<p>この場合、<tt>net-receive</tt> は送信側のアドレスとポートの情報を返さないので使えません。
UDP 通信では、通信が行われるソケット<em>ではなく</em> 、データパケット自身に送信側のアドレスを含みます。
<tt>net-receive</tt> を TCP/IP にも使うことができます。<br />
Note that <tt>net-receive</tt> 
could not be used in this case 
because it does not return 
the sender's address and port information, 
which are required to talk back.
In UDP communications, 
the data packet itself 
contains the address of the sender,
<em>not</em> the socket over which 
communication takes place.
<tt>net-receive</tt> can also be used for TCP/IP communications.
</p>

<p><tt>"udp"</tt> オプションの関数 <a href="#net-connect">net-connect</a> と
開いている接続で UDP データ・パケットを送信する関数 <a href="#net-send-to">net-send-to</a> も見てください。<br />
See also the <a href="#net-connect">net-connect</a> function 
with the <tt>"udp"</tt> option and the 
<a href="#net-send-to">net-send-to</a> function 
for sending UDP data packets over open connections.
</p>

<p>ブロッキング の短い UDP 処理には、関数 <a href="#net-send-udp">net-send-udp</a> や <a href="#net-receive-udp">net-receive-udp</a> を見てください。<br />
For blocking short UDP transactions, 
see the <a href="#net-send-udp">net-send-udp</a> 
and <a href="#net-receive-udp">net-receive-udp</a> functions.
</p>

<br/><br/>

<a name="net-receive-udp"></a>
<h2><span class="function">net-receive-udp</span></h2>
<h4>syntax: (net-receive-udp <em>int-port</em> <em>int-maxsize</em> [<em>int-microsec</em> [<em>str-addr-if</em>]])</h4>

<p>ポート <em>int-port</em> 上の<a href="http://ja.wikipedia.org/wiki/User_Datagram_Protocol">ユーザ・データグラム・プロトコル</a> (UDP) パケットを受信し、 <em>int-maxsize</em> バイト読み取ります。
tt>net-receive-udp</tt> が <em>int-maxsize</em> バイトより多く受信した場合、<Linux/BSD では <em>int-maxsize</em> を超えるバイトを破棄し、MS Windows では <tt>nil</tt> を返します。
<tt>net-receive-udp</tt> は、データが届くか、オプションのタイムアウト値 <em>int-microsec</em> に達するまでブロックします。
データの送信側と受信側で通信が成立する前に、<tt>net-receive-udp</tt> 宣言文が発行されている必要があります。<br />
Receives a User Datagram Protocol (UDP) packet on port <em>int-port</em>,
reading <em>int-maxsize</em> bytes. 
If more than <em>int-maxsize</em> bytes are received,
bytes over <em>int-maxsize</em> are discarded on Linux/BSD; 
on MS Windows, <tt>net-receive-udp</tt> returns <tt>nil</tt>.
<tt>net-receive-udp</tt> blocks until a datagram arrives 
or the optional timeout value in <em>int-microsec</em> expires. 
When setting up communications between datagram sender and receiver, 
the <tt>net-receive-udp</tt> statement must be set up first.
</p>


<p><tt>net-listen</tt> や <tt>net-connect</tt> を使って、前もって準備しておく必要はありません。<br />
No previous setup using <tt>net-listen</tt> 
or <tt>net-connect</tt> is necessary.
</p>

<p><tt>net-receive-udp</tt> が返すリストには、UDP パケットの文字列とそれに続けて、送信側が使った IP 番号とポートの文字列が入っています。<br />
<tt>net-receive-udp</tt> returns a list 
containing a string of the UDP packet 
followed by a string containing 
the sender's IP number and the port used.
</p>

<!-- example -->

<pre>
;; wait for datagram with maximum 20 bytes 
(net-receive-udp 10001 20) 

;; or
(net-receive-udp 10001 20 5000000)  ; wait for max 5 seconds
		  
;; executed on remote computer
(net-send-udp "nuevatec.com" 1001 "Hello")  <span class='arw'>&rarr;</span> 4 

;; returned from the net-receive-udp statement
<span class='arw'>&rarr;</span> ("Hello" "128.121.96.1" 3312)  

;; sending binary information
(net-send-udp "ahost.com" 2222 (pack "c c c c" 0 1 2 3))  
<span class='arw'>&rarr;</span> 4 

;; extracting the received info
(set 'buff (first (net-receive-udp 2222 10)))   

(print (unpack "c c c c" buff))  <span class='arw'>&rarr;</span> (0 1 2 3)
</pre>


<p>データ送信用関数 <a href="#net-send-udp">net-send-udp</a> や、バイナリ・データのパック用関数 <a href="#pack">pack</a> とアンパック用関数 <a href="#unpack">unpack</a> も見てください。<br />
See also the <a href="#net-send-udp">net-send-udp</a> 
function for sending datagrams and 
the <a href="#pack">pack</a> and <a href="#unpack">unpack</a> 
functions for packing and unpacking binary information.
</p>

<p>一個以上のインターフェイス・カードを持つコンピュータ上で、指定されたアドレスを待ち受け（listen）るために、オプションでインターフェイス IP アドレスまたは名前を <em>str-addr-if</em> に指定できます。
<em>str-addr-if</em> を指定する時は、タイムアウト <em>int-wait</em> の指定も必要です。<br />
To listen on a specified address 
on computers with more than one interface card, 
an interface IP address or name can be 
optionally specified in <em>str-addr-if</em>. 
When specifying <em>str-addr-if</em>, 
a timeout must also be specified
in <em>int-wait</em>.
</p>

<p>もう一つの方法として、ノン・ブロッキング・データ交換を可能にする <tt>"udp"</tt> オプションの <a href="#net-listen">net-listen</a> や <a href="#net-connect">net-connect</a> を <a href="#net-receive-from">net-receive-from</a> と <a href="#net-send-to">net-send-to</a> と一緒に使っても、UDP 通信を用意できます。<br />
As an alternative, UDP communication 
can be set up using <a href="#net-listen">net-listen</a>, 
or <a href="#net-connect">net-connect</a> 
together with the <tt>"udp"</tt> option 
to make non-blocking data exchange possible 
with <a href="#net-receive-from">net-receive-from</a> 
and <a href="#net-send-to">net-send-to</a>.
</p>

<br/><br/>

<a name="net-select"></a>
<h2><span class="function">net-select</span></h2>
<h4>syntax: (net-select <em>int-socket</em> <em>str-mode</em> <em>int-micro-seconds</em>)<br/>
syntax: (net-select <em>list-sockets</em> <em>str-mode</em> <em>int-micro-seconds</em>)</h4>

<p>第一形式の <tt>net-select</tt> は、<em>int-socket</em> で指定された一パケットの状態を検出します。
<em>str-mode</em> 次第で、ソケットが読み取りまたは書き込みが用意されているとか、エラー条件を持っているとかをチェックします。
タイムアウト値は <em>int-micro-seconds</em> で指定します。<br />
In the first form, 
<tt>net-select</tt> finds out about the status 
of one socket specified in  <em>int-socket</em>. 
Depending on <em>str-mode</em>, 
the socket can be checked 
if it is ready for reading or writing,
or if the socket has an error condition. 
A timeout value is specified in <em>int-micro-seconds</em>.
</p>

<p>第二構文の <tt>net-select</tt> は、<em>list-sockets</em> のソケット・リストをチェックできます。<br />
In the second syntax, 
<tt>net-select</tt> can check for a list of sockets 
in <em>list-sockets</em>.
</p>

<p><em>str-mode</em> には、次のような値が与えられます：<br>
読み取り状態か、受け入れ状態かどうかのチェックには、<tt>"read"</tt> か <tt>"r"</tt>。<br>
書き込み状態かどうかのチェックには、<tt>"write"</tt> か <tt>"w"</tt>。<br>
エラー状態のチェックには、<tt>"exception"</tt> か <tt>"e"</tt>。<br />
The following value can be given for <em>str-mode</em>:<br/>

<tt>"read"</tt> or <tt>"r"</tt> to check if ready for reading or accepting.<br/>
<tt>"write"</tt> or <tt>"w"</tt> to check if ready for writing.<br/>
<tt>"exception"</tt> or <tt>"e"</tt> to check for an error condition.<br/>
</p>


<p>関数 <tt>net-select</tt> を使えば、受信・送信・受付操作をブロック無しで処理できます。
<tt>net-select</tt> は、ソケットが準備されるまで <em>int-micro-seconds</em> で指定された時間待ち、準備状態によって <tt>true</tt> か <tt>nil</tt> を返します。
セレクト・ループ中、他のプログラム部分を実行可能です。
エラー発生時には、<a href="#net-error">net-error</a> が設定されます。
<em>int-micro-seconds</em> に <tt>-1</tt> が指定された時、<tt>net-select</tt> はタイムアウトしません。<br />
Read, send, or accept operations 
can be handled without blocking
by using the <tt>net-select</tt> function. 
<tt>net-select</tt> waits 
for a socket to be ready 
for the value given in <em>int-micro-seconds</em>, 
then returns <tt>true</tt> or <tt>nil</tt>
depending on the readiness of the socket.
During the select loop, 
other portions of the program can run. 
On error, 
<a href="#net-error">net-error</a> is set. 
When <tt>-1</tt> is specified for <em>int-micro-seconds</em>, 
<tt>net-select</tt> will never time out.
</p>

<!-- example -->

<pre>
(set 'listen-socket (net-listen 1001))

;; wait for connection
(while (not (net-select listen-socket "read" 1000))
    (if (net-error) (print (net-error))))

(set 'connection (net-accept listen-socket))
(net-send connection "hello")

;; wait for incoming message
(while (not (net-select connection "read" 1000))
    (do-something)) 

(net-receive connection buff 1024)
</pre>


<p><tt>net-select</tt> を使うことで、いくつかの待ち受け（listen）と接続ソケットを監視でき、複数の接続が処理できます。
ソケット・リストを使った時、<tt>net-select</tt> は準備の整ったソケットのリストを返します。
続く例は、二つのソケットを待ち受け（listen）、その接続の受け入れとサービスを続けます：<br />
When <tt>net-select</tt> is used, 
several listen and connection sockets can be watched, 
and multiple connections can be handled. 
When used with a list of sockets, 
<tt>net-select</tt> will return a list of ready sockets. 
The following example would listen on two sockets 
and continue accepting and servicing connections:
</p>

<!-- example -->

<pre>
(set 'listen-list '(1001 1002))

; accept-connection, read-connection and write-connection
; are user defined functions

(while (not (net-error))
    (dolist (conn (net-select listen-list "r" 1000))
    (accept-connection conn))  ; build an accept-list

    (dolist (conn (net-select accept-list "r" 1000))
    (read-connection conn))    ; read on connected sockets

    (dolist (conn (net-select accept-list "w" 1000))
    (write-connection conn)))  ; write on connected sockets
</pre>


<p>第二構文では、テストを通った全てのソケットを含むリストが返り、タイムアウト時は空のリストが返ります。
エラー発生時は、<a href="#net-error">net-error</a> が設定されます。<br />
In the second syntax, 
a list  is returned 
containing all the sockets 
that passed the test;
if timeout occurred, 
an empty list is returned. 
An error causes 
<a href="#net-error">net-error</a> to be set.
</p>

<p>存在しないソケットを <tt>net-select</tt> へ提供することはエラーを発生させ、<a href="#net-error">net-error</a> が設定されることに注意してください。<br />
Note that supplying a nonexistent socket to <tt>net-select</tt> 
will cause an error to be set in <a href="#net-error">net-error</a>.
</p>

<br/><br/>

<a name="net-send"></a>
<h2><span class="function">net-send</span></h2>
<h4>syntax: (net-send <em>int-socket</em> <em>str-buffer</em> [<em>int-num-bytes</em>])</h4>

<p><em>str-buffer</em> の内容を <em>int-socket</em> で指定された接続に送ります。
<em>int-num-bytes</em> を指定すれば、<em>int-num-bytes</em> までが送られます。 
<em>int-num-bytes</em> を指定しなければ、全内容が送られます。
<tt>net-send</tt> は、送信したバイト数か、失敗した時の <tt>nil</tt> を返します。 <br />
Sends the contents of <em>str-buffer</em> on the connection specified by <em>int-socket</em>. 
If <em>int-num-bytes</em> is specified, up to <em>int-num-bytes</em> are sent. 
If <em>int-num-bytes</em> is not specified, the entire contents will be sent.
<tt>net-send</tt> returns the number of bytes sent or <tt>nil</tt> on failure.
</p>

<p>失敗時にエラー情報を得るには、<a href="#net-error">net-error</a> を使ってください。<br />
On failure, use <a href="#net-error">net-error</a> to get more error information.</p>

<!-- example -->

<pre>
(set 'buf "hello there")

(net-send sock buf)       <span class='arw'>&rarr;</span> 11
(net-send sock buf 5)     <span class='arw'>&rarr;</span> 5

(net-send sock "bye bye") <span class='arw'>&rarr;</span> 7
</pre>


<p>最初の <tt>net-send</tt> は文字列 <tt>"hello there"</tt> を送り、二番目の <tt>net-send</tt> は文字列 <tt>"hello"</tt> のみを送ります。<br />
The first <tt>net-send</tt> sends the string <tt>"hello there"</tt>, while
the second <tt>net-send</tt> sends only the string <tt>"hello"</tt>.
</p>

<br/><br/>

<a name="net-send-to"></a>
<h2><span class="function">net-send-to</span></h2>
<h4>syntax: (net-send-to <em>str-remotehost</em> <em>int-remoteport</em> <em>str-buffer</em> <em>int-socket</em>)</h4>

<p>UDP か TCP/IP 通信のどちらかで使うことができます。
前もって、関数<a href="#net-connect">net-connect</a> か <a href="#net-listen">net-listen</a> で <em>int-socket</em> のソケットが開かれている必要が有ります。
関数 <tt>net-listen</tt> や <tt>net-connect</tt> を <tt>"udp"</tt> オプションで開いているなら、UDP ソケットを生成するだけで待ち受け（listen）や接続に使われていません。
<em>str-remotehost</em> のホストは、ホスト名か IP 番号文字列のどちらかで指定できます。<br />
Can be used for either UDP or TCP/IP communications. The socket in <em>int-socket</em> 
must have previously been opened with a <a href="#net-connect">net-connect</a> 
or <a href="#net-listen">net-listen</a> function. If the opening functions was used 
with the <tt>"udp"</tt> option, <tt>net-listen</tt> or <tt>net-connect</tt>
are not used to listen or to connect but only to create the UDP socket.
The host in <em>str-remotehost</em> can be specified either as 
a hostname or as an IP-number string.</p>

<p><tt>net-connect</tt> と一緒に <tt>net-send-to</tt> を使う時は、どちらかの関数一つだけにリモート・ホストを指定すべきです。
もう片方には、空の文字列を指定して、アドレスを切り離すのです。<br />
When using <tt>net-connect</tt> together with <tt>net-send-to</tt>, then 
only one of the functions should specify the remote host. The other should leave 
the address as an empty string.</p>

<!-- example -->

<pre>
;;;;;;;;;;;;;;;;;; UDP server
(set 'socket (net-listen 10001 "" "udp"))
(if socket (println "server listening on port " 10001)
       (println (net-error)))
(while (not (net-error))
   (set 'msg (net-receive-from socket 255))
   (println "-&gt; " msg)
   (net-send-to (nth 1 msg) (nth 2 msg) 
                (upper-case (first msg)) socket))

;;;;;;;;;;;;;;;;;; UDP client
(set 'socket (net-listen 10002 "" "udp"))
(if (not socket) (println (net-error)))
(while (not (net-error))
   (print "&gt; ")
   (net-send-to "127.0.0.1" 10001 (read-line) socket)
   (net-receive socket buff 255)
   (println "-&gt; " buff))
</pre>


<p>どちらの例でも、クライアントとサーバー双方が送受信用の UDP ソケット生成に <tt>net-listen</tt> を使っています。
サーバーは受け取ったメッセージからクライアントのアドレスとポートを抜き出し、それを <tt>net-send-to</tt> 宣言文に使っています。<br />
In the examples both, the client and the server use <tt>net-listen</tt> to
create the UDP socket for sending and receiving. The server extracts 
the client address and port from the message received and uses it in the 
<tt>net-send-to</tt> statement.</p>

<p>関数 <a href="#net-receive-from">net-receive-from</a> と関数 <a href="#net-listen">net-listen</a> の <tt>"udp"</tt> オプションも見てください。<br />
See also the <a href="#net-receive-from">net-receive-from</a> function
and the <a href="#net-listen">net-listen</a> function with the 
<tt>"udp"</tt> option.</p>

<p>ブロッキングの短い UDP 処理には、<a href="#net-send-udp">net-send-udp</a> と<a href="#net-receive-udp">net-receive-udp</a> を使ってください。<br />
For blocking short UDP transactions use <a href="#net-send-udp">net-send-udp</a> 
and <a href="#net-receive-udp">net-receive-udp</a>.</p>

<br/><br/>

<a name="net-send-udp"></a>
<h2><span class="function">net-send-udp</span></h2>
<h4>syntax: (net-send-udp <em>str-remotehost</em> <em>int-remoteport</em> <em>str-buffer</em> [<em>bool</em>])</h4>

<p><em>str-remotehost</em> で指定されるホストと <em>int-remoteport</em> のポートに<a href="http://ja.wikipedia.org/wiki/User_Datagram_Protocol">ユーザ・データグラム・プロトコル</a> (UDP) を送ります。
送信するデータは <em>str-buffer</em> の中です。<br />
Sends a User Datagram Protocol (UDP) 
to the host specified in <em>str-remotehost</em> 
and to the port in <em>int-remoteport</em>. 
The data sent is in <em>str-buffer</em>.
</p>

<p>IPv4 システム上では UDP パケットの理論的な最大データ・サイズが 64K から IP レイヤー分を引いた値ですが、多くの Unix 流派ではそれよりもかなり少なくなります。
macOS、BSD、Linux では 8k が安全なサイズでしょう。<br />
The theoretical maximum data size of a UDP packet on an IPv4 system
is 64K minus IP layer overhead, but much smaller on most Unix flavors.
8k seems to be a safe size on macOS, BSDs and Linux.</p>

<p><tt>net-connect</tt> や <tt>net-listen</tt> を使って、前もってセットアップしておくことは、必要ありません。
<tt>net-send-udp</tt> は直ちに送信したバイト数を返し、使ったソケットを閉じます。
受信側で <tt>net-receive-udp</tt> 宣言文が待っていないと、データは失われます。
不確かな接続上でのデータ通信をする時に伝送を確実にするためには、送信側と受信側間で簡単な手順のセットアップが推奨されます。
UDP 通信それ自体は、TCP/IP のように伝送の信頼性を保証しません。<br />
No previous setup using <tt>net-connect</tt> 
or <tt>net-listen</tt> is necessary. 
<tt>net-send-udp</tt> returns immediately 
with the number of bytes sent 
and closes the socket used. 
If no <tt>net-receive-udp</tt> statement 
is waiting at the receiving side, 
the datagram sent is lost. 
When using datagram communications over insecure connections, 
setting up a simple protocol between sender and receiver 
is recommended for ensuring delivery. 
UDP communication by itself 
does not guarantee reliable delivery 
as TCP/IP does.
</p>

<!-- example -->

<pre>
(net-send-udp "somehost.com" 3333 "Hello")  <span class='arw'>&rarr;</span> 5
</pre>


<p><tt>net-send-udp</tt> はバイナリ・データの送信にも適しています（例えば、ゼロ・キャラクタやその他、表示できないバイト等）。
もっとわかり易い例は、<a href="#net-receive-udp">net-receive-udp</a> で見てください。<br />
<tt>net-send-udp</tt> is also suitable 
for sending binary information 
(e.g., the zero character or other non-visible bytes). 
For a more comprehensive example, 
see <a href="#net-receive-udp">net-receive-udp</a>.
</p>

<p>オプションの <em>bool</em> に <tt>true</tt> を指定するか <tt>nil</tt> 以外に評価される式を指定すると、送信ソケットをブロードキャスト・モードにできます。<br />
Optionally, the sending socket 
can be put in broadcast mode 
by specifying <tt>true</tt> 
or any expression 
not evaluating to <tt>nil</tt> 
in <em>bool</em>:
</p>


<pre>
(net-send-udp "192.168.1.255" 2000 "Hello" true)  <span class='arw'>&rarr;</span> 5
</pre>


<p>（訳注：上の例では、）UDP が <tt>192.168.1</tt> ネットワーク上の全ノードに送信されます。
いくつかのオペレーティング・システムでは、<em>bool</em> の <tt>true</tt> 無しでもネットワーク・マスク <tt>255</tt> を送信することで、ブロードキャスト・モードが可能になります。<br />
The UDP will be sent to all nodes 
on the <tt>192.168.1</tt> network. 
Note that on some operating systems, 
sending the network mask <tt>255</tt> 
without the <em>bool</em> <tt>true</tt> option 
will enable broadcast mode.
</p>

<p>他の方法として、<tt>"udp"</tt> オプションを使った関数 <a href="#net-connect">net-connect</a> を&mdash;&mdash;関数 <a href="#net-send-to">net-send-to</a> と一緒に使うことで&mdash;&mdash;ノン・ブロッキング状態での UDP 待ち受け（listen）への通信に使えます。<br />
As an alternative, 
the <a href="#net-connect">net-connect</a> function 
using the <tt>"udp"</tt> option&mdash;together with 
the <a href="#net-send-to">net-send-to</a> function&mdash;can 
be used to talk to a UDP listener 
in a non-blocking fashion.
</p>

<br/><br/>

<a name="net-service"></a>
<h2><span class="function">net-service</span></h2>
<h4>syntax: (net-service <em>str-service</em> <em>str-protocol</em>)<br/>
syntax: (net-service <em>int-port</em> <em>str-protocol</em>)</h4>

<p>第一構文の <tt>net-service</tt> は、<em>services</em> のデータベースを検索して、そのサービスの標準ポート番号を返します。
（訳注： C 関数 getservbyname 相当。<a href="http://www.iana.org/assignments/port-numbers">参考まで</a>）<br />
In the first syntax <tt>net-service</tt> makes a lookup in the 
<em>services</em> database and returns the standard port number for 
this service.</p>

<p>第二構文では、サービス名を検索するために サービス・ポートを <em>int-port</em> に与えます。<br />
In the second syntax a service port is supplied in <em>int-port</em>
to look up the service name.</p>

<p>失敗時は <tt>nil</tt> を返します。<br />Returns <tt>nil</tt> on failure.</p>

<!-- example -->

<pre>
; get the port number from the name
(net-service "ftp" "tcp")       <span class='arw'>&rarr;</span> 21
(net-service "http" "tcp")      <span class='arw'>&rarr;</span> 80
(net-service "net-eval" "tcp")  <span class='arw'>&rarr;</span> 4711  ; if configured

; get the service name from the port number
(net-service 22 "tcp")          <span class='arw'>&rarr;</span> "ssh"
</pre>

<br/><br/>

<a name="net-sessions"></a>
<h2><span class="function">net-sessions</span></h2>
<h4>syntax: (net-sessions)</h4>

<p>アクティブな待ち受け（listen）や接続ソケットのリストを返します。<br />
Returns a list of active listening and connection sockets.
</p>

<br/><br/>

<a name="new"></a>
<h2><span class="function">new</span></h2>
<h4>syntax: (new <em>context-source</em> <em>sym-context-target</em> [<em>bool</em>])<br/>
syntax: (new <em>context-source</em>)</h4>

<p>コンテキスト <em>context-source</em> が <em>sym-context-target</em> にコピーされます。
目標コンテキストが存在しなければ、<em>context-source</em> にあるのと同じ名前の変数群とユーザ定義関数と持つ新コンテキストが作成されます（訳注：ただし、<a href="#default_function">デフォルト・ファンクタ</a> は目標コンテキスト名になります）。
目標コンテキストが既に存在するなら、新規のシンボルと定義が付け加えられます。
存在するシンボルは、<em>bool</em> の式が <tt>nil</tt> 以外に評価される時のみ上書きされ、それ以外では、そのままの内容で残ります（訳注：<em>bool</em> 式次第で、<a href="#default_function">デフォルト・ファンクタ</a> も上書きされます）。
これは、コンテキスト・オブジェクトの <a href="http://ja.wikipedia.org/wiki/Mixin"><em>mixins</em></a> を可能にします。
<tt>new</tt> は、MAIN ではない目標コンテキストを返します。<br />
The context <em>context-source</em> is copied to <em>sym-context-target</em>.
If the target context does not exist, a new context with the same variable names 
and user-defined functions as in <em>context-source</em> is created.
If the target context already exists, then new symbols and definitions are added.
Existing symbols are only overwritten when the expression in <em>bool</em>
evaluates to anything other than <tt>nil</tt>; otherwise, the content of existing symbols
will remain. This makes <em>mixins</em> of context objects possible. 
<tt>new</tt> returns the target context, which cannot be MAIN.</p>

<p>第二構文では、 <em>context-source</em> の既存のコンテキストが目標コンテキストとして現在のコンテキストにコピーされます。
（訳注：第一構文で <em>sym-context-target</em> に MAIN が使えないのと同様に、第二構文は MAIN コンテキスト上では使えません。）<br />
In the second syntax, the existing context in <em>context-source</em> gets 
copied into the current context as the target context.</p>

<p>元となるコンテキスト上の全てのシンボルへの参照は、目標コンテキスト上での参照に移植されます。
この方法で（訳注：コピーされた）元のコンテキスト上のシンボルを参照している全ての関数とデータ構造は、目標コンテキスト上のシンボルを参照します。<br />
All references to symbols in the originating context 
will be translated to references in the target context.
This way, all functions and data structures referring to symbols
in the original context will now refer to symbols in the target context.</p>

<!-- example -->

<pre>
(new CTX 'CTX-2)  <span class='arw'>&rarr;</span> CTX-2   

;; force overwrite of existing symbols
(new CTX MyCTX true)  <span class='arw'>&rarr;</span> MyCTX   
</pre>


<p>例の一行目は、元のコンテキストと厳密に同じ構造を持つ <tt>CTX-2</tt> と呼ばれる新規コンテキストを生成します。
コンテキストはそれ自身に評価されるので、<tt>CTX</tt> にクォートがありませんが、
<tt>CTX-2</tt> はまだ存在しないので、クォートであることが必要であることに注意してください。<br />
The first line in the example creates a new context 
called <tt>CTX-2</tt> that has the exact same structure 
as the original one. 
Note that <tt>CTX</tt> is not quoted 
because contexts evaluate to themselves, 
but CTX-2 must be quoted because it does not exist yet.
</p>

<p>二行目は、<tt>MyCTX</tt> に <tt>CTX</tt> を併合します。
<tt>MyCTX</tt> に同じ名前で存在するシンボルは、上書きされます。
<tt>MyCTX</tt> は既に存在するので、コンテキスト・シンボルの前のクォートは省略可能です。<br />
The second line merges the context <tt>CTX</tt> into <tt>MyCTX</tt>. 
Any existing symbols of the same name in <tt>MyCTX</tt> 
will be overwritten. 
Because <tt>MyCTX</tt> already exists, 
the quote before the context symbol can be omitted.
</p>

<p>コンテキスト中のシンボルを明示的に記述する必要はありませんが、変数として含められます。<br />
Context symbols need not be mentioned explicitly, 
but they can be contained in variables:
</p>

<!-- example -->

<pre>
(set 'foo:x 123)
(set 'bar:y 999)

(set 'ctxa foo)
(set 'ctxb bar)

(new ctxa ctxb)  ; from foo to bar

bar:x  <span class='arw'>&rarr;</span> 123  ; x has been added to bar
bar:y  <span class='arw'>&rarr;</span> 999)
</pre>


<p>例では、コンテキストを変数で参照し、コンテキスト <tt>bar</tt> に <tt>foo</tt> を併合しています。<br />
The example refers to contexts in variables 
and merges context <tt>foo</tt> into <tt>bar</tt>.
</p>


<p>完全なコンテキストの代わりに、単一関数の移植や併合用の関数 <a href="#def-new">def-new</a> も見てください。
<tt>new</tt> のよりわかりやすい例については、関数 <a href="#context">context</a> を見てください。<br />
See also the function <a href="#def-new">def-new</a> 
for moving and merging single functions 
instead of entire contexts. 
See the <a href="#context">context</a> function 
for a more comprehensive example of <tt>new</tt>.
</p>

<br/><br/>

<a name="nilp"></a>
<h2><span class="function">nil?</span></h2>
<h4>syntax: (nil? <em>exp</em>)</h4>

<p><em>exp</em> の式が <tt>nil</tt> に評価されるなら、<tt>nil?</tt> は <tt>true</tt> を返し、それ以外では <tt>nil</tt> を返します。<br />
If the expression in <em>exp</em> evaluates to <tt>nil</tt>, 
then <tt>nil?</tt> returns <tt>true</tt>; 
otherwise, it returns <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(map nil? '(x nil  1 nil "hi" ()))
<span class='arw'>&rarr;</span> (nil true nil true nil nil)

(nil? nil)  <span class='arw'>&rarr;</span> true
(nil? '())  <span class='arw'>&rarr;</span> nil

; nil? means strictly nil
(nil? (not '()))  <span class='arw'>&rarr;</span> nil
</pre>


<p>述語 <tt>nil?</tt> は、<tt>nil</tt> と空のリスト <tt>()</tt> を区別するのに使えます。<br />
The <tt>nil?</tt> predicate 
is useful for distinguishing between 
<tt>nil</tt> and the empty list <tt>()</tt>.
</p>

<p><tt>nil?</tt> が<em>厳密に</em> <tt>nil</tt> を示す一方で、<a href="#truep">true?</a> は <tt>nil</tt> でも空のリスト <tt>()</tt> でもない全てを示します。<br />
Note that <tt>nil?</tt> means <em>strictly</em> <tt>nil</tt>
while <tt>true?</tt> means everything not <tt>nil</tt> or the
empty list <tt>()</tt>.</p>

<br/><br/> 


<a name="normal"></a>
<h2><span class="function">normal</span></h2>
<h4>syntax: (normal <em>float-mean</em> <em>float-stdev</em> <em>int-n</em>)<br/>
syntax: (normal <em>float-mean</em> <em>float-stdev</em>)</h4>

<p>第一形式 の <tt>normal</tt> は、平均値 <em>float-mean</em> と 標準偏差  <em>float-stdev</em> でランダムかつ継続的に分散された長さ <em>int-n</em> の浮動小数点数のリストを返します。
内部のランダム生成は、関数 <a href="#seed">seed</a> を使って種 (seed) を設定されます。<br />
In the first form, <tt>normal</tt> returns a list of length <em>int-n</em> 
of random, continuously distributed floating point numbers 
with a mean of <em>float-mean</em> 
and a standard deviation of <em>float-stdev</em>. 
The random generator used internally 
can be seeded using the <a href="#seed">seed</a> function.
</p>

<!-- example -->

<pre>
(normal 10 3 10)
<span class='arw'>&rarr;</span> (7 6.563476562 11.93945312 6.153320312 9.98828125
7.984375 10.17871094 6.58984375 9.42578125 12.11230469)
</pre>


<p>第二形式の <tt>normal</tt> は、一個の標準分散値を返します（訳注：つまり、戻り値はリストではありません）：<br />
In the second form, 
<tt>normal</tt> returns a single 
normal distributed floating point number:
</p>

<pre>
(normal 1 0.2) <span class='arw'>&rarr;</span> 0.646875
</pre>

<p>パラメータなしの時、<tt>normal</tt> は平均を <tt>0.0</tt>、標準偏差を <tt>1.0</tt> と見なします。<br />
 When no parameters are given, <tt>normal</tt> assumes a mean of <tt>0.0</tt> 
and a standard deviation of <tt>1.0</tt>.</p>


<p>均等に分散された数値用の関数 <a href="#random">random</a> や <a href="#rand">rand</a>、式のリストの中からランダムに評価する <a href="#amb">amb</a>、擬似ランダム数生成に異なる開始点を設定する <a href="#seed">seed</a> も見てください。<br />
See also the <a href="#random">random</a> 
and <a href="#rand">rand</a> functions 
for evenly distributed numbers, 
<a href="#amb">amb</a> for randomizing evaluation 
in a list of expressions, 
and <a href="#seed">seed</a> for setting a different start point 
for pseudo random number generation.
</p>

<br/><br/>

<a name="not"></a>
<h2><span class="function">not</span></h2>

<h4>syntax: (not <em>exp</em>)</h4>

<p><em>exp</em> が <tt>nil</tt> か空リスト <tt>()</tt> に評価されたなら、
<tt>true</tt> が返り、それ以外では <tt>nil</tt> が返ります。<br />
If <em>exp</em> evaluates to <tt>nil</tt> or the empty list <tt>()</tt>, 
then <tt>true</tt> is returned; otherwise, <tt>nil</tt> is returned.</p>

<!-- example -->

<pre>
(not true)            <span class='arw'>&rarr;</span> nil
(not nil)             <span class='arw'>&rarr;</span> true
(not '())             <span class='arw'>&rarr;</span> true
(not (&lt; 1 10))        <span class='arw'>&rarr;</span> nil
(not (not (&lt; 1 10)))  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="now"></a>
<h2><span class="function">now</span></h2>
<h4>syntax: (now [<em>int-minutes-offset</em> [<em>int-index</em>]])</h4>

<p>現在の日付と時刻の情報を整数のリストで返します。
オプションの <em>int-minutes-offset</em> に、タイム・ゾーンのオフセットを分単位で指定できます。
このオプションは、日付に分ける前の時間を前後にずらします。<br />
Returns information about the current date and time 
as a list of integers.  An optional time-zone offset 
can be specified in minutes in <em>int-minutes-offset</em>. 
This causes the time to be shifted forward or backward in time,
before being split into separate date values.</p>

<p><em>int-index</em> オプションのリスト・インデックスにより、<tt>now</tt> は結果リストから指定された要素を返します。<br />
An optional list-index in <em>int-index</em> makes <tt>now</tt>
return a specific member in the result list.</p>

<!-- example -->

<pre>
(now)       <span class='arw'>&rarr;</span> (2002 2 27 18 21 30 140000 57 3 -300 0)
(now 0 -2)  <span class='arw'>&rarr;</span> -300 ; minutes west of GMT


(date-value (now))  <span class='arw'>&rarr;</span> 1014834090
</pre>


<p>数値は、次のように表現されています：<br />
The numbers represent the following date-time fields:</p>

<table  width="98%" summary="date formatting">
<tr align="left"><th>format</th><th>description</th></tr>

<tr><td>年<br />year</td><td><a href="http://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%AC%E3%82%B4%E3%83%AA%E3%82%AA%E6%9A%A6">グレゴリオ暦</a><br />Gregorian calendar</td></tr>
<tr><td>月<br />month</td><td>               (1&ndash;12)</td></tr>
<tr><td>日<br />day</td><td>                 (1&ndash;31)</td></tr>
<tr><td>時<br />hour</td><td><a href="http://ja.wikipedia.org/wiki/%E5%8D%94%E5%AE%9A%E4%B8%96%E7%95%8C%E6%99%82">協定世界時</a>上の (0&ndash;23)<br />                (0&ndash;23) UTC（）</td></tr>
<tr><td>分<br />minute</td><td>              (0&ndash;59)</td></tr>
<tr><td>秒<br />second</td><td>              (0&ndash;59)</td></tr>
<tr><td>マイクロ秒<br />microsecond</td><td>(0&ndash;999999) OS の仕様によっては、ミリ秒単位の解像度<br />         (0&ndash;999999) OS-specific, millisecond resolution</td></tr>
		
<tr><td>年間通算日<br />day of current year</td><td>一月一日が 1<br />Jan 1st is 1<br/></td></tr>
<tr><td>週の曜日<br />day of current week</td><td>月曜から始まる (1&ndash;7)<br />(1&ndash;7) starting Monday</td></tr>
<tr><td><a href="http://ja.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E6%99%82">タイムゾーン</a>のオフセット（分単位）<br />time zone offset in minutes</td><td><a href="http://ja.wikipedia.org/wiki/GMT">グリニッジ標準時</a>から西回りで、夏時間のオフセットを含む（訳注：(now (now 0 -2)) で現タイムゾーンの現在の日時）<br /> west of GMT including daylight savings bias</td></tr>
<tr><td><a href="http://ja.wikipedia.org/wiki/%E5%A4%8F%E6%99%82%E9%96%93">夏時間</a>の型<br />daylight savings time type </td><td>Linux/Unix では (0&ndash;6)、MS Windows では (0&ndash;2)<br /> (0&ndash;6) on Linux/Unix or (0&ndash;2) on MS Windows</td></tr>
</table><br/>

<p>二つ目の例は、協定世界時 (UTC) で1970年1月1日からの秒数を返しています。<br />
The second example returns the Coordinated Universal Time (UTC) 
time value of seconds after January 1, 1970.</p>

<p>0 ～ 23 の範囲でUTC 上の <tt>hour</tt> が与えられますが、ローカル・タイム・ゾーンの補正は行われません。
<tt>microsecond</tt> の精度は、オペレーティングシステムやプラットフォーム次第です。
いくつかのプラットフォームでは、 <tt>microsecond</tt> の下3桁は常に <tt>0</tt>（ゼロ）になります。<br />
Ranging from 0 to 23, hours are given in UTC and are not adjusted for 
the local time zone.  The resolution of the <tt>microseconds</tt> field 
depends on the operating system and platform.  On some platforms, 
the last three digits of the <tt>microseconds</tt> field are always 
<tt>0</tt> (zero).</p>

<p>日付と時刻表記に関する国際規格 ISO 8601 に合わせて、"day of the week" の値は月曜日を 1 として開始します。<br />
The "day of the week" field starts with 1 on Monday conforming to the 
ISO 8601 international standard for date and time representation.</p>

<p>いくつかのプラットフォームでは、夏時間フラグはアクティブでなく、夏時間期間 (dst) 中でも <tt>0</tt>（ゼロ）を返します<br />
On some platforms, the daylight savings time flag is not active and 
returns <tt>0</tt> (zero) even during daylight savings time (dst).</p>

<p>地域によって夏時間 (dst) の型は、1 ～ 6 までの異なる値を持ちます：<br />
Depending on the geographical area, the daylight savings time type
(dst) has a different value from 1 to 6:</p>

<table  width="35%" summary="date formatting">
<tr align="left"><th>UNIX type</th><th>area</th></tr>
<tr><td>0</td><td>not on daylight savings</td></tr>
<tr><td>1</td><td>USA style dst</td></tr>
<tr><td>2</td><td>Australian style daylight savings</td></tr>
<tr><td>3</td><td>Western European daylight savings</td></tr>
<tr><td>4</td><td>Middle European daylight savings</td></tr>
<tr><td>5</td><td>Eastern European daylight savings</td></tr>
<tr><td>6</td><td>Canada dst</td></tr>
</table>
<br />
<table  width="35%" summary="date formatting">
<tr align="left"><th>Windows type</th><th></th></tr>
<tr><td>0</td><td>Daylight saving time is not used</td></tr>
<tr><td>1</td><td>Standard date time range is used</td></tr>
<tr><td>2</td><td>Daylight date time range is used (daylight savings active)</td></tr> 
</table>



<p>関数 <a href="#date">date</a>、<a href="#date-list">date-list</a>、<a href="#date-parse">date-parse</a>、<a href="#date-value">date-value</a>、<a href="#time">time</a>、<a href="#time-of-day">time-of-day</a> も見てください。<br />
See also the <a href="#date">date</a>, 
<a href="#date-list">date-list</a>, 
<a href="#date-parse">date-parse</a>, 
<a href="#date-value">date-value</a>, 
<a href="#time">time</a>, and <a href="#time-of-day">time-of-day</a> functions.</p>

<br/><br/>

<a name="nper"></a>
<h2><span class="function">nper</span></h2>
<h4>syntax: (nper <em>num-interest</em> <em>num-pmt</em> <em>num-pv</em> 
[<em>num-fv</em> [<em>int-type</em>]])</h4>

<p>
<em>num-pv</em> のローンを固定利率 <em>num-interest</em> と支払額 <em>num-pmt</em> で支払う時に必要な支払回数を計算します。
支払いが期間の終わりなら <em>int-type</em> を <tt>0</tt>（ゼロ）にするか省略し、支払いが期間の最初なら <em>int-type</em> を 1 にします。（訳注：<em>int-type</em> を指定する時には、<em>num-fv</em> の指定（デフォルト値 <tt>0.0</tt>）も必要です）<br />
Calculates the number of payments required to pay a loan of <em>num-pv</em> 
with a constant interest rate of <em>num-interest</em> and payment <em>num-pmt</em>.
If payment is at the end of the period, <em>int-type</em> is <tt>0</tt> (zero) 
or <em>int-type</em> is omitted; for payment at the beginning of each period, 
<em>int-type</em> is 1.</p>

<!-- example -->

<pre>
(nper (div 0.07 12) 775.30 -100000)  <span class='arw'>&rarr;</span> 239.9992828
</pre>


<p>例では、100,000ドルのローンを年利 7%、月々 775.3 ドル支払う場合に必要な支払月数を計算しています。<br />
The example calculates the number of monthly payments required to pay a loan of 
$100,000 at a yearly interest rate of 7 percent with payments of $775.30.
</p>

<blockquote>（訳例：年利 0.07%、月々 775.3 ドル支払いで 100,000 ドルを貯めるに必要な月数の計算は、
<pre>
> (nper (div 0.0007 12) -775.30 0 100000)
128.503268
</pre>
となります。
）</blockquote>

<p>
関数 <a href="#fv">fv</a>、<a href="#irr">irr</a>、<a href="#npv">npv</a>、<a href="#pmt">pmt</a>、<a href="#pv">pv</a> も見てください。<br />
See also the <a href="#fv">fv</a>,
<a href="#irr">irr</a>,
<a href="#npv">npv</a>,
<a href="#pmt">pmt</a>,
and <a href="#pv">pv</a> functions.
</p>

<br/><br/>

<a name="npv"></a>
<h2><span class="function">npv</span></h2>
<h4>syntax: (npv <em>num-interest</em> <em>list-values</em>)</h4>

<p>固定利率 <em>num-interest</em> と未来の一連の投資および配当 <em>list-values</em> から、投資の総現在価値を計算します。
<em>list-values</em> 中に投資額を負の数で表し、配当は正の数で表します。<br />
Calculates the net present value of an investment with a fixed interest rate 
<em>num-interest</em> and a series of future payments and income in <em>list-values</em>.
Payments are represented by negative values in <em>list-values</em>,
while income is represented by positive values in <em>list-values</em>.
</p>

<!-- example -->

<pre>
(npv 0.1 '(1000 1000 1000)) 
<span class='arw'>&rarr;</span> 2486.851991

(npv 0.1 '(-2486.851991 1000 1000 1000)) 
<span class='arw'>&rarr;</span> -1.434386832e-08  ; ~ 0.0 (zero)
</pre>


<p>
例によれば、（訳注：年利10%での）初期投資2,481.85ドルは、一年後、二年後、三年後の年末に 1,000ドルの配当なら許されるでしょう。<br />
In the example,
an initial investment of $2,481.85 would allow for an income of $1,000 after the end of the first,
second,
and third years.
</p>

<p>
関数 <a href="#fv">fv</a>、<a href="#irr">irr</a>、<a href="#nper">nper</a>、<a href="#pmt">pmt</a>、<a href="#pv">pv</a> も見てください。<br />
See also the <a href="#fv">fv</a>,
<a href="#irr">irr</a>,
<a href="#nper">nper</a>,
<a href="#pmt">pmt</a>,
and <a href="#pv">pv</a> functions.
</p> 

<br/><br/>

<a name="nth"></a>
<h2><span class="function">nth</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (nth <em>int-index</em> <em>list</em>)<br/>
syntax: (nth <em>int-index</em> <em>array</em>)<br/>
syntax: (nth <em>int-index</em> <em>str</em>)<br/><br/>

syntax: (nth <em>list-indices</em> <em>list</em>)<br/>
syntax: (nth <em>list-indices</em> <em>array</em>)</h4>

<p>
第一構文グループの <tt>nth</tt> はインデックス <em>int-index</em> を使って、<em>list</em>, <em>array</em>, <em>str</em> からインデックスで見つかる要素を返します。
<a href="#indexing">文字列、リスト、アレイの要素指定</a> も見てください。<br />
In the first syntax group <tt>nth</tt> uses <em>int-index</em> an index into the 
<em>list</em>, <em>array</em> or <em>str</em> found and returning the element found 
at that index. See also <a href="#indexing">Indexing elements of strings and lists</a>.</p>

<p>入れ子構造のリストやアレイの要素を再帰的にアクセスするために、複数のインデックスを指定するかもしれません。
その際、入れ子レベルより多いインデックスは無視されます。
複数のインデックスを指定する時は、第二構文グループで示されているようにリストで指定する必要があります。<br />
Multiple indices may be specified to recursively access elements in nested lists
or arrays. If there are more indices than nesting levels, the extra indices are ignored. 
When multiple indices are used, they must be put in a list as shown in the second
syntax group.</p>

<!-- example -->

<pre>
(set 'L '(a b c))
(nth 0 L)    <span class='arw'>&rarr;</span> a
; or simply
(L 0) <span class='arw'>&rarr;</span> a

(set 'names '(john martha robert alex)) 
<span class='arw'>&rarr;</span> (john martha robert alex)

(nth 2 names)    <span class='arw'>&rarr;</span> robert
; or simply
(names 2)        <span class='arw'>&rarr;</span> robert

(names -1)       <span class='arw'>&rarr;</span> alex


; multiple indices
(set 'persons '((john 30) (martha 120) ((john doe) 17)))

(persons 1 1)           <span class='arw'>&rarr;</span> 120

(nth '(2 0 1) persons)  <span class='arw'>&rarr;</span> doe

; or simply
(persons 2 0 1)        <span class='arw'>&rarr;</span> doe

; multiple indices in a vector
(set 'v '(2 0 1))
(persons v)       <span class='arw'>&rarr;</span> doe
(nth v persons)   <span class='arw'>&rarr;</span> doe

; negative indices
(persons -2 0)    <span class='arw'>&rarr;</span> martha

; out-of-bounds indices cause error
(persons 10)  <span class='arw'>&rarr;</span> <span class='err'>ERR: list index out of bounds</span>
(person -5)   <span class='arw'>&rarr;</span> <span class='err'>ERR: list index out of bounds</span>
</pre>


<p>リスト <tt>L</tt> は、デフォルト・ファンクタ <tt>L:L</tt> のコンテキストでも可能です。
これは、リストの参照渡しを可能にします：<br />
The list <tt>L</tt> can be the context of the default functor <tt>L:L</tt>. 
This allows lists passed by reference:</p>

<pre>
(set 'L:L '(a b c d e f g))

(define (second ctx)
	(nth 1 ctx))

(reverse L) <span class='arw'>&rarr;</span> (g f e d c b a)
L:L <span class='arw'>&rarr;</span> (g f e d c b a)

;; passing the list in L:L by reference
(second L)   <span class='arw'>&rarr;</span> b

;; passing the list in L:L by value
(second L:L) <span class='arw'>&rarr;</span> b
</pre>

<p>参照渡しは高速で大きなリストでも少ないメモリで済みますので、数百より多い要素のリストでは使うべきです。<br />
Reference passing is faster and uses less memory in big lists and should
be used on lists with more than a few hundred items.</p>

<p><tt>nth</tt> の <i><a href="#implicit_indexing">暗黙の要素指定</a></i> 版は newLISP 構文を壊すものではなく、newLISP 構文の論理的拡張は組込関数やラムダ式よりもデータ型で規定されると理解すべきことに注目してください。
ｓ式のファンクタ（関数オブジェクト）位置にあるリストは、続くインデックス引数を使った自己インデックス機能と解釈されます。<br />
Note that the <i>implicit indexing</i> version of <tt>nth</tt> is not breaking newLISP
syntax rules but should be understood as a logical expansion of newLISP syntax rules to
other data types than built-in functions or lambda expressions. A list in the functor
position of an s-expression assumes self-indexing functionality using the index
arguments following.</p>

<p>暗黙のインデックス構文形式は速いですが、同じ状況下では、明示的に <tt>nth</tt> を使った形式の方が可読性の良いものになります。<br />
The implicit indexed syntax forms are faster but the other form with an explicit
<tt>nth</tt> may be more readable in some situations.
</p>

<p><tt>nth</tt> は、リストにと同様に <a href="#array">arrays</a> に対しても動作します：<br />
<tt>nth</tt> works on <a href="#array">arrays</a> just like it does on lists:</p>

<!-- example -->

<pre>
(set 'aArray (array 2 3 '(a b c d e f))) 
<span class='arw'>&rarr;</span> ((a b c) (d e f))
(nth 1 aArray)      <span class='arw'>&rarr;</span>  (d e f)
(aArray 1)          <span class='arw'>&rarr;</span>  (d e f)

(nth '(1 0) aArray)    <span class='arw'>&rarr;</span> d
(aArray 1 0)           <span class='arw'>&rarr;</span> d
(aArray '(1 0))        <span class='arw'>&rarr;</span> d

(set 'vec '(1 0))
(aArray vec)           <span class='arw'>&rarr;</span> d
</pre>


<p>文字列版の <tt>nth</tt> は、<em>str</em> から <em>int-index</em> 位置の文字を見つけ出し、文字列として返します。<br />
In the String version, <tt>nth</tt> returns the character found at the position 
<em>int-index</em> in <em>str</em> and returns it as a string.</p>

<!-- example -->

<pre>
(nth  0 "newLISP")   <span class='arw'>&rarr;</span> "n"

("newLISP" 0)        <span class='arw'>&rarr;</span> "n"

("newLISP" -1)       <span class='arw'>&rarr;</span> "P"
</pre>


<p>UTF-8 版 newLISP を使っている時、<a href="#nth">nth</a> はバイト境界ではなく、文字境界で作用することに注意してください。
ASCII やバイナリ文字列に１バイト境界でアクセスするためには、<a href="#slice">slice</a> を使います。<br />
Note that <a href="#nth">nth</a> works on character boundaries rather than byte 
boundaries when using the UTF-8&ndash;enabled version of newLISP. To access ASCII and
binary string buffers on single byte boundaries use <a href="#slice">slice</a>.</p>

<p>多次元リストやアレイを変更する <a href="#setf">setf</a> やリストを変更する <a href="#push">push</a> と <a href="#pop">pop</a> も見てください。<br />
See also <a href="#setf">setf</a> for modifying multidimensional lists and arrays and
<a href="#push">push</a> and <a href="#pop">pop</a> for modifying lists.</p>

<br/><br/>

<a name="nullp"></a>
<h2><span class="function">null?</span></h2>
<h4>syntax: (null? <em>exp</em>)</h4>

<p>式が <tt>nil</tt>、空リスト <tt>()</tt>、空文字列 <tt>""</tt>、<tt>NaN</tt> (not a number)、<tt>0</tt>（ゼロ）のいずれかに評価されるかどうかをチェックし、そうであれば <tt>true</tt> を返します。
それ以外の全てでは、<tt>null?</tt> は <tt>nil</tt> を返します。
述語 <tt>null?</tt> は、<a href="#filter">filter</a> や <a href="#clean">clean</a> と連携して、newLISP 操作の出力をチェックするために使えます。<br />
Checks if an expression evaluates to <tt>nil</tt>,
the empty list <tt>()</tt>,
the empty string <tt>""</tt>,
<tt>NaN</tt> (not a number),
or <tt>0</tt> (zero),
in which case it returns <tt>true</tt>.
In all other cases,
<tt>null?</tt> returns <tt>nil</tt>.
The predicate <tt>null?</tt> is useful in conjunction with the functions 
<a href="#filter">filter</a> or <a href="#clean">clean</a> to check the outcome of other newLISP operations.
</p>

<!-- example -->

<pre>
(set 'x (sqrt -1)) <span class='arw'>&rarr;</span> NaN ; or nan on UNIX
(null? x) <span class='arw'>&rarr;</span> true

(map null? '(1 0 0.0 2 "hello" "" (a b c) () true))
<span class='arw'>&rarr;</span> (nil true true nil nil true nil true nil) 

(filter null? '(1 0 2 0.0 "hello" "" (a b c) () nil true)) 
<span class='arw'>&rarr;</span> (0 0 "" () nil)

(clean null? '(1 0 2 0.0 "hello" "" (a b c) () nil true))
<span class='arw'>&rarr;</span> (1 2 "hello" (a b c) true)
</pre>

<blockquote>（訳例：
<pre>
> [cmd]
(let (NaN (sqrt -1) INF (div 1 0))
  (let (lst (list 0 0.0 NaN INF ""  '() nil))
    (println "list  " lst)
    (println "true? " (map true? lst))
    (println "not   " (map not   lst))
    (println "null? " (map null? lst))
    (println "nil?  " (map nil?  lst))
    (print   "list  ") lst))
[/cmd]
list  (0 0 nan inf "" () nil)
true? (true true true true true nil nil)
not   (nil nil nil nil nil true true)
null? (true true true nil true true true)
nil?  (nil nil nil nil nil nil true)
list  (0 0 nan inf "" () nil)
> 
</pre>）
</blockquote>

<p>
述語 <a href="#emptyp">empty?</a>、<a href="#nilp">nil?</a>、<a href="#zerop">zero?</a> も見てください。<br />
See also the predicates <a href="#emptyp">empty?</a>,
<a href="#nilp">nil?</a>
and <a href="#zerop">zero?</a>.
</p>

<br/><br/>

<a name="numberp"></a>
<h2><span class="function">number?</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (number? <em>exp</em>)</h4>

<p><em>exp</em> が浮動小数点数か整数に評価されたなら <tt>true</tt> が返り、それ以外では <tt>nil</tt> が返ります。<br />
<tt>true</tt> is returned only if <em>exp</em> evaluates to a floating point number or an integer;
otherwise,
<tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(set 'x 1.23)
(set 'y 456)
(number? x)      <span class='arw'>&rarr;</span> true
(number? y)      <span class='arw'>&rarr;</span> true
(number? "678")  <span class='arw'>&rarr;</span> nil  
</pre>
<blockquote>
（訳例：
<pre>
> (sqrt -1)
nan
> (number? (sqrt -1))
true
> (div 1 0)
inf
> (number? (div 1 0))
true
</pre>
　<tt>NaN</tt> や <tt>INF</tt> の型は、浮動小数点数です。）
</blockquote>

<p>数値型を特定するテスト関数 <a href="#floatp">float?</a> や <a href="#integerp">integer?</a> も見てください。<br />
See the functions <a href="#floatp">float?</a> and <a href="#integerp">integer?</a> to test for a specific number type.
</p>

<br/><br/>

<a name="oddp"></a>
<h2><span class="function">odd?</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (odd? <em>int-number</em>)</h4>

<p>整数値の偶奇をチェックします。
数値が <tt>2</tt> で<em>割り切れ</em> ないなら、それは<em>奇数</em> です。
<em>int-number</em> に浮動小数点数が渡されると、最初に小数部分が切り捨てられ、整数に変換されます。<br />
Checks the parity of an integer number. If the number is not <em>even divisible</em> by <tt>2</tt>, 
it has <em>odd</em> parity.  When a floating point number is passed for <em>int-number</em>, 
it will be converted first to an integer by cutting off its fractional part.</p>

<pre>
(odd? 123)  <span class='arw'>&rarr;</span> true
(odd? 8)    <span class='arw'>&rarr;</span> nil
(odd? 8.7)  <span class='arw'>&rarr;</span> nil
</pre>

<p>整数が <tt>2</tt> で割り切れる偶数かどうかのチェックには、<a href="#evenp">even?</a> を使ってください。<br />
Use <a href="#evenp">even?</a> to check if an integer is even, divisible by <tt>2</tt>.</p>

<br/><br/>

<a name="open"></a>
<h2><span class="function">open</span></h2>

<h4>syntax: (open <em>str-path-file</em> <em>str-access-mode</em> [<em>str-option</em>])</h4>

<p><em>str-path-file</em> はファイル名、<em>str-access-mode</em> はファイル・アクセス・モードを指定する文字列です。
<tt>open</tt> は整数値を返し、それがファイル・ハンドルとなって、以下に続くファイルの読み書き操作で使います。
失敗時、<tt>open</tt> は <tt>nil</tt> を返します。
<tt>"write"</tt> アクセス・モードでは、ファイルが存在しない時は作成します。また、ファイルが存在時は長さを <tt>0</tt>（ゼロ）バイトに切り詰めます。（訳注：つまり、新規ファイルと同じになります）<br />
The <em>str-path-file</em> is a file name,
and <em>str-access-mode</em> is a string specifying the file access mode.
<tt>open</tt> returns an integer,
which is a file handle to be used on subsequent read or write operations on the file.
On failure,
<tt>open</tt> returns <tt>nil</tt>.
The access mode <tt>"write"</tt> creates the file if it doesn't exist,
or it truncates an existing file to <tt>0</tt> (zero) bytes in length.
</p>

<p>以下の文字列が所定のアクセス・モードです：<br />
The following strings are legal access modes:
</p>

<p>
リード・オンリー・アクセス用　　<tt>"read"</tt> または <tt>"r"</tt><br>
ライト・オンリー・アクセス用　　<tt>"write"</tt> or <tt>"w"</tt><br>
リード／ライト・アクセス用　　　<tt>"update"</tt> or <tt>"u"</tt><br>
リード／追加ライト・アクセス用　<tt>"append"</tt> or <tt>"a"</tt><br />
<tt>"read"</tt> or <tt>"r"</tt> for read only access<br/>
<tt>"write"</tt> or <tt>"w"</tt> for write only access<br/>
<tt>"update"</tt> or <tt>"u"</tt> for read/write access<br/>
<tt>"append"</tt> or <tt>"a"</tt> for append read/write access<br/>
</p>
<br/>

<!-- example -->

<pre>
(device (open "newfile.data" "write"))  <span class='arw'>&rarr;</span> 5
(print "hello world\n")  <span class='arw'>&rarr;</span> "hello world"
(close (device))         <span class='arw'>&rarr;</span> 5

(set 'aFile (open "newfile.data" "read"))
(seek aFile 6)
(set 'inChar (read-char aFile))
(print inChar "\n")
(close aFile)
</pre>


<p>最初の例では <a href="#print">print</a> のデバイス設定に<tt>open</tt> を使い、文字列 <tt>"hello world"</tt> をファイル<tt>newfile.data</tt> に書き込んでいます。
二番目の例では、同ファイルのオフセット 6 のバイト値（ <tt>'w'</tt>アスキー値、 119）を読み取っています。
<a href="#device">(device)</a> に対して <tt>close</tt> を使う事は、<a href="#device">device</a> を自動的に <tt>0</tt>（ゼロ）にリセットするので注意してください。<br />
The first example uses <tt>open</tt> to set the device for <a href="#print">print</a> 
and writes the word <tt>"hello world"</tt> into the file <tt>newfile.data</tt>.
The second example reads a byte value at offset 6 in the same file (the ASCII value 
of <tt>'w'</tt> is 119). Note that using <tt>close</tt> on <a href="#device">(device)</a> 
automatically resets <a href="#device">device</a> to <tt>0</tt> (zero).
</p>

<p>tt>"read"</tt> や <tt>"write"</tt> オプションの後に、<em>str-option</em> オプション として <tt>"non-block"</tt> か <tt>"n"</tt> を指定できます。
これは Unix システムでのみで有効で、<em>名前付きパイプ</em> を開くが名前付きパイプ上の I/O の実行を要求されないノン・ブロッキング・モードに使えます。<br />
As an additional <em>str-option</em>,
<tt>"non-block"</tt> or <tt>"n"</tt> can be specified after the <tt>"read"</tt> or <tt>"write"</tt> option.
Only available on Unix systems,
non-blocking mode can be useful when opening <em>named pipes</em> but is not required to perform I/O on named pipes.
</p>

<br/><br/>

<a name="or"></a>
<h2><span class="function">or</span></h2>

<h4>syntax: (or <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p>
<em>exp-x</em> の式群を <tt>nil</tt> か 空リスト <tt>()</tt> 以外に評価されるまで左から右へ評価します。
その結果が <tt>or</tt> 式の戻り値になります。
<br/>
Evaluates expressions <em>exp-x</em> from left to right until finding a result 
that does not evaluate to <tt>nil</tt> or the empty list <tt>()</tt>.
The result is the return value of the <tt>or</tt> expression.
</p>

<!-- example -->

<pre>
(set 'x 10)
(or (&gt; x 100) (= x 10))          <span class='arw'>&rarr;</span> true
(or "hello" (&gt; x 100) (= x 10))  <span class='arw'>&rarr;</span> "hello"
(or '())                         <span class='arw'>&rarr;</span> ()
(or true)                        <span class='arw'>&rarr;</span> true
(or)                             <span class='arw'>&rarr;</span> nil
</pre>

<br/><br/>

<a name="ostype"></a>
<h2><span class="function">ostype</span></h2>
<h4>syntax: ostype</h4>

<p>newLISP の走っているオペレーティング・システム名が入っている組込定数です。<br />
<tt>ostype</tt> is a built-in system constant 
containing the name of the operating system 
newLISP is running on.</p>

<!-- example -->

<pre>
ostype  <span class='arw'>&rarr;</span> "Windows"
</pre>


<p>次の文字列の中の一つが返ります：<tt>"Linux", "BSD", "OSX", "Tru64Unix", "Solaris", "SunOS", "Windows", "Cygwin","OS/2"</tt><br />
One of the following strings is returned: 
<tt>"Linux", "BSD", "OSX", "Tru64Unix", "Solaris", "SunOS", "Windows", "Cygwin", or "OS/2"</tt>.
</p>


<p><tt>ostype</tt> は、プラットフォームに依存したコードを書く時に使えます：<br />
<tt>ostype</tt> can be used to write platform-independent code:</p>

<pre>
(if 
    (= ostype "Linux") (import "libz.so")
    (= ostype "BSD") (import "libz.so")
    (= ostype "OSX") (import "libz.dylib")
    ...
    (println "cannot import libz on this platform")
)
</pre>


<p>newLISP の走っている現環境について多く知るには、<a href="#sys-info">sys-info</a> を使ってください。<br />
Use <a href="#sys-info">sys-info</a> to learn more
about the current flavor of newLISP running.</p>

<p>他の組込システム変数やシンボルの表は、付録の <a href="#system_symbols">System Symbols and Constants</a> の章で見てください。<br />
For a table of other built-in system variables and symbols see the
chapter <a href="#system_symbols">System Symbols and Constants</a> in the
appendix.</p>

<br/><br/>

<a name="pack"></a>
<h2><span class="function">pack</span></h2>
<h4>syntax: (pack <em>str-format</em> [<em>exp-1</em> [<em>exp-2</em> ... ]])<br/>
syntax: (pack <em>str-format</em> [<em>list</em>])<br/><br/>
syntax: (pack <em>struct</em> [<em>exp-1</em> [<em>exp-2</em> ... ]])<br/>
syntax: (pack <em>struct</em> [<em>list</em>])</h4>

<p>一個以上の式群 (<em>exp-1</em> ～ <em>exp-n</em>) をフォーマット文字列 <em>str-format</em> に指定されたバイナリ・フォーマットでパックし、文字列バッファに入ったバイナリ構造体を返します。
アンパックには、対となる関数 <a href="#unpack">unpack</a> が使えます。
引数の式群は <em>list</em> で与えることもできます（訳注：第二構文）。
<tt>pack</tt> と <tt>unpack</tt> は、バイナリ・ファイルの読み書き（<a href="#read">read</a> と <a href="#write">write</a> 参照）や <tt>import</tt> で導入された C 関数の戻り値からバイナリ構造体をアンパックする時に役に立ちます。<br />
When the first parameter is a string, <tt>pack</tt> packs one or more expressions 
(<em>exp-1</em> to <em>exp-n</em>) into a binary format specified in the format 
string <em>str-format</em>, and returning the binary structure in a string buffer.
The symmetrical <a href="#unpack">unpack</a> function is used 
for unpacking. The expression arguments can also be given in a <em>list</em>.
<tt>pack</tt> and <tt>unpack</tt> are useful when reading and writing binary files 
(see <a href="#read">read</a> and <a href="#write">write</a>) 
or when unpacking binary structures from return values of imported C functions 
using <tt>import</tt>.</p>

<p>第一パラメータが <a href="#struct">struct</a> 定義シンボルの時、<tt>pack</tt> は <em>struct</em> で定義されたフォーマットを使います。
<em>str-format</em> を使った <tt>pack</tt> は、指定された文字の通りにパックします。
一方、<em>struct</em> を使った <tt>pack</tt> は、データ型と要素の順序とCPUアーキテクチャに従って一直線に詰められたバイト群である構造体に入れていきます。
詳細は関数 <a href="#struct">struct</a> を参照してください。<br />
When the first parameter is the symbol of a <a href="#struct">struct</a>
definition, <tt>pack</tt> uses the format as specified in <em>struct</em>. 
While <tt>pack</tt> with <em>str-format</em> literally packs as specified,
<tt>pack</tt> with <em>struct</em> will insert structure aligning pad-bytes
depending on data type, order of elements and CPU architecture.
Refer to the description of the <a href="#struct">struct</a> function for more detail.</p>

<p>式やリストのデータが指定されない時、フォーマットや構造体は <tt>0</tt>（ゼロ）で満たされます。<br/>
When no data expressions or lists are specified, formats or structures are filled
with <tt>0</tt>s (zeros).</p> 

<p><em>str-format</em> には、次の文字が使えます：<br/>
The following characters are used in <em>str-format</em>:</em>:
</p>

<table  summary="format characters">
<tr align="left"><th>format</th><th>description</th></tr>

<tr>
<td WIDTH="20%"><tt>c </tt></td>

<td WIDTH="80%">a signed 8-bit number</td>
</tr>

<tr>
<td><tt>b </tt></td>
<td>an unsigned 8-bit number</td>
</tr>

<tr>
<td><tt>d </tt></td>
<td>a signed 16-bit short number</td>
</tr>

<tr>
<td><tt>u </tt></td>
<td>an unsigned 16-bit short number</td>
</tr>

<tr>
<td><tt>ld</tt></td>
<td>a signed 32-bit long number</td>
</tr>

<tr>
<td><tt>lu</tt></td>
<td>an unsigned 32-bit long number</td>
</tr>

<tr>
<td><tt>Ld</tt></td>
<td>a signed 64-bit long number</td>
</tr>

<tr>
<td><tt>Lu</tt></td>
<td>an unsigned 64-bit long number</td>
</tr>

<tr>
<td><tt>f </tt></td>
<td>a float in 32-bit representation</td>
</tr>

<tr>
<td><tt>lf</tt></td>
<td>a double float in 64-bit representation</td>
</tr>

<tr>
<td><tt>sn</tt></td>
<td>a string of <em>n</em> null padded ASCII characters</td>
</tr>

<tr>
<td><tt>nn</tt></td>
<td><em>n</em> null characters</td>
</tr>

<tr>
<td><tt>&gt;</tt></td>

<td>switch to big endian byte order</td>
</tr>

<tr>
<td><tt>&lt;</tt></td>
<td>switch to little endian byte order</td>
</tr>

</table><br/>

<p>浮動小数点を <tt>b</tt>、<tt>c</tt>、<tt>d</tt>、<tt>ld</tt>、<tt>lu</tt> フォーマットで渡された時、<tt>pack</tt> は全て整数に変換します。
同様に <tt>f</tt> と <tt>lf</tt> で渡された時、整数を浮動小数点に変換します。<br />
<tt>pack</tt> will convert all floats into integers 
when passed to <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, <tt>ld</tt>,
or <tt>lu</tt> formats.
It will also convert integers into floats
when passing them to <tt>f</tt> and <tt>lf</tt> formats.
</p>

<!-- example -->

<pre>
(pack "c c c" 65 66 67)  <span class='arw'>&rarr;</span> "ABC"
(unpack "c c c" "ABC")   <span class='arw'>&rarr;</span> (65 66 67)

(pack "c c c" 0 1 2)             <span class='arw'>&rarr;</span> "\000\001\002"
(unpack "c c c" "\000\001\002")  <span class='arw'>&rarr;</span> (0 1 2)

(set 's (pack "c d u" 10 12345 56789))
(unpack "c d u" s)  <span class='arw'>&rarr;</span> (10 12345 56789)

(set 's (pack "s10 f" "result" 1.23))
(unpack "s10 f" s)
<span class='arw'>&rarr;</span> ("result\000\000\000\000" 1.230000019)

(pack "n10") <span class='arw'>&rarr;</span> "\000\000\000\000\000\000\000\000\000\000"

(set 's (pack "s3 lf" "result" 1.23))
(unpack "s3 f" s)  <span class='arw'>&rarr;</span> ("res" 1.23)

(set 's (pack "c n7 c" 11 22))
(unpack "c n7 c" s)  <span class='arw'>&rarr;</span> (11 22))

(unpack "b" (pack "b" -1.0))  <span class='arw'>&rarr;</span> (255)
(unpack "f" (pack "f" 123))   <span class='arw'>&rarr;</span> (123)
</pre>


<p>最後2行では、フォーマット指定で浮動小数点が整数に変換されるのを示しています。<br />
The last two statements show 
how floating point numbers are converted 
into integers when required by the format specification.
</p>

<p>パックする式はリストで与えることもできます：<br />
The expressions to pack can also be given in a list:</p>


<pre>
(set 'lst '("A" "B" "C"))
(set 'adr (pack "lululu" lst))
(map get-string (unpack "lululu" adr))    <span class='arw'>&rarr;</span> ("A" "B" "C")
</pre>

<p><tt>pack</tt> ではリストが直接参照されます。
そのため、 <tt>adr</tt> で渡されるポインタが有効になることに注意してください。
<tt>adr</tt> は C 言語では <tt>char * adr[]</tt> のように書け、32 ビット文字列ポインタ・アレイへの 32 ビット・ポインタを表します。64 ビット newLISP 版では 64 ビット・ポインタを表します。<br />
Note that the list should be referenced directly in <tt>pack</tt>,
so the pointers passed by <tt>adr</tt> are valid. <tt>adr</tt> would be written 
as <tt>char * adr[]</tt> in the C-programming language and represents a 32-bit pointer to an
array of 32-bit string pointers or a 64-bit pointers on the 64-bit version of newLISP.
</p>

<p>
<tt>&gt;</tt> と <tt>&lt;</tt> 指定は、
パック及びアンパック時のバイト順を<a href="http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3#.E3.83.AA.E3.83.88.E3.83.AB.E3.82.A8.E3.83.B3.E3.83.87.E3.82.A3.E3.82.A2.E3.83.B3"><em>リトル・エンディアン</em></a> や<a href="http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%87%E3%82%A3%E3%82%A2%E3%83%B3#.E3.83.93.E3.83.83.E3.82.B0.E3.82.A8.E3.83.B3.E3.83.87.E3.82.A3.E3.82.A2.E3.83.B3"><em>ビッグ・エンディアン</em></a> に切り替えるために使えます：<br />
The <tt>&gt;</tt> and <tt>&lt;</tt> specifiers 
can be used to switch between <em>little endian</em> 
and <em>big endian</em> byte order 
when packing or unpacking:
</p>


<pre>
(pack "d" 1)   <span class='arw'>&rarr;</span> "\001\000"  ;; on little endian CPU
(pack "&gt;d" 1)  <span class='arw'>&rarr;</span> "\000\001"  ;; force big endian

(pack "ld" 1)   <span class='arw'>&rarr;</span> "\001\000\000\000" ;; on little endian CPU
(pack "&lt;ld" 1)  <span class='arw'>&rarr;</span> "\000\000\000\001" ;; force big endian

(pack "&gt;u &lt;u" 1 1) <span class='arw'>&rarr;</span> "\000\001\001\000" ;; switch twice
</pre>


<p>
バイト順の切り替えは、16ビット長、32ビット長、64ビット長の数値フォーマットに影響します。<br />
Switching the byte order will affect all number formats with 16-,
32-, or 64-bit sizes.
</p>

<p>パックとアンパックのフォーマットが同じである必要はありません：<br />
The pack and unpack format need not be the same:
</p>

<pre>
(set 's (pack "s3" "ABC"))
(unpack "c c c" s)  <span class='arw'>&rarr;</span> (65 66 67)
</pre>

<p>例では、フォーマット指定子間にスペースを入れています。
これは要求されませんが、可読性を良くします。<br />
The examples show spaces between the format specifiers.
These are not required but can be used to improve readability.
</p> 


<p>UTF-8 文字列に <tt>pack</tt> と <tt>unpack</tt> を使うと：<br />
Using <tt>pack</tt> and <tt>unpack</tt> on UTF-8 strings:</p>

<pre>
(set 'txt "我能吞下玻璃而不伤身体。") 
<span class='arw'>&rarr;</span> "我能吞下玻璃而不伤身体。"
(set 'lst (unpack (dup "b" (length txt)) txt)) 
<span class='arw'>&rarr;</span> (230 136 145 232 ... 147 227 128 130)
(pack (dup "b" (length lst)) lst) 
<span class='arw'>&rarr;</span> "我能吞下玻璃而不伤身体。"
</pre>

<p>関数 <a href="#address">address</a>、<a href="#get-int">get-int</a>、<a href="#get-long">get-long</a>、<a href="#get-char">get-char</a>、<a href="#get-string">get-string</a>、<a href="#unpack">unpack</a> も見てください。<br />
See also the <a href="#address">address</a>,
<a href="#get-int">get-int</a>,
<a href="#get-long">get-long</a>,
<a href="#get-char">get-char</a>,
<a href="#get-string">get-string</a>,
and <a href="#unpack">unpack</a> functions.
</p>

<br/><br/>

<a name="parse"></a>

<h2><span class="function">parse</span></h2>
<h4>syntax: (parse <em>str-data</em> [<em>str-break</em>  [<em>regex-option</em>]])</h4>

<p><em>str-data</em> の評価結果の文字列を文字列トークンに分解し、リストにして返します。
<tt>parse</tt> は <em>str-break</em> が無い時、newLISP の内部解析ルールに従ってトークン化します。
特定の一文字列でトークン化するためには、その文字列を <em>str-break</em> に指定します。
<em>regex-option</em> 番号を指定すれば、<em>str-break</em> に正規表現パターンが使えます。<br />
Breaks the string that results from evaluating <em>str-data</em> into string tokens,
which are then returned in a list.
When no <em>str-break</em> is given,
<tt>parse</tt> tokenizes according to newLISP's internal parsing rules.
A string may be specified in <em>str-break</em> for tokenizing only at the occurrence of a string.
If an <em>regex-option</em> number is specified,
a regular expression pattern may be used in <em>str-break</em>.
</p>

<p><em>str-break</em> が指定されない時、トークンの最大サイズは引用文字列なら2048、識別子なら256です。
この場合、newLISP は newLISP ソース解析時と同じ速さでトークン化します。
<em>str-break</em> が指定された時のトークンの長さには、制限がありません。
文字列 <em>str-data</em> を文字列 <em>str-break</em> で分けるために、違うアルゴリズムが使われるからです。<br />
When <em>str-break</em> is not specified,
the maximum token size is 2048 for quoted strings and 256 for identifiers.
In this case,
newLISP uses the same faster tokenizer it uses for parsing newLISP source.
If <em>str-break</em> is specified,
there is no limitation on the length of tokens.
A different algorithm is used that splits the source string <em>str-data</em> at the string in <em>str-break</em>.
</p>

<!-- example -->

<pre>
; no break string specified
(parse "hello how are you")     <span class='arw'>&rarr;</span> ("hello" "how" "are" "you")

; strings break after spaces, parentheses, commas, colons and numbers. 
; Spaces and the colon are swollowed
(parse "weight is 10lbs")       <span class='arw'>&rarr;</span>
(parse "one:two:three" ":")     <span class='arw'>&rarr;</span> ("one" "two" "three")

;; specifying a break string
(parse "one--two--three" "--")  <span class='arw'>&rarr;</span> ("one" "two" "three")

; a regex option causes regex parsing
(parse "one-two--three---four" "-+" 0) 
<span class='arw'>&rarr;</span> ("one" "two" "three" "four")

(parse "hello regular   expression 1, 2, 3" {,\s*|\s+} 0)
<span class='arw'>&rarr;</span> ("hello" "regular" "expression" "1" "2" "3")
</pre>


<p>最後の二つの例は、デフォルトのオプション <tt>0</tt>（ゼロ）で文字列を分解する正規表現を示しています。
<tt>{</tt> と <tt>}</tt> (左と右の波括弧) の代わりに、ダブルクォートをパターン境界に使うことができます。
その場合は、パターン内に二重のバックスラッシュ（訳注：日本語環境では円記号 &yen; ）を使用する必要があります。 
最後のパターンは、CSV（カンマ区切り）ファイルの解析に使えます。
正規表現のオプション番号は <a href="#regex">regex</a> で見てください。<br />
The last two examples show a regular expression as the break string 
with the default option <tt>0</tt> (zero).  Instead of 
<tt>{</tt> and <tt>}</tt> (left and right curly brackets), double 
quotes can be used to limit the pattern.  In this case, double 
backslashes must be used inside the pattern.  The last pattern could 
be used for parsing  CSV (Comma Separated Values) files.  For the regular expression option 
numbers, see <a href="#regex">regex</a>.</p>

<p>
<tt>parse</tt> は、 <ruby>分離子<rp>（</rp><rt>セパレータ</rt><rp>）</rp></ruby>周りの空フィールドを空文字列として返します：<br />
<tt>parse</tt> will return empty fields 
around separators 
as empty strings:
</p>


<pre>
; empty fields around separators returned as empty strings
(parse "1,2,3," ",") <span class='arw'>&rarr;</span> ("1" "2" "3" "")
(parse "1,,,4" ",")  <span class='arw'>&rarr;</span> ("1" "" "" "4")
(parse "," ",")      <span class='arw'>&rarr;</span> ("" "")

(parse "")      <span class='arw'>&rarr;</span> ()
(parse "" " ")  <span class='arw'>&rarr;</span> ()
</pre>


<p>空フィールドを持つレコードの解析時に、この振る舞いが必要になります。<br />
This behavior is needed 
when parsing records 
with empty fields.
</p>

<p>空文字列の解析では、結果は常に空リストになります。<br />
Parsing an empty string 
will always result 
in an empty list.
</p>

<p>文字列分解用関数 <a href="#regex">regex</a> や正規表現の使える関数 <a href="#directory">directory</a>、<a href="#find">find</a>、<a href="#find-all">find-all</a>、<a href="#regex">regex</a>、<a href="#replace">replace</a>、<a href="#search">search</a> も見てください。<br />
Use the <a href="#regex">regex</a> function 
to break strings up 
and the <a href="#directory">directory</a>, 
<a href="#find">find</a>, 
<a href="#find-all">find-all</a>,
<a href="#regex">regex</a>, 
<a href="#replace">replace</a>, 
and <a href="#search">search</a> functions 
for using regular expressions.
</p>

<br/><br/>


<a name="peek"></a>
<h2><span class="function">peek</span></h2>
<h4>syntax: (peek <em>int-handle</em>)</h4>

<p>ファイル<ruby>記述子<rp>（</rp><rt>デスクリプタ</rt><rp>）</rp></ruby>で読み取り可能なバイト数を返します。
ファイル<ruby>記述子<rp>（</rp><rt>デスクリプタ</rt><rp>）</rp></ruby>が無効なら <tt>nil</tt> を返します。
<tt>peek</tt> は <tt>stdin</tt> のチェックにも使えます。
この関数は Unix ライク・オペレーティング・システム上でのみ使えます。<br />
Returns the number of bytes ready to be read on a file descriptor;
otherwise,
it returns <tt>nil</tt> if the file descriptor is invalid.
<tt>peek</tt> can also be used to check <tt>stdin</tt>.
This function is only available on Unix-like operating systems.
</p>

<!-- example -->

<pre>
(peek 0)  ; check # of bytes ready on stdin
</pre>


<p>ネットワーク・ソケットのチェックや利用可能なバイト数には、関数 <a href="#net-peek">net-peek</a> を使ってください。
Uinx システムでは、<a href="#net-peek">net-peek</a> がファイル<ruby>記述子<rp>（</rp><rt>デスクリプタ</rt><rp>）</rp></ruby>のチェックに使えます。
違いは、<a href="#net-peek">net-peek</a> が <a href="#net-error">net-error</a> もセットすることです。<br />
Use the <a href="#net-peek">net-peek</a> function 
to check for network sockets, 
or for the number of available bytes on them. 
On Unix systems, 
<a href="#net-peek">net-peek</a> can be used 
to check file descriptors. 
The difference is that 
<a href="#net-peek">net-peek</a> also sets 
<a href="#net-error">net-error</a>.
</p>

<br/><br/>

<a name="pipe"></a>
<h2><span class="function">pipe</span></h2>
<h4>syntax: (pipe)</h4>

<p>内部通信用パイプを作成し、<tt>read</tt> と <tt>write</tt> 用ハンドルをリストにして返します。<br />
Creates an inter-process communications pipe and returns the 
<tt>read</tt> and <tt>write</tt> handles to it within a list.
</p>

<!-- example -->

<pre>
(pipe)  <span class='arw'>&rarr;</span> (3 4)  ; 3 for read, 4 for writing
</pre>


<p>パイプ・ハンドルは、<a href="#process"> process</a> で起動した子プロセスや内部プロセス通信用の <a href="#fork">fork</a> へ渡されます。<br />
The pipe handles can be passed to a child process launched via 
   <a href="#process"> process</a> or to <a href="#fork">fork</a> for inter-process communications.
</p>

<p>パイプは、書き込みに関してはブロックしませんが、読み取りの際は読み取り可能になるまでブロックすることに注意してください。
<a href="#read-line">read-line</a> は、改行文字を受け取るまでブロックします。
<a href="#read"> read</a> は、全プロセスで閉じられた書き込み終了を持っていないパイプで読み取り可能な文字数が指定されたものより少ない時、ブロックします。<br />
Note that the pipe does not block when being written to,
but it does block reading until bytes are available.
A <a href="#read-line">read-line</a> blocks until a newline character is received.
A <a href="#read">read</a> blocks when fewer characters than 
specified are available from a pipe that has not had the writing end closed by all processes.
</p>

<p>要求されれば、一個以上のパイプが開かれます。<br />
More than one pipe can be opened if required.
</p>

<p>newLISP では <em>名前付きパイプ</em> も使えます。
詳細は関数 <a href="#open">open</a> を見てください。<br />
newLISP can also use <em>named pipes</em>.
See the <a href="#open">open</a> function for further information.
</p>

<br/><br/>

<a name="pmt"></a>
<h2><span class="function">pmt</span></h2>

<b>syntax: (pmt <em>num-interest</em> <em>num-periods</em> <em>num-principal</em> 
[<em>num-future-value</em> [<em>int-type</em>]])</b>

<p>固定金利 <em>num-interest</em> と支払回数 <em>num-periods</em> 回で（訳注： <em>num-principal</em> のローンを組む時の）一回あたりのローン支払い額を計算します。
<em>num-future-value</em> は最後のローン額です（普通は <tt>0.0</tt>）。
期間の終わりに支払うなら <em>int-type</em> を <tt>0</tt>（ゼロ）にするか省略し、期間の最初に支払うなら <em>int-type</em> を 1 にします。<br />
Calculates the payment for a loan based on a constant interest of <em>num-interest</em> 
and constant payments over <em>num-periods</em> of time.
<em>num-future-value</em> is the value of the loan at the end (typically <tt>0.0</tt>).
If payment is at the end of the period, <em>int-type</em> is <tt>0</tt> (zero) 
or <em>int-type</em> is omitted; for payment at the beginning of each period, 
<em>int-type</em> is 1.</p>


<!-- example -->

<pre>
(pmt (div 0.07 12) 240 100000)  <span class='arw'>&rarr;</span> -775.2989356
</pre>


<p>上記例では、年利 7％で $100,000 のローンを組むと毎回の支払額が $775.30 になると計算されます。
20 年の月払いで計算しています(20 * 12 = 240 ヶ月)。
これが示しているのは、借金の典型的な支払い方法の計算です。<br />
The above example calculates a payment of $775.30 for a loan of $100,000 at a yearly interest rate of 7 percent.
It is calculated monthly and paid over 20 years (20 * 12 = 240 monthly periods).
This illustrates the typical way payment is calculated for mortgages.
</p>

<p>関数 <a href="#fv">fv</a>、<a href="#irr">irr</a>、<a href="#nper">nper</a>、<a href="#npv">npv</a>、<a href="#pv">pv</a> も見てください。<br />
See also the <a href="#fv">fv</a>,
<a href="#irr">irr</a>,
<a href="#nper">nper</a>,
<a href="#npv">npv</a>,
and <a href="#pv">pv</a> functions.
</p>

<br/><br/>

<a name="pop"></a>
<h2><span class="function">pop</span>&nbsp;<a href="#destructive">!</a>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (pop <em>list</em> [<em>int-index-1</em> [<em>int-index-2</em> ... ]])<br/>
syntax: (pop <em>list</em> [<em>list-indexes</em>])<br/><br/>

syntax: (pop <em>str</em> [<em>int-index</em> [<em>int-length</em>]])</h4>

<p><tt>pop</tt> を使うと、リストから要素を、あるいは文字列から文字を取り去ることができます。<br />
Using <tt>pop</tt>, elements can be removed from lists and characters from strings.</p>

<p>第一構文の <tt>pop</tt> は、<em>list</em> を評価することで得られたリストから要素を抜き出します。
第二パラメータが存在するなら、<em>int-index</em> の要素を抜き出します。
<a href="#indexing">文字列、リスト、アレイの要素指定</a> も見てください。<br />
In the first syntax, <tt>pop</tt> extracts an element from the list found 
by evaluating <em>list</em>.
If a second parameter is present,
the element at <em>int-index</em> is extracted and returned.
See also <a href="#indexing">Indexing elements of strings and lists</a>.
</p>

<p>第二の型では、インデックスをリスト <em>list-indexes</em> で指定します。
この方法により、インデックスのリストを返す <a href="#ref">ref</a> や <a href="#ref-all">ref-all</a> と一緒に <tt>pop</tt> が簡単に使えます。<br />
In the second version,
indices are specified in the list <em>list-indexes</em>.
This way,
<tt>pop</tt> works easily together with <a href="#ref">ref</a>
and <a href="#ref-all">ref-all</a>,
which return lists of indices.
</p> 

<p><tt>pop</tt> は目標リストの内容を変更します。
抜き出された要素が返ります。<br />
<tt>pop</tt> changes the contents of the target list.
The popped element is returned.
</p>

<!-- example -->

<pre>
(set 'pList '((f g) a b c "hello" d e 10))

(pop pList)  <span class='arw'>&rarr;</span> (f g)
(pop pList)  <span class='arw'>&rarr;</span> a
pList        <span class='arw'>&rarr;</span> (b c "hello" d e 10)

(pop pList 3)    <span class='arw'>&rarr;</span> d
(pop pList -1)  <span class='arw'>&rarr;</span> 10
pList            <span class='arw'>&rarr;</span> (b c "hello" e)

(pop pList -1)  <span class='arw'>&rarr;</span> e
pList           <span class='arw'>&rarr;</span> (b c "hello")

(pop pList -2)  <span class='arw'>&rarr;</span> c
pList           <span class='arw'>&rarr;</span> (b "hello")

(set 'pList '(a 2 (x y (p q) z)))

(pop pList -1 2 0)  <span class='arw'>&rarr;</span> p

;; use indices in a list
(set 'pList '(a b (c d () e)))

(push 'x pList '(2 2 0))  
<span class='arw'>&rarr;</span> (a b (c d (x) e))

pList
<span class='arw'>&rarr;</span> (a b (c d (x) e))

(ref 'x pList)  <span class='arw'>&rarr;</span> (2 2 0)

(pop pList '(2 2 0))  <span class='arw'>&rarr;</span> x
</pre>


<p><tt>pop</tt> は、一つのインデックスで文字列に使うこともできます（訳注：つまり、インデックス・リストは文字列には使えません）：<br />
<tt>pop</tt> can also be used on strings with one index:</p>

<!-- example -->

<pre>
;; use pop on strings

(set 'str "newLISP")

(pop str -4 4)  <span class='arw'>&rarr;</span> "LISP"

str  <span class='arw'>&rarr;</span> "new"

(pop str 1)  <span class='arw'>&rarr;</span> "e"

str  <span class='arw'>&rarr;</span> "nw"

(set 'str "x")

(pop str)  <span class='arw'>&rarr;</span> "x"
(pop str)  <span class='arw'>&rarr;</span> ""
</pre>


<p>空文字列からの抜き出しは、空文字列を返します。<br />
Popping an empty string will return an empty string.</p>

<p><tt>pop</tt> と逆の操作をする関数 <a href="#push">push</a> も見てください。<br />
See also the <a href="#push">push</a> function, the inverse operation to <tt>pop</tt>.
</p>

<br/><br/>

<a name="pop-assoc"></a>
<h2><span class="function">pop-assoc</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (pop-assoc <em>exp-key</em> <em>list-assoc</em>)<br/>
syntax: (pop-assoc <em>list-keys</em> <em>list-assoc</em>)</h4>

<p><em>list-assoc</em> の連想リスト から <em>exp-key</em> のキーで参照された連想を抜き出し、抜き出した式を返します。<br />
Removes an association referred to by the key in <em>exp-key</em> from the association 
list in <em>list-assoc</em> and returns the popped expression.</p>

<!-- example -->

<pre>
;; simple associations

(set 'L '((a 1) (b 2) (c 3)))
(pop-assoc 'b L) <span class='arw'>&rarr;</span> (b 2)
L <span class='arw'>&rarr;</span> ((a 1) (c 3))

;; nested associations

(set 'L '((a (b 1) (c (d 2)))))
(pop-assoc 'a L) <span class='arw'>&rarr;</span> (a (b 1) (c (d 2)))
L <span class='arw'>&rarr;</span> ()

(set 'L '((a (b 1) (c (d 2)))))
(pop-assoc '(a b) L)  <span class='arw'>&rarr;</span> (b 1)
L <span class='arw'>&rarr;</span>  ((a (c (d 2))))

(set 'L '((a (b 1) (c (d 2)))))
(pop-assoc '(a c) L)  <span class='arw'>&rarr;</span> (c (d 2))
L <span class='arw'>&rarr;</span> ((a (b 1))))
</pre>


<p>連想を検索する <a href="#assoc">assoc</a> と連想リストを変更する <a href="#setf">setf</a> も見てください。<br />
See also <a href="#assoc">assoc</a> for retrieving associations and <a href="#setf">setf</a> 
for modifying association lists.</p>

<br/><br/>

<a name="post-url"></a>
<h2><span class="function">post-url</span></h2>
<h4>syntax: (post-url <em>str-url</em> <em>str-content</em> [<em>str-content-type</em> [<em>str-option</em>] [<em>int-timeout</em> [ <em>str-header</em>]]])</h4>

<p><em>str-url</em> の URL に HTTP POST <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を送ります。
POST<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby> は、ウェブ入力フォームで収集した情報をウェブ・サイトに投稿するために使われます。
多くの場合、関数 <tt>post-url</tt> は HTMLフォームで集めた情報をサーバーに送る時のウェブ・ブラウザの振る舞いに似ていますが、ファイルのアップロードにも使えます（HTTPレファレンスを見てください）。
関数はサーバーから戻ってきたページを文字列で返します。<br />
Sends an HTTP POST request to the URL in <em>str-url</em>.
POST requests are used to post information collected from web entry forms to a web site.
Most of the time,
the function <tt>post-url</tt> mimics what a web browser would do when sending information 
collected in an HTML form to a server,
but it can also be used to upload files (see an HTTP reference).
The function returns the page returned from the server in a string.
</p>

<p><tt>post-url</tt> はエラーに出会うと <tt>ERR:</tt> で始まるエラーの文字列記述を返します。<br />
When <tt>post-url</tt> encounters an error,
it returns a string description of the error beginning with <tt>ERR:</tt>.
</p>

<p>最後のパラメータ <em>int-timeout</em> は、ミリ秒で指定するタイムアウト値です。
タイムアウトに達する前にホストからの<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>が受信されないと、文字列 <tt>ERR:timeout</tt> を返します。<br />
The last parameter,
<em>int-timeout</em>,
is for an optional timeout value,
which is specified in milliseconds.
When no response from the host is received before the timeout has expired,
the string <tt>ERR:
timeout</tt> is returned. 
</p>
<!-- example -->

<pre>
;; specify content type
(post-url "http://somesite.com/form.pl" 
          "name=johnDoe&amp;city=New%20York" 
          "application/x-www-form-urlencoded")

;; specify content type and timeout
(post-url "http://somesite.com/form.pl" 
          "name=johnDoe&amp;city=New%20York" 
          "application/x-www-form-urlencoded" 8000)

;; assumes default content type and no timeout
(post-url "http://somesite.com/form.pl"
          "name=johnDoe&amp;city=New%20York" 
</pre>


<p>上記例は、<tt>application/x-www-form-urlencoded</tt> と呼ばれる指定フォーマットを使って、ユーザ名と都市名をアップロードします。
<tt>post-url</tt> は、ファイルやバイナリ・データのようなタイプの内容を投稿するためにも使えます。
他の content-type の指定やデータ・エンコード・フォーマットについては、HTTP リファレンスを見てください。
content-type パラメータが省略された時、<tt>post-url</tt> はデフォルトの型として <tt>application/x-www-form-urlencoded</tt> を使います。<br />
The above example uploads a user name and city using a special format called 
<tt>application/x-www-form-urlencoded</tt>.
<tt>post-url</tt> can be used to post other content types such as files or binary data.
See an HTTP reference for other content-type specifications and data encoding formats.
When the content-type parameter is omitted,
<tt>post-url</tt> assumes <tt>application/x-www-form-urlencoded</tt> as the default content type.
</p>

<h3>Additional parameters（追加のパラメータ）</h3>
<p><em>str-content-type</em> を指定する時は、戻り内容に <a href="#get-url">get-url</a> と同じオプションを取ることができます。
<em>int-timeout</em> オプションを指定するなら、カスタム・ヘッダ・オプション <em>str-header</em> も同様に指定できます。
全オプションの詳細は、関数 <a href="#get-url">get-url</a> を見てください。<br />
When <em>str-content-type</em> is specified, the optional <em>str-option</em> 
can take the same options as <a href="#get-url">get-url</a> for the returned 
content.  If the <em>int-timeout</em> option is specified, the custom header 
option <em>str-header</em> can be specified, as well. See the function 
<a href="#get-url">get-url</a> for details on all options.
</p>

<p>関数 <a href="#get-url">get-url</a> と <a href="#put-url">put-url</a> も見てください。<br />
See also the <a href="#get-url">get-url</a> and <a href="#put-url">put-url</a> functions.
</p>

<br/><br/>

<a name="pow"></a>
<h2><span class="function">pow</span></h2>
<h4>syntax: (pow <em>num-1</em> <em>num-2 </em> [<em>num-3</em> ... ])<br/>
syntax: (pow <em>num-1</em>)</h4>

<p><em>num-1</em> の <em>num-2</em> 乗を計算し、続くべき指数のべき乗を計算します。<br />
Calculates <em>num-1</em> to the power of <em>num-2</em> and so forth.
</p>

<!-- example -->

<pre>
(pow 100 2)      <span class='arw'>&rarr;</span> 10000
(pow 100 0.5)    <span class='arw'>&rarr;</span> 10
(pow 100 0.5 3)  <span class='arw'>&rarr;</span> 1000

(pow 3)  <span class='arw'>&rarr;</span> 9
</pre>


<p><em>num-1</em> のみが引数の時、<tt>pow</tt> はべき指数を 2 にします。<br />
When <em>num-1</em> is the only argument,
<tt>pow</tt> assumes 2 for the exponent.
</p>

<br/><br/>

<a name="prefix"></a>
<h2><span class="function">prefix</span></h2>
<h4>syntax: (prefix <em>sym</em>)</h4>

<p><em>sym</em> のシンボルのコンテキストを返します：<br />
Returns the context of a symbol in <em>sym</em>:</p>


<!-- example -->

<pre>
(setf s 'Foo:bar)      <span class='arw'>&rarr;</span> Foo:bar
(prefix s)             <span class='arw'>&rarr;</span> Foo
(context? (prefix s))  <span class='arw'>&rarr;</span> true

(term s)                         <span class='arw'>&rarr;</span> "bar"
(= s (sym (term s) (prefix s)))  <span class='arw'>&rarr;</span> true

<b>&gt;</b>(context (prefix s))   ; switches to context Foo
<b>Foo</b>
<b>Foo&gt;</b>
</pre>

<p>シンボルの名前部分を（訳注：文字列で）取り出す <a href="#term">term</a> も見てください。<br />
See also <a href="#term">term</a> to extract the term part of
a symbol.</p>

<br/><br/>

<a name="pretty-print"></a>

<h2><span class="function">pretty-print</span></h2>
<h4>syntax: (pretty-print [<em>int-length</em> [<em>str-tab</em> [<em>str-fp-format</em>]])</h4>

<p><a href="#print">print</a>、<a href="#save">save</a>、<a href="#source">source</a> の出力やインターラクティブ・コンソールへの整形出力を再設定します。
最初のパラメータ <em>int-length</em> は行の長さの最大を指定し、<em>str-tab</em> は行のインデントに用いる文字列を指定します。
第三パラメータ <em>str-fp-format</em> は、浮動小数点数出力時のデフォルトのフォーマットを記述します。
全てのパラメータはオプションです。
<tt>pretty-print</tt> は現行の設定内容を返すか、パラメータが指定された時に新規設定内容を返します。<br />
Reformats expressions for <a href="#print">print</a>,
<a href="#save">save</a>,
or <a href="#source">source</a> and when printing in an interactive console.
The first parameter, <em>int-length</em>, specifies the maximum line length,
and <em>str-tab</em> specifies the string used to indent lines. The third
parameter <em>str-fp-format</em> describes the default format for printing
floating point numbers.  All parameters are optional.  <tt>pretty-print</tt> 
returns the current settings or the new settings when parameters are specified.
</p>

<!-- example -->

<pre>
(pretty-print)  <span class='arw'>&rarr;</span> (80 " " "&#037;1.15g")  ; default setting

(pretty-print 90 "\t")  <span class='arw'>&rarr;</span> (90 "\t" "&#037;1.15g")

(pretty-print 100)  <span class='arw'>&rarr;</span> (100 "\t" "&#037;1.15g") 

(sin 1)    <span class='arw'>&rarr;</span> 0.841470984807897
(pretty-print 80 " " "&#37;1.3f")
(sin 1)    <span class='arw'>&rarr;</span> 0.841

(set 'x 0.0)
x   <span class='arw'>&rarr;</span> 0.000
</pre>


<p>最初の例では、デフォルトの設定内容である行の最大文字数 80、<tt>space</tt> のインデント文字を報告します。
二番目の例では、行の最大 90 とインデント文字に TAB 文字を指定しています。
三番目の例では、行の長さのみを変えています。
最後の例では、浮動小数点数のデフォルトのフォーマットを変更しています。
これは、少数部を持たない浮動小数点数をフォーマット指定せずに出力する時でも、数値を浮動小数点数として認識できようにしておきたい時に役立ちます。
カスタム・フォーマット無しでは、（訳注：上記例の）<tt>x</tt> は浮動小数点数だとは分からない <tt>0</tt> として出力されます。
フォーマット指定されていない浮動小数点数を出力する全ての状況が影響を受けます。<br />
The first example reports the default settings of 80 for the maximum line length and a 
<tt>space</tt> character for indenting. The second example changes the line length to 
90 and the indent to a TAB character. The third example changes the line length only.
The last example changes the default format for floating point numbers. This is useful
when printing unformatted floating point numbers without fractional parts, and these 
numbers should still be recognizable as floating point numbers. Without the custom
format, <tt>x</tt> would be printed as <tt>0</tt> indistinguishable from floating
point number. All situations where unformatted floating point numbers are printed,
are affected.</p>

<p><tt>pretty-print</tt> は、出力の行の形式が崩れるのを防止するためには使えないことに注意してください。
この整形出力を完全に抑制したい時は、次のように関数 <a href="#string">string</a> を使ってください。式が整形されない生の文字列に変換されます：<br />
Note that <tt>pretty-print</tt> cannot be used to prevent line breaks from being printed.
To completely suppress pretty printing, use the function <a href="#string">string</a> 
to convert the expression to a raw unformatted string as follows:</p>

<!-- example -->

<pre>
;; print without formatting

(print (string my-expression))	
</pre>

<br/><br/>

<a name="primitivep"></a>
<h2><span class="function">primitive?</span></h2>
<h4>syntax: (primitive? <em>exp</em>)</h4>

<p><em>exp</em> を評価して、組込シンボル（訳注：つまり、組込関数）かどうかをテストし、結果次第で <tt>true</tt> か <tt>nil</tt> を返します。
全ての組込関数と <a href="#import">import</a> で作られた関数も、組込関数として評価されます。<br />
Evaluates and tests if <em>exp</em> is a primitive symbol and returns
<tt>true</tt> or <tt>nil</tt> depending on the result. All built-in
functions and functions created using <a href="#import">import</a>
are primitives.
</p>

<!-- example -->

<pre>
(set 'var define)
(primitive? var)  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="print"></a>
<h2><span class="function">print</span></h2>
<h4>syntax: (print <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p><em>exp-1</em> 以下を評価して、カレント I/O デバイスに出力します。
デフォルトはコンソール・ウィンドウです。
異なる I/O デバイスへの指定方法の詳細は、組込関数 <a href="#device">device</a> を見てください。<br />
Evaluates and prints <em>exp-1</em>&mdash;
to the current I/O device,
which defaults to the console window.
See the built-in function <a href="#device">device</a> for details on how to specify a different I/O device.
</p>

<p>リスト式は、開いた括弧の入れ子レベルでインデントされます。<br />
List expressions are indented by the nesting levels of their opening parentheses.
</p>

<p>いくつかの特殊文字は、エスケープ文字 <tt>\</tt>（訳注：日本語環境では円記号 &yen; ）を使って文字列中に含められます：<br />
Several special characters may be included in strings encoded with the escape character <tt>\</tt>:
</p>
 
<table  summary="escape characters in print">
<tr align="left" valign="bottom"><th>character</th><th>description</th></tr>

<tr>
<td><tt>\n</tt></td>
<td>ライン・フィード文字 (ASCII 10)<br />the line-feed character (ASCII 10)</td>

</tr>

<tr>
<td><tt>\r</tt></td>
<td>キャリッジ・リターン文字 (ASCII 13)<br />the carriage-return character (ASCII 13)</td>
</tr>

<tr>
<td><tt>\t</tt></td>
<td>タブ文字 (ASCII 9)<br />the tab character (ASCII 9)</td>
</tr>

<tr>

<td><tt>\nnn</tt></td>
<td>十進数のアスキー・コードで、nnn は 000 から 255 です<br />where <tt>nnn</tt> is a decimal ASCII code between 000 and 255</td>
</tr>

<tr>
<td><tt>\xnn</tt></td>
<td>十六進数コードで、nn は 00 から FF です<br />where <tt>nn</tt> is a hexadecimal ASCII code between 00 and FF</td>
</tr>

</table><br/>

<br/>
<!-- example -->

<pre>
(print (set 'res (+ 1 2 3))) 
(print "the result is" res "\n")

"\065\066\067"  <span class='arw'>&rarr;</span> "ABC"
</pre>


<p>出力の終わりを改行にしたい時は <a href="#println">println</a> を使ってください。<br />
	To finish printing with a line-feed,
	use <a href="#println">println</a>.
</p>

<br/><br/>

<a name="println"></a>
<h2><span class="function">println</span></h2>
<h4>syntax: (println <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p><em>exp-1</em> 以下を評価して、カレント I/O デバイスに出力します。
デフォルトはコンソール・ウィンドウです。
改行が最後に出力されます。
異なる I/O デバイスの指定方法の詳細は、組込関数 <a href="#device">device</a> を見てください。
<tt>println</tt> は <a href="#print">print</a> と全く同じに作用しますが、最後に改行文字を出します。<br />
	Evaluates and prints <em>exp-1</em>&mdash;
	to the current I/O device,
	which defaults to the console window.
	A line-feed is printed at the end.
	See the built-in function <a href="#device">device</a> for details on how to specify a different I/O device.
	<tt>println</tt> works exactly like <a href="#print">print</a> but emits a line-feed character at the end.
</p>

<p>関数 <a href="#write-line">write-line</a> と <a href="#print">print</a> も見てください。<br />
See also the <a href="#write-line">write-line</a> and <a href="#print">print</a> functions.
</p>

<br/><br/>

<a name="prob-chi2"></a>
<h2><span class="function">prob-chi2</span></h2>
<h4>syntax: (prob-chi2 <em>num-chi2</em> <em>int-df</em>)</h4>

<p>帰無仮説下、自由度 <em>num-df</em> 以上で観測されたカイ二乗統計値 <em>num-chi2</em> の確率（訳注:危険率）を返します（訳注：EXCELの CHIDIST(x,自由度)に相当）。
<tt>prob-chi2</tt> は、不完全ガンマ関数 <a href="#gammai">gammai</a> から計算されます（訳注：EXCELの CHIDIST(x, 自由度)に相当）。<br />
Returns the probability of an observed <em>Chi&sup2;</em> statistic in <em>num-chi2</em> 
with <em>num-df</em> degrees of freedom to be equal or greater under the null hypothesis.
<tt>prob-chi2</tt> is derived from the incomplete Gamma function <a HREF="#gammai">gammai</a>.
</p>

<!-- example -->

<pre>
(prob-chi2 10 6)  <span class='arw'>&rarr;</span> 0.1246520195
</pre>


<p>逆関数 <a href="#crit-chi2">crit-chi2</a> も見てください。<br />
	See also the inverse function <a href="#crit-chi2">crit-chi2</a>.
</p> 

<br/><br/>

<a name="prob-f"></a>
<h2><span class="function">prob-f</span></h2>
<h4>syntax: (prob-f <em>num-f</em> <em>int-df1</em> <em>int-df2</em>)</h4>

<p>帰無仮説下、自由度 <em>int-df1</em>、<em>int-df2</em> 以上で観測された <em>F</em> 統計値 <em>num-f</em> の確率（訳注:危険率）を返します（訳注：EXCELの FDIST(x, 自由度1, 自由度2)に相当）。<br />
Returns the probability of an observed <em>F</em> statistic in <em>num-f</em> 
with <em>int-df1</em> and <em>int-df2</em> degrees of freedom to be equal or greater 
under the null hypothesis.</p>

<!-- example -->

<pre>
(prob-f 2.75 10 12)  <span class='arw'>&rarr;</span> 0.0501990804
</pre>


<p>逆関数 <a href="#crit-f">crit-f</a> も見てください。<br />
See also the inverse function <a href="#crit-f">crit-f</a>.
</p> 

<br/><br/>

<a name="prob-t"></a>
<h2><span class="function">prob-t</span></h2>
<h4>syntax: (prob-t <em>num-t</em> <em>int-df1</em>)</h4>

<p>帰無仮説下、自由度 <em>int-df1</em> 以上で観測された <em>スチューデントの t</em> 統計値 <em>num-t</em> の確率（訳注:危険率）を返します（訳注：EXCELの TDIST(x,自由度,1)に相当）。<br />
Returns the probability of an observed <em>Student's t</em> statistic in <em>num-t</em> 
with <em>int-df</em> degrees of freedom to be equal or greater 
under the null hypothesis.</p>

<!-- example -->

<pre>
(prob-t 1.76 14)  <span class='arw'>&rarr;</span> 0.05011454551
</pre>


<p>逆関数 <a href="#crit-t">crit-t</a> も見てください。<br />
See also the inverse function <a href="#crit-t">crit-t</a>.
</p> 

<br/><br/>

<a name="prob-z"></a>
<h2><span class="function">prob-z</span></h2>
<h4>syntax: (prob-z <em>num-z</em>)</h4>

<p>平均値 <tt>0.0</tt>、標準偏差 <tt>1.0</tt> の正規分布において、観測値 <em>num-z</em> を超えない確率を返します（訳注：EXCELのNORMSDIST(z)に相当）。 <br />
	Returns the probability of <em>num-z</em>,
	not to exceed the observed value where <em>num-z</em> is a normal distributed 
	value with a mean of <tt>0.0</tt> and a standard deviation of <tt>1.0</tt>.
</p>

<!-- example -->

<pre>
(prob-z 0.0)  <span class='arw'>&rarr;</span> 0.5
</pre>



<p>逆関数 <a href="#crit-z">crit-z</a> も見てください。<br />
	See also the inverse function <a href="#crit-z">crit-z</a>.
</p> 

<br/><br/>

<a name="process"></a>
<h2><span class="function">process</span></h2>
<h4>syntax: (process <em>str-command</em>)<br/>
syntax: (process <em>str-command</em> <em>int-pipe-in</em> <em>int-pipe-out</em> [<em>int-win-option</em>])<br/>
syntax: (process <em>str-command</em> <em>int-pipe-in</em> <em>int-pipe-out</em> [<em>int-unix-pipe-error</em>])</h4>

<p>第一構文の <tt>process</tt> は、<em>str-command</em> で指定されたプロセスを起動し、直ちにプロセスID かプロセス生成できなかった時の <tt>nil</tt> を返します。
このプロセスは指定されたプログラムを実行しますが、<em>str-command</em> が実行できなかった時は直ちに無くなります。<br />
In the first syntax,
<tt>process</tt> launches a  process specified in <em>str-command</em> and immediately 
returns with a process ID or <tt>nil</tt> if a process could not be created. This 
process will execute the program specified or immediately die if <em>str-command</em> could not be executed.
</p>

<p>macOS や他の Linux では、アプリケーションやスクリプトは、フル・パス名で指定されなければなりません。
新プロセスは、OS の環境を親プロセスから受け継ぎます。<br />
On macOS and other Unixes, the application or script must be specified with its full path-name.
The new process inherits the OS environment from the parent process.</p>

<p>コマンド・ラインの引数はスペースで分けられます。
スペースを含む引数は、macOS や他の Linux ではシングル・クォートを使って囲みます。
MS Windowsではダブル・クォートを使います。
プロセスがそれ自身で終わらない場合、戻り値のプロセス ID を <a href="#destroy">destroy</a> に使って、走っているプロセスを破棄できます。<br />
Command line arguments are parsed out at spaces. Arguments containing spaces must be delimited using
single quotes on macOS and other Unixes. On MS Windows, double quotes are used. The process id returned
can be used to destroy the running process using <a href="#destroy">destroy</a>, if the process does
not exit by itself.</p>

<!-- example -->

<pre>
(process "c:/WINDOWS/system32/notepad.exe")  <span class='arw'>&rarr;</span> 1894 ; Windows
; or when in executable path
(process "notepad.exe")                      <span class='arw'>&rarr;</span> 1894 ; Windows


; find out the path of the program to start using exec, 
; if the path is not known

(process (first (exec "which xclock")))  <span class='arw'>&rarr;</span> 22607 ; on Unix
</pre>


<p>実行可能なパスが不明な時、Unix なら <tt>exec</tt> に <tt>which</tt> コマンドを使ってプログラムを開始できます。
戻り値のプロセス ID はプロセスの <a href="#destroy">destroy</a> に使えます。<br />
If the path of the executable is unknown, <tt>exec</tt> together with the Unix <tt>which</tt>
command can be used to start a program. The pid returned can be used to <a href="#destroy">destroy</a>
the process.</p>

<p>第二構文では、生成されたプロセスの標準入出力がパイプ・ハンドルにリダイレクトされます。
起動したアプリケーションの標準 I/O をパイプに再配置した時は、<a href="#write-line">write-line</a> と <a href="#read-line">read-line</a> または <a href="#write-buffer">write-buffer</a> と <a href="#read-buffer">read-buffer</a> を通して他のアプリケーションとの通信が可能になります：<br />
In the second syntax,
standard input and output of the created process can be redirected to pipe handles.
When remapping standard I/O of the launched application to a pipe,
it is possible to communicate with the other application via <a href="#write-line">write-line</a> 
and <a href="#read-line">read-line</a>  or <a href="#write">write</a> and 
<a href="#read">read</a> statements:</p>

<!-- example -->

<pre>
;; Linux/Unix
;; create pipes
(map set '(myin bcout) (pipe))
(map set '(bcin myout) (pipe))   

;; launch Unix 'bc' calculator application
(process "/usr/bin/bc" bcin bcout) <span class='arw'>&rarr;</span> 7916

(write-line myout "3 + 4")  ; bc expects a line-feed

(read-line myin)  <span class='arw'>&rarr;</span> "7"


;; bc can use bignums with arbitrary precision

(write-line myout "123456789012345 * 123456789012345\n")

(read-line myin)  <span class='arw'>&rarr;</span> "15241578753238669120562399025"

;; destroy the process
(destroy 7916)

;; MS Windows
(map set '(myin cmdout) (pipe))
(map set '(cmdin myout) (pipe))

(process "c:/Program Files/newlisp/newlisp.exe -c" cmdin cmdout)
<span class='arw'>&rarr;</span> 1284

(write-line myout "(+ 3 4)")

(read-line myin) <span class='arw'>&rarr;</span> "7"

;; destroy the process
(destroy 1284)
</pre>


<p>MS Windows 版 newLISP では、<em>int-win-option</em> の第四オプション・パラメータにアプリケーションの表示状態制御を指定できます。
このオプションのデフォルトは <tt>1</tt> で、アプリケーション・ウィンドウを表示します。
他に、非表示用の <tt>0</tt> とランチ・バーに最小化する <tt>2</tt> があります。<br />
On MS Windows versions of newLISP, a fourth optional parameter of <em>int-win-option</em> 
can be specified to control the display status of the application.
This option defaults to <tt>1</tt> for showing the application's window,
<tt>0</tt> for hiding it, and <tt>2</tt> for showing it minimized on the Windows 
launch bar.</p>

<p>MS Windows と Linux/Unix の両システムで、標準エラーはデフォルトで標準出力にリダイレクトされます。
Linux/Unix では、標準エラー出力としてオプションのパイプ・ハンドルが <em>int-unix-pipe-error</em> に定義されます。<br />
On both MS Windows and Linux/Unix systems, standard error will be redirected to 
standard out by default. On Linux/Unix, an optional pipe handle for standard 
error output can be defined in <em>int-unix-pipe-error</em>.</p>

<p>関数 <a href="#peek">peek</a> はパイプ・ハンドル上の情報のチェックに使えます：<br />
The function <a href="#peek">peek</a> can be used to check for information 
on the pipe handles:</p>


<pre>
;; create pipes
(map set '(myin bcout) (pipe))
(map set '(bcin myout) (pipe))   
(map set '(errin errout) (pipe))   

;; launch Unix 'bc' calculator application
(process "bc" bcin bcout errout)

(write myout command)

;; wait for bc sending result or error info
(while (and (= (peek myin) 0)
            (= (peek errin) 0)) (sleep 10))

(if (&gt; (peek errin) 0)
	(println (read-line errin)))
	
(if (&gt; (peek myin) 0)
	(println (read-line myin)))
</pre>


<p>全てのインターラクティブ・コンソール・アプリケーションが、標準 I/O チャンネルに再配置できるわけではありません。
一つのチャンネルのみが <em>in</em> か <em>out</em> に再配置されることがあります。
この場合、使用しないチャンネルには <tt>0</tt>（ゼロ）を指定してください。
次の宣言文は、起動したアプリケーションの出力のみを使っています：<br />
	 Not all interactive console applications 
   can have their standard I/O channels remapped.
	Sometimes only one channel,
	<em>in</em> or <em>out</em>,
	can be remapped.
	In this case,
	specify <tt>0</tt> (zero) for the unused channel.
	The following statement uses only the launched application's output:
</p>


<pre>
(process "app" 0 appout)
</pre>


<p>通常は二つのパイプが使われ、一つが子プロセスへの通信用で、もう一つが子プロセスからの通信用です。<br />
	Normally,
	two pipes are used:
	one for communications to the child process and the other one for communications from the child process.
</p>

<p>内部プロセス通信用関数 <a href="#pipe">pipe</a> と <a href="#share">share</a> 及び複数のプロセス間同期用関数 <a href="#semaphore">semaphore</a> も見てください。
newLISP プロセスを開始する別の方法である関数 <a href="#fork">fork</a> と <a href="#spawn">spawn</a> を見てください。
両方とも macOS、Linux や Unix ライク・オペレーティング・システムでのみ利用できます。<br />
See also the <a href="#pipe">pipe</a> and <a href="#share">share</a> functions for inter-process 
communications and the <a href="#semaphore">semaphore</a> function for synchronization of several processes.
See the <a href="#fork">fork</a> and <a href="#spawn">spawn</a> functions for other ways of starting 
newLISP processes. Both are only available on macOS, Linux and other Unix like operating systems.
</p>

<br/><br/>

<a name="prompt-event"></a>
<h2><span class="function">prompt-event</span></h2>
<h4>syntax: (prompt-event <em>sym-event-handler</em> | <em>func-event-handler</em>)<br/>
syntax: (prompt-event nil)</h4>

<p>インターラクティブな newLISP シェルを改良します。
<em>sym-event-handler</em> または <em>func-event-handler</em> は、ユーザ定義関数のシンボルかラムダ関数のどちらかです：<br />
Refines the prompt as shown in the interactive newLISP shell.
The <em>sym-event-handler</em> or <em>func-event-handler</em>
is either a symbol of a user-defined function or a lambda expression:</p>

<p><tt>prompt-event</tt> を元の状態にリセットするには、第二構文を使ってください。<br />
To reset <tt>prompt-event</tt> to the original state, use the second syntax.</p>

<pre>
<b>></b> (prompt-event (fn (ctx) (string ctx ":" (real-path) "$ ")))
<b>$prompt-event</b>
<b>MAIN:/Users/newlisp$</b> (+ 3 4)
<b>7</b>
<b>MAIN:/Users/newlisp$</b>
</pre>

<p><tt>prompt-event</tt> コードが呼ばれる時の現コンテキストが、関数のパラメータとして渡されまています。
コンピュータの出力は太文字で示されています。<br />
The current context before calling the <tt>prompt-event</tt> code is passed as a 
parameter to the function. Computer output is shown in bold.</p>

<p>この例は、現コンテキストに続く <tt>&gt;</tt> プロンプトがドル・シンボルとディレクトリ名に続くコロン <tt>:</tt> になっています。
フル・カスタムなシェル、または、カスタム・コマンド・インターラプタを作成するために、この関数と <a href="#command-event">command-event</a> を一緒に使うことができます。<br />
The example redefines the <tt>&gt;</tt> prompt to be the current context followed
by a colon <tt>:</tt>, followed by the directory name, followed by the dollar symbol. 
Together with the <a href="#command-event">command-event</a> function this can be 
used to create fully customized shells or custom command interpreters.</p>

<p><tt>prompt-event</tt> の関数は、最大63文字の文字列を返さなくてはなりません。
文字列が返らなければ、プロンプトが変化しないからです。<br />
The function in <tt>prompt-event</tt> must return a string of 63 characters maximum. 
Not returning a string will leave the prompt unchanged.</p>

<br/><br/>

<a name="protectedp"></a>
<h2><span class="function">protected?</span></h2>

<h4>syntax: (protected? <em>sym</em>)</h4>

<p>シンボル <em>sym</em> がプロテクトされているかどうかをチェックします。
プロテクトされているシンボルは、組込関数、コンテキスト・シンボル、関数 <a href="#constant">constant</a> を使って <tt>constant</tt> にされた全てのシンボルです：<br />
Checks if a symbol in <em>sym</em> is protected. Protected symbols are built-in
functions, context symbols, and all symbols made constant using the <a href="#constant">constant</a>
function:</p>


<pre>
(protected? 'println)    <span class='arw'>&rarr;</span> true
(constant 'aVar 123)
(protected? 'aVar)       <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="push"></a>
<h2><span class="function">push</span>&nbsp;<a href="#destructive">!</a>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (push <em>exp</em> <em>list</em> [<em>int-index-1</em> [<em>int-index-2</em> ... ]])<br/>
syntax: (push <em>exp</em> <em>list</em> [<em>list-indexes</em>])<br/><br/>

syntax: (push <em>str-1</em> <em>str-2</em> [<em>int-index</em>])</h4>

<p><em>exp</em> の値をリスト <em>list</em> に挿入します。
<em>int-index</em> がある時、要素はインデックスの位置に挿入されます。
インデックスがない時は、インデックスが <tt>0</tt>（ゼロ）である最初の要素として挿入されます。
<tt>push</tt> は、目標リストの内容を変更する破壊的関数です。<br />
Inserts the value of <em>exp</em> into the list <em>list</em>.
If <em>int-index</em> is present, the element is inserted at that index.
If the index is absent, the element is inserted at index <tt>0</tt> (zero),
the first element. <tt>push</tt> is a destructive operation that changes the 
contents of the target list.</p>

<p>変更されたリストが返され、他の組込関数で参照動作可能です。
<a href="#indexing">文字列、リスト、アレイの要素指定</a> も見てください。<br />
The list changed is returned as a reference on which other built-in
functions can work. See also <a href="#indexing">Indexing elements of 
strings and lists</a>.</p>

<p>一個より多い <em>int-index</em> がある時、インデックスは入れ子構造のリストのアクセスとして使われます。
（リスト要素に一致しない）不適切なインデックス（訳注：入れ子構造と合っていないインデックス）は、破棄されます。（訳注：不適切なインデックスが破棄されるだけで、破棄されない部分のインデックスが有効であれば、要素はその位置に挿入されます。）<br />
If more than one <em>int-index</em> is present, the indices are used to 
access a nested list structure. Improper indices (those not matching list 
elements) are discarded.</p>

<p>第二の型は <em>list-indexes</em> のリストを取りますが、他は第一の型と同じです。
この方法なら、インデックスのリストを返す <a href="#ref">ref</a> や <a href="#ref-all">ref-all</a> と一緒に <tt>push</tt> を簡単使えます。<br />
The second version takes a list of <em>list-indexes</em> but is otherwise 
identical to the first. In this way, <tt>push</tt> works easily together 
with <a href="#ref">ref</a> and <a href="#ref-all">ref-all</a>,
which return lists of indices.
</p>

<p><em>list</em> にリストが入っていないなら、<em>list</em> は <tt>nil</tt> であるべきです。その際は、空リストに初期化されます。<br />
If <em>list</em> does not contain a list, <em>list</em> must contain a 
<tt>nil</tt> and will be initialized to the empty list.
</p>

<p><em>int-index</em> に <tt>-1</tt> を使ってリストの最後に繰り返し <tt>push</tt> するように最適化されていて、インデックス無しでリストの最初への <tt>push</tt> することより高速です。
この動作は、効率良くリストを増やすために有効です。<br />
Repeatedly using <tt>push</tt> to the end of a list using <tt>-1</tt> as 
the <em>int-index</em> is optimized and as fast as pushing 
to the front of a list with no index at all. This can be used to efficiently 
grow a list.
</p>

<!-- example -->

<pre>
; inserting in front
(set 'pList '(b c))  <span class='arw'>&rarr;</span> (b c)
(push 'a pList)      <span class='arw'>&rarr;</span> (a b c)
pList                <span class='arw'>&rarr;</span> (a b c)

; insert at index
(push "hello" pList 2)  <span class='arw'>&rarr;</span> (a b "hello" c)

; optimized appending at the end
(push 'z pList -1)  <span class='arw'>&rarr;</span> (a b "hello" c z)

; inserting lists in lists
(push '(f g) pList)  <span class='arw'>&rarr;</span> ((f g) a b "hello" c z)

; inserting at negative index
(push 'x pList -3)  <span class='arw'>&rarr;</span> ((f g) a b "hello" x c z)

; using multiple indices
(push 'h pList 0 -1)  <span class='arw'>&rarr;</span> ((f g h) a b "hello" x c z)

; use indices in a list
(set 'pList '(a b (c d () e)))

(push 'x pList '(2 2 0))  <span class='arw'>&rarr;</span> (a b (c d (x) e))

(ref 'x pList)   <span class='arw'>&rarr;</span> (2 2 0)

(pop pList '(2 2 0))  <span class='arw'>&rarr;</span> x

; the target list is a place reference
(set 'lst '((a 1) (b 2) (c 3) (d)))

(push 4 (assoc 'd lst) -1) <span class='arw'>&rarr;</span> (d 4)

lst <span class='arw'>&rarr;</span> ((a 1) (b 2) (c 3) (d 4))


; push on un-initialized symbol
aVar  <span class='arw'>&rarr;</span> nil 

(push 999 aVar)  <span class='arw'>&rarr;</span> (999)

aVar  <span class='arw'>&rarr;</span> (999)
</pre>


<p><tt>push</tt> と <tt>pop</tt> を組み合わせて、キューを作ることができます：<br />
<tt>push</tt> and pop can be combined to model a queue:</p>


<pre>
; pop and push a as a queue
(set 'Q '(a b c d e))

(pop (push 'f Q -1)) <span class='arw'>&rarr;</span> a
(pop (push 'g Q -1)) <span class='arw'>&rarr;</span> b

Q <span class='arw'>&rarr;</span>  (c d e f g)
</pre>


<p><tt>push</tt> は変更したリストへの参照を返すので、それ（訳注:返された参照）を <tt>pop</tt> で直接扱えます。<br />
Because <tt>push</tt> returns a reference to the modified list,
<tt>pop</tt> can work on it directly.</p>

<p>第三構文の <tt>push</tt> は文字列の変更に使えます。
<em>int-index</em> の使用は、バイト位置ではなく文字位置で参照します。
UTF-8 文字は多バイト文字かもしれません。<br />
In the third syntax <tt>push</tt> can be used to change strings. When
<em>int-index</em> is used, it refers to character positions rather than 
byte positions. UTF-8 characters may be multi-byte characters.</p>

<pre>
;; push on strings

(set 'str "abcdefg")

(push "hijk" str -1)  <span class='arw'>&rarr;</span> "abcdefghijk"
str                   <span class='arw'>&rarr;</span> "abcdefghijk"

(push "123" str)  <span class='arw'>&rarr;</span> "123abcdefghijk"
(push "4" str 3)  <span class='arw'>&rarr;</span> "1234abcdefghijk"

(set 'str "\u03b1\u03b2\u03b3")  <span class='arw'>&rarr;</span>  "ﾎｱﾎｲﾎｳ"

(push "*" str 1)  <span class='arw'>&rarr;</span>  "ﾎｱ*ﾎｲﾎｳ"

;; push on a string reference

(set 'lst '("abc" "xyz"))

(push x (lst 0)) <span class='arw'>&rarr;</span> "xabc"

lst <span class='arw'>&rarr;</span> ("xabc" "xyz")
</pre>
                                      
<p><tt>push</tt> と逆操作の関数 <a href="#pop">pop</a> も見てください。<br />
See also the <a href="#pop">pop</a> function, which is the inverse operation to <tt>push</tt>.
</p>

<br/><br/>

<a name="put-url"></a>
<h2><span class="function">put-url</span></h2>
<h4>syntax: (put-url <em>str-url</em> <em>str-content</em> [<em>str-option</em>] [<em>int-timeout</em> [<em>str-header</em>]])</h4>

<p>HTTP PUT プロトコルは、<em>str-url</em> で指定されたファイルへ <em>str-content</em> の情報を転送するために使われます。
あまり知られていない HTTP PUT モードは、HTML エディタからウェブ・サーバーへウェブ・ページを転送するために頻繁に使われます。
PUT モードを使うためには、ウェブ・サーバーのソフトウェアが正しく設定されている必要があります。
Apache ウェブ・サーバーでは、ディレクトリ・アクセス権が設定されているセクションに <tt>'Script PUT'</tt> 命令を使います。<br />
	The HTTP PUT protocol is used to transfer information in <em>str-content</em> 
	to a file specified in <em>str-url</em>. The lesser-known HTTP PUT mode is 
	frequently used for transferring web pages from HTML editors to Web servers.
	In order to use PUT mode, the web server's software must be configured correctly.
	On the Apache web server,
	use the <tt>'Script PUT'</tt> directive in the section where directory access rights are configured.
</p>

<p><em>str-url</em> が <tt>file://</tt> で始まっているならば、<em>str-content</em> はローカル・ファイル・システムに書き込まれます。<br />
If <em>str-url</em> starts with <tt>file://</tt> then <em>str-content</em> is written
to the local file system.</p>

<p>オプションで、最後のパラメータに <em>int-timeout</em> 値をミリ秒単位で指定できます。
ホストが<ruby>応答<rp>（</rp><rt>レスポンス</rt><rp>）</rp></ruby>を返さないか、タイムアウトに達した時、<tt>put-url</tt> は <tt>ERR: timeout</tt> を返します。
他のエラー条件では、<tt>put-url</tt> は <tt>ERR:</tt> で始まる文字列とエラーの記述を返します。<br />
	Optionally,
	an <em>int-timeout</em> value can be specified in milliseconds as the last parameter.
	<tt>put-url</tt> will return <tt>ERR:
	timeout</tt> when the host gives no response and the timeout expires.
	On other error conditions,
	<tt>put-url</tt> returns a string starting with <tt>ERR:</tt> and the description of the error.
</p>

<p><tt>put-url</tt> <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>は、newLISP サーバー・ノードでも解釈されますが、<tt>-http-safe</tt> モードで始まっている時は実行されません。<br />
<tt>put-url</tt> requests are also understood by newLISP server nodes, but will
not be served when the server is started in <tt>-http-safe</tt> mode.</p>

<!-- example -->

<pre>
(put-url "http://asite.com/myFile.txt" "Hi there")
(put-url "http://asite.com/myFile.txt" "Hi there" 2000)

(put-url "http://asite.com/webpage.html" 
    (read-file "webpage.html"))

; write /home/joe/newfile.txt on the local file system
(puts-url "file:///home/joe/newfile.txt" "Hello World!")
</pre>


<p>	最初の例は、ターゲット・サーバー上に <tt>myFile.txt</tt> で呼ばれるファイルを生成し、それにテキスト文字列 <tt>'Hi there'</tt> を保存します。
二番目の例は、ローカル・ファイル <tt>webpage.html</tt> を <tt>asite.com</tt> に転送します。<br />
	The first example creates a file called <tt>myFile.txt</tt> on the target server
	and stores the text string <tt>'Hi there'</tt> in it.
	In the second example,
	the local file <tt>webpage.html</tt> is transferred to <tt>asite.com</tt>.
</p>

<p>Apache ウェブ・サーバーでは、次のように <tt>httpd.conf</tt> に設定することができます：<br />
	On an Apache web server,
	the following could be configured in <tt>httpd.conf</tt>.
</p>

<!-- example -->

<pre>
&lt;directory /www/htdocs&gt;
Options All
Script PUT /cgi-bin/put.cgi
&lt;/directory&gt;
</pre>


<p>スクリプト <tt>put.cgi</tt> は、STDIN を通してウェブ・サーバーからの内容を受信するためのコードを含んでいます。
次は、Apache ウェブ・サーバー用に newLISP で書かれた <tt>put.cgi</tt> の動作です：<br />
	 The script <tt>put.cgi</tt> would contain code to receive content from the web server via STDIN.
	The following is a working <tt>put.cgi</tt> written in newLISP for the Apache web server:
</p>

<!-- example -->
<pre>
#!/usr/home/johndoe/bin/newlisp
#
#
# get PUT method data from CGI STDIN 
# and write data to a file specified
# int the PUT request
# 
#


(print "Content-Type: text/html\n\n")

(set 'cnt 0)
(set 'result "")

(if (= "PUT" (env "REQUEST_METHOD"))
    (begin
      (set 'len (int (env "CONTENT_LENGTH")))

      (while (&lt; cnt len)
          (set 'n (read (device) buffer len))
          (if (not n) 
            (set 'cnt len) 
            (begin 
              (inc cnt n)
              (write result buffer))))
              
      (set 'path (append 
              "/usr/home/johndoe" 
              (env "PATH_TRANSLATED")))

      (write-file path result)
    )
)

(exit)
</pre>


<p>アップロードされた悪意のあるスクリプトのCGI実行を避けるために、スクリプトが ".txt" を付加することに注意してください。
フル・パスを構成する二行がウェブ・サーバー環境によっては、異なる動作をするかもしれないことにも注意してください。
ウェブ・サーバーで正しいファイル・パスを構成するために、環境変数をチェックしてください。<br />
	Note that the script appends ".txt" to the path to avoid the CGI execution of uploaded malicious scripts.
	Note also that the two lines where the file path is composed may work differently in your web server environment.
	Check environment variables passed by your web server for composition of the right file path.
</p>

<p><tt>put-url</tt> は <tt>put.cgi</tt> によって返される内容を返します。<br />
	<tt>put-url</tt> returns content returned by the <tt>put.cgi</tt> script.
</p>

<h3>Additional parameters（追加のパラメータ）</h3>
<p><em>str-option</em> には、戻り内容に <a href="#get-url">get-url</a> と同じオプションを取ることができます。
<em>int-timeout</em> オプションを指定するなら、カスタム・ヘッダ・オプション <em>str-header</em> も同様に指定できます。
全オプションの詳細は、関数 <a href="#get-url">get-url</a> を見てください。<br />
In <em>str-option</em> can take the same options as <a href="#get-url">get-url</a>
for the returned content. If the <em>int-timeout</em> option is specified, the 
custom header option <em>str-header</em> can be specified, as well. See the 
function <a href="#get-url">get-url</a> for details on all options.
</p>

<p>関数 <a href="#get-url">get-url</a> と <tt>multipart/form-data</tt> 形式データを整形する時のファイルのアップロードに使われる <a href="#post-url">post-url</a> も見てください。<br />
See also the functions <a href="#get-url">get-url</a> and <a href="#post-url">post-url</a>,
which can be used to upload files when formatting form data as <tt>multipart/form-data</tt>.
</p>

<br/><br/>

<a name="pv"></a>
<h2><span class="function">pv</span></h2>
<h4>syntax: (pv <em>num-int</em> <em>num-nper</em> <em>num-pmt</em> 
[<em>num-fv</em> [<em>int-type</em>]])</h4>

<p>固定金利<em>num-interest</em> と 固定支払額 <em>num-pmt</em> で支払回数 <em>num-nper</em> の場合のローン残高を計算します。
最終ローン残高 <em>num-fv</em> は省略されると <tt>0.0</tt> になります。
期間の終わりに支払うなら <em>int-type</em> は <tt>0</tt>（ゼロ）か <em>int-type</em> は 省略され、期間の最初に支払うなら <em>int-type</em> は 1 です。<br />
Calculates the present value of a loan with the constant interest rate 
<em>num-interest</em> and the constant payment <em>num-pmt</em> after 
<em>num-nper</em> number of payments. The future value <em>num-fv</em> 
is assumed to be <tt>0.0</tt> if omitted. If payment is at the end of the 
period, <em>int-type</em> is <tt>0</tt> (zero) or <em>int-type</em> is omitted; 
for payment at the beginning of each period, <em>int-type</em> is 1.</p>

<!-- example -->

<pre>
(pv (div 0.07 12) 240 775.30)  <span class='arw'>&rarr;</span> -100000.1373
</pre>

<p>この例では、(future value が <tt>0.0</tt> で) 年利7％で240ヶ月、毎月775.30 ドル支払うローンの金額が $100,000.14 となります。<br />
	In the example,
	a loan that would be paid off (future value = <tt>0.0</tt>) in 240 payments of $775.30 at a 
	constant interest rate of 7 percent per year would start out at $100,000.14.
</p>

<p>関数 <a href="#fv">fv</a>、<a href="#irr">irr</a>、<a href="#nper">nper</a>、<a href="#npv">npv</a>、<a href="#pmt">pmt</a> も見てください。<br />
	See also the <a href="#fv">fv</a>,
	<a href="#irr">irr</a>,
	<a href="#nper">nper</a>,
	<a href="#npv">npv</a>,
	and <a href="#pmt">pmt</a> functions.
</p>

<br/><br/>

<a name="quote"></a>
<h2><span class="function">quote</span></h2>
<h4>syntax: (quote <em>exp</em>)</h4>

<p><em>exp</em> を評価せずに返します。
<em>exp</em> への <tt>'</tt>（シングル・クォート）先付けと同じ効果が得られます。
実行時に関数 <tt>quote</tt> はなくなり、先付けの <tt>'</tt> クォートはコード変換中に保護エンベロープ（クォート・セル）に変換されます。<br />
Returns <em>exp</em> without evaluating it. The same effect can be obtained by 
prepending a <tt>'</tt> (single quote) to <em>exp</em>. The function <tt>quote</tt> 
is resolved during runtime, the prepended <tt>'</tt> quote is translated into a 
protective envelope (quote cell) during code translation.</p>

<!-- example -->

<pre>
(quote x)         <span class='arw'>&rarr;</span> x
(quote 123)       <span class='arw'>&rarr;</span> 123
(quote (a b c))   <span class='arw'>&rarr;</span> (a b c)
(= (quote x) 'x)  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="quotep"></a>
<h2><span class="function">quote?</span></h2>
<h4>syntax: (quote? <em>exp</em>)</h4>

<p><em>exp</em> を評価し、クォートされているかどうかをテストします。
結果次第で、<tt>true</tt> か <tt>nil</tt> が返ります。<br />
	 Evaluates and tests whether <em>exp</em> is quoted.
	Returns <tt>true</tt> or <tt>nil</tt> depending on the result.
</p>

<!-- example -->

<pre>
(set 'var ''x)  <span class='arw'>&rarr;</span> 'x
(quote? var)    <span class='arw'>&rarr;</span> true
</pre>

<p>（訳注：例の） <tt>set</tt> 宣言文では、<tt> ''x</tt> が 2回クォートされることに注意してください。
それは、最初のクォートが <tt>set</tt> の引数としての評価で無くなるからです。<br />
	 Note that in the <tt>set</tt> statement,
	<tt> ''x</tt> is quoted twice because the first quote 
  is lost during the evaluation of the <tt>set</tt> assignment.
</p>

<br/><br/>

<a name="rand"></a>
<h2><span class="function">rand</span></h2>
<h4>syntax: (rand <em>int-range</em> [<em>int-N</em>])</h4>

<p><em>int-range</em> の式を評価して、<tt>0</tt> ～ (<em>int-range</em> - 1) 間の範囲で乱数を一つ生成します。
<tt>0</tt> (zero) が渡されると、内部乱数発生器に C 関数 <tt>time()</tt> による現在値を使って初期化を行います。
オプションで、<em>int-N</em> 個の長さの乱数リストを返す第二パラメータを指定できます。<br />
	Evaluates the expression in <em>int-range</em> 
	and generates a random number in the range of 
	<tt>0</tt> (zero) to (<em>int-range</em> - 1). 
	When <tt>0</tt> (zero) is passed, 
	the internal random generator 
	is initialized using 
	the current value returned by 
	the C <tt>time()</tt> function. 
	Optionally, a second parameter 
	can be specified to return 
	a list of length <em>int-N</em> 
	of random numbers.
</p>

<!-- example -->

<pre>
(dotimes (x 100) (print (rand 2))) =&gt;
11100000110100111100111101 ... 10111101011101111101001100001000

(rand 3 100)  <span class='arw'>&rarr;</span> (2 0 1 1 2 0 &hellip;)
</pre>


<p>例の一行目は均等に分配された <tt>0</tt> と <tt>1</tt> を出力し、二行目は均等に分配された <tt>0</tt> と <tt>1</tt> と <tt>2</tt> の 100 個の整数リストを生成します。
浮動小数点数の乱数生成には、関数 <a href="#random">random</a> や <a href="#normal">normal</a> を使ってください。
その際、乱数発生器の初期化用シード変更には <a href="#seed">seed</a> を使ってください。<br />
	The first line in the example 
	prints equally distributed <tt>0</tt>'s and <tt>1</tt>'s, 
	while the second line produces a list 
	of 100 integers with 
	<tt>0</tt>, <tt>1</tt>, and <tt>2</tt> equally distributed. 
	Use the <a href="#random">random</a> 
	and <a href="#normal">normal</a> functions
	to generate floating point
	random numbers, 
	and use <a href="#seed">seed</a> to vary 
	the initial seed 
	for random number generation.
</p>

<br/><br/>

<a name="random"></a>
<h2><span class="function">random</span></h2>
<h4>syntax: (random <em>float-offset</em> <em>float-scale</em> <em>int-n</em>)<br/>
syntax: (random <em>float-offset</em> <em>float-scale</em>)</h4>

<p>第一形式の <tt>random</tt> は、<em>float-offset</em> のオフセットを持ち <em>float-scale</em> の大きさに均等に配される <em>int-n</em> 個の浮動小数点数のリストを返します。
内部乱数生成器の開始点は、<a href="#seed">seed</a> を使って指定できます。<br />
	In the first form, 
	<tt>random</tt> returns a list of <em>int-n</em> 
	evenly distributed floating point numbers 
	scaled (multiplied) by <em>float-scale</em>, 
	with an added offset of <em>float-offset</em>. 
	The starting point of the internal random generator 
	can be seeded using <a href="#seed">seed</a>.
</p>

<!-- example -->

<pre>
(random 0 1 10)
<span class='arw'>&rarr;</span> (0.10898973 0.69823783 0.56434872 0.041507289 0.16516733
    0.81540917 0.68553784 0.76471068 0.82314585 0.95924564)
</pre>


<p>第二形式を使うと、<tt>random</tt> は均等に配された数値を一つ返します：<br />
	When used in the second form, 
	<tt>random</tt> returns a single 
	evenly distributed number:
</p>


<pre>
(random 10 5)  <span class='arw'>&rarr;</span> 11.0971
</pre>

<p>パラメータなしの時、<tt>random</tt> は平均を <tt>0.0</tt>、標準偏差を <tt>1.0</tt> と見なします。<br />
 When no parameters are given, <tt>random</tt> assumes a mean of <tt>0.0</tt> 
and a standard deviation of <tt>1.0</tt>.</p>

<p>関数<a href="#normal">normal</a> と <a href="#rand">rand</a> も見てください。<br />
	See also the <a href="#normal">normal</a> 
	and <a href="#rand">rand</a> functions.
</p>

<br/><br/>

<a name="randomize"></a>
<h2><span class="function">randomize</span></h2>
<h4>syntax: (randomize <em>list</em> [<em>bool</em>])</h4>

<p><em>list</em> の要素順をランダムに再配列します。<br />
	Rearranges the order of elements in <em>list</em> 
	into a random order.
</p>

<!-- example -->

<pre>
(randomize '(a b c d e f g))  <span class='arw'>&rarr;</span> (b a c g d e f)
(randomize (sequence 1 5))    <span class='arw'>&rarr;</span> (3 5 4 1 2)
</pre>


<p><tt>randomize</tt> はオプションの <em>bool</em> フラグ無しで、常に前と異なる順序を返します。
このためは、関数には要素の再配置計算が数回必要になるかも知れません。
従って、同じ長さのリスト上でも別々に起動された関数では、実行時間が異なる可能性があります。
入力と同じ出力が許されるなら、<tt>nil</tt> 以外か <tt>true</tt> に評価される式を <em>bool</em> に指定します。（訳注：<em>bool</em> が指定されていなければ引数と同じ順序は返されず、 <tt>nil</tt> 以外なら同じ順序のリストが返される場合があるということ。）<br />
	<tt>randomize</tt> will always return 
	a sequence different from the previous one 
	without the optional <em>bool</em> flag. 
	This may require the function to calculate 
	several sets of reordered elements, 
	which in turn may lead to different processing times 
	with different invocations of the function 
	on the same input list length. 
	To allow for the output to be equal 
	to the input, <tt>true</tt> 
	or any expression evaluating to 
	not <tt>nil</tt> 
	must be specified in <em>bool</em>.
</p>

<p><tt>randomize</tt> が使っている内部<em>擬似ランダム数列</em> 発生器は、newLISP 開始の度に毎回同じ数列結果を返します。
この数列を変更するためには、関数 <a href="#seed">seed</a> を使ってください。<br />
	<tt>randomize</tt> uses 
	an internal <em>pseudo random sequence</em> generator 
	that returns the same series of results 
	each time newLISP is started. 
	Use the <a href="#seed">seed</a> function to 
	change this sequence.
</p> 

<br/><br/>

<a name="read-buffer"></a>
<a name="read"></a>
<h2><span class="function">read</span>&nbsp;<a href="#destructive">!</a></h2>

<h4>syntax: (read <em>int-file</em> <em>sym-buffer</em> <em>int-size</em> [<em>str-wait</em>])</h4>

<p><em>int-file</em> で指定されたファイルから、バッファ <em>sym-buffer</em> に最大 <em>int-size</em> バイト読み取ります。
読み取りに先立ち、<em>sym-buffer</em> で参照されるデータは如何なるものも消去されます。
<em>int-file</em> のハンドルは、先行する <a href="#open">open</a> 宣言文から得られます。
読み取り処理後、シンボル <em>sym-buffer</em> は文字列型のデータを持ちます。
ユーザ定義関数へ入出力を受け渡すコンテキスト・シンボル指定のデフォルト・ファンクタを <em>sym-buffer</em> にすることも可能です。<br />
Reads a maximum of <em>int-size</em> bytes from a file specified in <em>int-file</em> 
into a buffer in <em>sym-buffer</em>.  Any data referenced by the symbol <em>sym-buffer</em> 
prior to the reading is deleted.  The handle in <em>int-file</em> is obtained from a 
previous <a href="#open">open</a> statement. The symbol <em>sym-buffer</em> contains 
data of type string after the read operation.  <em>sym-buffer</em> can also be a default 
functor specified by a context symbol for reference passing in and out of user-defined 
functions.</p>

<p><tt>read</tt> は <tt>read-buffer</tt> の省略形です。
長い名前の <tt>read-buffer</tt> は今でも動作しますが、推奨されません、
新しいコードでは避けてください。<br />
<p><tt>read</tt> is a shorter writing of <tt>read-buffer</tt>. The longer
form still works but is deprecated and should be avoided in new code.</p>

<p>オプションで、待機文字列を <em>str-wait</em> に指定できます。
<tt>read</tt> は、<em>int-size</em> で指定された最大バイト数を読み取るか、データ中に <em>str-wait</em> を見つけた時に戻ります。
待機文字列は戻りデータに含まれますが、バイナリ <tt>0</tt>（ゼロ）を含んではいけません。<br />
	Optionally, 
	a string to be waited for 
	can be specified in <em>str-wait</em>. 
	<tt>read</tt> will read 
	a maximum amount of bytes 
	specified in <em>int-size</em> 
	or return earlier 
	if <em>str-wait</em> was found 
	in the data. 
	The wait-string is part
	of the returned data and must
    not contain binary <tt>0</tt> (zero)
    characters.
</p>

<p>読み取ったバイト数か、待機文字が見つからなかった時の <tt>nil</tt> を返します。
如何なる場合も、読み取られたバイトは <em>sym-buffer</em> で指定されるバッファに置かれ、読み取られたファイルのファイル・ポインタは前に進みます。
読み取られなかった時、<em>sym-buffer</em> の中身は <tt>nil</tt> になります。<br />
	Returns the number of bytes read or <tt>nil</tt> 
	when the wait-string was not found. 
	In any case, 
	the bytes read are put into the buffer 
	pointed to by <em>sym-buffer</em>, 
	and the file pointer of the file read 
	is moved forward. 
	If no new bytes have been read, 
	<em>sym-buffer</em> will contain <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(set 'handle (open "aFile.ext" "read"))
(read handle buff 200)
</pre>


<p>ファイル <tt>aFile.ext</tt> からシンボル <tt>buff</tt> に 200 バイト読み込まれます。<br />
	Reads 200 bytes into the symbol <tt>buff</tt> 
	from the file <tt>aFile.ext</tt>.
</p>


<pre>
(read handle buff 1000 "password:")
</pre>


<p>1000バイトか、文字列 <tt>password:</tt> に出会うまで読み取られます。
文字列 <tt>password:</tt> は、返されるデータの一部です。<br />
	Reads 1000 bytes or until 
	the string <tt>password:</tt> is encountered. 
	The string <tt>password:</tt> 
	will be part of the data returned.
</p>

<p>関数 <a href="#write">write</a> も見てください。
ファイルの特定位置から読み出すには関数 <a href="#seek">seek</a> を使います。<br />
	See also the <a href="#write">write</a> function. To start reading at 
	a specific position in the file, use the <a href="#seek">seek</a> function.
</p>

<br/><br/>

<a name="read-char"></a>
<h2><span class="function">read-char</span></h2>

<h4>syntax: (read-char [<em>int-file</em>])</h4>

<p><em>int-file</em> のファイル・ハンドルで指定されたファイルから 1 バイト読み取ります。
ファイル・ハンドルを指定しなければ、現行の I/O デバイス、例えば <em>stdin</em> から読み取ります。
ファイル・ハンドルは先行する <a href="#open">open</a> 操作で得られます。
各 <tt>read-char</tt> は、読み取り毎にファイル・ポインタを一個ずつ進めます。
ファイルの終わりに達したら、<tt>nil</tt> を返します。<br />
Reads a byte from a file specified by the file handle in <em>int-file</em> 
or from the current I/O device - e.g. <em>stdin</em> - when no file handle is specified.
The file handle is obtained from a previous <a href="#open">open</a> operation. 
Each <tt>read-char</tt> advances the file pointer by one byte. 
Once the end of the file is reached, <tt>nil</tt> is returned.
</p>

<!-- example -->

<pre>
(define (slow-file-copy from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (write-char out-file chr))
    (close in-file)
    (close out-file)
    "finished")
</pre>


<p>一度に行単位で読み取りたい時は、<a href="#read-line">read-line</a> と <a href="#device">device</a> を使ってください。
ファイル・コピー用には、newLISP が <a href="#copy-file">copy-file</a> で呼び出される高速な組込関数を提供していることをお忘れなく。
（訳注：ですから、上記例のスクリプトを使う必要は、まず有りません。）<br />
	Use <a href="#read-line">read-line</a> 
	and <a href="#device">device</a> to read 
	whole text lines at a time. 
	Note that newLISP supplies 
	a fast built-in function 
	called <a href="#copy-file">copy-file</a> 
	for copying files.
</p>

<p>関数 <a href="#write-char">write-char</a> も見てください。<br />
	See also the <a href="#write-char">write-char</a> function.
</p>

<br/><br/>

<a name="read-expr"></a>
<h2><span class="function">read-expr</span></h2>
<h4>syntax: (read-expr <em>str-source</em> [<em>sym-context</em> [<em>exp-error</em> [<em>int-offset</em>]]])</h4>

<p><tt>read-expr</tt> は、<em>str-source</em> 中に見つけた最初の式を分析し、翻訳した式を評価せずに返します。
のオプションのコンテキスト <em>sym-context</em> が、翻訳された式の名前空間を指定します。<br />
<tt>read-expr</tt> parses the first expressions it finds in <em>str-source</em> and 
returns the translated expression without evaluating it. An optional context in 
<em>sym-context</em> specifies a namespace for the translated expression.</p>

<p><tt>read-expr</tt> が呼ばれた後、システム変数 <tt>$count</tt> には走査した文字数が入ります。<br />
After a call to <tt>read-expr</tt> the system variable <tt>$count</tt> contains the 
number of characters scanned.</p>

<p><em>str-source</em> を翻訳中にエラーが起こった場合、<em>exp-error</em> の式が評価され、その結果が返ります。<br />
If an error occurs when translating <em>str-source</em> the expression in
<em>exp-error</em> is evaluated and the result returned.</p>

<p><em>int-offset</em> は <em>str-source</em> 中で実行を開始するオプセットを指定します。
<tt>read-expr</tt> が繰り返し呼び出す時、この数値に処理した文字数の <tt>$count</tt> を使って更新できます。<br />
<em>int-offset</em> specifies an optional offset into <em>str-source</em> where
processing should start. When calling <tt>read-expr</tt> repeatedly this number
can be updated using <tt>$count</tt>, the number of characters processed.</p>

<!-- example -->

<pre>
(set 'code "; a statement\n(define (double x) (+ x x))")

(read-expr code) <span class='arw'>&rarr;</span> (define (double x) (+ x x))

$count <span class='arw'>&rarr;</span> 41

</pre>


<p><tt>read-expr</tt> は <a href="#eval-string">eval-string</a> のように振る舞いますが、評価のステップがありません：<br />
<tt>read-expr</tt> behaves similar to <a href="#eval-string">eval-string</a>
but without the evaluation step:</p>


<pre>
(read-expr "(+ 3 4)")    <span class='arw'>&rarr;</span> (+ 3 4)

(eval-string "(+ 3 4)")  <span class='arw'>&rarr;</span> 7
</pre>


<p><tt>read-expr</tt> を使えば、評価前に式をプリプロセッシングするカスタム・コード・リーダーをプログラムできます。<br />
Using <tt>read-expr</tt> a customized code reader can be programmed
preprocessing expressions before evaluation.</p>

<p>イベント駆動された式を処理する <a href="#reader-event">reader-event</a> も見てください。<br />
See also <a href="#reader-event">reader-event</a> for preprocessing
expressions event-driven.</p>

<br/><br/>

<a name="read-file"></a>
<h2><span class="function">read-file</span></h2>
<h4>syntax: (read-file <em>str-file-name</em>)</h4>

<p><em>str-file-name</em> のファイルを一気に読み取り、そのデータを文字列バッファで返します。<br />
Reads a file in <em>str-file-name</em> in one swoop and returns a string buffer 
containing the data.</p>

<p>失敗した時、関数は <tt>nil</tt> を返します。
ファイルに対して使った時のエラー情報には <a href="#sys-error">sys-error</a> を使います。
URL の場合は <a href="#net-error">net-error</a> が詳細なエラー情報を与えます。<br />
On failure the function returns <tt>nil</tt>. For error information, 
use <a href="#sys-error">sys-error</a> when used on files. When used
on URLs <a href="#net-error">net-error</a> gives more error
information.</p>
</p>

<!-- example -->

<pre>
(write-file "myfile.enc" 
    (encrypt (read-file "/home/lisp/myFile") "secret"))
</pre>


<p>読み取られたファイル <tt>myFile</tt> は、パスワード <tt>"secret"</tt> を使って暗号化され、現行のディレクトリ下で <tt>"myfile.enc"</tt> という名の新ファイルに書き込まれます。<br />
The file <tt>myfile</tt> is read, then encrypted using the password <tt>"secret"</tt> 
before being written back into a new file titled <tt>"myfile.enc"</tt> 
in the current directory.</p>

<p><tt>read-file</tt> は、<em>str-file-name</em> に <tt>http://</tt> や <tt>file://</tt> 等の URL を取ることができます。
先頭が <tt>http://</tt> の時、<tt>read-file</tt> は <a href="#get-url">get-url</a> と全く同じ動作をするので、（訳注：<a href="#get-url">get-url</a> と）同じ付加パラメータを取ることができます。<br />
<tt>read-file</tt> can take an <tt>http://</tt> 
or <tt>file://</tt> URL in <em>str-file-name</em>. 
When the prefix is <tt>http://</tt>, <tt>read-file</tt> works exactly like 
<a href="#get-url">get-url</a> and can take the same additional parameters.</p>

<!-- example -->

<pre>
(read-file "http://asite.com/somefile.tgz" 10000)
</pre>


<p>ファイル<tt>somefile.tgz</tt> が、リモート位置にある <tt>http://asite.com</tt> から取り出されます。。
ファイル転送が１０秒超えても終わないと、タイム・アウトになります。
このモードの <tt>read-file</tt> は、リモートにある newLISP サーバーからのファイル転送にも使われます。<br />
	The file <tt>somefile.tgz</tt> is retrieved from 
	the remote location <tt>http://asite.com</tt>. 
	The file transfer will time out after 10 seconds 
	if it is not finished. 
	In this mode, <tt>read-file</tt> can also be used 
	to transfer files from remote newLISP server nodes.</p>

<p>関数 <a href="#write-file">write-file</a> と <a href="#append-file">append-file</a> も見てください。<br />
See also the <a href="#write-file">write-file</a> and 
<a href="#append-file">append-file</a> functions.
</p>

<br/><br/>

<a name="read-key"></a>
<h2><span class="function">read-key</span></h2>
<h4>syntax: (read-key [true])</h4>

<p>キーボードからキーを読み取り、整数値を返します。
プラットフォーム OS によっては、ナビーゲーション・キーのために一回より多い <tt>read-key</tt> の呼び出しが必要になります。
ASCII文字を表すキーは全ての OS で同じ値が返りますが、ナビゲーション・キーやファンクション・キーのようなコントール・シーケンスの場合、戻り値は OS の違いや設定で変わります。<br />
Reads a key from the keyboard and returns an integer value. 
For navigation keys, more than one <tt>read-key</tt> call 
must be made depending of the platform OS. For keys representing 
ASCII characters, the return value is the same on all OSes, except 
for navigation keys and other control sequences like function keys, 
in which case the return values may vary on different OSes and 
configurations.
</p>

<p><tt>true</tt> フラグを使うと <tt>read-key</tt> はノン・ブロッキングになり、キーが押されていなければ（ゼロ）を返します。
この拡張フラグを使わない時、<tt>read-key</tt> の呼び出しはキーが押されるまでブロッキング状態です。<br />
When using the <tt>true</tt> flag the <tt>read-key</tt> is non-blocking
and a <tt>0</tt> (zero) is returned when no key has been pressed.
When not using the extra flag, the call to <tt>read-key</tt> is blocking
until a key is pressed.</p>



<!-- example -->

<pre>
(read-key)  <span class='arw'>&rarr;</span> 97  ; after hitting the A key
(read-key)  <span class='arw'>&rarr;</span> 65  ; after hitting the shifted A key
(read-key)  <span class='arw'>&rarr;</span> 10  ; after hitting [enter] on Linux
(read-key)  <span class='arw'>&rarr;</span> 13  ; after hitting [enter] on Windows

(read-key true)  <span class='arw'>&rarr;</span> 0 ; when no key has been pressed

(while (!= (set 'c (read-key)) 1) (println c))
</pre>


<p>最後の例は、ナビゲーション・キーやファンクション・キーからの戻り値列を確認するために使えます。
ループから抜け出す時は、<tt>Ctrl-A</tt> を押してください。<br />
The last example can be used to check return sequences 
from navigation and function keys. To break out of the loop, 
press <tt>Ctrl-A</tt>.
</p>

<p>newLISP が Unix シェル か MS Windows コマンド・シェル上で走っている時のみに、<tt>read-key</tt> は動作することに注意してください。
また、newLISP Unix 共有ライブラリ や newLISP MS Windows DLL（ダイナミック・リンク・ライブラリ）上でも動作しません。
これらのライブラリが標準入力を見ていないからです。<br />
Note that <tt>read-key</tt> will only work when newLISP is running in a
Unix shell or Windows command shell. It will also not work when executed by 
newLISP Unix shared library or newLISP MS Windows DLL (Dynamic Link Library).
These libraries are not listening to STD input.</p>

<br/><br/>

<a name="read-line"></a>

<h2><span class="function">read-line</span></h2>
<h4>syntax: (read-line [<em>int-file</em>])</h4>

<p>現在の I/O デバイスから改行文字 (ASCII 10) で区切られた文字列を読み取ります。
読み取られる文字列の長さに制限はありません。
改行文字は戻り文字列に含まれません。
行は改行で分割され、改行自体は消えます。
行が復帰 (ASCII 13) で分割されるのは、その後に改行が続いている場合にのみで、どちらの文字も消えます。
復帰がストリームの最後の文字である場合は復帰のみでも分割され、消えます。<br />
	Reads from the current I/O device a string 
	delimited by a line-feed character (ASCII 10). 
	There is no limit 
	to the length of the string 
	that can be read. 
	The line-feed character is not part of the returned string. 
	The line always breaks on a line-feed, 
	which is then swallowed. 
	A line breaks on a carriage return (ASCII 13) 
	only if followed by a line-feed, 
	in which case both characters are discarded. 
	A carriage return alone only breaks and is swallowed 
	if it is the last character in the stream.
</p>

<p>デフォルトで、現行 <a href="#device">device</a> はキーボード (<a href="#device">device</a> <tt>0</tt>) です。 
異なる I/O デバイス（例えば、ファイルとか）を指定するためには、組込関数 <a href="#device">device</a> を使ってください。
オプションで、先行する <a href="#open">open</a> 宣言文で得られるファイル・ハンドルを <em>int-file</em> に指定できます。<br />
	By default, 
	the current <a href="#device">device</a> 
	is the keyboard (<a href="#device">device</a> <tt>0</tt>). 
	Use the built-in function <a href="#device">device</a> 
	to specify a different I/O device (e.g., a file). 
	Optionally, 
	a file handle can be specified 
	in the <em>int-file</em> obtained 
	from a previous <a href="#open">open</a> statement.
</p>

<p>read-line 操作の最新のバッファ内容は、<a href="#current-line">current-line</a> を使って取り出せます。<br />
	The last buffer contents 
	from a read-line operation 
	can be retrieved using <a href="#current-line">current-line</a>.
</p>

<p>CGI プログラムやパイプ上で、<tt>read-line</tt> がファイルや <em>stdin</em> から読み取っている時、入力が終わった時点で <tt>nil</tt> を返します。<br />
When <tt>read-line</tt> is reading from a file or from <em>stdin</em>
in a CGI program or pipe, it will return <tt>nil</tt> when input is exhausted.</p>

<p><em>stdin</em> 上で <tt>read-line</tt> を使う時の行の長さは 2048 に制限され、より速く実行されます。<br />
When using <tt>read-line</tt> on <em>stdin</em>, line length is limited
to 2048 characters and performance is much faster.</p>

<!-- example -->

<pre>
(print "Enter a num:")
(set 'num (int (read-line)))

(set 'in-file (open "afile.dat" "read"))
(while (read-line in-file)
        (write-line))   
(close in-file)
</pre>


<p>最初の例では、キーボードからの入力を読み取り、数値に変換します。
二番目の例では、ファイルが一行ずつ読み取られ、スクリーン上に表示されます。
<tt>write-line</tt> 宣言文は、最後の <tt>read-line</tt> 操作の結果がシステムの内部バッファに保存されていることを利用しています。
つまり、<a href="#write-line">write-line</a> が引数なしで使われ、最後の <tt>read-line</tt> バッファの内容がスクリーンに書き込まれていることになります。<br />
	The first example reads input from the keyboard 
	and converts it to a number. 
	In the second example, 
	a file is read line-by-line 
	and displayed on the screen. 
	The <tt>write-line</tt> statement 
	takes advantage of the fact 
	that the result from the last 
	<tt>read-line</tt> operation 
	is stored in a system internal buffer. 
	When <a href="#write-line">write-line</a> 
	is used without argument, 
	it writes the contents 
	of the last <tt>read-line</tt> buffer 
	to the screen.
</p>

<p>このバッファから取り出すための関数 <a href="#current-line">current-line</a> も見てください。<br />
	See also the <a href="#current-line">current-line</a> function
	for retrieving this buffer.
</p>

<br/><br/>

<a name="read-utf8"></a>
<h2><span class="function">read-utf8</span></h2>

<h4>syntax: (read-utf8 <em>int-file</em>)</h4>

<p>ファイル・ハンドル <em>int-file</em> で指定されたファイルから、UTF-8 文字を一文字読み取ります。
ファイル・ハンドルは、先行する <a href="#open">open</a> 操作から得られます。
各 <tt>read-utf8</tt> は UTF-8文字で得られたバイト数分、ファイルポインタを進めます。
ファイルが終わりに達した時、<tt>nil</tt> が返されます。<br />
Reads an UTF-8 character from a file specified by the file handle in <em>int-file</em>. 
The file handle is obtained from a previous <a href="#open">open</a> operation. 
Each <tt>read-utf8</tt> advances the file pointer by the number of bytes contained
in the UTF-8 character.  Once the end of the file is reached, <tt>nil</tt> is returned. </p>

<p>この関数の戻り値は整数値で、その数値に関数 <a href="#char">char</a> を使えば、表示可能な UTF-8 文字に変換できます。<br />
The function returns an integer value which can be converted to a displayable UTF-8
character string using the <a href="#char">char</a> function.</p>

<!-- example -->
<pre>
(set 'fle (open "utf8text.txt" "read"))
(while (setq chr (read-utf8 fle))
	(print (char chr)))
</pre>


<p>この例は、UTF-8 エンコード・テキストからなるファイルを読み取り、それをターミナル・スクリーンに表示します。<br />
The example reads a file containing UTF-8 encoded text and displays it to the
terminal screen.</p>

<br/><br/>


<a name="reader-event"></a>
<h2><span class="function">reader-event</span></h2>
<h4>syntax: (reader-event [<em>sym-event-handler | func-event-handler</em>])<br/>
syntax: (reader-event nil)</h4>

<p>newLISPリーダーの翻訳と評価のプロセス間をフックするためのイベント・ハンドラを指定できます。
newLISP が式を翻訳して評価する前に、<em>sym-event-handler</em> か <em>func-event-handler</em> で指定された関数が呼び出されます。
イベント・ハンドラが評価される前の式を変換できるのです。<br />
An event handler can be specified to hook between newLISP's reader, 
translation and evaluation process. The function specified in 
<em>sym-event-handler</em> or <em>func-event-handler</em> gets called after 
newLISP translates an expression and before evaluating it. The event handler can do 
transformation on the expression before it gets evaluated.</p>

<p>イベントに <tt>nil</tt> を指定すると、初期のデフォルト状態にリセットされます。<br />
Specifying <tt>nil</tt> for the event will reset it to the initial default state.</p>

<p>次の一行 <tt>reader-event</tt> は、インターラクティブ・シェルをトレーサー付きに拡張しています：<br />
The following one-liner <tt>reader-event</tt> could be used to enhance
the interactive shell with a tracer:</p>

<!-- example -->
<pre>
<b>&gt;</b>(reader-event (lambda (ex) (print " =&gt; " ex)))
$reader-event
<b>&gt; (+ 1 2 3)
 =&gt; (+ 1 2 3) 
6
&gt;</b>
</pre>

<p>インターセプトされた式は変化せずに渡されていますが、出力が改良されています。<br />
The expression intercepted passes through unchanged, but output
is enhanced.</p>

<p>関数 <a href="#load">load</a> や <a href="#eval-string">eval-string</a> で、各ｓ式が読み取られる度に、リーダー・イベント機能が呼び出されます。<br />
The reader event function will be called after each reading of an s-expression
by the <a href="#load">load</a> or <a href="#eval-string">eval-string</a> function.</p>

<p>10.5.8 以前のバージョンでは、拡張 <tt>macro</tt> 機能を定義するためにモジュール・ファイル <tt>macro.lsp</tt> を使用していました。
バージョン 10.5.8 からの newLISP は、同じように動作する組込関数 <a href="#macro">macro</a> を持ち、ファイルのロードやソースの読み込みがより早くなっています。<br />
In versions previous to 10.5.8 <tt>reader-event</tt> was used to define a 
<tt>macro</tt> expansion function in the module file <tt>macro.lsp</tt>. Starting 
version 10.5.8, newLISP has <a href="#macro">macro</a> as a built-in function 
behaving the same, but much faster when loading files and reading source.</p>

<br/><br/>

<a name="real-path"></a>
<h2><span class="function">real-path</span></h2>
<h4>syntax: (real-path [<em>str-path</em>])<br/>
syntax: (real-path <em>str-exec-name</em> true)
</h4>

<p>第一構文の <em>str-path</em> は、与えられた相対ファイル・パス からフル・パスを返します。
パスが与えられないと <tt>"."</tt>（カレント・ディレクトリ）になります。<br />
In the first syntax <tt>real-path</tt> returns the full path from the relative 
file path given in <em>str-path</em>. If a path is not given, <tt>"."</tt> 
(the current directory) is assumed.</p>

<!-- example -->

<pre>
(real-path)  <span class='arw'>&rarr;</span> "/usr/home/fred"  ; current directory
(real-path "./somefile.txt")
<span class='arw'>&rarr;</span> "/usr/home/fred/somefile.txt"
</pre>

<p>第二構文の <tt>real-path</tt> は <em>str-exe-name</em> で与えられる実行ファイルのフル・パスを返します。
UNIX や Windows システムにおいて、この構文は環境変数 PATH に依存します。<br />
In the second syntax <tt>real-path</tt> returns the full path for an 
executable found given in <em>str-exe-name</em>. This syntax relies on an 
environment variable PATH defined on UNIX and Windows systems.</p>

<pre>
(real-path "make" true) <span class='arw'>&rarr;</span> "/usr/bin/make"
</pre>

<p>出力の長さは、OS で許されているパスの最大長で制限されます。
<tt>real-path</tt> は、失敗する（すなわち、パスが存在しない）と <tt>nil</tt> を返します。<br />
The output length is limited by the OS's maximum allowed path length. 
If <tt>real-path</tt> fails (e.g., because of a nonexistent path), 
<tt>nil</tt> is returned.
</p>

<br/><br/>

<a name="receive"></a>
<h2><span class="function">receive</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (receive <em>int-pid</em> <em>sym-message</em>)<br/>
syntax: (receive)</h4>

<p>この関数の第一構文は、<a href="#spawn">spawn</a> で起動した子プロセスとその親プロセス間のメッセージ交換に使われます。
受信したメッセージは、<em>sym-message</em> の内容になります。<br />
In the first syntax, the function is used for message exchange between 
child processes launched with <a href="#spawn">spawn</a> and their parent 
process. The message received replaces the contents in <em>sym-message.</em></p>

<p>関数は起動される度に <em>int-pid</em> の受信キューからメッセージを一つ読み取ります。
キューが空の時は <tt>nil</tt> が返ります。<br />
The function reads one message from the receiver queue of <em>int-pid</em>
for each invocation. When the queue is empty, <tt>nil</tt> is returned.</p>

<!-- example -->

<pre>
; sending process
(send spid "hello")  <span class='arw'>&rarr;</span> true

; receiving process
(receive pid msg)    <span class='arw'>&rarr;</span> true
msg                  <span class='arw'>&rarr;</span> "hello"
</pre>

<p>関数 <tt>receive</tt> をブロッキングしてメッセージが届くまで待たせるには、次の形をとります：<br />
To make <tt>receive</tt> blocking and wait for arriving messages,
use the following form:</p>

<pre>
; wait until a message can be read
(until (receive pid msg))
</pre>

<p>キューからメッセージを読みだせるようになるまで、この関数はループします。<br />
The function will loop until a message can be read from the queue.</p>

<p>この関数の第二構文は、親プロセスからのメッセージを保留している子プロセスの全リストを返します：<br />
In the second syntax, the function returns a list of all child processes
with pending messages for the parent process:</p>

<!-- example -->
<pre>
; read pending messages from child processes
(dolist (pid (receive))
    (receive pid msg)
    (println "received message: " msg " from:" pid)
)
</pre>

<p><tt>(receive)</tt> で返される子プロセス ID のリストには、読み取られていないメッセージを送信キューに持っているプロセスの PID のみが入ります。
これにより、保留中のメッセージが子プロセスのメッセージ・キューにあることが常に保証され、<tt>(receive pid msg)</tt> 宣言文がノン・ブロッキングで実行されます。<br />
The list of child process IDs returned by <tt>(receive)</tt> only
contains PIDs of processes which have unread messages in their 
send queues. The <tt>(receive pid msg)</tt> statement now can
be issued non-blocking, because it always is guaranteed to find
a pending message in a child's message queue.</p>

<p>関数 <tt>receive</tt> は MS Windows では使えません。<br />
The <tt>receive</tt> function is not available on MS Windows.</p>

<p>この関数と例題のより詳細な議論は、関数 <a href="#send">send</a> を見てください。<br />
For a more detailed discussion of this function and examples, see the
<a href="#send">send</a> function.</p>

<br/><br/>

<a name="ref"></a>
<h2><span class="function">ref</span></h2>
<h4>syntax: (ref <em>exp-key</em> <em>list</em> [<em>func-compare</em> [true]])</h4>

<p><tt>ref</tt> はキー式 <em>exp-key</em> を <em>list</em> 中で検索し、整数インデックスのリストを返します。
<em>exp-key</em> が見つからない時は空リストを返します。
インデックスのリストが使える <a href="#push">push</a> や <a href="#pop">pop</a> と一緒に、<tt>ref</tt> を使うことができます。<br />
<tt>ref</tt> searches for the key expression <em>exp-key</em> in <em>list</em> and 
returns a list of integer indices or an empty list if <em>exp-key</em> cannot be 
found.  <tt>ref</tt> can work together with <a href="#push">push</a> and 
<a href="pop">pop</a>, both of which can also take lists of indices.</p>

<p>デフォルトの <tt>ref</tt> は、式が等しいかどうかをチェックします。
より複雑な比較関数を <em>func-compare</em> に使うこともできます。
比較関数を前もって定義しておくことも可能です。
この関数が関数内部で第二引数しか使わない場合でも、常に引数を二つとることに注意してください（訳注：第一引数に <em>exp-key</em> が、第二引数に <em>list</em> の要素が入ります）。<br />
By default, <tt>ref</tt> checks if expressions are equal. With <em>func-compare</em>, 
more complex comparison functions can be used. The comparison function can be a 
previously defined function. Note that this function always takes two arguments,
even if only the second argument is used inside the function.</p>

<p>オプションの <tt>true</tt> パラメータがある時は、インデックス・ベクトルの代わりに見つかった要素が返ります。<br />
When the optional <tt>true</tt> parameter is present, the element found
is returned instead of the index vector.</p>

<!-- example -->

<pre>
; get index vectors for list elements

(set 'pList '(a b (c d (x) e)))

(ref 'x pList)    <span class='arw'>&rarr;</span> (2 2 0)

(ref '(x) pList)   <span class='arw'>&rarr;</span> (2 2)

; the key expression is in a variable

(set 'p '(c d (x) e))

(ref p pList)   <span class='arw'>&rarr;</span> (2)

; indexing using the vector returned from ref

(set 'v (ref '(x) pList)) <span class='arw'>&rarr;</span> (2 2)

(pList v) <span class='arw'>&rarr;</span> (x)

; if nothing is found, nil is returned

(ref 'foo plist)  <span class='arw'>&rarr;</span> nil

; not specifying a comparison functor assumes =

(set 'L '(a b (c d (e) f)))

(ref 'e L)      <span class='arw'>&rarr;</span> (2 2 0)
(ref 'e L =)    <span class='arw'>&rarr;</span> (2 2 0)

; a is the first symbol where e is greater

(ref 'e L &gt;)  <span class='arw'>&rarr;</span> (0)

; return the element instead of the index

(ref 'e L &gt; true)  <span class='arw'>&rarr;</span> a

; use an anonymous comparison function

(ref 'e L (fn (x y) (or (= x y) (= y 'd))))      <span class='arw'>&rarr;</span> (2 1)

(ref 'e L (fn (x y) (or (= x y) (= y 'd))) true) <span class='arw'>&rarr;</span> d
</pre>


<p>次の例は、文字列に対する正規表現と同じくらい強力な検索を提供する <a href="#match">match</a> や <a href="#unify">unify</a> の使い方を示しています：<br />
The following example shows the use of 
<a href="#match">match</a> and <a href="#unify">unify</a> 
to formulate searches that are as powerful as regular expressions are 
for strings:
</p>


<pre>
(set 'L '((l 3) (a 12) (k 5) (a 10) (z 22)))

; use match as a comparison function

(ref '(a ?) L match) <span class='arw'>&rarr;</span> (1)

; use unify as a comparison function

(set 'L '( ((a b) (c d)) ((e e) (f g)) ))

(ref '(X X) L unify)      <span class='arw'>&rarr;</span> (1 0)

(ref '(X g) L unify)      <span class='arw'>&rarr;</span> (1 1)

(ref '(X g) L unify true) <span class='arw'>&rarr;</span> (f g)
</pre>


<p><a href="#unify">unify</a> と一緒の <tt>'(X X)</tt> パターンは、二つの要素が同じリスト・ペアを検索します。
<tt>unify</tt> のパターン <tt>'(X g)</tt> は、二番目の要素がシンボル <tt>g</tt> であるリスト・ペアを検索します。
パターンには、評価されないようにクォートを付けます。<br />
The <tt>'(X X)</tt> pattern with <a href="#unify">unify</a> searches for a list pair 
where the two elements are equal.  The <tt>unify</tt> pattern <tt>'(X g)</tt>
searches for a list pair with the symbol <tt>g</tt> as the second member.
The patterns are quoted to protect them from evaluation.</p>

<p>デフォルト・ファンクタでリストを渡すと：<br />
Pass the list as a default functor:</p>

<pre>
(set 'C:C '(a b (c d) e f))

(ref 'd C)  <span class='arw'>&rarr;</span> (2 1)
</pre>

<p>リストを渡すには、コンテキストを使った参照が適切です。
<a href="#pass_big">参照によるデータの受け渡し</a> の章も見てください。<br />
This is suitable when passing lists by reference using a context. See also
the chapter <a href="#pass_big">Passing data by reference</a>.</p>

<p>入れ子リストでのキー式を全て検索する関数 <a href="#ref-all">ref-all</a> も見てください。<br />
 See also the <a href="#ref-all">ref-all</a> function, which searches for all occurrences
of a key expression in a nested list. </p>

<br/><br/>

<a name="ref-all"></a>
<h2><span class="function">ref-all</span></h2>
<h4>syntax: (ref-all <em>exp-key</em> <em>list</em> [<em>func-compare</em> [true]])</h4>

<p><a href="#ref">ref</a> のように動作しますが、<em>list</em> 中で見つかった <em>exp-key</em> の全インデックス・ベクトルをリストで返します。<br />
Works similarly to <a href="#ref">ref</a>, but returns a list of all index vectors found 
for <em>exp-key</em> in <em>list</em>. </p>

<p>オプションの <tt>true</tt> パラメータがある時は、インデックス・ベクトルの代わりに見つかった要素が返ります。<br />
When the optional <tt>true</tt> parameter is present, the elements found
is returned of the index vectors.</p>

<p>デフォルトの <tt>ref-all</tt>は、式が等しいかどうかをチェックします。
より複雑な比較関数を <em>func-compare</em> に使うこともできます。<br />
By default, <tt>ref-all</tt> checks if expressions are equal. 
With <em>func-compare</em>, more complex comparison functions can be used.
</p>

<p>システム変数 <tt>$count</tt> には、見つかった要素数が入ります。<br />
The system variable <tt>$count</tt> counts the number of elements found.</p>

<!-- example -->

<pre>
(set 'L '(a b c (d a f (a h a)) (k a (m n a) (x))))

(ref-all 'a L) <span class='arw'>&rarr;</span> ((0) (3 1) (3 3 0) (3 3 2) (4 1) (4 2 2))

; the index vector returned by ref-all can be used to index the list

(L '(3 1)) <span class='arw'>&rarr;</span> a

; mapped implicit indexing of L 

(map 'L (ref-all 'a L)) <span class='arw'>&rarr;</span> (a a a a a a)

; with comparison operator

(set 'L '(a b c (d f (h l a)) (k a (m n) (x))))

; not specifying a comparison functor assumes =

(ref-all 'c L)       <span class='arw'>&rarr;</span> ((2))
(ref-all 'c L =)     <span class='arw'>&rarr;</span> ((2))

; look for all elements where c is greater

(ref-all 'c L &gt;)       <span class='arw'>&rarr;</span> ((0) (1) (3 2 2) (4 1))
(ref-all 'c L &gt; true)  <span class='arw'>&rarr;</span> (a b a a)


; use an anonymous function to compare

(ref-all 'a L (fn (x y) (or (= x y) (= y 'k))))  
<span class='arw'>&rarr;</span> ((0) (3 2 2) (4 0) (4 1))

; the key is nil because the comparison function only looks at the second argument

(ref-all nil L (fn (x y) (&gt; (length y) 2)))      
<span class='arw'>&rarr;</span> ((3) (3 2) (4))

; define the comparison functions first

(define (is-long? x y) (&gt; (length y) 2)) ; the x gets occupied by 'nil

(ref-all nil L is-long?)    <span class='arw'>&rarr;</span>  ((3) (3 2) (4))

(define (is-it-or-d x y) (or (= x y) (= y 'd)))

(set 'L '(a b (c d (e) f)) )

(ref-all 'e L is-it-or-d)  <span class='arw'>&rarr;</span> ((2 1) (2 2 0))
</pre>


<p>比較関数を前もって定義しておくことも可能です。
比較関数は、（<tt>is-long?</tt> を使った例のように）関数の中で第二引数しか使わない場合でも、常に引数を二つ持つことに注意してください
（訳注：第一引数に <em>exp-key</em> が、第二引数に <em>list</em> の要素が入ります）。<br />
The comparison function can be a previously defined function. 
Note that the comparison function always takes two arguments, 
even if only the second argument is used 
inside the function (as in the example using <tt>is-long?</tt>).
</p>

<p>関数 <a href="#match">match</a> や <a href="#unify">unify</a> を使うと、文字列に対する正規表現と同じくらい強力なリスト検索が可能です。<br />
Using the <a href="#match">match</a> and <a href="#unify">unify</a> functions, list 
searches can be formulated that are as powerful as regular expression searches are 
for strings.
</p>


<pre>
(set 'L '((l 3) (a 12) (k 5) (a 10) (z 22)) )

; look for all pairs staring with the symbol a

(ref-all '(a ?) L match)      <span class='arw'>&rarr;</span> ((1) (3))
(ref-all '(a ?) L match true) <span class='arw'>&rarr;</span> ((a 12) (a 10))

; look for all pairs where elements are equal

(set 'L '( ((a b) (c d)) ((e e) (f g)) ((z) (z))))

(ref-all '(X X) L unify)      <span class='arw'>&rarr;</span> ((1 0) (2))
(ref-all '(X X) L unify true) <span class='arw'>&rarr;</span> ((e e) ((z) (z)))

; look for all pairs where the second element is the symbol g

(set 'L '( ((x y z) g) ((a b) (c d)) ((e e) (f g)) ))

(ref-all '(X g) L unify)      <span class='arw'>&rarr;</span> ((0) (2 1))
(ref-all '(X g) L unify true) <span class='arw'>&rarr;</span> (((x y z) g) (f g))
</pre>

<p>関数 <a href="#ref">ref</a> も見てください。<br />
 See also the <a href="#ref">ref</a> function. </p>

<br/><br/>

<a name="regex"></a>

<h2><span class="function">regex</span></h2>
<h4>syntax: (regex <em>str-pattern</em> <em>str-text</em> [<em>regex-option</em> [<em>int-offset</em>]])</h4>

<p><em>str-pattern</em> で指定されたパターンの Perl コンパチブル正規表現 (PCRE) 検索を <em>str-text</em> に対して実行します。
同じ正規表現パターン・マッチングが、文字列を扱う関数 <a href="#directory">directory</a>、<a href="#find">find</a>、<a href="#find-all">find-all</a>、<a href="#parse">parse</a>、<a href="#replace">replace</a>、<a href="#search">search</a> でもサポートされています。<br />
Performs a Perl Compatible Regular Expression (PCRE) search 
on <em>str-text</em> with the pattern specified in <em>str-pattern</em>. 
The same regular expression pattern matching 
is also supported in the functions <a href="#directory">directory</a>, 
<a href="#find">find</a>, <a href="#find-all">find-all</a>, 
<a href="#parse">parse</a>, <a href="#replace">replace</a>, 
and <a href="#search">search</a> when using these functions on strings.
</p>

<p><tt>regex</tt> は、一致した文字列と部分文字列、テキスト中の各文字列の開始位置と長さのリストを返します。
一致しなかった時は <tt>nil</tt> を返します。
オフセットの数値は、後に続く手続きの中で使えます。<br />
<tt>regex</tt> returns a list with the matched strings and substrings 
and the beginning and length of each string inside the text. 
If no match is found, it returns <tt>nil</tt>.
The offset numbers can be used for subsequent processing.
</p>

<p>追加で、後で説明する正規表現の制御用 <em>regex-option</em> を指定できます。
オプションは、数値と文字列による文字のどちらかで与えられます。<br />
Addtionally an <em>regex-option</em> can be specified to control certain
regular expression options explained later. Options can be given either by
numbers or letters in a string.</p>

<p>追加の <em>int-offset</em> パラメータは、マッチ検索の開始が文字列の先頭ではなくオフセット位置からであることを <tt>regex</tt> に知らせます。<br />
The additional <em>int-offset</em>
parameter tells <tt>regex</tt> to start searching for a match not at the
beginning of the string but at an offset.</p>

<p><em>regex-option</em> が無い時、<tt>regex</tt> の結果のオフセットと長さは UTF－8 版 newLISP であってもバイト単位で与えられます。
<em>regex-option</em> に PCRE_UTF8 オプションを指定した時のみ、オフセットと長さが UTF8 文字単位で報告されます。<br />
When no <em>regex-option</em> is present, the offset and length numbers in 
the <tt>regex</tt> results are given based bytes even when running the UTF-8 
enabled version of newLISP. When specifying the PCRE_UTF8 option in <em>regex-option</em>
only offset and length are reported in UTF8 characters.</p>

<p><tt>regex</tt> は、見つかった式と部分式を変数 <tt>$0, $1, $2&ndash;</tt> にもセットします。
他の newLISP シンボルと同じように、これらの変数とその等価式 <tt>($ 0), ($ 1), ($ 2)&ndash;</tt> は、続く手続きの中で他の newLISP 式と同じように使えます。<br />
<tt>regex</tt> also sets the variables <tt>$0, $1,</tt> 
and <tt>$2&mdash;</tt> 
to the expression and subexpressions found. 
Just like any other symbol in newLISP, 
these variables or their equivalent expressions 
<tt>($ 0), ($ 1),</tt> and <tt>($ 2)&mdash;</tt> can be used in other 
newLISP expressions for further processing.
</p>

<p>正規表現を使った関数は、一致が見つからなかった時には変数 <tt>$0, $1 ... $15</tt> を <tt>nil</tt> にリセットしません（訳注：この場合、前に一致した内容が入ってくることがありますので注意してください。<tt>regex</tt> の戻り値が <tt>nil</tt> だったなら、変数 <tt>$0, $1 ... $15</tt> は使わない方が賢明です）。<br />
Functions using regular expressions will not reset the <tt>$0, $1 ... $15</tt> 
variables to <tt>nil</tt> when no match is found.</p>

<!-- example -->

<pre>
(regex "b+" "aaaabbbaaaa")  <span class='arw'>&rarr;</span> ("bbb" 4 3)

; case-insensitive search option 1
(regex "b+" "AAAABBBAAAA" 1)  <span class='arw'>&rarr;</span> ("BBB" 4 3) 

(regex "[bB]+" "AAAABbBAAAA" )  <span class='arw'>&rarr;</span> ("BbB" 4 3)

(regex "http://(.*):(.*)" "http://nuevatec.com:80") 
<span class='arw'>&rarr;</span> ("http://nuevatec.com:80" 0 22 "nuevatec.com" 7 12 "80" 20 2)

$0  <span class='arw'>&rarr;</span> "http://nuevatec.com:80"
$1  <span class='arw'>&rarr;</span> "nuevatec.com"
$2  <span class='arw'>&rarr;</span> "80"

(dotimes (i 3) (println ($ i)))
<b>http://nuevatec.com:80
nuevatec.com
80</b>
<span class='arw'>&rarr;</span> "80"
</pre>


<p>二番目の例はオプションの使い方を示し、三番目の例は検索パターン中の括弧によってマークされた二つの部分式による複雑な分解を実演しています。
最後の例では、式と部分式がシステム変数 <tt>$0</tt> ～ <tt>$2</tt> あるいは 等価式 <tt>($ 0)</tt> ～ <tt>($ 2)</tt> を使って取り出されています。<br />
	The second example shows the usage of extra options,
	while the third example demonstrates more complex parsing of two subexpressions
	that were marked by parentheses in the search pattern.
	In the last example,
	the expression and subexpressions are retrieved using the system variables 
	<tt>$0</tt> to <tt>$2</tt> or their equivalent expression <tt>($ 0)</tt> to <tt>($ 2)</tt>.
</p>

<p>バックスラッシュ文字を含む文字列を囲むために <tt>""</tt>（引用符）が使われている時は、正規表現パターン中でバックスラッシュを二重にする必要があります。
代わりの文字列の区切りに、<tt>{ }</tt>（波括弧）か <tt>[text]</tt> と <tt>[/text]</tt>（テキスト・タグ）が使えます。
これらの場合には、余計なバックスラッシュが要求されません。<br />
	When <tt>""</tt> (quotes) are used 
	to delimit strings 
	that include literal backslashes, 
	the backslash must be doubled in the regular expression pattern.
	As an alternative, <tt>{ }</tt> (curly brackets) 
	or <tt>[text]</tt> and <tt>[/text]</tt> (text tags) 
	can be used to delimit text strings.
	In these cases, no extra backslashes are required.
</p>

<p>バックスラッシュでエスケープされる newLISP 文字（例えば、引用符 <tt>\"</tt> とか <tt>\n</tt> とか）は、引用符で囲まれている正規表現パターン内でも（訳注：バックスラッシュを）二重化する必要はありません。<br />
	Characters escaped by a backslash in newLISP 
	(e.g., the quote <tt>\"</tt> or <tt>\n</tt>) 
	need not to be doubled in a regular expression pattern, 
	which itself is delimited by quotes.
</p>


<pre>
;; double backslash for parentheses and other special char in regex
(regex "\\(abc\\)" "xyz(abc)xyz")  <span class='arw'>&rarr;</span> ("(abc)" 3 5)
;; double backslash for backslash (special char in regex)
(regex "\\d{1,3}" "qwerty567asdfg")  <span class='arw'>&rarr;</span> ("567" 6 3)

;; one backslash for quotes (special char in newLISP)
(regex "\"" "abc\"def")  <span class='arw'>&rarr;</span> ("\"" 3 1)     

;; brackets as delimiters
(regex {\(abc\)} "xyz(abc)xyz")  <span class='arw'>&rarr;</span> ("(abc)" 3 5)  

;; brackets as delimiters and quote in pattern
(regex {"} "abc\"def")  <span class='arw'>&rarr;</span> ("\"" 3 1)     

;; text tags as delimiters, good for multiline text in CGI
(regex [text]\(abc\)[/text] "xyz(abc)xyz")  <span class='arw'>&rarr;</span> ("(abc)" 3 5)  
(regex [text]"[/text] "abc\"def")           <span class='arw'>&rarr;</span> ("\"" 3 1) 
</pre>


<p>引用符の代わりに波括弧かテキスト・タグがパターン文字列の囲みに使われている時は、一個のバックスラッシュで十分です。
そして、パターンと文字列はそのままの形で正規表現ルーチンに渡されます。
波括弧で区切られたパターン内で波括弧が使われる時は、次のように内部の波括弧がバランスされていなければなりません：<br />
	When curly brackets or text tags 
	are used to delimit the pattern string 
	instead of quotes, 
	a simple backslash is sufficient. 
	The pattern and string are then passed in raw form 
	to the regular expression routines.
	When curly brackets are used inside a pattern 
	itself delimited by curly brackets,
	the inner brackets must be balanced, as follows:
</p>


<pre>
;; brackets inside brackets are balanced
(regex {\d{1,3}} "qwerty567asdfg")  <span class='arw'>&rarr;</span> ("567" 6 3) 
</pre>



<p>次の定数が <em>regex-option</em> で使えます。
いくつかのオプションは、バイナリか <tt>|</tt>（パイプ）演算子を使って結合できます。
例えば、<tt>(| 1 4)</tt> は、オプション <tt>1</tt> と <tt>4</tt> を結合します（訳注：<tt>|</tt> は<a href="#bit_inclusive">ビット OR 演算子</a>です）。
大文字の名称は <a href="http://www.planewave.org/translations/pcre-3.4/pcre.ja.3.html">PCRE regex ドキュメント</a>で使われているもので、<tt>init.lsp</tt> に前もって定義しておけばよいでしょう。
<br />
The following constants can be used for <em>regex-option</em>.
Several options can be combined using a binary or <tt>|</tt> (pipe) operator. 
E.g. <tt>(| 1 4)</tt> would combine options <tt>1</tt> and <tt>4</tt> or <tt>"is"</tt>
when using letters for the two options.</p>

<p>最後の二つのオプションは newLISP 専用オプションです。REPLACE_ONCE オプションは <a href="#replace">replace</a> でのみ使え、他の PCRE オプションと組み合わせることができます。<br />
The last two options are specific for newLISP. The REPLACE_ONCE option is only 
to be used in <a href="#replace">replace</a>; it can be combined with other PCRE options.</p>

<p>複数のオプションは <tt>+</tt> (プラス) や <tt>|</tt> (or) 演算子を使って組み合わせることができます。例えば： <tt>(| PCRE_CASELESS PCRE_DOTALL)</tt> や文字を使ったオプション指定 <tt>"is"</tt> 。<br />
Multiple options can be combined using a <tt>+</tt> (plus) or <tt>|</tt> (or) operator,
e.g.: <tt>(| PCRE_CASELESS PCRE_DOTALL)</tt> or <tt>"is"</tt> when using letters as options.
</p>

<table width="98%" summary="regex options">
<tr align="left"><th>PCRE name</th><th>no</th><th>description</th></tr>
<tr><td>PCRE_CASELESS</td><td>1 or i</td><td>大文字を小文字として扱う<br />treat uppercase like lowercase</td></tr>
<tr><td>PCRE_MULTILINE</td><td>2 or m</td><td>Perl の /m のように改行で検索が制限されます。<br>（訳注： 行頭 (^) と行末 ($) が一行毎に使えるようになる ）<br />limit search at a newline like Perl's /m</td></tr>
<tr><td>PCRE_DOTALL</td><td>4 or s</td><td>. (dot) が改行にもマッチします。<br />. (dot) also matches newline</td></tr>
<tr><td>PCRE_EXTENDED</td><td>8 or x</td><td>文字クラス内以外の空白文字を無視します。<br />ignore whitespace except inside char class</td></tr>
<tr><td>PCRE_ANCHORED</td><td>16 or A</td><td>（訳注：検索位置を）文字列の先頭に固定します。<br />anchor at the start</td></tr>
<tr><td>PCRE_DOLLAR_ENDONLY</td><td>32 or D</td><td>$ は、改行の前ではない文字列の最後での一致を試みます。<br />$ matches at end of string, not before newline</td></tr>
<tr><td>PCRE_EXTRA</td><td>64</td><td>この付加機能は、現在使えません。<br />additional functionality currently not used</td></tr>
<tr><td>PCRE_NOTBOL</td><td>128</td><td>行の先頭でない最初の文字が ^ で一致しなくなります。<br>（訳注：PCRE_MULTILINE と一緒に使う）<br />first ch, not start of line; ^ shouldn't match</td></tr>
<tr><td>PCRE_NOTEOL</td><td>256</td><td>行の終わりでない最後の文字が $ で一致しなくなります。<br>（訳注：PCRE_MULTILINE と一緒に使う）<br />last char, not end of line; $ shouldn't match</td></tr>
<tr><td>PCRE_UNGREEDY</td><td>512 or U</td><td>量指定子の貪欲さを反転します。<br>（訳注：最小の一致を見つける時に使う）<br />invert greediness of quantifiers</td></tr>
<tr><td>PCRE_NOTEMPTY</td><td>1024</td><td>空文字列は、無効になります。<br />empty string considered invalid</td></tr>
<tr><td>PCRE_UTF8</td><td>2048 or u</td><td>パターンと文字列が、UTF-8文字になります。<br />pattern and strings as UTF-8 characters</td></tr>
<tr><td>REPLACE_ONCE</td><td>0x8000</td><td><a href="#replace">replace</a>で使われた時のみ、一回だけ置換されます。<br />replace only one occurrence only for use in <a href="#replace">replace</a></td></tr>
<tr><td>PRECOMPILED</td><td>0x10000 or p</td><td>パターンは、プリ・コンパイルされ、RREPLACE_ONCE 0x8000とだけ結合できます。<br />pattern is pre-compiled, can only be combined with RREPLACE_ONCE 0x8000</td></tr>
</table><br/>

<p>PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, PCRE_EXTENDED オプションの設定は、
"(?" と ")" で囲まれたオプション文字シーケンスによるパターン内でも変更できます。
オプション文字は、次の通り：<br />
The settings of the PCRE_CASELESS, PCRE_MULTILINE, PCRE_DOTALL, and PCRE_EXTENDED 
options can be changed from within the pattern by a sequence of option letters enclosed 
between "(?" and ")". The option letters are:</p>

<table summary="regex inline options">
<tr><td>i</td><td>for PCRE_CASELESS</td></tr>
<tr><td>m</td><td>for PCRE_MULTILINE</td></tr>
<tr><td>s</td><td>for PCRE_DOTALL</td></tr>
<tr><td>x</td><td>for PCRE_EXTENDED</td></tr>
</table><br/>

<p>正規表現構文は多くの特殊文字と形式により非常に複雑で特徴に富んでいるので、気を付けてください。
どうか、詳細を書籍か PCRE マニュアル・ページで調べてください。
多くの PERL 本や Linux または Unix の紹介は正規表現の章を持っています。
さらなるリファレンスとマニュアルのページとして、<a href="http://www.pcre.org/">http://www.pcre.org</a> を見てください。<br />
Note that regular expression syntax is very complex 
and feature-rich with many special characters and forms.
Please consult a book or the PCRE manual pages for more detail.
Most PERL books or introductions to Linux or Unix 
also contain chapters about regular expressions.
See also <a href="http://www.pcre.org">http://www.pcre.org</a> 
for further references and manual pages.  </p>

<p><a href="#regex-comp">regex-comp</a> を使えば、正規表現パターンの反復の多いパターンを高速用にプリコンパイルできます。<br />
Regular expression patterns can be precompiled for higher speed when using 
changing repetitive patterns with <a href="#regex-comp">regex-comp</a>.</p>

<br/><br/>

<a name="regex-comp"></a>
<h2><span class="function">regex-comp</span></h2>
<h4>syntax: (regex-comp <em>str-pattern</em> [<em>int-option</em>])</h4>

<p>newLISP は自動的に正規表現パターンをコンパイルし、反復の多いパターン検索を高速化するために最後の編集をキャッシュします。
パターンを次から次へと変化させて幾重にも繰り返すならば、最後のパターンのキャッシュでも十分ではありません。
<tt>regex-comp</tt> は、正規表現検索の高速化のために反復の多いパターンをプリ・コンパイルするために使えます：<br />
newLISP automatically compiles regular expression patterns and caches 
the last compilation to speed up repetitive pattern searches. If patterns
change from one to the next, but are repeated over and over again, then 
the caching of the last pattern is not sufficient. <tt>regex-comp</tt>
can be used to pre-compile repetitive patterns to speed up regular 
expression searches:</p>


<!-- example -->

<pre>
; slower without pre-compilation

(dolist (line page)
	(replace pattern-str1 line repl1 0)
	(replace pattern-str2 line repl2 512)
)

; fast with pre-compilation and option 0x10000

(set 'p1 (regex-comp pattern-str1))
(set 'p2 (regex-comp pattern-str2 512))

(dolist (line page)
	(replace p1 line repl1 0x10000)
	(replace p2 line repl2 0x10000)
)
</pre>


<p>正規表現を使う関数でパターンのプリ・コンパイルを使う時は <tt>0x10000</tt> をセットして、プリ・コンパイルされたパターンの使用を合図します。
通常の正規パターン・オプションは <tt>regex-comp</tt> でプリ・コンパイルする際に指定します。
<a href="#replace">replace</a> で使う時のみ、<tt>0x10000</tt> オプションを一回だけの置換を指定するオプション <tt>0x8000</tt> と結合できます。<br />
When using pre-compiled patterns in any of the functions using regular
expressions, the option number is set to <tt>0x10000</tt> to signal
that pre-compiled patterns are used. Normal pattern options are specified
 during pre-compilation with <tt>regex-comp</tt> . The <tt>0x10000</tt> option 
can only be combined with <tt>0x8000</tt>, the option used to specify that only 
one replacement should be made when using <a href="#replace">replace</a>.</p>

<p>関数 <a href="#ends-with">ends-with</a> は内部に非コンパイル・パターンを付加しようするので、コンパイル・パターンと一緒には使うべきではありません。<br />
The function <a href="#ends-with">ends-with</a> should not be used with compiled 
patterns, as it tries to append to an un-compiled pattern internally.</p>

<br/><br/>

<a name="remove-dir"></a>
<h2><span class="function">remove-dir</span></h2>
<h4>syntax: (remove-dir <em>str-path</em>)</h4>

<p><em>str-path</em> で指定されたパス名のディレクトリを削除します。
<tt>remove-dir</tt> を成功させるには、ディレクトリが空である必要があります。
失敗すると、<tt>nil</tt> を返します。<br />
	Removes the directory
	whose path name is specified in <em>str-path</em>.
	The directory must be empty for <tt>remove-dir</tt> to succeed.
	Returns <tt>nil</tt> on failure.
</p>

<!-- example -->

<pre>
(remove-dir "temp")
</pre>


<p>カレント・ディレクトリの <tt>temp</tt> を削除します。<br />
	Removes the directory <tt>temp</tt> 
	in the current directory.
</p>

<br/><br/>

<a name="rename-file"></a>
<h2><span class="function">rename-file</span></h2>
<h4>syntax: (rename-file <em>str-path-old</em> <em>str-path-new</em>)</h4>

<p>パス名 <em>str-path-old</em> で与えられたファイルやディレクトリを <em>str-path-new</em> で与えられた名前に変更します。
操作の結果次第で、<tt>nil</tt> か <tt>true</tt> が返ります。<br />
Renames a file or directory entry given in the path name <em>str-path-old</em> 
to the name given in <em>str-path-new</em>. Returns <tt>nil</tt> or <tt>true</tt> 
depending on the operation's success.
</p>

<!-- example -->

<pre>
(rename-file "data.lisp" "data.backup")
</pre>

<br/><br/>

<a name="replace"></a>
<h2><span class="function">replace</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (replace <em>exp-key</em> <em>list</em> <em>exp-replacement</em> [<em>func-compare</em>])<br/>
syntax: (replace <em>exp-key</em> <em>list</em>)<br/><br/>

syntax: (replace <em>str-key</em> <em>str-data</em> <em>exp-replacement</em>)<br/>
syntax: (replace <em>str-pattern</em> <em>str-data</em> <em>exp-replacement</em> <em>regex-option</em>)</h4>

<h3>List replacement（リストの置換）</h3>

<p><tt>replace</tt> は第二引数がリストなら、リスト <em>list</em> の中で式 <em>exp-key</em> に等しい要素を全て置換します。
要素は <em>exp-replacement</em> に置換されます。
<em>exp-replacement</em> が無い時は、<em>list</em> から <em>exp-key</em> が削除されます。<br />
If the second argument is a list, <tt>replace</tt> replaces all elements in
the list <em>list</em> that are equal to the expression in <em>exp-key</em>. The 
element is replaced with <em>exp-replacement</em>. If <em>exp-replacement</em>
is missing, all instances of <em>exp-key</em> will be deleted from <em>list</em>.
</p>

<p><tt>replace</tt> が破壊的であることに注意してください。
渡されたリストは変更され、その変更されたリストが返ります。
関数から戻った時、置換された数はシステム変数 <tt>$count</tt> に入ります。
置換式を実行中、アナフォリック・システム変数 <tt>$it</tt> には置換された式が入っています。<br />
Note that <tt>replace</tt> is 
destructive. It changes the list passed to it and returns the changed list. The 
number of replacements made is contained in the system variable <tt>$count</tt> 
when the function returns. During executions of the replacement expression, the 
anaphoric system variable <tt>$it</tt> is set to the expression to be replaced.
</p>

<p>オプションで、<em>func-compare</em> に比較演算子かユーザ定義関数を指定できます。
デフォルトで、<em>func-compare</em> は <tt>=</tt>（等号記号）です。<br />
Optionally, <em>func-compare</em> can specify a comparison operator 
or user-defined function. By default, <em>func-compare</em> is the <tt>=</tt> 
(equals sign).</p>

<!-- example -->

<pre>
;; list replacement

(set 'aList '(a b c d e a b c d))

(replace 'b aList 'B)  <span class='arw'>&rarr;</span> (a B c d e a B c d)
aList  <span class='arw'>&rarr;</span> (a B c d e a B c d)
$count <span class='arw'>&rarr;</span> 2  ; number of replacements

;; list replacement with special compare functor/function

; replace all numbers where 10 &lt; number
(set 'L '(1 4 22 5 6 89 2 3 24))

(replace 10 L 10 &lt;) <span class='arw'>&rarr;</span> (1 4 10 5 6 10 2 3 10)
$count <span class='arw'>&rarr;</span> 3

; same as:

(replace 10 L 10 (fn (x y) (&lt; x y))) <span class='arw'>&rarr;</span> (1 4 10 5 6 10 2 3 10)

; change name-string to symbol, x is ignored as nil

(set 'AL '((john 5 6 4) ("mary" 3 4 7) (bob 4 2 7 9) ("jane" 3)))

(replace nil AL (cons (sym ($it 0)) (rest $it)) 
                (fn (x y) (string? (y 0)))) ; parameter x = nil not used
<span class='arw'>&rarr;</span> ((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3))

; use $count in the replacement expression
(replace 'a '(a b a b a b) (list $count $it) =) <span class='arw'>&rarr;</span>  ((1 a) b (2 a) b (3 a) b)
</pre>


<p>関数 <a href="#match">match</a> や <a href="#unify">unify</a> を使うと、正規表現文字列検索と同じくらい強力にリスト検索が定型化されます：<br />
Using the <a href="#match">match</a> and <a href="#unify">unify</a> functions,
list searches can be formulated that are as powerful as regular expression string 
searches:</p>


<pre>
; calculate the sum in all associations with 'mary

(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))

(replace '(mary *)  AL (list 'mary (apply + (rest $it))) match)
<span class='arw'>&rarr;</span> ((john 5 6 4) (mary 14) (bob 4 2 7 9) (jane 3))
$count <span class='arw'>&rarr;</span> 1

; make sum in all expressions

(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))

(replace '(*) AL (list ($it 0) (apply + (rest $it))) match)
<span class='arw'>&rarr;</span> ((john 15) (mary 14) (bob 22) (jane 3))
$count <span class='arw'>&rarr;</span> 4

; using unify, replace only if elements are equal
(replace '(X X) '((3 10) (2 5) (4 4) (6 7) (8 8)) (list ($it 0) 'double ($it 1)) unify)
<span class='arw'>&rarr;</span> ((3 10) (2 5) (4 double 4) (6 7) (8 double 8))
 </pre>


<h3>List removal（リストからの削除）</h3>
<p>最後の形式の <tt>replace</tt> は、二つの引数 <em>exp</em> と <em>list</em> のみを持ちます。
この形式は、<em>list</em> 中に見つかった全ての <em>exp</em> を削除します。<br />
The last form of <tt>replace</tt> has only two arguments: the expression <em>exp</em> 
and <em>list</em>. This form removes all <em>exp</em>s found in <em>list</em>.
</p>

<!-- example -->

<pre>
;; removing elements from a list

(set 'lst '(a b a a c d a f g))
(replace 'a lst)  <span class='arw'>&rarr;</span> (b c d f g)
lst               <span class='arw'>&rarr;</span> (b c d f g)

$count <span class='arw'>&rarr;</span> 4
</pre>


<h3>String replacement without regular expression（正規表現無しの文字列置換）</h3>

<p>全引数が文字列なら、<tt>replace</tt> は <em>str-data</em> 中に出現した全ての <em>str-key</em> を <em>exp-replacement</em> の評価値に置き換えます。
式 <em>exp-replacement</em> は、置換対象用に全て評価されます。
置換した数はシステム変数 <tt>$0</tt> に入ります。
この形式の <tt>replace</tt> は、バイナリ <tt>0</tt>（ゼロ）も処理できます。<br />
If all arguments are strings, <tt>replace</tt> replaces all occurrences 
of <em>str-key</em> in <em>str-data</em> with the evaluated 
<em>exp-replacement</em>, returning the changed string. The expression in 
<em>exp-replacement</em> is evaluated for every replacement. The number of 
replacements made is contained in the system variable <tt>$0</tt>. This 
form of <tt>replace</tt> can also process binary <tt>0</tt>s (zeros).</p>

<!-- example -->

<pre>
;; string replacement
(set 'str "this isa sentence")
(replace "isa" str "is a")  <span class='arw'>&rarr;</span> "this is a sentence"

$count <span class='arw'>&rarr;</span> 1
</pre>


<h3>Regular expression replacement（正規表現による置換）</h3>
<p>第四パラメータの存在は、正規表現検索が実行されることを意味します。<em>str-pattern</em> に正規表現パターンを、<em>regex-option</em> にオプション番号（例えば、標準 Perl コンパチブル正規表現 (PCRE) 検索で大文字・小文字同一視をするかしないかを指定する <tt>1</tt>（一）やオプションなしの <tt>0</tt>（ゼロ）とか）を指定します。
（訳注：正規表現の）詳細は、<a href="#regex">regex</a> を見てください。<br />
The presence of a fourth parameter indicates that a regular expression search 
should be performed with a regular expression pattern specified in <em>str-pattern</em> 
and an option number specified in <em>regex-option</em> (e.g., <tt>1</tt> (one) for 
case-insensitive searching or <tt>0</tt> (zero) for a standard Perl Compatible Regular 
Expression (PCRE) search without options). See <a href="#regex">regex</a> above for details.
</p>

<p>デフォルトでは、検索パターン中に行頭指定が含まれていても、<tt>replace</tt> は検索文字列の全ての出現を置換します。
各置換の後、<em>str-data</em> の新しい位置からの新しい検索が開始されます。
<em>regex-option</em> にオプション・ビット <tt>0x8000</tt> を設定すれば、<tt>replace</tt> は最初の出現だけを置換します。
変更された文字列が返ります。<br />
By default, <tt>replace</tt> replaces all occurrences of a search string even if a 
beginning-of-line specification is included in the search pattern. 
After each replace, a new search is started at a new position in <em>str-data</em>.
Setting the option bit to <tt>0x8000</tt> in <em>regex-option</em> will force 
<tt>replace</tt> to replace only the first occurrence. The changed string is returned.
</p>

<p>正規表現を使った <tt>replace</tt> は、見つかった式と部分式の内容を内部変数 <tt>$0, $1, $2&ndash;</tt> にセットします。
アナフォリック・システム変数 <tt>$it</tt>に は、<tt>$0</tt> と同じ内容がセットされます。
これらを使って、置換中に見つかる内容に応じた置換を実現できます。
シンボル <tt>$it, $0, $1>$2&ndash;</tt> は、他のシンボルと同様に式として使えます。
置換式が文字列以外に評価された時は、置換が行われません。
変数の内容のアクセスには、代替方法として <tt>($ 0), ($ 1), ($ 2),</tt> 等々も使えます。
この方法は、インデックスによるアクセスを許可しています（例えば <tt>($ i)</tt>、ここで <tt>i</tt> は整数）。<br />
<tt>replace</tt> with regular expressions also sets the internal variables 
<tt>$0, $1,</tt> and <tt>$2&mdash;</tt> with the contents of the expressions 
and subexpressions found. The anaphoric system variable <tt>$it</tt> is set to
the same value as <tt>$0</tt>. These can be used to perform replacements 
that depend on the content found during replacement. The symbols <tt>$it, $0, $1,</tt> 
and <tt>$2&mdash;</tt> can be used in expressions just like any other symbols.
If the replacement expression evaluates to something other than a string,
no replacement is made. As an alternative, the contents of these variables can 
also be accessed by using <tt>($ 0), ($ 1), ($ 2),</tt> and so forth.
This method allows indexed access (e.g., <tt>($ i)</tt>,
where <tt>i</tt> is an integer).
</p>

<p>全ての置換終了後、置換した数がシステム変数 <tt>$0</tt> に入ります。<br />
After all replacements are made, the number of replacements 
is contained in the system variable <tt>$count</tt>.</p>

<!-- example -->

<pre>
;; using the option parameter to employ regular expressions

(set 'str "ZZZZZxZZZZyy")     <span class='arw'>&rarr;</span> "ZZZZZxZZZZyy"
(replace "x|y" str "PP" 0)  <span class='arw'>&rarr;</span> "ZZZZZPPZZZZPPPP"
str                           <span class='arw'>&rarr;</span> "ZZZZZPPZZZZPPPP"

;; using system variables for dynamic replacement

(set 'str "---axb---ayb---")
(replace "(a)(.)(b)" str (append $3 $2 $1) 0) 
<span class='arw'>&rarr;</span> "---bxa---bya---"

str  <span class='arw'>&rarr;</span> "---bxa---bya---"

;; using the 'replace once' option bit 0x8000

(replace "a" "aaa" "X" 0)  <span class='arw'>&rarr;</span> "XXX"

(replace "a" "aaa" "X" 0x8000)  <span class='arw'>&rarr;</span> "Xaa"

;; URL translation of hex codes with dynamic replacement

(set 'str "xxx%41xxx%42")
(replace "%([0-9A-F][0-9A-F])" str 
               (char (int (append "0x" $1))) 1)

str  <span class='arw'>&rarr;</span> "xxxAxxxB"

$count <span class='arw'>&rarr;</span> 2
</pre>


<p>関数 <a href="#setf">setf</a> を <a href="#nth">nth</a> や <a href="#first">first</a> や <a href="#last">last</a> と一緒に使っても、リストの内容変更ができます。<br />
The <a href="#setf">setf</a> function together with <a href="#nth">nth</a>,
<a href="#first">first</a> or <a href="#last">last</a> can also
be used to change elements in a list.</p>

<p>正規表現を使える他の関数 <a href="#directory">directory</a>、<a href="#find">find</a>、<a href="#find-all">find-all</a>、<a href="#parse">parse</a>、<a href="#regex">regex</a>、<a href="#search">search</a> も見てください。<br />
	See <a href="#directory">directory</a>,
	<a href="#find">find</a>,
	<a href="#find-all">find-all</a>,
	<a href="#parse">parse</a>,
	<a href="#regex">regex</a>, 
	and <a href="#search">search</a> 
	for other functions using regular expressions.
</p>

<br/><br/>

<a name="reset"></a>
<h2><span class="function">reset</span></h2>
<h4>syntax: (reset)<br/>
syntax: (reset true)<br/>
syntax: (reset <em>int-max-cells</em>)</h4>

<p>第一構文の <tt>reset</tt> は、<a href="#trace">trace</a> モードをオフにして、コンテキスト／名前空間を MAIN に切り替え、評価のトップ・レベルに戻ります。
<tt>reset</tt> は、トップ・レベルの変数環境をスタックに保存されていた変数環境に戻します。
このことは エラー "user reset - no error" も引き起こしますが、ユーザ定義のエラー・ハンドラで報告させることも可能です。
バージョン 10.5.5 からは、コマンド・ライン・パラメータ処理中でも中断します。<br />
In the first syntax, <tt>reset</tt> returns to the top level of evaluation,
switches the <a href="#trace">trace</a> mode off, and switches to the MAIN 
context/namespace. <tt>reset</tt> restores the top-level variable environment 
using the saved variable environments on the stack. It also throws an error 
"user reset - no error" which can be reported with user defined error handlers.
Since version 10.5.5 <tt>reset</tt> also interrupts command line parameter
processing.</p>

<p><tt>reset</tt> は全てのセル空間を通るので、重い負荷のかかったシステムでは数秒かかるかもしれません。<br />
<tt>reset</tt> walks through the entire cell space, 
which may take a few seconds in a heavily loaded system.</p>

<p>エラー条件が起こると、<tt>reset</tt> が自動的に起動します。<br />
<tt>reset</tt> occurs automatically after an error condition.</p>

<p>第二構文の <tt>reset</tt> はカレント・プロセスを止めて、同じコマンド・ライン・パラメータで新しい newLISP プロセスを開始します。
このモードは単に <tt>newlisp</tt> ではなく、例えば <tt>/usr/local/bin/newlisp</tt> のようにフルパス名の newLISP を使ってのみ開始され、作動します。
このモードは、MS Windows では利用できません。<br />
In the second syntax, <tt>reset</tt> will stop the current process 
and start a new clean newLISP process with the same command-line parameters.
This mode will only work when newLISP was started using its full path-name, 
e.g. <tt>/usr/local/bin/newlisp</tt> instead of only <tt>newlisp</tt>. This mode is 
not available on MS Windows.</p>

<p>第二構文の <tt>reset</tt> はシステムに許される最大セル数を変更します。
この数は <a href="#sys-info">sys-info</a> のリスト中二番目にあります。
64 ビットの newLISP では一セルが 32 バイト占有し、32 ビット版では 16 バイトです。
これには文字列のメモリは含まれていません、セルが文字列を指し示していますけど。<br />
In the third syntax. <tt>reset</tt> will change the maximum cell count allowed
in the system. This number is also reported as the second number in the list 
by <a href="#sys-info">sys-info</a>. On 64-bit newLISP one lisp cell occupies
32 bytes, or 16 bytes on the 32-bit version. This does not include
string memory, which may be pointed to by cells.</p>

<p>最小セル数は 4095 個です。試しにセル数を 4095 に指定してみましょう。
それ以上の割り当てを試すと、プログラムは終了します。<br />
The minimum cell count is 4095, trying to specify less will set it to 4095.
The program will exit when trying to allocate more.</p>

<pre>
(sys-info)  <span class='arw'>&rarr;</span> (437 576460752303423488 409 1 0 2048 0 60391 10602 1411)

; allocate about 1 Mbyte of cell memory on 64-bit newlisp
(reset 32768) <span class='arw'>&rarr;</span> true

(sys-info)  <span class='arw'>&rarr;</span> (437 32768 409 1 0 2048 0 60392 10602 1411)
</pre>

<p>最大セル数のリセットではシステムは再開始になりませんし、どの時点でも行うことができます。
セル・メモリーは最小構成でもある 4095 セルのブロック単位で割り当てられます。<br />
Resetting the maximum cell count will not restart the system and can be done at any point
in a program. Cell memory is allocated in blocks of 4095 cells, which is also initial 
minimum configuration.</p>

<br/><br/>

<a name="rest"></a>
<h2><span class="function">rest</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>

<h4>syntax: (rest <em>list</em>)<br/>
syntax: (rest <em>array</em>)<br/>
syntax: (rest <em>str</em>)</h4>

<p>リストや文字列の最初だけ除いた全てを返します。
<tt>rest</tt> は、他の Lisp 方言の <em>cdr</em> や <em>tail</em> と等価です。<br />
Returns all of the items in a list or a string, except for the first.
<tt>rest</tt> is equivalent to <em>cdr</em> or <em>tail</em> in other Lisp dialects.
</p>

<!-- example -->

<pre>
(rest '(1 2 3 4))            <span class='arw'>&rarr;</span> (2 3 4)
(rest '((a b) c d))          <span class='arw'>&rarr;</span> (c d)
(set 'aList '(a b c d e))    <span class='arw'>&rarr;</span> (a b c d e)
(rest aList)                 <span class='arw'>&rarr;</span> (b c d e)
(first (rest aList))         <span class='arw'>&rarr;</span> b
(rest (rest aList))          <span class='arw'>&rarr;</span> (d e)
(rest (first '((a b) c d)))  <span class='arw'>&rarr;</span> (b)

(set 'A (array 2 3 (sequence 1 6)))
<span class='arw'>&rarr;</span> ((1 2) (3 4) (5 6))

(rest A)  <span class='arw'>&rarr;</span> ((3 4) (5 6))

(rest '()) <span class='arw'>&rarr;</span> ()
</pre>


<p>第二構文の <tt>rest</tt> は、文字列 <em>str</em> の最初の文字以外の全てを返します。<br />
In the second version, <tt>rest</tt> returns all but the first character 
of the string <em>str</em> in a string.
</p>

<!-- example -->

<pre>
(rest "newLISP")          <span class='arw'>&rarr;</span> "ewLISP"
(first (rest "newLISP"))  <span class='arw'>&rarr;</span> "e"
</pre>


<p>関数 <a href="#first">first</a> と <a href="#last">last</a> も見てください。<br />
See also the <a href="#first">first</a> and <a href="#last">last</a> functions.
</p>

<p><em>暗黙表現の rest</em> がリストで使えることもお忘れなく。
<a href="#implicit_rest_slice"><tt>rest</tt> や <tt>slice</tt> 的な暗黙インデックス</a> の章を見てください。<br />
Note that an <em>implicit rest</em> is available for lists.
See the chapter <a href="#implicit_rest_slice">Implicit rest and slice</a>.
</p>

<p>UTF-8 版 newLISP が使われている時、<a href="#rest">rest</a> はバイト境界ではなく、キャラクタ境界で動作することに注意してください。<br />
Note that <a href="#rest">rest</a> works on character boundaries rather 
than byte boundaries when the UTF-8&ndash;enabled version of newLISP is used.</p>

<br/><br/>

<a name="reverse"></a>
<h2><span class="function">reverse</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (reverse <em>list</em>)<br/>
syntax: (reverse <em>array</em>)<br/>
syntax: (reverse <em>string</em>)</h4>

<p>第一及び第二構文の <tt>reverse</tt> は、<em>list</em> や <em>array</em> を反転して返します。
<tt>reverse</tt> は破壊的であり、元のリストを変更しますので注意してください。<br />
In the first and second form, <tt>reverse</tt> reverses and returns the 
<em>list</em> or <em>array</em>. Note that <tt>reverse</tt> is destructive 
and changes the original list or array.</p>

<!-- example -->

<pre>
; reverse a list
(set 'l '(a b c d e f))

(reverse l)  <span class='arw'>&rarr;</span> (f e d c b a)
l            <span class='arw'>&rarr;</span> (f e d c b a)
i
; reverse an array
(set 'a (array 3 2 '(1 2 3 4 5 6))) <span class='arw'>&rarr;</span> ((1 2) (3 4) (5 6))

(reverse a)                         <span class='arw'>&rarr;</span> ((5 6) (3 4) (1 2))
a                                   <span class='arw'>&rarr;</span> ((5 6) (3 4) (1 2))
</pre>


<p>第三構文の <tt>reverse</tt> は、文字列の文字順を反転すために使います。<br />
In the third form, <tt>reverse</tt> is used to reverse the order 
of characters in a string.</p>

<!-- example -->

<pre>
; reverse byte character string

(set 'str "newLISP")

(reverse str)  <span class='arw'>&rarr;</span> "PSILwen"
str            <span class='arw'>&rarr;</span> "PSILwen"

; reverse a multibyte character UTF-8 string, explode is UTF-8 sensitive

(join (reverse (explode "ΑΒΓΔΕΖΗΘ")))  <span class='arw'>&rarr;</span> "ΘΗΖΕΔΓΒΑ"
</pre>


<p>関数 <a href="#sort">sort</a> も見てください。<br />
See also the <a href="#sort">sort</a> function.</p>

<br/><br/>

<a name="rotate"></a>
<h2><span class="function">rotate</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (rotate <em>list</em> [<em>int-count</em>])<br/>
syntax: (rotate <em>str</em> [<em>int-count</em>])</h4>

<p><em>list</em> や文字列 <em>str</em> を回転して返します。
オプションで一個より多い回転数を <em>int-count</em> に指定できます。
<em>int-count</em> が正なら、回転は右回りです。
<em>int-count</em> が負なら、回転は左回りです。
<em>int-count</em> が指定されない時、<tt>rotate</tt> は右に一個回転します。
<tt>rotate</tt> は、元のリストや文字列の内容を変える破壊的関数です。<br />
Rotates and returns the <em>list</em> or string in <em>str</em>.
A count can be optionally specified in <em>int-count</em> 
to rotate more than one position.  If <em>int-count</em> is positive, 
the rotation is to the right; if <em>int-count</em> is negative, 
the rotation is to the left.  If no <em>int-count</em> is specified, 
<tt>rotate</tt> rotates 1 to the right.  <tt>rotate</tt> is a destructive function 
that changes the contents of the original list or string.</p>

<!-- example -->

<pre>
(set 'l '(1 2 3 4 5 6 7 8 9))

(rotate l)    <span class='arw'>&rarr;</span> (9 1 2 3 4 5 6 7 8)
(rotate l 2)  <span class='arw'>&rarr;</span> (7 8 9 1 2 3 4 5 6)

l  <span class='arw'>&rarr;</span> (7 8 9 1 2 3 4 5 6)

(rotate l -3)  <span class='arw'>&rarr;</span> (1 2 3 4 5 6 7 8 9)

; rotate a byte character string

(set 'str "newLISP")

(rotate str)     <span class='arw'>&rarr;</span> "PnewLIS"
(rotate str 3)   <span class='arw'>&rarr;</span> "LISPnew"
(rotate str -4)  <span class='arw'>&rarr;</span> "newLISP"

; rotate a multibyte character UTF-8 string on character boundaries

(join (rotate (explode "ΑΒΓΔΕΖΗΘ")))  <span class='arw'>&rarr;</span> "ΘΑΒΓΔΕΖΗ"
</pre>


<p><tt>rotate</tt> が文字列に作用する時、文字境界ではなく、バイト境界で動作します。<br />
When working on a string, <tt>rotate</tt> works on byte boundaries 
rather than character boundaries.</p>

<br/><br/>

<a name="round"></a>
<h2><span class="function">round</span></h2>
<h4>syntax: (round <em>number</em> [<em>int-digits</em>])</h4>

<p><em>number</em> の数値を与えられた <em>int-digits</em> の桁数で丸めます。
小数部を丸める時の <em>int-digits</em> は負数です。
整数部を丸める時は正数です。<br />
Rounds the number in <em>number</em> 
to the number of digits given in <em>int-digits</em>. 
When decimals are being rounded, <em>int-digits</em> is negative. 
It is positive when the integer part of a number is being rounded.</p>

<p>この関数の <em>int-digits</em> が省略されると、小数部が <tt>0</tt> に丸められます。<br />
If <em>int-digits</em> is omitted, the function rounds to <tt>0</tt> decimal
digits.</p>

<!-- example -->

<pre>
(round 123.49 2)    <span class='arw'>&rarr;</span> 100
(round 123.49 1)    <span class='arw'>&rarr;</span> 120
(round 123.49 0)    <span class='arw'>&rarr;</span> 123
(round 123.49)      <span class='arw'>&rarr;</span> 123
(round 123.49 -1)   <span class='arw'>&rarr;</span> 123.5
(round 123.49 -2)   <span class='arw'>&rarr;</span> 123.49
</pre>


<p>表示目的で丸める時は、<a href="#format">format</a>を使った方がより洗練されることに注意してください。<br />
Note that rounding for display purposes is better accomplished using 
<a href="#format">format</a>.</p>

<br/><br/>

<a name="save"></a>
<h2><span class="function">save</span></h2>
<h4>syntax: (save <em>str-file</em>)<br/>
syntax: (save <em>str-file</em> <em>sym-1</em> [<em>sym-2</em> ... ])</h4>

<p>第一構文の関数 <tt>save</tt> は、newLISP 作業領域の内容をファイル <em>str-file</em> に（テキスト形式で）書き込みます。
<tt>save</tt> は <tt>load</tt> の逆関数です。
<tt>save</tt> で作成したファイルを <tt>load</tt> することで、newLISP は <tt>save</tt> が実行された時と同じ状態に戻ります。
<tt>$</tt> 文字で始まるシステム・シンボル (例えば、正規表現からの <tt>$0</tt> やコマンド・ラインからの <tt>$main-args</tt>) や組込関数のシンボルや <tt>nil</tt> 等のシンボルは保存されません。<br />
	In the first syntax, 
	the <tt>save</tt> function writes 
	the contents of the newLISP workspace 
	(in textual form) to the file <em>str-file</em>.
	<tt>save</tt> is the inverse function of <tt>load</tt>. 
	Using <tt>load</tt> on files 
	created with <tt>save</tt> causes 
	newLISP to return to the same state 
	as when <tt>save</tt> was originally invoked.
	System symbols starting with the <tt>$</tt> character 
	(e.g., <tt>$0</tt> from regular expressions 
	or <tt>$main-args</tt> from the command-line), symbols of built-in
	functions and symbols containing <tt>nil</tt> are not saved.
</p>

<p>第二構文では、引数にシンボルを指定できます。
<em>sym-n</em> を提供すれば、そのシンボルの定義だけが保存されます。
<em>sym-n</em> がコンテキストに評価されるなら、そのコンテキスト内の全シンボルが保存されます。
一個以上のシンボルを指定でき、シンボルとコンテキスト・シンボルは混在可能です。
コンテキストが保存される時でも、システム変数や <tt>$</tt> 文字で始まるシンボルは保存されません。
システム変数を指定した場合、それらは保存されます。<br />
	In the second syntax, 
	symbols can be supplied as arguments.
	If <em>sym-n</em> is supplied, 
	only the definition of that symbol is saved.
	If <em>sym-n</em> evaluates to a context,
	all symbols in that context are saved.
	More than one symbol can be specified,
	and symbols and context symbols can be mixed.
	When contexts are saved,
	system variables and symbols starting with the <tt>$</tt> character 
	are not saved.
	Specifying system symbols explicitly 
	causes them to be saved.
</p>

<p>各シンボルは <a href="#set">set</a> 宣言文で保存されます。
シンボルがラムダ関数かラムダ・マクロ関数なら、<a href="#define">define</a> か <a href="#define-macro">define-macro</a> 宣言文で保存されます。<br />
	Each symbol is saved 
	by means of a <a href="#set">set</a> statement or&mdash;if 
	the symbol contains a lambda or lambda-macro function&mdash;by 
	means of <a href="#define">define</a> 
	or <a href="#define-macro">define-macro</a> statements.
</p>

<p><tt>save</tt> は、完了時に <tt>true</tt> を返します。<br />
	<tt>save</tt> returns <tt>true</tt> on completion.
</p>

<!-- example -->

<pre>
(save "save.lsp")

(save "/home/myself/myfunc.LSP" 'my-func) 
(save "file:///home/myself/myfunc.LSP" 'my-func) 

(save "http://asite.com:8080//home/myself/myfunc.LSP" 'my-func)

(save "mycontext.lsp" 'mycontext) 

;; multiple args
(save "stuff.lsp" 'aContext 'myFunc '$main-args 'Acontext)
</pre>


<p>全てのコンテキスト・シンボルはコンテキスト <tt>MAIN</tt> の一部なので、<tt>MAIN</tt> の保存は全てのコンテキストを保存します。<br />
	Because all context symbols are part of the context <tt>MAIN</tt>,
	saving <tt>MAIN</tt> saves all contexts.
</p>

<p>URL への保存は、URL へ送信するために HTTP PUT <ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>を起こします。
このモードの <tt>save</tt> は、リモートの newLISP サーバー・ノードへプログラム・ソースをプッシュするために使えます。
パス名をルート・ディレクトリから相対的に指定する時は、二重のバックスラッシュが要求されることに注意してください。
<tt>HTTP</tt> モードの <tt>save</tt> は 60 秒でタイムアウトになります。<br />
	Saving to a URL 
	will cause an HTTP PUT request to be sent to the URL.
	In this mode, 
	<tt>save</tt> can also be used 
	to push program source 
	to remote newLISP server nodes.
	Note that a double backslash is required 
	when path names are specified 
	relative to the root directory.
	<tt>save</tt> in <tt>HTTP</tt>  mode will 
	observe a 60-second timeout.</p>

<p><a href="#sym">sym</a> を使って作られたシンボルは一般シンボルの構文ルールと互換性がないので、<a href="#set">set</a> 宣言文の代わりに <a href="#sym">sym</a> を使って<ruby><rb><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">直列化</a></rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>されます。<br />
	Symbols made using <a href="#sym">sym</a>
	that are incompatible with the normal syntax rules for symbols
	are serialized using a <a href="#sym">sym</a> statement 
	instead of a <a href="#set">set</a> statement.
</p>

<p><tt>save</tt> がコンテキストとシンボルを<ruby><rb>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>する際、現在のコンテキストが <tt>MAIN</tt> であるかのように振る舞います。
つまり、現在のコンテキストに関わらず、<tt>save</tt> は常に同じ出力を生成します。<br />
	<tt>save</tt> serializes contexts and symbols 
	as if the current context is <tt>MAIN</tt>.
	Regardless of the current context,
	<tt>save</tt> will always generate the same output.
</p>

<p>（<tt>save</tt> の逆操作である）関数 <a href="#load">load</a> とシンボルやコンテキストをファイルではなく文字列にする <a href="#source">source</a> も見てください。<br />
	See also the functions <a href="#load">load</a> 
	(the inverse operation of <tt>save</tt>) 
	and <a href="#source">source</a>,
	which saves symbols and contexts to a string 
	instead of a file.
</p>

<br/><br/>

<a name="search"></a>
<h2><span class="function">search</span></h2>
<h4>syntax: (search <em>int-file</em> <em>str-search</em> [<em>bool-flag</em> [<em>regex-option</em>]])</h4>

<p><em>int-file</em> のハンドルで指定されたファイルで <em>str-search</em> の文字列を検索します。
<em>int-file</em> は先行するファイルの <a href="#open">open</a> から得られます。
検索後、ファイル・ポインタは（訳注：<em>bool-flag</em> オプション次第で）検索文字列の最初か最後に位置し、見つからなかった時はファイルの最後です。<br />
Searches a file specified by its handle in <em>int-file</em> for a string in <em>str-search</em>.
<em>int-file</em> can be obtained from a previous <a href="#open">open</a> file.  After the search, 
the file pointer is positioned at the beginning  or the end of the searched string or at the end 
of the file if nothing is found.</p>

<p>デフォルトで、ファイルポインタは検索した文字列の最初に位置します。
<em>bool-flag</em> が <tt>true</tt> に評価されると、ポインタは検索した文字列の最後に位置します。<br />
 By default, the file pointer is positioned at the beginning
of the searched string. If <em>bool-flag</em> evaluates to <tt>true</tt>,
then the file pointer is positioned at the end of the searched string.</p>

<p><em>regex-option</em> に PCRE 正規表現検索のオプション・フラグを指定できます。
（訳注：正規表現オプション・フラグの）詳細は <a href="#regex">regex</a> を見てください。
<em>regex-option</em> を指定しなければ、明快でより早い文字列検索が実行されます。
<tt>search</tt> は（訳注：見つかった時に）最新のファイル・ポインタを返し、見つからなかった時に <tt>nil</tt> を返します。<br />
 In <em>regex-option</em>,  the options flags can be specified to perform 
a PCRE regular expression search.  See the function <a href="#regex">regex</a> for details.
If <em>regex-option</em> is not specified a faster, plain string search is performed.
<tt>search</tt> returns the new file position or <tt>nil</tt> if nothing is found.
</p>

<p>正規表現オプション・フラグを使った時、見つかったパターンはシステム変数 <tt>$0</tt> ～ <tt>$15</tt> に保存されます。<br />
 When using the regular expression options flag, patterns found are stored in the system variables 
<tt>$0</tt> to <tt>$15</tt>.  </p>

<!-- example -->

<pre>
(set 'file (open "init.lsp" "read"))
(search file "define")
(print (read-line file) "\n")
(close file)

(set 'file (open "program.c" "r"))
(while (search file "#define (.*)" true 0) (println $1))
(close file)
</pre>


<p>ファイル <tt>init.lsp</tt> を開いて文字列 <tt>define</tt> を検索し、その文字列のある行を出力します。<br />
 The file <tt>init.lsp</tt> is opened and searched for the string <tt>define</tt> and the
line in which the string occurs is printed. </p>

<p>二番目の例では、ファイル <tt>program.c</tt> 中に文字列 <tt>#define</tt> で始まる行を全て探し出し、文字列 "#define " 後の行の残りを出力します（訳注：<em>bool-flag</em> が <tt>true</tt> であることに注意してください）。<br />
The second example looks for all lines in the file <tt>program.c</tt> which start with
the string <tt>#define</tt> and prints the rest of the line after the string "#define ".</p>

<p>正規表現を使った他の関数 <a href="#directory">directory</a>、<a href="#find">find</a>、<a href="#find-all">find-all</a>、<a href="#parse">parse</a>、<a href="#regex">regex</a>、<a href="#replace">replace</a> を見てください。<br />
	For other functions using regular expressions, 
	see <a href="#directory">directory</a>,
	<a href="#find">find</a>,
	<a href="#find-all">find-all</a>, 
	<a href="#parse">parse</a>,
	<a href="#regex">regex</a>, 
	and <a href="#replace">replace</a>.
</p>

<br/><br/>

<a name="seed"></a>
<h2><span class="function">seed</span></h2>
<h4>syntax: (seed <em>int-seed</em>)<br/>
syntax: (seed <em>int-seed</em> <tt>true</tt> [<em>int-pre-N</em>])<br/>
syntax: (seed)</h4>

<p><a href="#amb">amb</a>、<a href="#normal">normal</a>、<a href="#rand">rand</a>、<a href="#random">random</a> 用に数値を発生する内部乱数発生器に、<em>int-seed</em> で指定された数値を種として与えます。
newLISP で使っている乱数発生器は C ライブラリ関数の <em>rand()</em> です。
newLISP の乱数関連関数は全て、この関数に基づいています。<br />
<p>Seeds the internal random generator that generates numbers for <a href="#amb">amb</a>,
<a href="#normal">normal</a>, <a href="#rand">rand</a>, and <a href="#random">random</a> 
with the number specified in <em>int-seed</em>.  Note that the first syntax uses a 
random generator based on the C-library function <em>rand()</em>.  All randomizing functions 
in newLISP are based on this function.</p>

<p>第二構文を使うと、全ての乱数発生を利用したか関数が newLISP を構築したブラットフォームに依存しない乱数発生器に基づくようになります。
第二構文で種を設定すると、<a href="#amb">amb</a>、<a href="#normal">normal</a>、<a href="#rand">rand</a>、<a href="#random">random</a>、<a href="#randomize">randomize</a> から呼び出される全ての乱数関数は、このプラットフォーム非依存乱数発生器に基づきます。<br />
When using the second syntax, all randomizing functions are based on a random generator
independent of platforms and compilers used to built newLISP. When seeding with the second
syntax all random functions called subsequently like 
<a href="#amb">amb</a>, <a href="#normal">normal</a>, <a href="#rand">rand</a>,
<a href="#random">random</a> and <a href="#randomize">randomize</a> are based on this
platform independent random generator.</p>

<p>オプションの <em>int-pre-N</em> は、種を設定する初期化手続きでプリ・フェッチされる乱数の数を指定します。このパラメータを省略すると、<tt>seed</tt> は <tt>50</tt> を用います。<br />
The optional <em>int-pre-N</em> specifies the number of random numbers to be pre-
fetched as part of the seeding and initialization procedure. When this parameter is
ommitted <tt>seed</tt> assumes <tt>50</tt>.</p>

<p><em>int-seed</em> の最大値は、使っているオペレーティング・システムによって 16 ビットか 32 ビットに制限されます。
内部的には、下位の 32 ビットが OS の乱数の種関数に渡されます。<br />
Note that the maximum value for <em>int-seed</em> is limited to 16 or 32 bits, 
depending on the operating system used.  Internally, only the 32 least significant 
bits are passed to the random seed function of the OS.</p>

<!-- example -->

<pre>
(seed 12345)

(seed (time-of-day))
</pre>


<p>同じ数値を <tt>seed</tt> に使った後、乱数発生器は同じ系列の数値で開始します。
これにより、乱数データにまつわるデバックが容易になります。
<tt>seed</tt> を使うことで、同じ乱数列を何度でも発生できるからです。<br />
After using <tt>seed</tt> with the same number,	the random generator starts 
the same sequence of numbers. This facilitates debugging 
when randomized data are involved. Using <tt>seed</tt>, 
the same random sequences can be generated over and over again.</p>

<p>二番目の例は、プログラム開始時間で異なる種を保証できるので重宝します。<br />
The second example is useful for guaranteeing 
a different seed any time the program starts.</p>

<p>以下の例は、組込乱数発生器内部の種の状態の使われ方を示しています。<br />
The following example shows usage of the internal seed state in the built-in
random generator:</p>

<pre>
&gt; (seed 123 true) ; use the true parameter
123
&gt; (random)
0.2788576787704871
&gt; (random)
0.7610070955758016
&gt; (random)
0.2462553424976092
&gt; (random)
0.8135413573186572
&gt; (set 'state (seed)) ; save current state
1747066761
&gt; (random)
0.1895924546707387
&gt; (random)
0.4803856511043318
&gt; (seed state true 0) ; seed with saved state
1747066761
&gt; (random)            ; produces old sequence
0.1895924546707387       
&gt; (random)
0.4803856511043318      
&gt; 
</pre>

<p>最後の構文では、<tt>seed</tt> は現在の種の状態を返します。<br />
In the last syntax <tt>seed</tt> returns the current seed state.</p>

<br/><br/>

<a name="self"></a>
<h2><span class="function">self</span></h2>
<h4>syntax: (self [<em>int-index</em> ... ])</h4>

<p>関数 <tt>self</tt> は FOOP <a href="">メソッド</a>の目標オブジェクトにアクセスします。
オブジェクト・メンバーのアクセスに一個以上の <em>int-index</em> を使います。
<tt>self</tt> （訳注：でアクセスした要素）のセットには、演算子 <a href="#colon">:&nbsp;colon</a> を使います。<br />
The function <tt>self</tt> accesses the target object of a FOOP method.
One or more <em>int-index</em> are used to access the object members.
<tt>self</tt> is set by the <a href="#colon">:&nbsp;colon</a> operator.</p>

<p><tt>self</tt> で参照されるオブジェクトは<a href="http://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%9F%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%96%E3%83%AB">ミュータブル</a>です：<br />
Objects referenced with <tt>self</tt> are mutable:</p>

<!-- example -->

<pre>
(new Class 'Circle)

(define (Circle:move dx dy)
	(inc (self 1) dx) 
	(inc (self 2) dy))

(set 'aCircle (Circle 1 2 3))
(:move aCircle 10 20)

aCircle <span class='arw'>&rarr;</span> (Circle 11 22 3)

; objects can be anonymous
(set 'circles '((Circle 1 2 3) (Circle 4 5 6)))

(:move (circles 0) 10 20)
(:move (circles 1) 10 20)

circles <span class='arw'>&rarr;</span> ((Circle 11 22 3) (Circle 14 25 6))
</pre>

<p>FOOP プログラミングについては<a href="#foop">関数的オブジェクト指向プログラミング</a>の章も見てください。<br />
See also the chapter about programming with FOOP: 
<a href="#foop">Functional object-oriented programming</a></p>

<br/><br/>

<a name="seek"></a>
<h2><span class="function">seek</span></h2>
<h4>syntax: (seek <em>int-file</em> [<em>int-position</em>])</h4>

<p><em>int-file</em> で指定されるファイルのファイル・ポインタを新しい位置 <em>int-position</em> に設定します。
新しい位置はファイルの先頭からのオプセットで表現され、<tt>0</tt>（ゼロ）がファイルの先頭を意味します。
<em>int-position</em> の指定がない時、<tt>seek</tt> はファイルの現在位置を返します。
BSD で <em>int-file</em> が <tt>0</tt>（ゼロ）ならば、<tt>seek</tt> は STDOUT に出力した文字数を返します。Linux や MS Windows では <tt>-1</tt> を返します。
失敗した時の <tt>seek</tt> は <tt>nil</tt> を返します。
<em>int-position</em> が <tt>-1</tt> の時、<tt>seek</tt> はファイル・ポインタをファイルの最後に設定します。<br />
Sets the file pointer to the new position <em>int-position</em> in the file 
specified by <em>int-file</em>.The new position is expressed as an offset from 
the beginning of the file, <tt>0</tt> (zero) meaning the beginning of the file.
If no <em>int-position</em> is specified, <tt>seek</tt> returns the current 
position in the file. If <em>int-file</em> is <tt>0</tt> (zero), 
on BSD, <tt>seek</tt> will return the number of characters printed to STDOUT, 
and on Linux and MS Windows, it will return <tt>-1</tt>. On failure, <tt>seek</tt> 
returns <tt>nil</tt>. When <em>int-position</em> is set to <tt>-1</tt>, 
<tt>seek</tt> sets the file pointer to the end of the file.</p>

<p><tt>seek</tt> はファイル位置を、現行ファイルの最後を越えて設定できます。
続けて、この位置に書き込むとファイルは拡張され、使われていない位置はゼロで埋められます。
このゼロのブロックはディスクに実際割り当てられないのでファイルは余計なスペースをとらず、<em><a href="http://en.wikipedia.org/wiki/Sparse_file">スパースファイル</a></em> と呼ばれます。（訳注：<a href="http://www.atmarkit.co.jp/flinux/rensai/fs03/fs03b.html">スパースファイルの関連記事</a>）<br />
<tt>seek</tt> can set the file position past the current end of the file. Subsequent
writing to this position will extend the file and fill unused positions with zero's.
The blocks of zeros are not actually allocated on disk, so the file takes up less
space and is called a <em>sparse file</em>.</p>

<!-- example -->

<pre>
(set 'file (open "myfile" "read"))  <span class='arw'>&rarr;</span> 5 
(seek file 100)                     <span class='arw'>&rarr;</span> 100
(seek file)                         <span class='arw'>&rarr;</span> 100

(open "newlisp_manual.html" "read")
(seek file -1)  ; seek to EOF
<span class='arw'>&rarr;</span> 593816     

(set 'fle (open "large-file" "read") 
(seek file 30000000000)  <span class='arw'>&rarr;</span> 30000000000
</pre>


<p>newLISP が提供するファイル位置数は 9,223,372,036,854,775,807 までです。<br />
	newLISP supports file position numbers up to 
	9,223,372,036,854,775,807.
</p>

<br/><br/>

<a name="select"></a>
<h2><span class="function">select</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>

<h4>syntax: (select <em>list</em> <em>list-selection</em>)<br/>
syntax: (select <em>list</em> [<em>int-index_i</em> ... ])<br/><br/>

syntax: (select <em>string</em> <em>list-selection</em>)<br/>

syntax: (select <em>string</em> [<em>int-index_i</em> ... ])</h4>

<p>最初の二つの形式の <tt>select</tt>は、<em>list-selection</em> か <em>int-index_i</em> で指定される一個以上のインデックスを使って、<em>list</em> から一個以上の要素を取り出します。<br />
	In the first two forms,
	<tt>select</tt> picks one or more elements 
	from <em>list</em> using one or more indices 
	specified in <em>list-selection</em> or the <em>int-index_i</em>.
</p>

<!-- example -->

<pre>
(set 'lst '(a b c d e f g))

(select lst '(0 3 2 5 3))  <span class='arw'>&rarr;</span> (a d c f d)

(select lst '(-2 -1 0))  <span class='arw'>&rarr;</span> (f g a)

(select lst -2 -1 0)  <span class='arw'>&rarr;</span> (f g a)
</pre>


<p>次の二つの形式の <tt>select</tt> は、<em>list-selection</em> か <em>int-index_i</em> で指定される一個以上のインデックスを使って、<em>string</em> から一個以上の文字を取り出します。<br />
	In the second two forms,
	<tt>select</tt> picks one or more characters 
	from <em>string</em> 
	using one or more indices specified in <em>list-selection</em> 
	or the <em>int-index_i</em>.
</p> 

<!-- example -->

<pre>
(set 'str "abcdefg") 

(select str '(0 3 2 5 3))  <span class='arw'>&rarr;</span> "adcfd"

(select str '(-2 -1 0))  <span class='arw'>&rarr;</span> "fga"

(select str -2 -1 0)  <span class='arw'>&rarr;</span> "fga"
</pre>


<p>選択する要素は何度でも使えます（訳注：つまり、重複するインデックスも可）。また、順番通りである必要はありませんが、（訳注：順番通りなら）動作は、速くなります。
<em>list-selection</em> または <em>int-index_i</em> の順序は、再編成される要素に合わせて変更できます。<br />
	Selected elements can be repeated and do not have to appear in order,
	although this speeds up processing.
	The order in <em>list-selection</em> or <em>int-index_i</em> 
	can be changed to rearrange elements.
</p>

<br/><br/>



<br/><br/>

<a name="semaphore"></a>
<h2><span class="function">semaphore</span></h2>

<h4>syntax: (semaphore)<br/>
syntax: (semaphore <em>int-id</em>)<br/>
syntax: (semaphore <em>int-id</em> <em>int-wait</em>)<br/>
syntax: (semaphore <em>int-id</em> <em>int-signal</em>)<br/>

syntax: (semaphore <em>int-id</em> <em>0</em>)</h4>

<p>セマフォは内部プロセス同期用オブジェクトで、<tt>0</tt>（ゼロ）と最大値の間のカウントを維持します。
共有リソースへのアクセス制御用に使えるセマフォは、カウントがゼロより大きい時にシグナル状態に、カウントがゼロの時に非シグナル状態にセットされます。<br />
A semaphore is an interprocess synchronization object 
that maintains a count between <tt>0</tt> (zero) and some maximum value.
Useful in controlling access to a shared resource, 
a semaphore is set to signaled when its count is greater than zero 
and to non-signaled when its count is zero.</p>

<p>セマフォは、第一構文を使って生成されます。
これの際に返されるセマフォID は整数値で、次に関数 <em>semaphore</em> を呼び出す時の <em>int-id</em> として使えます。
最初のセマフォはゼロの値を持ち、非シグナル状態を表しています。<br />
A semaphore is created using the first syntax.  This returns 
the semaphore ID, an integer used subsequently as <em>int-id</em> 
when the <em>semaphore</em> function is called.  Initially, the 
semaphore has a value of zero, which represents the non-signaled state.
</p>

<p><em>int-wait</em> に負数値を用いて <tt>semaphore</tt> を呼び出し、セマフォ値をゼロより下に減らそうとしても、他のプロセスが正数値の <em>int-signal</em> 用いてセマフォ値をシグナル状態にするまで、この関数呼び出しは <ruby>停止<rp>（</rp><rt>ブロック</rt><rp>）</rp></ruby>します。
<em>int-signal</em> を用いたセマフォの呼び出しは <em>int-signal</em> に指定された正数値によるセマフォ値の増加を試み、<em>int-wait</em> を用いたセマフォの呼び出しは <em>int-wait</em> に指定された負数値によるセマフォ値の減少を試みます。
セマフォは決してゼロより小さくはならないので、そうしようとしてもこの関数の呼び出しは <ruby>停止<rp>（</rp><rt>ブロック</rt><rp>）</rp></ruby>します (すなわち、ゼロのセマフォは、他のプロセスが <em>int-signal</em> を正の値に増加するまで <ruby>停止<rp>（</rp><rt>ブロック</rt><rp>）</rp></ruby>します) 。<br />
If calling <tt>semaphore</tt> with a negative value in <em>int-wait</em> 
causes it to be decremented below zero,
the function call will block until another process
signals the semaphore with a positive value in <em>int-signal</em>.
Calls to the semaphore with <em>int-wait</em> or <em>int-signal</em>
effectively try to increment or decrement the semaphore value 
by a positive or negative value specified in <em>int-signal</em> 
or <em>int-wait</em>.
Because the value of a semaphore must never fall below zero,
the function call will block when this is attempted
(i.e., a semaphore with a value of zero 
will block until another process
increases the value with a positive <em>int-signal</em>).
</p>

<p>第二構文はセマフォ値を要求するために使い、<tt>semaphore</tt> を <em>int-id</em> のみで呼び出します。
この形式は、MS Windows では利用できません。<br />
The second syntax is used to inquire about the value of a semaphore
 by calling <tt>semaphore</tt> with the <em>int-id</em> only.
This form is not available on MS Windows.</p>

<p>最後の引数に <tt>0</tt>（ゼロ）を提供すれば、セマフォ用システム・リソースが解放され、利用できなくなります。
このセマフォにおける他の如何なる子プロセスの待ち状態も解放されます。<br />
Supplying <tt>0</tt> (zero) as the last argument will release system 
resources for the semaphore, which then becomes unavailable.
Any pending waits on this semaphore in other child processes 
will be released.</p>

<p>MS Windows では、親子関係のプロセスのみがセマフォを共有できます。
Linux/Unix では、プロセスに依存せずにセマフォを共有できます。<br />
On MS Windows, only parent and child processes can share a semaphore.
On Linux/Unix, independent processes can share a semaphore.</p>

<p>関数 <tt>semaphore</tt> は失敗すると <tt>nil</tt> を返します。
オペレーティングシステム下からエラー番号とそのテキストを取り出すために、<a href="#sys-error">sys-error</a> が使えます。<br />
On failure the <tt>semaphore</tt> function returns <tt>nil</tt>.
<a href="#sys-error">sys-error</a> can be used to retrieve the error
number and text from the underlying operating system.</p>

<p>次のコード例は、異なる構文形式を要約しています：<br />
The following code examples summarize the different syntax forms:</p>

<!-- example -->

<pre>
;; init semaphores 
(semaphore) 

;; assign a semaphore to sid 
(set 'sid (semaphore))

;; inquire the state of a semaphore (not on Windows OS)
(semaphore sid)

;; put sid semaphore in wait state (-1) 
(semaphore sid -1) 

;; run sid semaphore previously put in wait (always 1) 
(semaphore sid 1) 

;; run sid semaphore with X times a skip (backward or forward) on the function 
(semaphore sid X) 

;; release sid semaphore system-wide (always 0) 
(semaphore sid 0) 
</pre>


<p>次の例は、子プロセスを制御するセマフォを示しています：<br />
The following example shows semaphores controlling a child process:</p> 

<!-- example -->

<pre>
;; counter process output in bold

(define (counter n)
	(println "counter started")
	(dotimes (x n)
		(semaphore sid -1)
		(println x)))

;; hit extra &lt;enter&gt; to make the prompt come back
;; after output to the console from the counter process

&gt; (set 'sid (semaphore))

&gt; (semaphore sid)
<b>0</b>

&gt; (fork (counter 100))

<b>counter started</b>
&gt; (semaphore sid 1)
<b>0</b>
&gt; (semaphore sid 3)
<b>1</b>
<b>2</b>
<b>3</b>
&gt; (semaphore sid 2)
<b>4</b>

<b>5</b>
&gt; _
</pre>


<p>セマフォが <tt>sid</tt> で獲得され、<tt>0</tt> の値を持ちます（非シグナル状態）。
プロセス <tt>counter</tt> が始まると、初期開始メッセージを出した後、セマフォは<ruby>停止<rp>（</rp><rt>ブロック</rt><rp>）</rp></ruby>し、セマフォ呼び出しの待ち状態になります。
<tt>-1</tt> はセマフォ値を減らそうとしますが、既にゼロであり、できません。
メインの親プロセスのインターラクティブ環境でセマフォ値を <tt>1</tt> に上げて、シグナル状態にします。
これが <tt>counter</tt> プロセスのセマフォ呼び出しの待ちを解除し、それで（<tt>counter</tt>プロセスは）セマフォ値を <tt>1</tt> から <tt>0</tt> へと減らすことができ、<tt>print</tt> 宣言文が実行されます。
セマフォ呼び出しに再び到達すると、セマフォ値は既に待ち状態（<tt>0</tt>）になっているので<ruby>停止<rp>（</rp><rt>ブロック</rt><rp>）</rp></ruby>します。<br />
	After the semaphore is acquired in <tt>sid</tt>, 
	it has a value of <tt>0</tt>
	(the non-signaled state).
	When starting the process <tt>counter</tt>,
	the semaphore will block after the initial start message 
	and will wait in the semaphore call.
	The <tt>-1</tt> is trying to decrement the semaphore,
	which is not possible because its value is already zero.
	In the interactive, main parent process,
	the semaphore is signaled by raising its value by <tt>1</tt>.
	This unblocks the semaphore call in the <tt>counter</tt> process,
	which can now decrement the semaphore from <tt>1</tt> to <tt>0</tt> 
	and execute the <tt>print</tt> statement.
	When the semaphore call is reached again,
	it will block because the semaphore is already in the wait 
	(<tt>0</tt>) state.
</p>

<p>続く <tt>1</tt> より多い数での <tt>semaphore</tt> の呼び出しは、<tt>counter</tt> プロセスでセマフォが<ruby>停止<rp>（</rp><rt>ブロック</rt><rp>）</rp></ruby>する前にセマフォ値を減らす機会を数回与えます。<br />
	Subsequent calls to <tt>semaphore</tt> 
	with numbers greater than <tt>1</tt> 
	give the <tt>counter</tt> process an opportunity 
	to decrement the semaphore several times before blocking.
</p>

<p>一個以上のセマフォの生成が可能なように、一個以上のプロセスがセマフォの制御に参加できます。
Unixライクのオペレーティングシステムでは、セマフォの最大数は kernel の system-wide 設定で制御されます。<br />
	More than one process can participate in controlling the semaphore, 
	just as more than one semaphore can be created.
	The maximum number of semaphores is controlled 
	by a system-wide kernel setting on Unix-like operating systems.
</p>

<p>新プロセスの開始には関数 <a href="#fork">fork</a> を、プロセス間の情報共有には関数 <a href="#share">share</a> を使ってください。
<tt>semaphore</tt> を使ったプロセス同期のより包括的な例は、newLISP で配布している例やモジュールと同様に配布ソースの <tt>examples</tt> ディレクトリ下にあるファイル <tt>prodcons.lsp</tt> を見てください。<br />
Use the <a href="#fork">fork</a> function to start a new process 
and the <a href="#share">share</a> function to share information between 
processes. For a more comprehensive example of using <tt>semaphore</tt> 
to synchronize processes, see the file <tt>prodcons.lsp</tt> example 
in the <tt>examples</tt> directory in the source distribution, 
as well as the examples and modules distributed with newLISP.</p>

<br/><br/>

<a name="send"></a>
<h2><span class="function">send</span></h2>
<h4>syntax: (send <em>int-pid</em> <em>exp</em>)<br/>
syntax: (send)</h4>

<p>関数 <tt>send</tt> は、親プロセスと <a href="#spawn">spawn</a> で開始した子プロセス間の通信を可能にします。
親プロセスは子プロセスへメッセージを送り、子プロセスからのメッセージを受け取ることができます。
子プロセスも親プロセスへメッセージを送り、親プロセスからのメッセージを受け取ることができます。
後で示すようなプロキシ・テクニックは、子プロセス間同士の通信に使われます。
<tt>send</tt> と <a href="#receive">receive</a> は、ロックやセマフォを必要としません。
これらは、送信と受信、両方のメッセージ・キューで動作します。<br />
The <tt>send</tt> function enables communication between
parent and child processes started with <a href="#spawn">spawn</a>.
Parent processes can send and receive messages to and from
their child processes and child processes can send and receive
messages to and from their parent process. A proxy technique &ndash; shown further
down &ndash; is  employed to communicate between child process
peers. <tt>send</tt> and <a href="#receive">receive</a> do not require 
locks or semaphores. They work on dual send and receive message queues.
</p>

<p><a href="#fork">fork</a> や <a href="#process">process</a> を使って開始したプロセスには、メッセージ関数 <tt>send</tt> や <tt>receive</tt> を使えません。
代わりの通信用途としては、<a href="#semaphore">semaphore</a> と一緒の <a href="#share">share</a> か <a href="#pipe">pipe</a> を使うべきです。<br />
Processes started using <a href="#fork">fork</a> or 
<a href="#process">process</a> can not use <tt>send</tt> and <tt>receive</tt>
message functions. Instead they should use either <a href="#share">share</a> 
with <a href="#semaphore">semaphore</a> or <a href="#pipe">pipe</a> to 
communicate.</p>

<p>関数 <tt>send</tt> は、MS Windows では使えません。<br />
The <tt>send</tt> function is not available on MS Windows.</p>

<p>第一構文の <tt>send</tt> は親から子プロセスへ、あるいは子から親プロセスへのメッセージ送信に使われます。<br />
In the first syntax <tt>send</tt> is used to send a message 
from a parent to a child process or a child to a parent process.</p>

<p>第二構文は親プロセスでのみ使われ、親からのメッセージを受信キューに受け入れ可能な子プロセスの全リストが得られます。
子プロセスの受信キューが満杯なら、<tt>(send)</tt> 宣言文で返るリストには含まれません。<br />
The second syntax is only used by parent processes to get a list
of all child processes ready to accept message from the parent in their 
receive queues. If a child's receive queue is full, it will not be part of
the list returned by the <tt>(send)</tt> statement.</p>

<p>メッセージ内容は、アトム式、リスト式等の newLISP の如何なる式でもかまいません。例えば、<tt>nil</tt> と <tt>true</tt> からなる論理値、整数、浮動小数点数、文字列、newLISP 構文を含むリスト式等。
データの大きさに、制限はありません。<br />
The content of a message may be any newLISP expression either
atomic or list expressions: boolean constants <tt>nil</tt> and <tt>true</tt>,
integers, floating point numbers or strings, or any list expression 
in valid newLISP syntax. The size of a message is unlimited.</p>


<p><em>exp</em> パラメータには、<em>int-pid</em> の受け取り側に送るデータを指定します。
受け取り側は、現行プロセスが生成した子プロセスでも親プロセスでも可能です。
メッセージ・キューが満杯でも、最後に受信したものから読み取ることもできますが、
キューの反対側で実行された <tt>send</tt> は失敗し、<tt>nil</tt> を返します。<br />
The <em>exp</em> parameter specifies the data to be sent
to the recipient in <em>int-pid</em>. The recipient can be either a
spawned child process of the current process or the parent
process. If a message queue is full, it can be read from the receiving
end, but a <tt>send</tt> issued on the other side of the queue will
fail and return <tt>nil</tt>.</p>


<pre>
; child process dispatching message to parent

(set 'ppid (sys-info -4)) ; get parent pid

(send ppid "hello") ; send message
</pre>

<p>このメッセージの受け取り側目標は、親プロセスです：<br />
The targeted recipient of the message is the parent process:</p>

<pre>
; parent process receiving message from child

(receive child-pid msg) <span class='arw'>&rarr;</span> true
msg                     <span class='arw'>&rarr;</span> "hello"
</pre>


<p><tt>send</tt> のキューが満杯の時は、メッセージ内容が受信側から十分に読み取られ、キューが <tt>send</tt> 宣言文から新しいメッセージを受け入れる準備ができるまで、
<tt>send</tt> は <tt>nil</tt> を返します。<br />
When the <tt>send</tt> queue is full, <tt>send</tt> will return
<tt>nil</tt> until enough message content is read on the receiving side
of the queue and the queue is ready to accept new messages from 
<tt>send</tt> statements.</p>

<p>ループ関数 <a href="#until">until</a> を使えば、メッセージ宣言文は <tt>nil</tt> 以外の値を返すまで繰り返すことができます。
この方法で、ノン・ブロッキングな <tt>send</tt> と <tt>receive</tt> を成功するまで止めておくことができます：<br />
Using the <a href="#until">until</a> looping function, the
message statements can be repeated until they return a value
not <tt>nil</tt>. This way, non-blocking <tt>send</tt> and <tt>receive</tt> 
can be made blocking until they succeed:</p>


<pre>
; blocking sender
(until (send pid msg)) ; true after message is queued up

; blocking receiver
(until (receive pid msg)) ; true after message could be read
</pre>

<p>送り側の宣言文は、メッセージが受け取り側のメールボックスに届けられるまで止まっています。<br />
The sender statement blocks until the message could be deposited
in the recipients mailbox.</p>

<p><tt>receive</tt> 宣言文は、新メッセージがキューから取り出されるまで止まっています。<br />
The <tt>receive</tt> statement blocks until a new message can
be fetched from the queue.</p>

<p>この例のように <tt>until</tt> 宣言文が本体式を欠いている時、評価された条件式の最後の値が <tt>until</tt> ループの戻り値になります。<br />
As the <tt>until</tt> statements in this example lack body expressions,
the last value of the evaluated conditional expression is the return
value of the <tt>until</tt> loop.</p>

<h3>Blocking message exchange（ブロッキング・メッセージ交換）</h3>

<p>次のコードは、受け取り側が入力メッセージを待ち受け（listen）る方法を示し、同様に、送り側がキューへメッセージを送信するために再試行する方法を示しています。
例では、5 個の子プロセスが定期的に状態データを親プロセスに配信し、親プロセスでそのデータを表示する様子を示しています。
三組のデータが読み取られた後、親プロセスは全ての子プロセスを中止して、終了します：
<br />
The following code shows how a recipient can listen for incoming
messages, and in turn how a sender can retry to deposit a message
into a queue. The example shows 5 child processes constantly delivering 
status data to a parent process which will display the data.
After three data sets have been read, the parent will abort all
child processes and exit:</p>

<!-- example -->

<pre>
#!/usr/local/bin/newlisp

; child process transmits random numbers
(define (child-process)
    (set 'ppid (sys-info -4)) ; get parent pid
    (while true
        (until (send ppid (rand 100))))
)

; parent starts 5  child processes, listens and displays
; the true flag is specified to enable send/receive

(dotimes (i 5) (spawn 'result (child-process) true))

(for (i 1 3)
    (dolist (cpid (sync)) ; iterate thru child pids
        (until (receive cpid msg))
        (print "pid:" cpid "-&gt;" (format "%-2d  " msg)))
    (println)
)

(abort) ; cancel child-processes
(exit)
</pre>


<p>上の例を走らせると、次のような出力が作り出されます：<br />
Running above example produces the following output:</p>

<pre><b>pid:53181->47  pid:53180->61  pid:53179->75  pid:53178->39  pid:53177->3   
pid:53181->59  pid:53180->12  pid:53179->20  pid:53178->77  pid:53177->47  
pid:53181->6   pid:53180->56  pid:53179->96  pid:53178->78  pid:53177->18
</b></pre>

<p><tt>(sync)</tt> は子プロセスの PID を全て返します。
各子プロセスからの状態メッセージを受け取とるまで待つために、<tt>(until (receive cpid msg))</tt> を使っています。<br />
The <tt>(sync)</tt> expression returns a list of all child PIDs,
and <tt>(until (receive cpid msg))</tt> is used to force a wait
until status messages are received for each of the child processes.</p>

<p>ある時間経過後に待つのをやめるタイムアウト機能を、 <tt>until</tt> または <tt>while</tt> ループに含めることもできます。<br />
A timeout mechanism could be part of an <tt>until</tt> or <tt>while</tt>
loop to stop waiting after certain time has expired.</p>

<p>例では、子プロセスから親プロセスへと流れるメッセージを示すと共に、メッセージが親から子プロセスへと異なる方向へ流れることも示しています。
このような場合、メッセージ・キューの位置する子プロセスのリストを入手するために、親プロセスは <tt>(send)</tt> を使います。<br />
The examples show messages flowing from a child processes to
a parent process, in the same fashion messages could flow
into the other direction from parent to child processes. In that
case the parent process would use <tt>(send)</tt> to obtain a
list of child processes with place in their message queues.</p>

<h3>Messages containing code for evaluation（評価用コードを含むメッセージ）</h3>

<p>メッセージ関数の最も強力な機能は、newLISP の式を送れることです。
そして、それを受け取り側で評価することができます。
受け取り側は、受け取った式の評価に <a href="#eval">eval</a> 使います。
式に含まれるシンボルは受信側の環境で評価されます。<br />
The most powerful feature of the message functions is the ability
to send any newLISP expression, which then can be evaluated by the recipient. 
The recipient uses <a href="#eval">eval</a> to evaluate the received
expression. Symbols contained in the expression are evaluated in the
receivers environment.</p>

<p>次の例は、親プロセスがメッセージ・プロキシのように振る舞う方法を示しています。
親プロセスは子プロセス A からメッセージを受け取り、ID B の第二子プロセスに発送します。
実際、これは子プロセス間のメッセージのやりとりを実現します。
この実装は、受け取り側が受け取ったメッセージに含まれる式を評価できるという事実に基づいています。
これらの式には、有効であれば如何なる newLISP 宣言文もかまいません：<br />
The following example shows how a parent process acts like a message 
proxy. The parent receives messages from a child process A and routes them 
to a second child process with ID B. In effect this implements messages 
between child process peers. The implementation relies on the fact that 
the recipient can evaluate expressions contained in messages received.
These expressions can be any valid newLISP statements:</

<!-- example -->
<pre>
#!/usr/local/bin/newlisp

; sender child process of the message
(set 'A (spawn 'result 
    (begin
        (dotimes (i 3)
            (set 'ppid (sys-info -4))
            /* the statement in msg will be evaluated in the proxy */
            (set 'msg '(until (send B (string "greetings from " A))))
            (until (send ppid msg)))
        (until (send ppid '(begin 
            (sleep 100) ; make sure all else is printed
            (println "parent exiting ...\n")
            (set 'finished true))))) true)) 

; receiver child process of the message
(set 'B (spawn 'result 
    (begin
        (set 'ppid (sys-info -4))
        (while true
            (until (receive ppid msg))
            (println msg)
            (unless (= msg (string "greetings from " A))
                (println "ERROR in proxy message: " msg)))) true))

(until finished (if (receive A msg) (eval msg))) ; proxy loop

(abort)
(exit)
</pre>

<p>子プロセス <tt>A</tt> は <tt>B</tt> に 3個のメッセージを送ります。
これは直接できないので、<tt>A</tt> は評価してもらうため親プロセスに <tt>send</tt> 宣言文を送ります。宣言文：<br />
Child process <tt>A</tt> sends three messages to <tt>B</tt>.
As this cannot be done directly <tt>A</tt>  sends <tt>send</tt>
statements to the parent for evaluation. The statement:</p>

<pre>
(until (send pidB (string "greetings from " A)))
</pre>

<p>は、親プロセスの環境で評価されます。
変数 <tt>A</tt> と <tt>B</tt> が送り側プロセス <tt>A</tt> で <tt>nil</tt> に束縛されていたとしても、親プロセスでは正しい ID 番号に束縛されています。<br />
will be evaluated in the environment of the parent process. Even so the 
variables <tt>A</tt> and <tt>B</tt> are bound to <tt>nil</tt> in 
the sender process <tt>A</tt>, in the parent process they will be
bound to the correct process ID numbers.</p>

<p>三つのメッセージを送った後、宣言文：<br />
After sending the three messages, the statement:</p>

<pre>
(set 'finished true)
</pre>

<p>は、親プロセスに送られます。一度だけ評価され、<tt>until</tt> ループを終了させます。<br />
is sent to the parent process. Once evaluated, it will cause the <tt>until</tt>
loop to finish.</p>

<p><tt>send</tt> と <tt>receive</tt> の更なる例題については <a href="http://www.newlisp.org/CodePatterns-jp.html">Code Patterns</a> 文書を見てください。<br />
For more details on <tt>send</tt> and <tt>receive</tt> and more examples 
see the <a href="http://www.newlisp.org/CodePatterns.html">Code Patterns</a>
document.</p>

<br/><br/>

<a name="sequence"></a>
<h2><span class="function">sequence</span></h2>
<h4>syntax: (sequence <em>num-start</em> <em>num-end</em> [<em>num-step</em>])</h4>

<p><em>num-start</em> から <em>num-end</em> までの数列（訳注：等差数列）をオプション <em>num-step</em> のステップ・サイズで生成します。
<em>num-step</em> が省略された時は、値 <tt>1</tt>（一）になります。
生成される数値は（ステップ・サイズが指定されなかった時の）整数型か、（オプションのステップ・サイズがある時の）浮動小数点型です。<br />
	Generates a sequence of numbers 
	from <em>num-start</em> to <em>num-end</em> 
	with an optional step size of <em>num-step</em>.
	When <em>num-step</em> is omitted,
	the value <tt>1</tt> (one) is assumed.
	The generated numbers are of type integer 
	(when no optional step size is specified) 
	or floating point 
	(when the optional step size is present).
</p>

<!-- example -->

<pre>
(sequence 10 5)     <span class='arw'>&rarr;</span> (10 9 8 7 6 5)
(sequence 0 1 0.2)  <span class='arw'>&rarr;</span> (0 0.2 0.4 0.6 0.8 1)
(sequence 2 0 0.3)  <span class='arw'>&rarr;</span> (2 1.7 1.4 1.1 0.8 0.5 0.2)
</pre>


<p>高い数値から低い数値への数列でも、ステップ・サイズは正の数値でなければならないことに注意してください。<br />
	Note that the step size must be a positive number,
	even if sequencing from a higher to a lower number.
</p>

<p>幾何数列（訳注：等比数列）の生成には、関数 <a href="#series">series</a> を使ってください。<br />
	Use the <a href="#series">series</a> function
	to generate geometric sequences.
</p>

<br/><br/>

<a name="series"></a>
<h2><span class="function">series</span></h2>

<h4>syntax: (series <em>num-start</em> <em>num-factor</em> <em>num-count</em>)<br/>
syntax: (series <em>exp-start</em> <em>func</em> <em>num-count</em>)</h4>

<p>第一構文の <tt>series</tt> は、要素 <em>num-start</em> から始まる要素 <em>num-count</em> 個の幾何数列（訳注：等比数列）を生成します。
一連の要素には <em>num-factor</em> が掛けられています。
生成される数値は、常に浮動小数点数です。<br />
In the first syntax, <tt>series</tt> creates a geometric sequence with <em>num-count</em> 
elements starting with the element in <em>num-start</em>. Each subsequent element 
is multiplied by <em>num-factor</em>. The generated numbers are always floating point 
numbers.</p>

<p><em>num-count</em> が <tt>1</tt> より小さい時、<tt>series</tt> は空リストを返します。<br />
When <em>num-count</em> is less than <tt>1</tt>, then <tt>series</tt>
returns an empty list.</p>

<!-- example -->

<pre>
(series 2 2 5)     <span class='arw'>&rarr;</span> (2 4 8 16 32)
(series 1 1.2 6)   <span class='arw'>&rarr;</span> (1 1.2 1.44 1.728 2.0736 2.48832)
(series 10 0.9 4)  <span class='arw'>&rarr;</span> (10 9 8.1 7.29)
(series 0 0 10)    <span class='arw'>&rarr;</span> (0 0 0 0 0 0 0 0 0 0)
(series 99 1 5)    <span class='arw'>&rarr;</span> (99 99 99 99 99)
</pre>


<p>第二構文の <tt>series</tt> は、前の式から次の式に変わるために <em>func</em> で指定された関数を使います：<br />
In the second syntax, <tt>series</tt> uses a function specified in <em>func</em>
to transform the previous expression in to the next expression:</p>


<!-- example -->

<pre>
; embed the function Phi: f(x) = 1 / (1 + x)
; see also http://en.wikipedia.org/wiki/Golden_ratio

(series 1 (fn (x) (div (add 1 x))) 20)  <span class='arw'>&rarr;</span>

(1 0.5 0.6666666 0.6 0.625 0.6153846 0.619047 0.6176470 0.6181818 
 0.6179775 0.6180555 0.6180257 0.6180371 0.6180327 0.6180344 
 0.6180338 0.6180340 0.6180339 0.6180339 0.6180339)

; pre-define the function

(define (oscillate x) 
  (if (&lt; x) 
    (+ (- x) 1) 
    (- (+ x 1)))
)

(series 1 oscillate 20)  <span class='arw'>&rarr;</span> 

(1 -2 3 -4 5 -6 7 -8 9 -10 11 -12 13 -14 15 -16 17 -18 19 -20)

; any data type is accepted as a start expression

(series "a" (fn (c) (char (inc (char c)))) 5) <span class='arw'>&rarr;</span> ("a" "b" "c" "d" "e")

; dependency of the two previous values in this fibonacci generator

(let (x 1) (series x (fn (y) (+ x (swap y x))) 10))  <span class='arw'>&rarr;</span>

(1 2 3 5 8 13 21 34 55 89)
 
</pre>


<p>最初の例は、（どんな値で始めても）<em>黄金比、φ</em>に収束する数列を示しています。
二番目の例は、<tt>series</tt> 文を読み易くするため、前もって <em>func</em> を定義する方法を示しています。<br />
The first example shows a series converging to the <em>golden ratio, &phi;</em>
(for any starting value). The second example shows how <em>func</em> can be defined
previously for better readability of the <tt>series</tt> statement.</p>

<p>関数 <tt>series</tt> は、内部リスト・インデックス値 <tt>$idx</tt> も更新しますので、<em>func</em> 内で使用することができます。<br />
The <tt>series</tt> function also updates the internal list <tt>$idx</tt>
index value, which can be used inside <em>func</em>.</p>


<p>算術数列（訳注：等差数列）には、関数 <a href="#sequence">sequence</a> を使ってください。<br />
Use the <a href="#sequence">sequence</a> function to generate arithmetic sequences.
</p>

<br/><br/>

<a name="set"></a>
<h2><span class="function">set</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (set <em>sym-1</em> <em>exp-1</em> [<em>sym-2</em> <em>exp-2</em> ... ])</h4>

<p>両引数を評価し、<em>exp</em> の結果を <em>sym</em> で見つかるシンボルに割り当てます。 
<tt>set</tt> 式は、割り当てた結果を返します。
割り当てられるのは、シンボルの右側の内容のコピーです。
シンボルの元の内容は、消去されます。
シンボル <tt>nil</tt> と <tt>true</tt> 若しくはコンテキスト・シンボルを変更しようとすると、結果はエラーメッセージとなります。
<tt>set</tt> は、複数の引数ペアを取ることができます。<br />
Evaluates both arguments and then assigns the result of <em>exp</em> 
to the symbol found in <em>sym</em>. The <tt>set</tt> expression 
returns the result of the assignment. The assignment is performed by copying 
the contents of the right side into the symbol. The old contents of the symbol 
are deleted. An error message results when trying to change the contents 
of the symbols <tt>nil</tt>, <tt>true</tt>, or a context symbol.
<tt>set</tt> can take multiple argument pairs.</p>

<!-- example -->

<pre>
(set 'x 123)     <span class='arw'>&rarr;</span> 123
(set 'x 'y)      <span class='arw'>&rarr;</span> y
(set x "hello")  <span class='arw'>&rarr;</span> "hello"

y  <span class='arw'>&rarr;</span> "hello"

(set 'alist '(1 2 3))  <span class='arw'>&rarr;</span> (1 2 3)


(set 'x 1 'y "hello")  <span class='arw'>&rarr;</span> "hello"  ; multiple arguments

x  <span class='arw'>&rarr;</span> 1
y  <span class='arw'>&rarr;</span> "hello"
</pre>


<p>割り当てられるシンボルは、別の newLISP 式からの結果でも可能です。
式は <tt>set</tt> 式中の変数に参照できます。<br />
The symbol for assignment could be the result from another newLISP expression.
Expressions can refer to variables in the <tt>set</tt> expression.</p>

<pre>
(set 'lst '(x y z))  <span class='arw'>&rarr;</span> (x y z)

(set (first lst) 123)  <span class='arw'>&rarr;</span> 123

x  <span class='arw'>&rarr;</span> 123

(set 'a 10 'b (+ a a))

a   <span class='arw'>&rarr;</span> 10,  b   <span class='arw'>&rarr;</span> 20
</pre>


<p>シンボルにラムダ式やラムダ・マクロ式をセットできます。
この操作は、 <a href="#define">define</a> や <a href="#define-macro">define-macro</a> の使用と等価です。<br />
Symbols can be set to lambda or lambda-macro expressions.
This operation is equivalent to using <a href="#define">define</a> 
or <a href="#define-macro">define-macro</a>.</p>


<pre>
(set 'double (lambda (x) (+ x x)))
<span class='arw'>&rarr;</span> (lambda (x) (+ x x))
</pre>


<p>は、以下と等価です：<br />
is equivalent to:</p>


<pre>
(define (double x) (+ x x))
<span class='arw'>&rarr;</span> (lambda (x) (+ x x))
</pre>


<p>次とも、等価です：<br />
is equivalent to:</p>


<pre>
(define double (lambda (x) (+ x x)))
<span class='arw'>&rarr;</span> (lambda (x) (+ x x))
</pre>


<p>シンボルをその後の変更から保護するには、（<tt>set</tt> のように作用する）関数 <a href="#constant">constant</a> を使います。
関数 <a href="#setq">setq</a> や <a href="#setf">setf</a> を使えば、変数シンボルをクォートする必要がありません。<br />
Use the <a href="#constant">constant</a> function (which works like <tt>set</tt>)
to protect the symbol from subsequent alteration. Using the <a href="#setq">setq</a> 
or <a href="#setf">setf</a> function eliminates the need to quote the variable symbol.
</p>

<br/><br/>

<a name="set-locale"></a>
<h2><span class="function">set-locale</span></h2>
<h4>syntax: (set-locale [<em>str-locale</em> [<em>int-category</em>]])</h4>

<p>オペレーティングシステムやプラットフォームのロケールを報告したり、切り替えたりします。
引数なしで使う <em>set-locale</em> は、使われている現行ロケールを報告します。
<em>str-locale</em> が指定されている時の <em>set-locale</em> は、全てのカテゴリ・オプションがつけられている状態 (<tt>LC_ALL</tt>) でロケールを切り替えます。
<em>str-locale</em> に空文字列を置くと、現行プラットフォームで使っているデフォルトのロケールに切り替わります。<br />
Reports or switches to a different locale on your operating system or platform.
When used without arguments, <em>set-locale</em> reports 
the current locale being used. When <em>str-locale</em> is specified, 
<em>set-locale</em> switches to the locale with all category options turned on 
(<tt>LC_ALL</tt>). Placing an empty string in <em>str-locale</em> 
switches to the default locale used on the current platform.</p>

<p><tt>set-locale</tt> は現行ロケールの文字列と小数点文字列のリストを返すか、要求された変更が実行できなかった時の <tt>nil</tt> を返します。<br />
<tt>set-locale</tt> returns either the current locale string and decimal 
point string in a list  or <tt>nil</tt> if the requested change could not 
be performed.</p>

<!-- example -->

<pre>
; report current locale

(set-locale)     

; set default locale of your platform and country
; return value shown when executing on German MS-Windows

(set-locale "")    <span class='arw'>&rarr;</span> ("German_Germany.1252" ",")
(add 1,234 1,234)  <span class='arw'>&rarr;</span> 2,468
</pre>

<p>デフォルトの newLISP は &ndash; UTF-8 版でないなら &ndash; POSIX C デフォルト・ロケールで立ち上がります。
これにより、newLISPの振る舞いがプラットフォームのロケールによらず同一であることを保証します。UTF-8 版 newLISP では、現行プラットフォームのロケールが選択されます。<br />
By default, newLISP &ndash; if not enabled for UTF-8 &ndash; starts up with the POSIX C 
default locale. This guarantees that newLISP's behavior will be identical on any 
platform locale. On UTF-8 enabled versions of newLISP the locale of
the current platform is chosen.</p>

<pre>
; after non-UTF-8 newLISP start up

(set-locale)  <span class='arw'>&rarr;</span> ("C" ".")
</pre>


<p><em>int-category</em>には、<em>category options</em> としての整数値を指定して、デイスプレイ数とか、日付表示とか等のロケールの一部を微調整します。
お使いのプラットフォームで有効なオプションは、C のインクルード・ファイル <tt>locale.h</tt> で見ることができ、プラットフォーム毎に異なっているかもしれません。
<em>int-category</em> を指定しなければ、<tt>LC_ALL</tt> オプションが使われ、そのロケールの全オプションが対象となります。<br />
In <em>int-category</em> integer numbers may be specified as <em>category options</em> 
for fine-tuning certain aspects of the locale, such as number display, date display, 
and so forth. The options valid on your platform can be found in the C include file 
<tt>locale.h</tt> and may be different on each platform. When no <em>int-category</em>
is specified, <tt>LC_ALL</tt> is used to turn on all options for that locale.</p>

<table>
<tr align="left"><th>Category</th><th>macOS, BSDs<br/>&amp; MS Windows</th></tr>
<tr><td>LC_ALL</td><td>0</td></tr>
<tr><td>LC_COLLATE</td><td>1</td></tr>
<tr><td>LC_CTYPE</td><td>2</td></tr>
<tr><td>LC_MONETARY</td><td>3</td></tr>
<tr><td>LC_NUMERIC</td><td>4</td></tr>
<tr><td>LC_TIME</td><td>5</td></tr>
</table>
<br/>

<p>デフォルトの C ロケールは小数点にドットを使いますが、カンマを使うものも他に数多く存在します。<br />
The default C locale uses the decimal dot, but most others use a decimal comma.</p>

<pre>
; with the current locale "en_US.UTF-8", only change the decimal separator 
; to German locale comma on  macOS. LC_NUMERIC is 4 on most platforms 

(set-locale) <span class='arw'>&rarr;</span> ("en_US.UTF-8" ".") 
(set-locale "de_DE.UTF-8" 4) <span class='arw'>&rarr;</span> ("de_DE.UTF-8" ",") 

; mixed locale shows country setting for each category, 4 has changed
(set-locale) <span class='arw'>&rarr;</span> ("en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/de_DE.UTF-8/en_US.UTF-8/en_US.UTF-8" ",")
</pre>

<p><tt>set-locale</tt> を使っても、newLISPの正規表現の振る舞いは変わらないことに注意してください。
PCRE の振る舞いをローカライズするためには、newLISPを異なるキャラクタ・テーブルでコンパイルしなければなりません。
詳細は、newLISP 配布ソースのファイル LOCALIZATION を見てください。<br />
Note that using <tt>set-locale</tt> does not change the behavior 
of regular expressions in newLISP. To localize the behavior of PCRE 
(Perl Compatible Regular Expressions), newLISP must be compiled 
with different character tables. See the file, LOCALIZATION, 
in the newLISP source distribution for details.</p>

<p><a href="#switching">ロケールの切り替え</a> の章も見てください。<br />
	See also the chapter <a href="#switching">Switching the locale</a>.
</p>

<br/><br/>

<a name="set-ref"></a>
<h2><span class="function">set-ref</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (set-ref <em>exp-key</em> <em>list</em> <em>exp-replacement</em> [<em>func-compare</em>])</h4>


<p><em>list</em> 中で <em>exp-key</em> を検索し、見つかった要素を <em>exp-replacement</em> で置き換えます。
<em>list</em> は、入れ子のリストも使えます。
システム変数 <tt>$it</tt> には見つかった式が入り、<em>exp-replacement</em> で使うことができます。
この関数は、新たに変更された <em>list</em> を返します。<br />
Searches for <em>exp-key</em> in <em>list</em> and replaces the found element with 
<em>exp-replacement</em>. The <em>list</em> can be nested. The system variables 
<tt>$it</tt> contains the expression found and can be used in 
<em>exp-replacement</em>. The function returns the new modified <em>list</em>.</p>


<!-- example -->

<pre>
(set 'data '(fruits (apples 123 44) (oranges 1 5 3)))

(set-ref 'apples data 'Apples)  <span class='arw'>&rarr;</span> (fruits (Apples 123 44) (oranges 1 5 3))

data <span class='arw'>&rarr;</span> (fruits (Apples 123 44) (oranges 1 5 3)))
</pre>


<p><tt>data</tt> には<a href="#default_function">デフォルト・ファンクション</a>のコンテキスト指定子を使うことができ、この時のリストは参照で渡されます：<br />
<tt>data</tt> could be the context identifier of a default function for passing lists by reference:</p>


<pre>
(set 'db:db '(fruits (apples 123 44) (oranges 1 5 3)))

(define (update ct key value)
	(set-ref key ct value))

(update db 'apples 'Apples)    <span class='arw'>&rarr;</span> (fruits (Apples 123 44) (oranges 1 5 3))
(update db 'oranges 'Oranges)  <span class='arw'>&rarr;</span> (fruits (Apples 123 44) (Oranges 1 5 3))

db:db <span class='arw'>&rarr;</span> (fruits (Apples 123 44) (Oranges 1 5 3))
</pre>


<p><em>func-compare</em> の使い方については、<a href="#set-ref-all">set-ref-all</a> を見てください。<br />
For examples on how to use <em>func-compare</em> see 
<a href="#set-ref-all">set-ref-all</a></p>

<p>リスト中に検出した全ての要素の変更には、<a href="#set-ref-all">set-ref-all</a> を使ってください。<br />
For changing all occurrences of an element in a list use 
<a href="#set-ref-all">set-ref-all</a>.</p>

<br/><br/>

<a name="set-ref-all"></a>
<h2><span class="function">set-ref-all</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (set-ref-all <em>exp-key</em> <em>list</em>  <em>exp-replacement</em> [<em>func-compare</em>])</h4>

<p><em>list</em> 中で <em>exp-key</em> を検索し、見つかった要素を各々 <em>exp-replacement</em> で置き換えます。
<em>list</em> は、入れ子のリストも使えます。
システム変数 <tt>$it</tt> には見つかった要素が入り、<em>exp-replacement</em> で使えます。
システム変数 <tt>$count</tt> に、置換された数が入ります。
この関数は、新たに変更された <em>list</em> を返します。<br />
Searches for <em>exp-key</em> in <em>list</em> and replaces each instance of the found element 
with <em>exp-replacement</em>. The <em>list</em> can be nested. The system variable <tt>$it</tt> 
contains the expression found and can be used in <em>exp-replacement</em>.
The system variable <tt>$count</tt> contains the number of replacements made.
The function returns the new modified <em>list</em>.</p>

<!-- example -->

<pre>
(set 'data '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))

(set-ref-all 'apples data "Apples")
 <span class='arw'>&rarr;</span> ((monday ("Apples" 20 30) (oranges 2 4 9)) (tuesday ("Apples" 5) (oranges 32 1)))

$count <span class='arw'>&rarr;</span> 2
</pre>


<p><tt>(<em>list</em> <em>key</em>)</tt> パターンのデフォルト・ファンクタを使うことは、<tt>set-ref-all</tt> 宣言文を使ったユーザ定義関数にリストの参照渡しを許します。
これにより、大きなリストを扱う時のメモリ使用量を減らし高速化されます：<br />
Using the default functor in the <tt>(<em>list</em> <em>key</em>)</tt> pattern allows the
list to be passed by reference to a user-defined function containing a <tt>set-ref-all</tt>
statement. This would result in less memory usage and higher speeds in when doing replacements
in large lists:</p>


<pre>
(set 'db:db '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))

(define (foo ctx)
	(set-ref-all 'apples ctx "Apples")
)

(foo db) 
 <span class='arw'>&rarr;</span> ((monday ("Apples" 20 30) (oranges 2 4 9)) (tuesday ("Apples" 5) (oranges 32 1)))
</pre>


<p><tt>(foo db)</tt> の評価の際、<tt>db:db</tt> のリストは参照で渡され、<tt>set-ref-all</tt> は <tt>db:db</tt> のコピーではなくオリジナルを変更します
（訳注：newLISP のユーザ定義関数には、通常、引数が全てコピーで渡されます。上記手法の詳細は <a href="#pass_big">参照によるデータの受け渡し</a> を見てください）。<br />
When evaluating <tt>(foo db)</tt>, the list in <tt>db:db</tt> will be passed
by reference and <tt>set-ref-all</tt> will make the changes on the original, not on
a copy of <tt>db:db</tt>.</p>

<p><a href="#find">find</a>、<a href="#replace">replace</a>、<a href="#ref">ref</a>、<a href="#ref-all">ref-all</a> のように、<em>func-compare</em> 中に <a href="#match">match</a> や <a href="#unify">unify</a> を使えば、複雑な検索を表現できます：<br />
Like with <a href="#find">find</a>, <a href="#replace">replace</a>, 
<a href="#ref">ref</a> and <a href="#ref-all">ref-all</a>, 
complex searches can be expressed using 
<a href="#match">match</a> or <a href="#unify">unify</a> in <em>func-compare</em>:</p>


<pre>
(set 'data '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))

(set-ref-all '(oranges *) data (list (first $it) (apply + (rest $it))) match)
    <span class='arw'>&rarr;</span> ( ... (oranges 15) ... (oranges 33) ... ) 
</pre>


<p>この例では、シンボル <tt>oranges</tt> で始まるレコードで見つかった全ての数値を合計しています。
見つかった要素は <tt>$it</tt> に現れます。<br />
The example sums all numbers found in records starting with 
the symbol <tt>oranges</tt>. The found items appear in <tt>$it</tt></p>

<p>見つかった最初の要素だけを置き換える <a href="#set-ref">set-ref</a> も見てください。<br />
See also <a href="#set-ref">set-ref</a> which replaces only the first element found.</p>

<br/><br/>

<a name="setq"></a> <a name="setf"></a>
<h2><span class="function">setq setf</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (setq <em>place-1</em> <em>exp-1</em> [<em>place-2</em> <em>exp-2</em> ... ])</h4>

<p>newLISP の <tt>setq</tt> と <tt>setf</tt> は同じように動作し、シンボル・リスト・アレイ・文字列の中身、あるいはリスト・アレイ・文字列の参照位置の中身をセットします。
<a href="#set">set</a> のように、<tt>setq</tt> と <tt>setf</tt> は複数の引数ペアを取ることができます。
<tt>setq</tt> と <tt>setf</tt> の両方共、内部的には同じ組込関数を指していますが、このマニュアルでは <tt>setq</tt> がシンボル参照のセットに使われ、<tt>setf</tt> はリストやアレイの参照のセットに使われています。<br />
<tt>setq</tt> and <tt>setf</tt> work alike in newLISP and set the contents
of a symbol, list, array or string or of a list, array or string place reference. Like 
<a href="#set">set</a>, <tt>setq</tt> and <tt>setf</tt> can take multiple argument pairs. 
Although both <tt>setq</tt> and <tt>setf</tt> point to the same built-in function internally, 
throughout this manual <tt>setq</tt> is used when setting a symbol reference and <tt>setf</tt> 
is used when setting list or array references.</p>

<!-- example -->

<pre>
(setq x 123)  <span class='arw'>&rarr;</span> 123

; multiple arguments

(setq x 1 y 2 z 3)  <span class='arw'>&rarr;</span> 3 

x  <span class='arw'>&rarr;</span> 1
y  <span class='arw'>&rarr;</span> 2
z  <span class='arw'>&rarr;</span> 3

; with nth or implicit indices
(setq L '(a b (c d) e f g))

(setf (L 1) 'B)      <span class='arw'>&rarr;</span> B
; or the same
(setf (nth 1 L) 'B)
L                    <span class='arw'>&rarr;</span> (a B (c d) e f g)

(setf (L 2 0) 'C)    <span class='arw'>&rarr;</span> C
L                    <span class='arw'>&rarr;</span> (a B (C d) e f g)

(setf (L 2) 'X)   
L                    <span class='arw'>&rarr;</span> (A B X e f g)

; with assoc
(setq L '((a 1) (b 2)))
(setf (assoc 'b L) '(b 3)) <span class='arw'>&rarr;</span> (b 3)
L                          <span class='arw'>&rarr;</span> ((a 1) (b 3))

; with lookup
(setf (lookup 'b L) 30) <span class='arw'>&rarr;</span> 30
L                       <span class='arw'>&rarr;</span> ((a 1) (b 30))

; several list accessors can be nested
(setq L '((a 1) (b 2)))

(push 'b (setf (assoc 'b l) '(b 4))) 'b) <span class='arw'>&rarr;</span> b
L                                        <span class='arw'>&rarr;</span>((a 1) (b b 4)))

; on strings
(set 's "NewISP")

(setf (s 0) "n") <span class='arw'>&rarr;</span> "n"
s <span class='arw'>&rarr;</span> "newISP"

(setf (s 3) "LI") <span class='arw'>&rarr;</span> "LI"
s <span class='arw'>&rarr;</span> "newLISP"
</pre>


<p>新しい値の設定が古い値に依存することは、有り勝ちです。
<tt>setf</tt> はアナフォリック・システム変数 <tt>$it</tt> を使って、<tt>setf</tt> 式内で古い値を参照できます：<br />
Often the new value set is dependent on the old value. <tt>setf</tt> can
use the anaphoric system variable <tt>$it</tt> to refer to the old
value inside the <tt>setf</tt> expression:</p>


<pre>
(setq L '((apples 4) (oranges 1))) 

(setf (L 1 1) (+ $it 1)) <span class='arw'>&rarr;</span> 2

L                        <span class='arw'>&rarr;</span> ((apples 4) (oranges 2))

(set 's "NewLISP")

(setf (s 0) (lower-case $it)) <span class='arw'>&rarr;</span> "n")

s <span class='arw'>&rarr;</span> "newLISP"
</pre>

<br/><br/>

<a name="sgn"></a>

<h2><span class="function">sgn</span></h2>
<h4>syntax: (sgn <em>num</em>)<br/>
syntax: (sgn <em>num</em> <em>exp-1</em> [<em>exp-2</em> [<em>exp-3</em>]])</h4>

<p>第一構文の関数 <tt>sgn</tt> は、次のルールに従って実数の符号を取り出す論理関数です：<br />
In the first syntax,
the <tt>sgn</tt> function is a logical function 
that extracts the sign of a real number 
according to the following rules:
</p>
<p>
<b><em>
x &gt; <tt>0</tt> : sgn(x) = 1<br/>
x &lt; <tt>0</tt> : sgn(x) = -1<br/>
x = <tt>0</tt> : sgn(x) = <tt>0</tt>
</em></b>
</p>

<!-- example -->

<pre>
(sgn -3.5)  <span class='arw'>&rarr;</span> -1
(sgn 0)     <span class='arw'>&rarr;</span> 0
(sgn 123)   <span class='arw'>&rarr;</span> 1
</pre>

<p>第二構文では、<tt>-1</tt>, <tt>0</tt>, <tt>1</tt> の代わりに、オプション式 <em>exp-1</em>, <em>exp-2</em>, <em>exp-3</em> の中の一つが評価されて返されます。
ケースに対応する <em>exp-n</em> が無い時は <tt>nil</tt> が返されます。<br />
In the second syntax, the result of evaluating 
one of the optional expressions 
<em>exp-1</em>, <em>exp-2</em>, or <em>exp-3</em> is returned, 
instead of <tt>-1</tt>, <tt>0</tt>, or <tt>1</tt>. 
If <em>exp-n</em> is missing for the case triggered,
then <tt>nil</tt> is returned.</p>

<!-- example -->

<pre>
(sgn x -1 0 1)         ; works like (sgn x)
(sgn x -1 1 1)         ; -1 for negative x all others 1
(sgn x nil true true)  ; nil for negative else true
(sgn x (abs x) 0)      ; (abs x) for x &lt; 0, 0 for x = 0, else nil
</pre>


<p><em>exp-1</em>、<em>exp-2</em>、<em>exp-3</em> には、如何なる式や定数も使えます。<br />
Any expression or constant can be used for 
<em>exp-1</em>, <em>exp-2</em>, or <em>exp-3</em>.
</p>

<br/><br/>

<a name="share"></a>
<h2><span class="function">share</span></h2>
<h4>syntax: (share)<br/>
syntax: (share <em>int-address-or-handle</em>)<br/>
syntax: (share <em>int-address-or-handle</em> <em>exp-value</em>)<br/><br/>
syntax: (share <em>nil</em> <em>int-address</em>)</h4>

<p>いくつかの newLISP プロセス間通信で共有するメモリをアクセスします。
引数なしで呼ばれた <tt>share</tt> は、オペレーティング・システムに共有メモリのページを要求します。
これにより、Linux/Unix ではメモリ・アドレスを、MS Windows ではハンドルを返すので、後で参照する変数に割り当てることができます。
この関数は OS/2 では利用できません。<br />
Accesses shared memory 
for communicating between 
several newLISP processes.
When called without arguments, 
 <tt>share</tt> requests a page of shared memory 
from the operating system. 
This returns a memory address on Linux/Unix 
and a handle on MS Windows, 
which can then be 
assigned to a variable 
for later reference.
This function is not available on OS/2.
</p>

<p>共有メモリに内容をセットするには、<tt>share</tt> の第三構文を使います。
<em>int-address-or-handle</em> には Linux/Unix の共有メモリアドレスまたは MS Windows のハンドルを、<em>exp-value</em> には整数、浮動小数点、文字列式、その他の式（ v.10.1.0から）を与えます。
この構文を使うと、値が <em>exp-value</em> に供給され、戻り値にもなります。<br />
To set the contents of shared memory, use the third syntax of <tt>share</tt>. 
Supply a shared memory address on Linux/Unix or a handle on MS Windows in 
<em>int-address-or-handle</em>, along with an integer, float, string 
expression or any other expression (since v.10.1.0) supplied
in <em>exp-value</em>.  Using this syntax, the value supplied in <em>exp-value</em> 
is also the return value.</p>

<p>共有メモリの中身にアクセするには、共有メモリ・アドレスまたはハンドルのみを与える <tt>share</tt> の第二構文を使います。
戻り値は、先に書き込まれた如何なる定数や式にもなります（ v.10.1.0から）。
値がセットされていなかった時は <tt>nil</tt> が返ります。<br />
To access the contents of shared memory, 
use the second syntax of <tt>share</tt>, 
supplying only the shared memory address or handle.
The return value will be any constant or expression (since v.10.1.0)
written previously into the memory.
If the memory has not been previously set to a value, 
<tt>nil</tt> will be returned.</p>

<p>最後の構文は Unixライクのオペレーティングシステムでのみ使用でき、共有メモリを解放します。
解放された後で、共有メモリを使うとシステムがクラッシュしますので注意してください。<br />
Only available on Unix-like operating systems, 
the last syntax unmaps a shared memory address.
Note that using a shared address after unmapping it 
will crash the system.</p>

<p>>メモリは独立したプロセス間ではなく、親子プロセス間で共有可能です。<br />
Memory can be shared between parent and child processes,
but not between independent processes.</p>

<p>10.1.0 から、共有オブジェクトの大きさはオペレーティング・システムのページサイズを超えることができます。
ページサイズより大きいオブジェクトでは、newLISP が内部でファイルを使って共有します。
この際、Unixライクのオペレーティング・システムでは <tt>/tmp</tt> ディレクトリを必要とします。
MS Windows システムでは、 環境変数 <tt>TEMP</tt> を用意しておくべきです。
<br />
Since 10.1.0 size of share objects can exceed the shared memory pagesize
of the operating system. For objects bigger than the pagesize, newLISP internally
uses files for sharing. This requires a <tt>/tmp</tt> directory on Unix-like
operating system.  On MS Windows systems the environment variable <tt>TEMP</tt>
must be set.</p>

<!-- example -->

<pre>
(set 'mem (share))

(share mem 123)  <span class='arw'>&rarr;</span> 123
(share mem)      <span class='arw'>&rarr;</span> 123

(share mem "hello world") <span class='arw'>&rarr;</span> "hello world"
(share mem)               <span class='arw'>&rarr;</span> "hello world"

(share mem true)  <span class='arw'>&rarr;</span> true
(share mem)       <span class='arw'>&rarr;</span> true

(share mem '(+ 1 2 3 4))  <span class='arw'>&rarr;</span> (+ 1 2 3 4)
(share mem)               <span class='arw'>&rarr;</span> (+ 1 2 3 4)

; expressions received can be evaluated (since v.10.1.0)
(eval (share mem))        <span class='arw'>&rarr;</span> 10 

(share nil mem)   <span class='arw'>&rarr;</span> true  ; unmap only on Unix
</pre>


<p>共有メモリから読み出され評価される式は、読み出し側プロセスの環境下で評価されます。<br />
Expression read from shared memory and evaluated, will be evaluated
in the recipient's process environment.</p>

<p>異なるプロセス間の共有メモリ・アクセスは <a href="#semaphore">semaphore</a> を使って、同期されるべきことに注意してください。
共有メモリの同時アクセスは、走っているプロセスをクラッシュしかねません。<br />
Note that shared memory access between different processes 
should be synchronized using a <a href="#semaphore">semaphore</a>.
Simultaneous access to shared memory can crash the running process.</p>

<p>マルチ・プロセスの Linux/Unix アプリケーションで共有メモリを使ったより包括的な例は、newLISP 配布ソースのファイル <tt>example/prodcons.lsp</tt> で見てください。<br />
For a more comprehensive example of using shared memory in a multi process 
Linux/Unix application, see the file <tt>example/prodcons.lsp</tt> in the
newLISP source distribution.</p>

<br/><br/>

<a name="signal"></a>
<h2><span class="function">signal</span></h2>
<h4>syntax: (signal <em>int-signal</em> <em>sym-event-handler</em> | <em>func-event-handler</em>)<br/>
syntax: (signal <em>int-signal</em> "ignore" | "default" | "reset")<br/>
syntax: (signal <em>int-signal</em>)</h4>

<p><em>int-signal</em> で指定された<a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%82%B0%E3%83%8A%E3%83%AB_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2)">シグナル</a>に、<em>sym-event-handler</em> のユーザ定義関数または <em>func-event-handler</em> の関数式をセットします。<br />
Sets a user-defined handler in <em>sym-event-handler</em> for a signal specified in <em>int-signal</em>
or sets to a function expression in <em>func-event-handler</em>.</p>

<p><em>int-signal</em> に続くオプション・パラメータは、評価されません。<br />
A parameter following <em>int-signal</em> is not evaluated.</p>

<p>シグナルハンドラなしで指定される三つの文字列定数 <tt>"ignore"</tt>、<tt>"default"</tt>、<tt>"reset"</tt> は、いずれも小文字でも大文字でもよく、オプション文字列の第一文字だけでもかまいません。
三つのオプションのいずれかが指定されてセットアップが成功すると、<tt>true</tt> が返ります。<br />
If no signal handler is specified any of the string constants <tt>"ignore"</tt>,
<tt>"default"</tt> or <tt>"reset"</tt> can be specified in either lower or upper case
or simply using the first letter of the option string. When signal setup with any
of these three options has been successful, <tt>true</tt> is returned.</p>

<p><tt>"ignore"</tt> を使用すると、newLISP はシグナルを無視します。
<tt>"default"</tt> を使用すると、ハンドラはプラットフォーム下のデフォルト・ハンドラにセットされます。
<tt>"reset"</tt> オプションは、ハンドラをnewLISP 開始時の状態に戻します。<br />
Using <tt>"ignore"</tt> will make newLISP ignore the signal. Using <tt>"default"</tt>
will set the handler to the default handler of the underlying platform OS. The <tt>"reset"</tt>
option will restore the handler to newLISP startup state.</p>

<p>newLISP は開始時に、空の newLISP ハンドラか、<tt>SIGINT</tt> と <tt>SIGCHLD</tt> 用 C 呼び出し <tt>waitpipd(-1, 0, WNOHANG)</tt> である Ctrl-C ハンドラのどちらかを指定します。<br />
On startup, newLISP either specifies an empty newLISP handler or a Ctrl-C handler for 
<tt>SIGINT</tt> and a <tt>waitpipd(-1, 0, WNOHANG)</tt> C-call for <tt>SIGCHLD</tt>.
</p>

<p>異なる OS プラットフォームや Linux/Unix の類では、異なるシグナルが利用されます。
<em>int-signal</em> に指定する数値は、プラットフォーム毎に異なります。
有効な値は大抵、<tt>/usr/include/sys/signal.h</tt> か <tt>/usr/include/signal.h</tt> から取り出せます。<br />
Different signals are available on different OS platforms and Linux/Unix flavors.
The numbers to specify in <em>int-signal</em> also differ from platform-to-platform.
Valid values can normally be extracted from a file found in <tt>/usr/include/sys/signal.h</tt> 
or <tt>/usr/include/signal.h</tt>.</p>

<p>ユーザ定義ハンドラが指定されて実行していても、いくつかのシグナルは newLISP を終了させます（例えば、シグナル SIGKILL）。
この振る舞いは、プロットフォーム毎に異なります。<br />
Some signals make newLISP exit even after a user-defined handler 
has been specified and executed (e.g., signal SIGKILL).
This behavior may also be different on different platforms.</p>

<!-- example -->

<pre>
(constant 'SIGINT 2)
(define (ctrlC-handler) (println "ctrl-C has been pressed"))

(signal SIGINT 'ctrlC-handler)

; now press ctrl-C
; the following line will appear
; this will only work in an interactive terminal window

ctrl-C has been pressed

; reset treatment of signal 2 to startup conditions

(signal SIGINT "reset")
</pre>


<p>上記例だと、MS Windowsでは newLISP が終了する前にハンドラを実行します。
多くの Linux/Unix systemsでは newLISP がロードされたまま留まり、[enter] キーを打った後にプロンプトが現れます。<br />
 On MS Windows, the above example would execute the handler before exiting newLISP.
On most Linux/Unix systems, newLISP would stay loaded and the prompt would appear 
after hitting the [enter] key.</p>

<p>シグナル・ハンドラが入ったシンボルを指定する代わりに、関数を直接指定できます。
（その際、）シグナル番号はパラメータとして渡せます：<br />
 Instead of specifying a symbol containing the signal handler,
a function can be specified directly.  The signal number is passed as a parameter:
</p>


<pre>
(signal SIGINT exit)  <span class='arw'>&rarr;</span> $signal-2

(signal SIGINT (fn (s) (println "signal " s " occurred")))
</pre>


<p>シグナル SIGKILL (ほとんどのプラットフォームで 9 ) はシグナル・ハンドラの存在に関わらず、常にアプリケーションを終了させることに注意してください。<br />
 Note that the signal SIGKILL (9 on most platforms) will always terminate the 
application regardless of an existing signal handler.</p>

<p>シグナルは、同じコンピュータ上の別のシェルから送ることができます：<br />
The signal could have been sent from another shell on the same computer:</p>


<pre>
kill -s SIGINT 2035
</pre>


<p>この例で、<tt>2035</tt> は走っている newLISP のプロセス ID です。<br />
In this example, <tt>2035</tt> is the process ID of the running newLISP.</p>

<p>シグナルは関数 <a href="#destroy">destroy</a> を使って別の newLISP アプリケーションから送ることもできます：<br />
The signal could also have been sent from another newLISP application using 
the function <a href="#destroy">destroy</a>:</p>


<pre>
(destroy 2035) <span class='arw'>&rarr;</span> true
</pre>


<p>newLISP が他の関数を評価中にシグナルを受け取ると、シグナルを受け入れ、ハンドラ関数を実行します：<br />
If newLISP receives a signal while evaluating another function,
it will still accept the signal and the handler function will be executed:</p>


<pre>
; only on Mac OSX, BSDs and Linux, not on Windows
(constant 'SIGINT 2)
(define (ctrlC-handler) (println "ctrl-C has been pressed"))

(signal SIGINT 'ctrlC-handler)
;; or
(signal SIGINT ctrlC-handler)


(while true (sleep 300) (println "busy"))

;; generates following output
busy
busy
busy
ctrl-C has been pressed
busy
busy
&hellip;
</pre>


<p>シグナル番号のみを指定すると、現在の定義ハンドラの名前か <tt>nil</tt> のどちらかが返ります。<br />
Specifying only a signal number will return either the name of 
the currently defined handler function or <tt>nil</tt>.
</p>

<p>ユーザ定義シグナル・ハンドラはパラメータにシグナル番号を渡せます。<br />
The user-defined signal handler can pass the signal number as a parameter.</p>


<pre>
(define (signal-handler sig)
	(println "received signal: " sig))

;; set all signals from 1 to 8 to the same handler	
(for (s 1 8) 
	(signal s 'signal-handler))
</pre>


<p>この例では、1 から 8 までの全シグナルが同じハンドラにセットされます。<br />
In this example, all signals from 1 to 8 are set to the same handler.</p>

<br/><br/>

<a name="silent"></a>
<h2><span class="function">silent</span></h2>

<h4>syntax: (silent [<em>exp-1</em> [<em>exp-2</em> ... ]])</h4>

<p><em>exp-1</em> 以下の一個以上の式を評価します。
<tt>silent</tt> は <a href="#begin">begin</a> に似ていますが、戻り値のコンソール出力とそれ続くプロンプトを抑制します。
これは、newLISPのリモート・アプリケーションからの通信（例えば、GUI フロント・エンドとか、他のnewLISP制御アプリケーションとか）の時や戻り値があまり意味のない時によく使われます<br />
	Evaluates one or more expressions in <em>exp-1</em>&mdash;.
	<tt>silent</tt> is similar to <a href="#begin">begin</a>,
	but it suppresses console output 
	of the return value 
	and the following prompt.
	It is often used 
	when communicating from 
	a remote application with newLISP 
	(e.g., GUI front-ends 
	or other applications controlling newLISP), 
	and the return value is of no interest.
</p>

<p>プロンプトに戻ると、サイレント・モードは解除されます。
このため、式の一括処理時には引数なしで使うこともできます。
インターラクティブモードの時、<tt>silent</tt> 文を使った後でプロンプトに戻るには、[enter] を二度打ちます。<br />
	Silent mode is reset when returning to a prompt.
	This way, 
	it can also be used without arguments 
	in a batch of expressions.
	When in interactive mode, 
	hit [enter] twice after a statement 
	using <tt>silent</tt> 
	to get the prompt back.
</p>


<!-- example -->

<pre>
(silent (my-func))  ; same as next

(silent) (my-func)  ; same effect as previous
</pre>

<br/><br/>

<a name="sin"></a>
<h2><span class="function">sin</span></h2>
<h4>syntax: (sin <em>num-radians</em>)</h4>

<p><em>num-radians</em> から正弦関数を計算し、結果を返します。<br />
	Calculates the sine function 
	from <em>num-radians</em> 
	and returns the result.
</p>

<!-- example -->

<pre>
(sin 1)                     <span class='arw'>&rarr;</span> 0.8414709838
(set 'pi (mul 2 (acos 0)))  <span class='arw'>&rarr;</span> 3.141592654
(sin (div pi 2))            <span class='arw'>&rarr;</span> 1
</pre>

<br/><br/>

<a name="sinh"></a>
<h2><span class="function">sinh</span></h2>
<h4>syntax: (sinh <em>num-radians</em>)</h4>

<p><em>num-radians</em> の双曲線正弦を計算します。
双曲線正弦は、次式で定義されています： <em>(exp (x) - exp (-x)) / 2</em>。
<em>num-radians</em> が大きすぎると、オーバーフロー<tt>inf</tt> になります。<br />
Calculates the hyperbolic sine of <em>num-radians</em>. 
The hyperbolic sine is defined mathematically as: <em>(exp (x) - exp (-x)) / 2</em>.
An overflow to <tt>inf</tt> may occur if <em>num-radians</em> is too large.</p>

<!-- example -->

<pre>
(sinh 1)     <span class='arw'>&rarr;</span> 1.175201194
(sinh 10)    <span class='arw'>&rarr;</span> 11013.23287
(sinh 1000)  <span class='arw'>&rarr;</span> inf
(sub (tanh 1) (div (sinh 1) (cosh 1))) <span class='arw'>&rarr;</span> 0
</pre>

<br/><br/>

<a name="sleep"></a>
<h2><span class="function">sleep</span></h2>

<h4>syntax: (sleep <em>num-milliseconds</em>)</h4>

<p>ミリ秒単位で指定された <em>num-milli-seconds</em> の CPU 時間を他のプロセスに与えます。<br />
Gives up CPU time to other processes for the amount of 
milliseconds specified in <em>num-milli-seconds</em>.
</p>

<!-- example -->

<pre>
(sleep 1000)  ; sleeps 1 second
(sleep 0.5)   ; sleeps 500 micro seconds
</pre>


<p>いくつかのプラットフォームでは、<tt>sleep</tt> は一秒の解像度でのみ利用できます。
この場合、<em>int-milli-seconds</em> パラメータは一番近い秒数に丸められます。<br />
On some platforms, <tt>sleep</tt> is only available with a resolution 
of one second. In this case, the parameter <em>int-milli-seconds</em> 
will be rounded to the nearest full second.</p>

<p><tt>sleep</tt> は <a href="#fork">fork</a> や <a href="#spawn">spawn</a> で開始した子プロセスを終わらせるショート・カットになるでしょう。<br />
A <tt>sleep</tt> may be cut short by a finishing child process started
with <a href="#fork">fork</a> or <a href="#spawn">spawn</a>.</p>

<br/><br/>

<a name="slice"></a>
<h2><span class="function">slice</span></h2>

<h4>syntax: (slice <em>list</em> <em>int-index</em> [<em>int-length</em>])<br/>
syntax: (slice <em>array</em> <em>int-index</em> [<em>int-length</em>])<br/>
syntax: (slice <em>str</em> <em>int-index</em> [<em>int-length</em>])</h4>

<p>第一形式の <tt>slice</tt> は、<em>list</em> から部分リスト（訳注:リストの一部）をコピーします。
元のリストは、変わりません。
部分リストはインデックス <em>int-index</em> から始まり、長さが <em>int-length</em> です。
<em>int-length</em> が負数なら、<tt>slice</tt> はパラメータを最後から数えるオフセットとして取りますが、そのオフセット位置は含みません（訳注：つまり、負数オフセット位置の要素は含まれない）。
（訳注：<em>int-length</em>）パラメータが無い場合、リストの最後までの全要素がコピーされます。）<br />
In the first form, <tt>slice</tt> copies a sublist 
from a <em>list</em>.  The original list is left unchanged.
The sublist extracted starts at index <em>int-index</em> 
and has a length of <em>int-length</em>.  If <em>int-length</em> is negative,
<tt>slice</tt> will take the parameter as offset counting from the end and copy 
up to but not including that offset.  If the parameter is omitted, 
<tt>slice</tt> copies all of the elements to the end of the list.</p>

<p>	<a href="#indexing">文字列、リスト、アレイの要素指定</a> も見てください。<br />
	See also <a href="#indexing">Indexing elements of strings and lists</a>.
</p>

<!-- example -->

<pre>
(slice '(a b c d e f) 3 2)   <span class='arw'>&rarr;</span> (d e)
(slice '(a b c d e f) 2 -2)  <span class='arw'>&rarr;</span> (c d)
(slice '(a b c d e f) 2)     <span class='arw'>&rarr;</span> (c d e f)
(slice '(a b c d e f) -4 3)  <span class='arw'>&rarr;</span> (c d e)

(set 'A (array 3 2 (sequence 1 6))) <span class='arw'>&rarr;</span> ((1 2) (3 4) (5 6))
(slice A 1 2) <span class='arw'>&rarr;</span> ((3 4) (5 6))
</pre>


<p>第二形式では、文字列 <em>str</em> の一部を取り出します。
<em>int-index</em> には開始インデックス、<em>int-length</em> には部分文字列の長さが入ります。
<em>int-length</em> が指定されないと、文字列の終りまでの全てが取り出されます。
<tt>slice</tt> は、<tt>0</tt>（ゼロ）のようなバイナリ・データからなる文字列バッファでも動作します。
<tt>slice</tt> はキャラクタ境界ではなく、バイト境界で動作します。
<a href="#indexing">文字列、リスト、アレイの要素指定</a> も見てください。<br />
In the second form, a part of the string in <em>str</em> 
is extracted.  <em>int-index</em> contains the start index
and <em>int-length</em> contains the length of the substring.
If <em>int-length</em> is not specified, everything to the end of the string is extracted.
<tt>slice</tt> also works on string buffers containing binary data like <tt>0</tt>'s (zeroes). 
It operates on byte boundaries rather than character boundaries.
See also <a href="#indexing">Indexing elements of strings and lists</a>.</p>

<p>UTF-8 版 newLISPでも、<tt>slice</tt> はオフセット数と長さにおいて、常に 8 ビット・1 バイト単位で動作することに注意してください。<br />
Note that <tt>slice</tt> always works on single 8-bit byte boundaries for
offset and length numbers, even when running the UTF-8 enabled version of newLISP.</p>

<!-- example -->

<pre>
(slice "Hello World" 6 2)  <span class='arw'>&rarr;</span> "Wo"
(slice "Hello World" 0 5)  <span class='arw'>&rarr;</span> "Hello"
(slice "Hello World" 6)    <span class='arw'>&rarr;</span> "World"
(slice "newLISP" -4 2)     <span class='arw'>&rarr;</span> "LI"

; UTF-8 strings are converted to a list, then joined again

(join (slice (explode "ΩΨΧΦΥΤΣΣΡΠΟΞΝΜΛΚΙΘΗΖΕΔΓΒΑ") 3 5))  <span class='arw'>&rarr;</span> "ΦΥΤΣΣ" 
</pre>


<p><em>implicit slice</em> がリストでも使えることもお忘れなく。
<a href="#implicit_rest_slice"><tt>rest</tt> や <tt>slice</tt> 的な暗黙インデックス</a> を見てください。<br />
	Note that an <em>implicit slice</em> 
	is available for lists.
	See the chapter <a href="#implicit_rest_slice">Implicit rest and slice</a>.
</p>

<p>UTF-8版 newLISP でも、<a href="#slice">slice</a> は常に文字境界ではなく、バイト境界で動作することを覚えておいてください。
そのため、<a href="#slice">slice</a> はバイナリ・データの操作に使えます。<br />
	Be aware that <a href="#slice">slice</a> 
	always works on byte boundaries 
	rather than character boundaries 
	in the UTF-8&ndash;enabled version of newLISP.
	As a result, 
	<a href="#slice">slice</a> can be used 
	to manipulate binary content.
</p>

<br/><br/>

<a name="sort"></a>
<h2><span class="function">sort</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (sort <em>list</em> [<em>func-compare</em>])<br/>
syntax: (sort <em>array</em> [<em>func-compare</em>])</h4>

<p><em>list</em> や <em>array</em> の全要素が、昇順に並べ替えられます。
型によらず、どんなものも並べ替えられます。
要素自身がリストの場合、各リスト要素は再帰的に比較されます。
異なる型の二つの式が比較されると、次の順序に従って低い型が高い型の前になります：<br />
All members in <em>list</em> or <em>array</em> are sorted in ascending order.
Anything may be sorted, regardless of the types.
When members are themselves lists or arrays, each element 
is recursively compared.  If two expressions 
of different types are compared, the lower type is sorted 
before the higher type in the following order:
</p>

<pre>
Atoms: nil, true, integer or float, string, symbol, primitive
Lists: quoted expression, list, lambda, lambda-macro
</pre>

<p><tt>sort</tt> は破壊的で、元のリストやアレイの要素の順序を変えて並べ替えたリストやアレイを返します。
安定したバイナリ・マージソートを使っているので、その性能は隣接した要素順でもほぼ <em>O(n log2 n)</em> が保たれます。
<em>func-compare</em> を使う時は、動作を安定させるために <tt>&lt;=</tt> か <tt>&gt;=</tt> を一緒に使うべきです。<br />
The <tt>sort</tt> is destructive, changing the order of the elements in the
original list or array and returning the sorted list or array. It is a stable
binary merge-sort with approximately <em>O(n log2 n)</em> performance
preserving the order of adjacent elements which are equal. When  
<em>func-compare</em> is used it must work with either <tt>&lt;=</tt> or
<tt>&gt;=</tt> operators to be stable.</p>

<p>オプションとして、比較演算子、ユーザ定義関数、無名関数を与えることができます。
ファンクタ（関数オブジェクト）やオペレータは、クォート無しで与えることが可能です。<br />
An optional comparison operator, user-defined function, 
or anonymous function can be supplied. The functor or operator 
can be given with or without a preceding quote.</p>

<!-- example -->

<pre>
(sort '(v f r t h n m j))     <span class='arw'>&rarr;</span> (f h j m n r t v)
(sort '((3 4) (2 1) (1 10)))  <span class='arw'>&rarr;</span> ((1 10) (2 1) (3 4))
(sort '((3 4) "hi" 2.8 8 b))  <span class='arw'>&rarr;</span> (2.8 8 "hi" b (3 4))

(set 's '(k a l s))
(sort s)  <span class='arw'>&rarr;</span> (a k l s)  

(sort '(v f r t h n m j) &gt;) <span class='arw'>&rarr;</span> (v t r n m j h f)

(sort s &lt;)  <span class='arw'>&rarr;</span> (a k l s)
(sort s &gt;)  <span class='arw'>&rarr;</span> (s l k a)  
s           <span class='arw'>&rarr;</span> (s l k a)

;; define a comparison function
(define (comp x y) 
    (&gt;= (last x) (last y)))
    
(set 'db '((a 3) (g 2) (c 5)))

(sort db comp)  <span class='arw'>&rarr;</span>  ((c 5) (a 3) (g 2))

;; use an anonymous function
(sort db (fn (x y) (&gt;= (last x) (last y))))
</pre>

<br/><br/>

<a name="source"></a>
<h2><span class="function">source</span></h2>
<h4>syntax: (source)<br/>
syntax: (source <em>sym-1</em> [<em>sym-2</em> ... ])</h4>

<p>ほとんど <a href="#save">save</a> と同じように動作しますが、シンボルとコンテキストはファイルに書かれる代わりに、<ruby><rb><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">直列化</a></rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>されます。
複数の変数シンボル、定義、コンテキストを指定できます。
引数が与えられない時、<tt>source</tt> は newLISP ワークスペースの全てを<ruby>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>します。
同様に、コンテキストが文字列化される時、コンテキストに含まれるいかなるシンボルも<ruby>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>されます。
<tt>nil</tt> の入っているシンボルは<ruby>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>されません。
<tt>$</tt> (dollar sign) 文字で始まるシステム変数は、指定された時のみ <ruby>直列化</rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>されます。<br />
	Works almost identically to <a href="#save">save</a>,
	except symbols and contexts get serialized to a string 
	instead of being written to a file.
	Multiple variable symbols,
	definitions, and contexts 
	can be specified.
	If no argument is given,
	<tt>source</tt> serializes the entire 
	newLISP workspace.
	When context symbols are serialized,
	any symbols contained within that context 
	will be serialized, as well.
	Symbols containing <tt>nil</tt> 
	are not serialized.
	System symbols beginning with the <tt>$</tt> (dollar sign) character 
	are only serialized when mentioned explicitly.
</p>

<p>現在のコンテキストに従属しないシンボルは、それらのコンテキストが先付されて書き込まれます。<br />
	Symbols not belonging to the current context
	are written out with their context prefix.
</p>

<!-- example -->

<pre>
(define (double x) (+ x x))

(source 'double)  <span class='arw'>&rarr;</span> "(define (double x)\n  (+ x x))\n\n"
</pre>


<p><a href="#save">save</a> の時のように、関数 <a href="#pretty-print">pretty-print</a> を使って行分割や先導スペースやタブを制御することができます。<br />
	As with <a href="#save">save</a>,
	the formatting of line breaks 
	and leading spaces or tabs 
	can be controlled using the 
	<a href="#pretty-print">pretty-print</a> function.
</p>

<br/><br/>

<a name="spawn"></a>
<h2><span class="function">spawn</span></h2>
<h4>syntax: (spawn <em>sym</em> <em>exp</em> [true])</h4>

<p><em>exp</em> の評価を子プロセスとして起動し、すぐに戻ります。
<em>sym</em> はクォートされ、関数<a href="#sync">sync</a> が実行された時の評価結果を受け取ります。
<tt>spawn</tt> は、コカレント・プロセスにおける式の並列評価開始に使われます。
マルチ・コア CPU 上で newLISP が走っているなら、オペレーティング・システム下で生成されたプロセスは別々のコアに割り当てられるでしょう。
その結果、式は並行して評価され、プロセス全体が高速化されます。<br />
Launches the evaluation of <em>exp</em> as a child process and immediately
returns. The symbol in <em>sym</em> is quoted and receives the result of the 
evaluation when the function <a href="#sync">sync</a> is executed. <tt>spawn</tt>
is used to start parallel evaluation of expressions in concurrent processes.
If newLISP is running on a multi-core CPU, the underlying operating system 
will distribute spawned processes onto different cores, thereby evaluating 
expressions in parallel and speeding up overall processing.</p>

<p>生成した子プロセスとの通信に、<a href="#send">send</a> か <a href="#receive">receive</a> を使う時は、オプションの <tt>true</tt> パラメーターを設定しなければなりません。<br />
The optional <tt>true</tt> parameter must be set if <a href="#send">send</a>
or <a href="#receive">receive</a> is used to communicated with the child
process spawned.</p>

<p>関数<tt>spawn</tt> は MS Windows では使えません。<br />
The function <tt>spawn</tt> is not available on MS Windows.</p>

<p>子プロセスを開始した後、<tt>spawn</tt> 式は分岐したプロセスのプロセス ID を返します。
次の例は、ある範囲の素数の計算において、範囲全体の計算の高速化を図るため、範囲を四つに分ける方法を示しています：<br />
After successfully starting a child process,  the <tt>spawn</tt> expression
returns the process id of the forked process. The following examples shows
how the calculation of a range of prime numbers can be split up in four sub ranges to
speed up the calculation of the whole range:</p>

<!-- example -->

<pre>
; calculate primes in a range
(define (primes from to)
  (local (plist)
      (for (i from to)
          (if (= 1 (length (factor i)))
              (push i plist -1)))
      plist))

; start child processes
(set 'start (time-of-day))

(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; wait for a maximum of 60 seconds for all tasks to finish
(sync 60000) ; returns true if all finished in time
; p1, p2, p3 and p4 now each contain a lists of primes

(println "time spawn: " (- (time-of-day) start))
(println "time simple: " (time  (primes 1 4000000)))

(exit)
</pre>


<p>1.83 Intel Core 2 Duo processor 上で、上記例は約 13 秒で終了します。
<tt>(primes 1 4000000)</tt> を使った素数の計算は、およそ20秒かかります。<br />
On a 1.83 Intel Core 2 Duo processor, the above example will finish
after about 13 seconds. Calculating all primes using <tt>(primes 1 4000000)</tt>
would take about 20 seconds.</p>

<p>関数 <a href="#sync">sync</a> は全ての子プロセスが終了するまで待ち、評価結果をシンボル <tt>p1</tt> ～ <tt>p4</tt> で受け取ります。
全ての結果が集まると、<tt>sync</tt> は待つのを止めて <tt>true</tt> を返します。
指定された時間が不足している時、<tt>sync</tt> は <tt>nil</tt> を返しますが、別の <tt>sync</tt> 宣言文に十分なウェイトを与えて結果を集めることができます。
短いタイムアウトを使って、待っている間に他のプロセスを行えます：<br />
The <a href="#sync">sync</a> function will wait for all child processes
to finish and receive the evaluation results in the symbols <tt>p1</tt> to
<tt>p4</tt>. When all results are collected, <tt>sync</tt>
will stop waiting and return <tt>true</tt>. When the time specified was
insufficient , <tt>sync</tt> will return <tt>nil</tt> and  another 
<tt>sync</tt> statement could be given to further wait and collect results. 
A short timeout time can be used to do other processing during waiting:</p>


<pre>
(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; print a dot after each 2 seconds of waiting
(until (sync 2000) (println "."))
</pre>


<p>パラメータ無しで使われた <tt>sync</tt> は待たずに、すぐにペンディング中の子プロセスのリストを返します。
<tt>primes</tt> の例では、続く <tt>sync</tt> 式が進行状態を見るために使われています：<br />
<tt>sync</tt> when used without any parameters, will not wait but immediately
return a list of pending child processes. For the <tt>primes</tt> example, the following
<tt>sync</tt> expression could be used to watch the progress:</p>


<pre>
(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; show a list of pending process ids after each three-tenths of a second
(until (sync 300) (println (sync)))
</pre>


<p><tt>-1</tt> のパラメータは、<tt>sync</tt> に非常に長い時間 (～ 1193 時間) を指定します。
より良い解決法は、待てるだけ待ってから、全てのペンディング中の子プロセスを <a href="#abort">abort</a> することです：<br />
A parameter of <tt>-1</tt> tells <tt>sync</tt> to wait for a very long time
(~ 1193 hours). A better solution would be to wait for a maximum time, 
then <a href="#abort">abort</a>  all pending child processes:</p>


<pre>
(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))

; wait for one minute, then abort and
; report unfinished PIDs

(if (not (sync 60000))
    (begin
        (println "aborting unfinished: " (sync))
        (abort))
    (println "all finished successfully")
)
</pre>


<p><tt>spawn</tt>、<tt>sync</tt>、<tt>abort</tt> の三関数は、<a href="http://supertech.csail.mit.edu/cilk/">Cilk</a> API 部品です。
オリジナルの実装は、マルチ CPU コア用に細分されたタスクの洗練されたスケジュール管理と割り当てを実行します。
newLISP の Cilk API 実装は、プラットフォーム下のオペレーティングシステムにプロセス管理を扱わせます。
API の中身は、Unix libc 関数 <tt>fork()</tt>、<tt>waitpid()</tt>、<tt>kill()</tt> を使って実装されています。
プロセスと子プロセス間の内部通信は、関数 <a href="#send">send</a> と <a href="#receive">receive</a> を使って実行されます。<br />
The three functions <tt>spawn</tt>, <tt>sync</tt> and <tt>abort</tt>
are part of the <a href="http://supertech.csail.mit.edu/cilk/">Cilk</a> API.
The original implementation also does sophisticated scheduling and allocation
of threaded tasks to multiple CPU cores. The newLISP implementation of the Cilk API
lets the operating system of the underlying platform handle process management.
Internally, the API is implemented using the Unix libc functions <tt>fork()</tt>,
<tt>waitpid()</tt> and <tt>kill()</tt>. Intercommunications between processes
and child processes is done using the <a href="#send">send</a> and 
<a href="#receive">receive</a> functions.</p>

<p><tt>spawn</tt> を生成されたサブタスクから再帰的に呼び出すこともできます：<br />
<tt>spawn</tt> can be called recursively from spawned subtasks:</p>


<pre>
(define (fibo n)
  (local (f1 f2)
    (if(&lt; n 2) 1
       (begin
          (spawn 'f1 (fibo (- n 1)))
          (spawn 'f2 (fibo (- n 2)))
          (sync 10000)
          (+ f1 f2)))))

(fibo 7)  <span class='arw'>&rarr;</span> 21
</pre>


<p><tt>(fibo 7)</tt> では、41 プロセスが生成されます。
上記コードは、再帰アプリケーション での Cilk API の動作を示していますが、spawn のサブタスクに要求されるオーバーヘッドが並列化で救われる時間よりもはるかに大きいので、実用的ではありません。<br />
With <tt>(fibo 7)</tt> 41 processes will be generated. Although the above
code shows the working of the Cilk API in a recursive application, 
it would not be practical, as the overhead required to spawn subtasks 
is much higher than the time saved through parallelization.</p>

<p>バージョン 10.1 以来、メッセージ関数 <a href="#send">send</a> と <a href="#receive">receive</a> は、親子のプロセス間通信に利用できます。
これらの関数を使うことで、いかなるサイズのいかなるデータや式も伝送できます。
付け加えて、メッセージの式は受け取り側の環境で評価されます。<br />
Since version 10.1 a <a href="#send">send</a> and <a href="#receive">receive</a>
message functions are available for communications between parent and child processes. 
Using these functions any data or expression of any size can be transferred. 
Additionally messaged expressions can be evaluated in the recipient's environment.</p>

<p>newLISP プロセスを開始する別の方法として、<a href="#fork">fork</a> と <a href="#process">process</a> があります。<br />
<a href="#fork">fork</a> and <a href="#process">process</a> are other functions
to start newLISP processes.</p>

<br/><br/>

<a name="sqrt"></a>
<h2><span class="function">sqrt</span></h2>
<h4>syntax: (sqrt <em>num</em>)</h4>

<p><em>num</em> の式から平方根を計算し、結果を返します。<br />
	Calculates the square root from 
	the expression in <em>num</em> 
	and returns the result.
</p>

<!-- example -->

<pre>
(sqrt 10)  <span class='arw'>&rarr;</span> 3.16227766
(sqrt 25)  <span class='arw'>&rarr;</span> 5
</pre>

<br/><br/>

<a name="ssq"></a>
<h2><span class="function">ssq</span></h2>
<h4>syntax: (ssq <em>list-vector | array-vector</em>)</h4>

<p><em>list-vector</em> や <em>array-vector</em> ベクトル中の数値の二乗和を計算します。<br />
Calculates the sum of squares of numbers in a vector in 
<em>list-vector</em> or <em>array-vector</em>.</p>

<!-- example -->

<pre>
(set 'vector (sequence 1 10))
(ssq vector) <span class='arw'>&rarr;</span> 385

(set 'vector (array 10 (sequence 1 10)))
(ssq vector) <span class='arw'>&rarr;</span> 385
</pre>

<br/><br/>

<a name="starts-with"></a>
<h2><span class="function">starts-with</span></h2>
<h4>syntax: (starts-with <em>str</em> <em> str-key</em> [<em>num-option</em>])<br/>
syntax: (starts-with <em>list</em> [<em>exp</em>])</h4>

<p>第一形式の <tt>starts-with</tt> は、文字列 <em>str</em> がキー文字列 <em>str-key</em> から始まるかどうかをチェックし、結果次第で <tt>true</tt> か <tt>nil</tt> を返します。<br />
In the first version, <tt>starts-with</tt> checks if the string <em>str</em> 
starts with a key string in <em>str-key</em> and returns <tt>true</tt> or <tt>nil</tt> 
depending on the outcome.</p>

<p>	正規表現用の数値を <em>num-option</em> に指定するなら、<em>str-key</em> に入るのは正規表現パターンです。
有効な <em>option</em> 番号は <a href="#regex">regex</a> を参照してください。<br />
If a regular expression number is specified in <em>num-option</em>,
<em>str-key</em> contains a regular expression pattern.
See <a href="#regex">regex</a> for valid <em>option</em> numbers. </p>

<!-- example -->

<pre>
(starts-with "this is useful" "this")        <span class='arw'>&rarr;</span> true
(starts-with "this is useful" "THIS")        <span class='arw'>&rarr;</span> nil

;; use regular expressions
(starts-with "this is useful" "THIS" 1)      <span class='arw'>&rarr;</span> true
(starts-with "this is useful" "this|that" 0) <span class='arw'>&rarr;</span> true
</pre>


<p>	第二形式の <tt>starts-with</tt> は、リストが <em>exp</em> のリスト要素で始まるかどうかをチェックし、結果次第で <tt>true</tt> か <tt>nil</tt> を返します。<br />
In the second version, <tt>starts-with</tt> checks to see if a list 
starts with the list element in <em>exp</em>.  <tt>true</tt> or <tt>nil</tt> 
is returned depending on outcome.</p>

<!-- example -->

<pre>
(starts-with '(1 2 3 4 5) 1)             <span class='arw'>&rarr;</span> true
(starts-with '(a b c d e) 'b)            <span class='arw'>&rarr;</span> nil
(starts-with '((+ 3 4) b c d) '(+ 3 4))  <span class='arw'>&rarr;</span> true
</pre>



<p>関数 <a href="#ends-with">ends-with</a> も見てください。<br />
	See also the <a href="#ends-with">ends-with</a> function.
</p>

<br/><br/>

<a name="stats"></a>
<h2><span class="function">stats</span></h2>
<h4>syntax: (stats <em>list-vector</em>)</h4>

<p>この関数は <em>list-vector</em> の値から、<a href="http://www2.hak.hokkyodai.ac.jp/fukuda/lecture/SocialLinguistics/03average.html">中心傾向</a>や<a href="http://ja.wikipedia.org/wiki/%E3%83%A2%E3%83%BC%E3%83%A1%E3%83%B3%E3%83%88_(%E6%95%B0%E5%AD%A6)">分布積率</a>などの様々な統計値を計算します。 
<tt>stats</tt> が返すリストには次の値が入ります:<br />
The functions calculates statistical values of central tendency and distribution moments
of values in <em>list-vector</em>. The following values are returned by <tt>stats</tt>
in a list:</p>

<table>
<tr align="left"><th>name</th><th>description</th></tr>
<tr><td>N</td><td>個数<br />Number of values</td></tr>
<tr><td>mean</td><td>平均値<br />Mean of values</td></tr>
<tr><td>avdev</td><td>平均偏差<br />Average deviation from mean value</td></tr>
<tr><td>sdev</td><td><a href="http://ja.wikipedia.org/wiki/%E6%A8%99%E6%BA%96%E5%81%8F%E5%B7%AE">標準偏差</a></a>（母集団推定）<br />Standard deviation (population estimate)</td></tr>
<tr><td>var</td><td><a href="http://ja.wikipedia.org/wiki/%E5%88%86%E6%95%A3">分散</a>（母集団推定）<br />Variance (population estimate)</td></tr>
<tr><td>skew</td><td>分布の<a href="http://ja.wikipedia.org/wiki/%E6%AD%AA%E5%BA%A6">歪度</a><br />Skew of distribution</td></tr>
<tr><td>kurt</td><td>分布の<a href="http://ja.wikipedia.org/wiki/%E5%B0%96%E5%BA%A6">尖度</a><br />Kurtosis of distribution</td></tr>
</table>
<br/>

<!-- example -->

<p>次の例は <tt>stats</tt> の出力リスト式を <a href="#format">format</a> 宣言文の引数に使っています:<br />
The following example uses the list output from the <tt>stats</tt> expression as an
argument for the <a href="#format">format</a> statement:</p>

<pre>
(set 'data '(90 100 130 150 180 200 220 300 350 400))

(println (format [text]
    N        = %5d
    mean     = %8.2f
    avdev    = %8.2f
    sdev     = %8.2f
    var      = %8.2f
    skew     = %8.2f
    kurtosis = %8.2f
[/text] (stats data)))

; outputs the following

    N        =    10
    mean     =   212.00
    avdev    =    84.40
    sdev     =   106.12
    var      = 11262.22
    skew     =     0.49
    kurtosis =    -1.34

</pre>


<br/><br/>

<a name="string"></a>
<h2><span class="function">string</span></h2>
<h4>syntax: (string <em>exp-1</em> [<em>exp-2</em> ... ])</h4>

<p><em>exp-1</em>&ndash; の評価のいかなる結果も、文字列に変換します。
一個の式より多い場合、結果の文字列は結合されます。<br />
	Translates into a string anything that results 
	from evaluating <em>exp-1</em>&mdash;.
	If more than one expression is specified, 
	the resulting strings are concatenated.
</p>

<!-- example -->

<pre>
(string 'hello)          <span class='arw'>&rarr;</span> "hello"
(string 1234)            <span class='arw'>&rarr;</span> "1234"
(string '(+ 3 4))        <span class='arw'>&rarr;</span> "(+ 3 4)"
(string (+ 3 4) 8)       <span class='arw'>&rarr;</span> "78"
(string 'hello " " 123)  <span class='arw'>&rarr;</span> "hello 123"
</pre>


<p><tt>string</tt> に渡されたバッファが <tt>\000</tt> を含んでいるなら、最初のゼロ（訳注：<tt>\000</tt>）までの文字列がコピーされます：<br />
	If a buffer passed to <tt>string</tt> 
	contains <tt>\000</tt>,
	only the string up to the first terminating zero will be copied:
</p>


<pre>
(set 'buff "ABC\000\000\000")  <span class='arw'>&rarr;</span> "ABC\000\000\000"

(length buff)  <span class='arw'>&rarr;</span> 6

(string buff)  <span class='arw'>&rarr;</span> "ABC"

(length (string buff))  <span class='arw'>&rarr;</span> 3
</pre>


<p>ゼロ・バイトを含む文字列の結合には、関数 <a href="#append">append</a> か（指定された結合文字を許可する）<a href="#join">join</a> を使ってください。
ラムダ式を newLISP ソース文字列表現に変換するためには、関数 <a href="#source">source</a> を使ってください。<br />
	Use the <a href="#append">append</a> 
	and <a href="#join">join</a> 
	(allows the joining string 
	to be specified) functions 
	to concatenate strings containing zero bytes.
	Use the <a href="#source">source</a> function 
	to convert a lambda expression 
	into its newLISP source string representation.
</p>

<br/><br/>

<a name="stringp"></a>
<h2><span class="function">string?</span></h2>
<h4>syntax: (string? <em>exp</em>)</h4>

<p><em>exp</em> を評価し、それが文字列かどうかをテストします。
結果次第で <tt>true</tt> か <tt>nil</tt> が返ります。<br />
	Evaluates <em>exp</em> and tests 
	to see if it is a string.
	Returns <tt>true</tt> or <tt>nil</tt>
	depending on the result.
</p>

<!-- example -->

<pre>
(set 'var "hello")
(string? var)  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="struct"></a>
<h2><span class="function">struct</span></h2>
<h4>syntax: (struct <em>symbol</em> [<em>str-data-type</em> ... ])</h4>

<p>関数 <tt>struct</tt> は <i>libffi</i> をコンパイルした newLISP 全バージョンで利用可能で、<a href="#import">import</a>、<a href="#pack">pack</a>、<a href="#unpack">unpack</a> の拡張構文で使用するデータ型集合体を定義するために使えます。これにより、C 言語の<em>構造体</em> データ型やデータ型集合体のポインタを取る関数の導入が可能になります。<br />
The <tt>struct</tt> function can be used to define aggregate data types for 
usage with the extended syntax of <a href="#import">import</a>,
<a href="#pack">pack</a> and <a href="#unpack">unpack</a>, available on all
versions of newLISP compiled with <i>libffi</i>. This allows importing
functions which take C-language <em>struct</em> data types or pointers to these
aggregate data types.</p>

<p>以下の例では、C のデータ関数 <tt>localtime</tt> と <tt>asctime</tt> における <tt>struct</tt> の使い方を示しています。
関数 <tt>localtime</tt> は組込関数 <a href="#now">now</a> に似た動作をします。
関数 <tt>asctime</tt> は <tt>localtime</tt> の出力する数値データを取って、可読性のよいテキストに整形します。<br />
The following example illustrates the usage of <tt>struct</tt> together with
the C data functions <tt>localtime</tt> and <tt>asctime</tt>. The <tt>localtime</tt>
functions works similar to the built-in <a href="#now">now</a> function. The
<tt>asctime</tt> function takes the numerical data output by <tt>localtime</tt>
and formats these to readable text.</p>

<pre>
/* The C function prototypes for the functions to import */

struct tm * localtime(const time_t *clock);

char * asctime(const struct tm *timeptr);

/* the tm struct aggregating different time related values */

struct tm {
    int tm_sec;      /* seconds after the minute [0-60] */
    int tm_min;      /* minutes after the hour [0-59] */
    int tm_hour;     /* hours since midnight [0-23] */
    int tm_mday;     /* day of the month [1-31] */
    int tm_mon;      /* months since January [0-11] */
    int tm_year;     /* years since 1900 */
    int tm_wday;     /* days since Sunday [0-6] */
    int tm_yday;     /* days since January 1 [0-365] */
    int tm_isdst;    /* Daylight Savings Time flag */
    long tm_gmtoff;  /* offset from CUT in seconds */   /*** not on Windows ***/
    char *tm_zone;   /* timezone abbreviation */        /*** not on Windows ***/
};
</pre>

<p>newLISP における関数の導入と構造体データ型の定義：<br />
Function import and definition of the structure data type in newLISP:</p>

<pre>
;; for pointers to structs always use void*
;; as a library use msvcrt.dll on Windows or libc.so on Unix.
;; The tm struct type is configured for Mac OSX and Linux.
;; On other OS the tm structure may be different
 
(import "libc.dylib" "asctime" "char*" "void*")
(import "libc.dylib" "localtime" "void*" "void*")

; definition of the struct
(struct 'tm "int" "int" "int" "int" "int" "int" "int" "int" "int" "long" "char*")


;; use import and struct

; todays date number (seconds after 1970 also called Unix epoch time)
(set 'today (date-value))  <span class='arw'>&rarr;</span> 1324134913

;; the time value is passed by it's address
;; localtime retirns a pointer to a tm struct

(set 'ptr (localtime (address today))) <span class='arw'>&rarr;</span> 2896219696

; unpack the tm struct  (7:15:13 on the 17th etc.)
(unpack tm ptr) <span class='arw'>&rarr;</span> (13 15 7 17 11 111 6 350 0 -28800 "PST")

; transform to readable form
(asctime ptr) <span class='arw'>&rarr;</span> "Sat Dec 17 07:15:13 2011\n"

; all in one statement does actually not use struct, pointers are passed directly
(asctime (localtime (address today))) <span class='arw'>&rarr;</span> "Sat Dec 17 07:15:13 2011"

; same as the built-in date function
(date today) <span class='arw'>&rarr;</span> "Sat Dec 17 07:15:13 2011"
</pre>

<p>導入された関数へのポインタ変数には有効なアドレスを渡すように注意すべきです。
<a href="#unpack">unpack</a> にアドレス・ポインタを渡す際も同様です。
無効なアドレス・ポインタは newLISP をクラッシュしたり、動作を不安定にしかねません。<br />
Care must be taken to pass valid addresses to pointer parameters in imported functions
or when passing address pointers to <a href="#unpack">unpack</a>. Invalid address pointers
can crash newLISP or make it unstable.</p>

<p><tt>struct</tt> の定義は入れ子も可能です：<br />
<tt>struct</tt> definitions can be nested:</p>

<pre>
; the pair aggregate type
(struct 'pair "char" "char") <span class='arw'>&rarr;</span> pair

; nested struct type
(struct 'comp "pair" "int")  <span class='arw'>&rarr;</span> comp

; pack data using the extended pack syntax
; note the insertion of structure alignment bytes after the pair
(pack comp (pack pair 1 2) 3) <span class='arw'>&rarr;</span> "\001\002\000\000\003\000\000\000"

; unpack reverses the process
(unpack comp "\001\002\000\000\003\000\000\000") <span class='arw'>&rarr;</span> ((1 2) 3)
</pre>

<p>入れ子構造は再帰的にアンパックされます。<br />
Nested structures are unpacked recursively.</p>

<br/><br/>


<a name="sub"></a>
<h2><span class="function">sub</span></h2>
<h4>syntax: (sub <em>num-1</em> [<em>num-2</em> ... ])</h4>

<p><em>num-1</em>, <em>num-2</em> 以下の式を連続的に引き算します。
<tt>sub</tt> は（訳注：整数と浮動小数点数の）混在型算術を実行し、整数と浮動小数点を扱えますが、常に浮動小数点を返します。
一個だけの引数が供給された時は、符号が逆になります。
<tt>NaN</tt> を伴なう浮動小数点計算では如何なる場合も <tt>NaN</tt> を返します。<br />
	Successively subtracts
	the expressions in <em>num-1</em>,
	<em>num-2</em>&mdash;.
	<tt>sub</tt> performs mixed-type arithmetic 
	and handles integers or floating points,
	but it will always return 
	a floating point number.
	If only one argument is supplied,
	its sign is reversed.
	Any floating point calculation 
	with <tt>NaN</tt> also returns <tt>NaN</tt>.
</p>

<!-- example -->

<pre>
(sub 10 8 0.25)  <span class='arw'>&rarr;</span> 1.75
(sub 123)        <span class='arw'>&rarr;</span> -123
</pre>

<br/><br/>

<a name="swap"></a>
<h2><span class="function">swap</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (swap <em>place-1</em> <em>place-2</em>)</h4>

<p><em>place-1 と place-2</em> の内容を交換します。
<em>place</em> の対象となるのは、クォートなしのシンボル、リスト、<a href="#nth">nth</a>、<a href="#first">first</a>、<a href="#lst">last</a> で表れされた参照、暗黙の <a href="#indexing">要素指定</a>、<a href="#assoc">assoc</a>、<a href="#lookup">lookup</a> で参照された場所等の中身です。<br />
The contents of the two places <em>place-1 and place-2</em> 
are swapped. A <em>place</em> can be the contents of an unquoted symbol or any
list or array references expressed with <a href="#nth">nth</a>, 
 <a href="#first">first</a>, <a href="#lst">last</a> or implicit
 <a href="#indexing">indexing</a> or places referenced by <a href="#assoc">assoc</a>
or <a href="#lookup">lookup</a>.</p>

<p><tt>swap</tt> は含まれているリスト、アレイ、シンボルを変化させる破壊的操作です。<br />
<tt>swap</tt> is a destructive operation that changes the contents of the 
lists, arrays, or symbols involved.</p>

<!-- example -->

<pre>
(set 'lst '(a b c d e f))

(swap (first lst) (last lst)) <span class='arw'>&rarr;</span> a
lst                           <span class='arw'>&rarr;</span> (f b c d e a)

(set 'lst-b '(x y z))

(swap (lst 0) (lst-b -1)) <span class='arw'>&rarr;</span> f
lst                       <span class='arw'>&rarr;</span> (z b c d e a)
lst-b                     <span class='arw'>&rarr;</span> (x y f)

(set 'A (array 2 3 (sequence 1 6)) <span class='arw'>&rarr;</span> ((1 2 3) (4 5 6))

(swap (A 0) (A 1)) <span class='arw'>&rarr;</span> (1 2 3)
A                  <span class='arw'>&rarr;</span> ((4 5 6) (1 2 3))

(set 'x 1 'y 2)

(swap x y)  <span class='arw'>&rarr;</span> 1
x  <span class='arw'>&rarr;</span> 2
y  <span class='arw'>&rarr;</span> 1

(set 'lst '((a 1 2 3) (b 10 20 30)))
(swap (lookup 'a lst -1) (lookup 'b lst 1))
lst <span class='arw'>&rarr;</span> ((a 1 2 10) (b 3 20 30))

(swap (assoc 'a lst) (assoc 'b lst))
lst <span class='arw'>&rarr;</span>  ((b 3 20 30) (a 1 2 10))
</pre>


<p>二つの場所が如何なるものであれ、同じまたは違うオブジェクトが交換されます。<br />
Any two places can be swept in the same or different objects.</p>

<br/><br/>

<a name="sym"></a>
<h2><span class="function">sym</span></h2>
<h4>syntax: (sym <em>string</em> [<em>sym-context</em> [<em>nil-flag</em>]])<br/>
syntax: (sym <em>number</em> [<em>sym-context</em> [<em>nil-flag</em>]])<br/>
syntax: (sym <em>symbol</em> [<em>sym-context</em> [<em>nil-flag</em>]])</h4>

<p>第一引数の <em>string</em>、<em>number</em>、<em>symbol</em> をシンボルに変換し、それを返します。
<em>sym-context</em> にコンテキストが指定されない時は、シンボルを参照した時、または生成する時の現コンテキストが使われます。
シンボルが存在していない時は生成されます。
存在していないコンテキストがクォート付きシンボルで指定された時も、シンボルは生成されます（訳注：コンテキストも生成されます）。
コンテキスト指定がクォート無しの時、コンテキストが指定された名前になるか、コンテキスト指定がそのコンテキストを含む変数になります（訳注：この場合、コンテキストが存在していないと、エラーになります）。<br />
	Translates the first argument in <em>string</em>, 
	<em>number</em>, or <em>symbol</em> 
	into a symbol and returns it.
	If the optional context is not specified 
	in <em>sym-context</em>, 
	the current context is used 
	when doing symbol lookup or creation.
	Symbols will be created 
	if they do not already exist.
	When the context does not exist
	and the context is specified by a quoted symbol, 
	the symbol also gets created.
	If the context specification is unquoted, 
	the context is the specified name 
	or the context specification is a variable 
	containing the context.
</p>

<p><tt>sym</tt> は、newLISP ソース・コードでは適正でないシンボルをシンボル・テーブル内に生成できます(例えば、数字、括弧やコロン等の特殊文字を含む名前) 。
これにより、他のスクリプト言語における <em>hash table</em> アクセスのような連想メモリ・アクセス用の関数として、<tt>sym</tt> を使えるようになります。<br />
	<tt>sym</tt> can create symbols within the symbol table
	that are not legal symbols in newLISP source code
	(e.g., numbers or names containing special characters
	such as parentheses, colons, etc.).
	This makes <tt>sym</tt> usable 
	as a function for associative memory access, 
	much like <em>hash table</em> access 
	in other scripting languages. 
</p>

<p>	第三引数オプションとして、シンボルが見つからない時のシンボル生成を止めるために、<tt>nil</tt> を指定できます。
この場合、シンボルが存在しない時の <tt>sym</tt> は <tt>nil</tt> を返します。
この最後の形式を使うことで、<tt>sym</tt> をシンボルの存在チェックに使えます。<br />
	As a third optional argument,
	<tt>nil</tt> can be specified 
	to suppress symbol creation 
	if the symbol is not found.
	In this case,
	<tt>sym</tt> returns <tt>nil</tt> 
	if the symbol looked up does not exist.
	Using this last form,
	<tt>sym</tt> can be used 
	to check for the existence 
	of a symbol.
</p>

<!-- example -->

<pre>
(sym "some")           <span class='arw'>&rarr;</span> some
(set (sym "var") 345)  <span class='arw'>&rarr;</span> 345
var                    <span class='arw'>&rarr;</span> 345
(sym "aSym" 'MyCTX)    <span class='arw'>&rarr;</span> MyCTX:aSym
(sym "aSym" MyCTX)     <span class='arw'>&rarr;</span> MyCTX:aSym  ; unquoted context

(sym "foo" MyCTX nil)  <span class='arw'>&rarr;</span> nil  ; 'foo does not exist
(sym "foo" MyCTX)      <span class='arw'>&rarr;</span> foo  ; 'foo is created
(sym "foo" MyCTX nil)  <span class='arw'>&rarr;</span> foo  ; foo now exists
</pre>


<p>関数 <tt>sym</tt> はシンボルを検出または生成するので、<tt>sym</tt> と一緒の式はシンボルを引数として使う他の式に直接埋め込めます。
次の例では、連想メモリ・アクセスのハッシュ・ライク関数としての <tt>sym</tt> の使用例と、同時に newLISP シンボルとして適正でないシンボルの生成を示しています：<br />
	Because the function <tt>sym</tt> 
	returns the symbol looked up or created,
	expressions with <tt>sym</tt> can be embedded 
	directly in other expressions 
	that use symbols as arguments.
	The following example shows 
	the use of <tt>sym</tt> 
	as a hash-like function 
	for associative memory access, 
	as well as symbol configurations 
	that are not legal newLISP symbols:
</p>

<!-- example -->

<pre>
;; using sym for simulating hash tables

(set (sym "John Doe" 'MyDB) 1.234)
(set (sym "(" 'MyDB) "parenthesis open")
(set (sym 12 'MyDB) "twelve")

(eval (sym "John Doe" 'MyDB))  <span class='arw'>&rarr;</span> 1.234
(eval (sym "(" 'MyDB))         <span class='arw'>&rarr;</span> "parenthesis open"
(eval (sym 12 'MyDB))          <span class='arw'>&rarr;</span> "twelve"

;; delete a symbol from a symbol table or hash
(delete (sym "John Doe" 'MyDB))  <span class='arw'>&rarr;</span> true
</pre>


<p>最後の行は、<a href="#delete">delete</a> を使ってシンボルを削除できる例です。<br />
	The last statement shows 
	how a symbol can be eliminated 
	using <a href="#delete">delete</a>.
</p>

<p>第三構文は、シンボル名としての文字列の代わりに、シンボルを目標コンテキストに使われることを許します。
この場合、<tt>sym</tt> はシンボルから名前を取り出し、それを目標コンテキストでのシンボル用名前の文字列として使います：<br />
	The third syntax allows symbols to be used 
	instead of strings for the symbol name 
	in the target context.
	In this case,
	<tt>sym</tt> will extract the name from the symbol 
	and use it as the name string 
	for the symbol in the target context:
</p>

<!-- example -->

<pre>
(sym 'myVar 'FOO)  <span class='arw'>&rarr;</span> FOO:myVar

(define-macro (def-context)
  (dolist (s (rest (args)))
    (sym s (first (args)))))

(def-context foo x y z)

(symbols foo)  <span class='arw'>&rarr;</span> (foo:x foo:y foo:z)
</pre>


<p><tt>def-context</tt> マクロは、これ（訳注：<tt>sym</tt>）が動的にコンテキストとその変数を生成するマクロを生成するために、どのように使われているかを示しています。<br />
The <tt>def-context</tt> macro shows how this could be used 
to create a macro that creates contexts and their variables 
in a dynamic fashion.</p>

<p>関数 <a href="#context">context</a> の構文は、シンボルの生成、セット、評価にも使えます。<br />
 A syntax of the <a href="#context">context</a> function can also be used to 
create, set and evaluate symbols.
</p>

<br/><br/>

<a name="symbolp"></a>
<h2><span class="function">symbol?</span></h2>
<h4>syntax: (symbol? <em>exp</em>)</h4>

<p>式 <em>exp</em> を評価し、その値がシンボルなら <tt>true</tt> を返し、それ以外では <tt>nil</tt> を返します。<br />
	Evaluates the <em>exp</em> expression 
	and returns <tt>true</tt> if the value is a symbol;
	otherwise, it returns <tt>nil</tt>.
</p>

<!-- example -->

<pre>
(set 'x 'y)  <span class='arw'>&rarr;</span> y

(symbol? x)  <span class='arw'>&rarr;</span> true 

(symbol? 123)  <span class='arw'>&rarr;</span> nil

(symbol? (first '(var x y z)))  <span class='arw'>&rarr;</span> true
</pre>


<p>一行目は、<tt>x</tt> の内容をシンボル <tt>y</tt> にセットしています。
二行目は、<tt>x</tt> の内容をチェックしています。
最後の例は、リストの最初の要素をチェックしています。<br />
	The first statement sets the contents of <tt>x</tt> 
	to the symbol <tt>y</tt>.
	The second statement then checks the contents of <tt>x</tt>.
	The last example checks the first element of a list.
</p>

<br/><br/>

<a name="symbols"></a>
<h2><span class="function">symbols</span></h2>
<h4>syntax: (symbols [<em>context</em>])</h4>

<p>引数なしで呼ばれた時、現コンテキストでの全シンボルのリストをソートして返します。
コンテキスト・シンボルを指定すると、そのコンテキストで定義されたシンボルを返します。<br />
	Returns a sorted list of all symbols 
	in the current context 
	when called without an argument.
	If a context symbol is specified, 
	symbols defined in that context are returned.
</p>

<!-- example -->

<pre>
(symbols)       ; list of all symbols in current context
(symbols 'CTX)  ; list of symbols in context CTX
(symbols CTX)   ; omitting the quote
(set 'ct CTX)   ; assigning context to a variable
(symbols ct)    ; list of symbols in context CTX
</pre>


<p>コンテキストは、それ自身に評価されるので、クォートを省略できます。<br />
	The quote can be omitted 
	because contexts evaluate to themselves.
</p>

<br/><br/>

<a name="sync"></a>
<h2><span class="function">sync</span></h2>
<h4>syntax: (sync <em>int-timeout</em> [<em>func-inlet</em>])<br/>
syntax: (sync)</h4>

<p>ミリ秒単位の <em>int-timeout</em> を指定された <tt>sync</tt> は、<a href="#spawn">spawn</a> で起動された子プロセスの終了を待ちます。
子プロセスが終了した時はいつも、<tt>sync</tt> は、産み出されたサブタスクの評価結果を spawn 宣言文で指定されたシンボルに割り当てます。
<tt>sync</tt> は、全ての子プロセスがプロセスし終えたなら <tt>true</tt> を返し、タイムアウト値を越えても多くの子プロセスがペンディング中の時 <tt>nil</tt> を返します。<br />
When <em>int-timeout</em> in milliseconds is specified, <tt>sync</tt> waits 
for child processes launched with <a href="#spawn">spawn</a> to finish. 
Whenever a child process finishes, <tt>sync</tt> assigns the evaluation result 
of the spawned subtask to the symbol specified in the spawn statement.
The <tt>sync</tt> returns <tt>true</tt> if all child processes have been processed 
or <tt>nil</tt> if the timeout value has been reached and more child processes
are pending.</p>

<p><tt>sync</tt> が <em>func-inlet</em> に追加のオプション・ユーザ定義 <em>inlet</em> 関数を与えられると、この関数は産み出された子プロセスが戻ってきた時、常に子プロセス ID を引数として呼び出されます。
<em>func-inlet</em> は、ラムダ式か、関数を定義されたシンボルのどちらかになります。
<br />
If <tt>sync</tt> additionally is given with an optional user-defined <em>inlet</em> 
function in <em>func-inlet</em>, this function  will be called with the child process-id
as argument whenever a spawned child process returns. <em>func-inlet</em> can contain 
either a lambda expression or a symbol which defines a function.</p>

<p>パラメータ無しの時の <tt>sync</tt> は、結果がまだ戻ってきていないペンディング中の子プロセス PID (プロセス指定子) のリストを返します。
<br />
Without any parameter, <tt>sync</tt> returns a list of pending child process
PIDs (process identifiers), for which results have not been processed yet.</p>

<p>関数 <tt>sync</tt> は、MS Windows では使えません。<br />
The function <tt>sync</tt> is not available on MS Windows.</p>

<!-- example -->

<pre>
; wait for 10 seconds and process finished child processes
(sync 10000) 

; wait for the maximum time (~ 1193 hours)
(sync -1) 

(define (report pid)
    (println "process: " pid " has returned"))

; call the report function, when a child returns
(sync 10000 report) ; wait for 10 seconds max

; return a list of pending child processes
(sync)         <span class='arw'>&rarr;</span> (245 246 247 248)

; wait and do something else
(until (true? (sync 10 report) )
    (println (time-of-day)))

</pre>


<p>タイムアウト・パラメータを与えられた <tt>sync</tt> は、タイムアウトか、子プロセスが戻ってくるか、のどちらか早い方まで止まります。
パラメータ無しか、関数が指定された時、<tt>sync</tt> は直ちに戻ります。<br />
When <tt>sync</tt> is given with a timeout parameter, it will block
until timeout or until all child processes have returned, whichever
comes earlier. When no parameter is specified or a function is specified,
<tt>sync</tt> returns immediately.</p>


<p>関数 <tt>sync</tt> は、子プロセスの同期とプロセスの並列化のための Cilk API の部品です。
Cilk API の全貌は、関数 <a href="#spawn">spawn</a> のリファレンスを見てください。<br />
The function <tt>sync</tt> is part of the Cilk API for synchronizing
child processes and process parallelization. See the reference for the
function <a href="#spawn">spawn</a> for a full discussion of the Cilk API.</p>

<br/><br/>


<a name="sys-error"></a>
<h2><span class="function">sys-error</span></h2>
<h4>syntax: (sys-error)<br/>
syntax: (sys-error <em>int-error</em>)<br/>
syntax: (sys-error <tt>0</tt>)</h4>

<p>newLISP の走っている OS で発生した最後のエラーを報告します。
報告されるエラーは、newLISP がコンパイルされたプラットフォームで異なります。
プラットフォームの C ライブラリの情報を調べてください。
エラーは、エラー番号とエラー・テキストのリストで報告されます。<br />
Reports the last error generated by the underlying OS 
which newLISP is running on.  The error reported 
may differ on the platforms newLISP has been compiled for.
Consult the platform's C library information. The error is
reported as a list of error number and error text.</p>

<p>エラーが起こっていないか、システム・エラー番号がリセットされてる時は、<tt>nil</tt> が返ります。<br />
If no error has occurred or the system error number has
been reset, <tt>nil</tt> is returned.</p>

<p><em>int-error</em> が <tt>0</tt> (zero) より大きい時、その番号とエラー・テキストのリストが返ります。<br />
When <em>int-error</em> is greater <tt>0</tt> (zero) a
list of the number and the error text is returned.</p>

<p>エラーをリセットするためには、エラー番号に <tt>0</tt> を指定します。<br />
To reset the error specify <tt>0</tt> as the error number.</p>

<p>システム・リソース領域で使う newLISP の関数が <tt>nil</tt> を返す時はいつも、下層の理由のチェックに <tt>sys-error</tt> が使えます。
ファイル操作では、ファイルが存在していないとか、リソース・アクセス時の誤った許可とか、に <tt>sys-error</tt> がセットされるかもしれません。
エラーの他の理由としては、ファイル・ハンドルやセマフォのようなシステム・リソースの枯渇もありえます。<br />
Whenever a function in newLISP within the system resources area
returns <tt>nil</tt>, <tt>sys-error</tt> can be checked 
for the underlying reason. For file operations, 
<tt>sys-error</tt> may be set for nonexistent files 
or wrong permissions when accessing the resource.
Another cause of error could be the exhaustion of certain system 
resources like file handles or semaphores.</p>

<!-- example -->

<pre>
;; trying to open a nonexistent file
(open "xyz" "r")  <span class='arw'>&rarr;</span> nil

(sys-error)       <span class='arw'>&rarr;</span> (2 "No such file or directory")

;; reset errno
(sys-error 0)     <span class='arw'>&rarr;</span> (0 "Unknown error: 0")
(sys-error)       <span class='arw'>&rarr;</span> nil
</pre>


<p><a href="#last-error">last-error</a> や <a href="#net-error">net-error</a> も見てください。<br />
See also <a href="#last-error">last-error</a> and <a href="#net-error">net-error</a>.</p>

<br/><br/>

<a name="sys-info"></a>
<h2><span class="function">sys-info</span></h2>
<h4>syntax: (sys-info [<em>int-idx</em>])</h4>

<p><em>int-idx</em> 無しで呼ばれた <tt>sys-info</tt> は、内部リソース統計値のリストを返します。
10 個の整数が次のステータスを報告します：<br />
Calling <tt>sys-info</tt> without <em>int-idx</em> returns a list of internal 
resource statistics. Ten integers report the following status:</p>

<table width="98%" summary="sys-info offsets">
<tr align="left"><th>offset</th><th>description</th></tr>
<tr><td>0</td><td>Lispセルの数<br />Number of Lisp cells</td></tr>
<tr><td>1</td><td>Lispセルの最大数、定数<br />Maximum number of Lisp cells constant</td></tr>
<tr><td>2</td><td>シンボル数<br />Number of symbols</td></tr>
<tr><td>3</td><td>評価／再帰レベル<br />Evaluation/recursion level</td></tr>
<tr><td>4</td><td>環境スタック・レベル<br />Environment stack level</td></tr>
<tr><td>5</td><td>最大呼び出しスタック数、定数<br />Maximum call stack constant</td></tr>
<tr><td>6</td><td>親プロセスの PID または 0<br />Pid of the parent process or 0</td></tr>
<tr><td>7</td><td>走っている newLISP プロセスの PID<br />Pid of running newLISP process</td></tr>
<tr><td>8</td><td>バージョンを整数で表したもの、定数<br />Version number as an integer constant</td></tr>
<tr><td>9</td><td>オペレーティング・システムを表す、定数：<br/>linux=1, bsd=2, osx=3, solaris=4,  Windows=6, os/2=7, cygwin=8, tru64, unix=9, aix=10, android=11<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 11 は ffilib (extended import/callback API) 版で設定される (add 1024)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 10 は IPv6 版で設定される (add 512)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 9 は 64-bit (changeable at runtime) 版で設定される(add 256)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 8 は UTF-8 版で設定される (add 128)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 7 はライブラリ版で設定される (add 64)<br />Operating system constant:<br/>linux=1, bsd=2, osx=3, solaris=4,  Windows=6, os/2=7, cygwin=8, tru64, unix=9, aix=10, android=11<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 11 will be set for ffilib (extended import/callback API) versions (add 1024)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 10 will be set for IPv6 versions (add 512)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 9 will be set for 64-bit (changeable at runtime) versions (add 256)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 8 will be set for UTF-8 versions (add 128)<br/>&nbsp;&nbsp;&nbsp;&nbsp;bit 7 will be added for library versions (add 64)</td></tr>
</table><br/>

<p><tt>0</tt> から <tt>9</tt> は、戻りリストのオプションのオフセットを指しています。<br />
The numbers from <tt>0</tt> to <tt>9</tt> indicate the optional offset 
in the returned list.</p>

<p> "Maximum call stack constant" までの指定には、オフセット 0 ～ 5 を使い、
残りの四つのエントリのアクセスには、負数のオプセット -1 ～ -4 を使うことを推奨します。
将来、新エントリは、オフセット 5 の後に挿入されるでしょう。
この方法なら、古いソースコードでも変更の必要がありません。<br />
It is recommended to use offsets 0 to 5 to address
up and including "Maximum call stack constant" and to use
negative offsets -1 to -4 to access the last four
entries in the system info list. Future new entries will be inserted
after offset 5. This way older source code does not need to change.</p>

<p><em>int-idx</em> を使えば、リスト中の一要素が返されます。<br />
 When using <em>int-idx</em>, one element of the list will be returned.
</p>

<!-- example -->

<pre>
(sys-info)     <span class='arw'>&rarr;</span> (429 268435456 402 1 0 2048 0 19453 10406 1155)
(sys-info 3)   <span class='arw'>&rarr;</span> 1 
(sys-info -2)  <span class='arw'>&rarr;</span> 10406 ;; version 10.4.6
</pre>


<p>Lisp セルの最大数は、コマンド・ラインのスイッチ <tt>-m</tt> で変更できます。
Lisp セル・メモリ １メガ・バイト当たり 64k メモリ・セルが割り当てられます。
最大コール・スタック深さは、コマンド・ラインのスイッチ <tt>-s</tt> を使って、変更できます。<br />
The number for the maximum of Lisp cells can be changed via the <tt>-m</tt> 
command-line switch. For each megabyte of Lisp cell memory, 
64k memory cells can be allocated. The maximum call stack depth 
can be changed using the <tt>-s</tt> command-line switch. </p>

<br/><br/>

<a name="t-test"></a>
<h2><span class="function">t-test</span></h2>
<h4>syntax: (t-test <em>list-vector</em> <em>number-value</em>)<br/>
syntax: (t-test <em>list-vector-A</em> <em>list-vector-B</em> [<tt>true</tt>])<br/>
syntax: (t-test <em>list-vector-A</em> <em>list-vector-B</em> <em>float-probability</em>)</h4>

<p><b>第一構文</b>において、この関数は <em>list-vector</em> の平均値と <em>number-value</em> を比較するために、一サンプルの<a href="http://ja.wikipedia.org/wiki/T%E6%A4%9C%E5%AE%9A"><em>スチューデントの t</em> 検定</a>を使います：<br />
In the <b>first syntax</b> the function uses a one sample <em>Student's t</em> 
test to compare the mean value of <em>list-vector</em> to the value in 
<em>number-value</em>:</p>

<!-- example -->
<pre>
; one sample t-test
(t-test '(3 5 4 2 5 7 4 3) 2.5)
<span class='arw'>&rarr;</span> '(4.125 2.5 1.552 0.549 2.960 7 0.021)
</pre>

<p>次のようなデータがリストで返ります：<br />
The following data are returned in a list:</p>

<table>
<tr align="left"><th>name</th><th>description</th></tr>
<tr><td>mean</td><td>ベクトル・ベクターの平均値<br />mean of data in vector</td></tr>
<tr><td>value</td><td>比較する値<br />value to compare</td></tr>
<tr><td>sdev</td><td>ベクトル・データの標準偏差<br />standard deviation in data vector</td></tr>
<tr><td>mean-error</td><td>平均値の標準誤差<br />standard error of mean</td></tr>
<tr><td>t</td><td>平均値と値の t 値<br />t between mean and value</td></tr>
<tr><td>df</td><td>自由度<br />degrees of freedom</td></tr>
<tr><td>p</td><td>帰無仮説下での t の尾部両側の確率<br />two tailed probability of t under the null hypothesis</td></tr>
</table>

<p>上記例では、<tt>4.125</tt> の平均値と <tt>2.5</tt> の差がそれなりの意味を持ちます。
確率が <tt>p = 0.021 (2.1%)</tt> なので、平均値が余り違わないという帰無仮説は破棄されます。<br />
In above example the difference of the mean value <tt>4.125</tt> from <tt>2.5</tt> is
moderately significant. With a probability <tt>p = 0.021 (2.1%)</tt> the null hypothesis
that the mean is not significantly different, can be rejected.</p>

<p><b>第二構文</b>において、この関数は <em>スチューデントの t</em> 統計量を使った <a href="">t 検定</a>を実行し、<em>list-vector-A</em> と <em>list-vecor-B</em> の平均値を比較します。
 <tt>true</tt> フラグが使われていないなら、A と B のベクトルの大きさが違っていても良く、A と B であらわされる集合体には関連がありません。（訳注：EXCELのTTEST(配列 1,配列 2, 2, 3)に相当）<br />
In the <b>second syntax</b>, the function performs a t-test using the 
<em>Student's t</em> statistic for comparing the means values in <em>list-vector-A</em> 
and <em>list-vector-B</em>. If the <tt>true</tt> flag is not used, both vectors 
in A and B can be of different length and groups represented by A and B are 
not related.</p>

<p>オプション・フラグが <tt>true</tt> に設定されると、測定は同じ集団から二度取られたことになります。たとえば、処理の前と後とか。（訳注：EXCELのTTEST(配列 1,配列 2, 2, 1)に相当）<br />
When the optional flag is set to <tt>true</tt>, measurements were taken
from the same group twice, e.g. before and after a procedure.</p>

<p>次のような結果がリストで返ります：<br />
The following results are returned in a list:</p>

<table>
<tr align="left"><th>name</th><th>description</th></tr>
<tr><td>mean-a</td><td> A 集団の平均値<br />Mean of group A</td></tr>
<tr><td>mean-b</td><td> B 集団の平均値<br />Mean of group B</td></tr>
<tr><td>sdev-a</td><td> A 集団の標準偏差<br />Standard deviation in group A</td></tr>
<tr><td>sdev-b</td><td> B 集団の標準偏差<br />Standard deviation in group B</td></tr>
<tr><td>t</td><td>平均値間の t 値<br />t between mean values</td></tr>
<tr><td>df</td><td>自由度<br />degress of freedom</td></tr>
<tr><td>p</td><td>帰無仮説下での t の尾部両側の確率<br />Two tailed probability of t under the null hypothesis</td></tr>
</table>

<p><a href="http://web.mst.edu/~psyworld/texample.htm">最初の例</a>は SCAT（Sam の認識能力試験）前の異なる睡眠時間の影響調査です：<br />
The first example studies the effect of different sleep length
before a test on the SCAT (Sam's Cognitive Ability Test):</p>

<!-- example -->
<pre>
; SCAT (Sam's Cognitive Ability Test) 
; two independent sample t-test
(set 'hours-sleep-8 '(5 7 5 3 5 3 3 9))
(set 'hours-sleep-4 '(8 1 4 6 6 4 1 2))

(t-test hours-sleep-8 hours-sleep-4)
 <span class='arw'>&rarr;</span> (5 4 2.138 2.563 0.847 14 0.411)
</pre>

<p>SCAT 前の睡眠時間は、確率値が <tt>0.411</tt> なのであまり影響がありません。<br />
The duration of sleeps before the SCAT does not have a significant
effect with a probability value of <tt>0.411</tt>.</p>

<p>二番目の例では、同じ集団の人が Prozac うつ病薬を処方する前と後で二度試験しています：<br />
In the second example, the same group of people get tested twice,
before and after a treatment with Prozac depression medication:</p>

<!-- example -->
<pre>
; Effect of an antidepressant on a group of depressed people
; two related samples t-test
(set 'mood-pre '(3 0 6 7 4 3 2 1 4))
(set 'mood-post '(5 1 5 7 10 9 7 11 8))

(t-test mood-pre mood-post true)
<span class='arw'>&rarr;</span> (3.333 7 2.236 3.041 -3.143 8 0.0137)
</pre>

<p>抗うつ薬の処方の効果は、<tt>p</tt> が <tt>0.0137</tt> なのでそれなりに効果がありそうです。<br />
The effect of the antidepressant treatment is moderately significant with a 
<tt>p</tt> of <tt>0.0137</tt>.</p>

<p><b>第三構文</b>において、この関数は<em>ウェルチの t 検定</em> と呼ばれる<em>スチューデントの t</em> の形式です。
この手法は、両サンプルで観測される分散が著しく違う（訳注：異分散）場合に使われます。
使用する閾値は変数 <em>float-probability</em> に設定できます。
この変数が使われると、<tt>t-test</tt> は二つのデータ・サンプルの分散を比較する F 検定を実行します。
見つかった <em>F 比</em> の確率が変数 <em>float-probability</em> 以下なら、<em>ウェルチの t 検定</em> 手法が使えるでしょう。
この比率を<tt>1.0</tt> に指定することは、<em>ウェルチの t 検定</em> を有効にします：<br />
In the <b>third syntax</b>, a form of the <em>Student's t</em> called <em>Welch's t-test</em>
is performed. This method is used when the variances observed in both
samples are significantly different. The threshold can be set using the 
<em>float-probability</em> parameter. When this parameter is used the <tt>t-test</tt>
function will perform a F-test to compare the variances in the two data samples.
If the probability of the found <em>F-ratio</em> is below the <em>float-probability</em> 
parameter, the <em>Welch's t-test</em> method will be used. Specifying this value
as <tt>1.0</tt> effectively forces a <em>Welch's t-test</em>:</p>

<!-- example -->
<pre>
; two independent sample t-test using the Welch method
(t-test '(10 4 7 1 1 6 1 8 2 4) '(4 6 9 4 6 8 9 3) 1.0)
<span class='arw'>&rarr;</span> (4.4 6.125 3.239 2.357 -1.307 15 0.211) 

; two independent sample t-test using the normal method
(t-test '(10 4 7 1 1 6 1 8 2 4) '(4 6 9 4 6 8 9 3))
<span class='arw'>&rarr;</span> (4.4 6.125 3.239 2.357 -1.260 16 0.226)
</pre>

<p>この二つサンプルの平均値間には、余り違いが認められません。
このケースでは、普通の t 検定手法を使う時よりも、<em>ウェルチ</em> 手法の t 検定の方がわずかに敏感です。<br />
There is no significant difference between the means of the two samples.
The <em>Welch</em> method of the t-test is slightly more sensitive in this
case than using the normal t-test method.</p>

<p>サンプルの異分散の有意性が特定の値に届いているなら、<tt>1.0</tt> より小さい値が<em>ウェルチの t 検定</em> 手法の引き金になります。<br />
Smaller values than <tt>1.0</tt> would trigger the <em>Welch's t-test</em>
method only when the significance of variance difference in the samples reaches
certain value.</p>

<br/><br/>

<a name="tan"></a>
<h2><span class="function">tan</span></h2>
<h4>syntax: (tan <em>num-radians</em>)</h4>

<p>
	<em>num-radians</em> の正接関数を計算し、結果を返します。<br />
	Calculates the tangent function from <em>num-radians</em> 
	and returns the result.
</p>

<!-- example -->

<pre>
(tan 1)                     <span class='arw'>&rarr;</span> 1.557407725
(set 'pi (mul 2 (asin 1)))  <span class='arw'>&rarr;</span> 3.141592654
(tan (div pi 4))            <span class='arw'>&rarr;</span> 1
</pre>

<br/><br/>

<a name="tanh"></a>
<h2><span class="function">tanh</span></h2>
<h4>syntax: (tanh <em>num-radians</em>)</h4>

<p><em>num-radians</em> の双曲線正接を計算します。双曲線正接は、次のように定義されます： <em>sinh (x) / cosh (x)</em><br />
Calculates the hyperbolic tangent of <em>num-radians</em>. 
The hyperbolic tangent is defined mathematically as: <em>sinh (x) / cosh (x)</em>.
</p>

<!-- example -->

<pre>
(tanh 1)     <span class='arw'>&rarr;</span> 0.761594156
(tanh 10)    <span class='arw'>&rarr;</span> 0.9999999959
(tanh 1000)  <span class='arw'>&rarr;</span> 1
(= (tanh 1) (div (sinh 1) (cosh 1)))  <span class='arw'>&rarr;</span> true
</pre>

<br/><br/>

<a name="term"></a>
<h2><span class="function">term</span></h2>
<h4>syntax: (term <em>symbol</em>)</h4>

<p><em>シンボル</em> の名前部分をコンテキスト無しの文字列で返します。<br />
Returns as a string, the term part of a <em>symbol</em> without the context prefix.</p>

<!-- example -->

<pre>
(set 'ACTX:var 123)
(set 'sm 'ACTX:var)
(string sm)     <span class='arw'>&rarr;</span> "ACTX:var"
(term sm)       <span class='arw'>&rarr;</span> "var"

(set 's 'foo:bar)
(= s (sym (term s) (prefix s)))
</pre>

<p>シンボルから名前空間やコンテキストを取り出す <a href="#prefix">prefix</a> も見てください。<br />
See also <a href="#prefix">prefix</a> to extract the namespace or
context prefix from a symbol.</p>

<br/><br/>

<a name="throw"></a>
<h2><span class="function">throw</span></h2>
<h4>syntax: (throw <em>exp</em>)</h4>

<p>
	関数 <a href="#catch">catch</a> と一緒に動作します。
	<tt>throw</tt> は、先行する <tt>catch</tt> 文への戻りを強行し、<tt>catch</tt> の結果シンボルに <em>exp</em> をおきます。<br />
	Works together with 
	the <a href="#catch">catch</a> function.
	<tt>throw</tt> forces the return of a previous <tt>catch</tt> statement 
	and puts the <em>exp</em> into the result symbol of <tt>catch</tt>.
</p>


<!-- example -->

<pre>
(define (throw-test)
    (dotimes (x 1000) 
        (if (= x 500) (throw "interrupted"))))

(catch (throw-test) 'result)  <span class='arw'>&rarr;</span> true

result  <span class='arw'>&rarr;</span> "interrupted"

(catch (throw-test))  <span class='arw'>&rarr;</span> "interrupted"
</pre>


<p>
	最後の例は、<tt>throw</tt> の結果を直接返す <a href="#catch">catch</a> のショート形式を示しています。<br />
	The last example shows a shorter form of <a href="#catch">catch</a>,
	which returns the <tt>throw</tt> result directly.
</p>

<p>
	<tt>throw</tt> は、ループからの脱出やユーザ定義関数や式ブロックからの早期戻りに有効です。
	次の例で、<tt>begin</tt> ブロックは	<tt>(foo X)</tt> が <tt>true</tt> の時 <tt>X</tt> を、そうでない時は <tt>Y</tt> を返します。<br />
	<tt>throw</tt> is useful for breaking out of a loop 
	or for early return from user-defined functions 
	or expression blocks.
	In the following example,
	the <tt>begin</tt> block will return <tt>X</tt> 
	if <tt>(foo X)</tt> is <tt>true</tt>; 
	else <tt>Y</tt> will be returned:
</p>


<pre>
(catch (begin
    &hellip;
    (if (foo X) (throw X) Y)
    &hellip;
))
</pre>


<p>
	<tt>throw</tt> は、エラー例外を<em>起こしません</em> 。
	ユーザ・エラー例外を出したい時は、<a href="#throw-error">throw-error</a> を使ってください。<br />
	<tt>throw</tt> will <em>not</em> cause an error exception.
	Use <a href="#throw-error">throw-error</a>
	to throw user error exceptions.
</p> 

<br/><br/>

<a name="throw-error"></a>
<h2><span class="function">throw-error</span></h2>
<h4>syntax: (throw-error <em>exp</em>)</h4>

<p>
	<em>exp</em> の評価で供給されるテキストで、ユーザ定義エラー例外を起こします。<br />
	Causes a user-defined error exception 
	with text provided by evaluating <em>exp</em>.
</p>

<!-- example -->

<pre>
(define (foo x y)
    (if (= x 0) (throw-error "first argument cannot be 0"))
    (+ x y))

(foo 1 2)  <span class='arw'>&rarr;</span> 3

(foo 0 2)  ; causes a user error exception
<span class='err'>ERR: user error : first argument cannot be 0
called from user-defined function foo</span>
</pre>


<p>
	ユーザ・エラーは、ユーザ定義エラー・ハンドラと関数 <a href="#error-event">error-event</a>、またはエラー例外を捉える <a href="#catch">catch</a> の形式を使って、他のエラー例外と同じように処理されます。<br />
	The user error can be handled 
	like any other error exception 
	using user-defined error handlers 
	and the <a href="#error-event">error-event</a> function, 
	or the form of <a href="#catch">catch</a> 
	that can capture error exceptions.
</p>

<br/><br/>

<a name="time"></a>
<h2><span class="function">time</span></h2>
<h4>syntax: (time <em>exp</em> [<em>int-count</em>)</h4>

<p><em>exp</em> の式を評価し、評価に費やした時間をミリ秒単位の浮動小数点で返します。
ミリ秒の小数が現れるかどうかは、プラットフォーム次第です。<br />
Evaluates the expression in <em>exp</em> and returns the time spent 
on evaluation in floating point milliseconds. Depending on the platform
decimals of milliseconds are shown or not shown.</p>

<!-- example -->

<pre>
(time (myprog x y z))  <span class='arw'>&rarr;</span> 450.340

(time (myprog x y z) 10)  <span class='arw'>&rarr;</span> 4420.021
</pre>


<p>一番目の例では、<tt>(myprog x y z)</tt> の評価に 450 ミリ秒かかっています。
二番目の例は、(myprog x y z)</tt> の 10回の評価の時間を返します。
<a href="#date">date</a>、
<a href="#date-value">date-value</a>、
<a href="#time-of-day">time-of-day</a>、
<a href="#now">now</a> も見てください。<br />
In first the example, 450 milliseconds elapsed 
while evaluating <tt>(myprog x y z)</tt>.  The second example 
returns the time for ten evaluations of  <tt>(myprog x y z)</tt>.
See also <a href="#date">date</a>,
<a href="#date-value">date-value</a>,
<a href="#time-of-day">time-of-day</a>, 
and <a href="#now">now</a>.</p>

<br/><br/>

<a name="time-of-day"></a>
<h2><span class="function">time-of-day</span></h2>

<h4>syntax: (time-of-day)</h4>

<p>今日の最初からの時間をミリ秒単位で返します。<br />
Returns the time in milliseconds since the start of the current day. 
</p>

<p>関数 <a href="#date">date</a>、
<a href="#date-value">date-value</a>、
<a href="#time">time</a>、
and <a href="#now">now</a> も見てください。<br />
See also the <a href="#date">date</a>,
<a href="#date-value">date-value</a>,
<a href="#time">time</a>, 
and <a href="#now">now</a> functions.</p>

<br/><br/>

<a name="timer"></a>
<h2><span class="function">timer</span></h2>
<h4>syntax: (timer <em>sym-event-handler | func-event-handler</em> <em>num-seconds</em> [<em>int-option</em>])<br/>
syntax: (timer <em>sym-event-handler | func-event-handler</em>)<br/>
syntax: (timer)</h4>

<p>
（<em>num-seconds</em> で指定された）秒単位の時間経過後に Unix シグナル <tt>SIGALRM</tt>、<tt>SIGVTALRM</tt>、<tt>SIGPROF</tt> が発火するワン・ショット・タイマーを開始します。
タイマーが発火すると、<em>sym--event-handler</em> のユーザ定義関数か <em>func-event-handler</em> が呼び出されます。<br />
Starts a one-shot timer firing off the Unix signal <tt>SIGALRM</tt>, <tt>SIGVTALRM</tt>, 
or <tt>SIGPROF</tt> after the time in seconds (specified in <em>num-seconds</em>) 
has elapsed. When the timer fires, it calls the user-defined function 
in <em>sym-</em> or <em>func-event-handler</em>.
</p>

<p>Linux/Unix では、オプション <tt>0</tt>, <tt>1</tt>,  <tt>2</tt> が、
タイマー・カウント方法の制御用に指定できます。
デフォルトのオプション <tt>0</tt> では、実時間が計測されます。
オプション <tt>1</tt> は、タイマー自身のプロセスで CPU が費やした時間を計測します。
オプション <tt>3</tt> は、<em>profiling time</em> と呼ばれる両方の組み合わせです。
詳細は、Unix man ページの <tt>setitimer()</tt> を見てください。<br />
On Linux/Unix, an optional <tt>0</tt>, <tt>1</tt>, or <tt>2</tt> can 
be specified to control how the timer counts.  With default option 
<tt>0</tt>, real time is measured.  Option <tt>1</tt> measures the time 
the CPU spends processing in the process owning the timer.
Option <tt>2</tt> is a combination of both called <em>profiling time</em>.
See the Unix man page <tt>setitimer()</tt> for details.
</p>

<p>イベント・ハンドラは、イベントの連続的なフローを実行するためにタイマーを再び開始できます。
バージョン 8.5.9 から、秒数は小数点以下の浮動小数点で定義可能です（例えば、 250 ミリ秒は、 <tt>0.25</tt>)。<br />
The event handler can start the timer again to achieve a 
continuous flow of events.  Starting with version 8.5.9,
seconds can be defined as floating point numbers with a fractional 
part (e.g., <tt>0.25</tt> for 250 milliseconds).</p>

<p>走っているタイマーを止めて発火するのを防ぐには、<tt>0</tt> (zero) を指定します。<br />
Defining <tt>0</tt> (zero) as time shuts the running timer down 
and prevents it from firing.</p>

<p>
<em>sym-event-handler</em> や <em>func-event-handler</em> で呼ばれた時、<tt>timer</tt> は進行中のタイマーの消費時間を返します。
これは、プログラム計画や予定に使えます。<br />
When called with <em>sym-</em> or <em>func-event-handler</em>, 
<tt>timer</tt> returns the elapsed time of the timer in progress.
This can be used to program time lines or schedules.</p>

<p>
引数なしの<tt>timer</tt> は、現在のイベント・ハンドラのシンボルを返します。<br />
<tt>timer</tt> called without arguments returns the symbol of the current 
event handler.</p> 


<!-- example -->

<pre>
(define (ticker) 
    (println (date)) (timer 'ticker 1.0))

&gt; (ticker)
<b>Tue Apr 12 20:44:48 2005</b>	; first execution of ticker
<span class='arw'>&rarr;</span> ticker			      ; return value from ticker

&gt; <b>Tue Apr 12 20:44:49 2005</b>	; first timer event
<b>Tue Apr 12 20:44:50 2005</b>	; second timer event ...
<b>Tue Apr 12 20:44:51 2005
Tue Apr 12 20:44:52 2005</b>
</pre>


<p>
	例は、各イベント後でタイマーが再び開始するイベント・ハンドラ、<tt>ticker</tt> を示しています。<br />
	The example shows an event handler, <tt>ticker</tt>,
	which starts the timer again after each event.
</p>

<p>
	組込関数の実行中は、タイマーがインターラプトできないことに注意してください。
	タイマー・インターラプトは newLISP に登録されますが、一つの式が評価されて次が開始するまで、タイマー・ハンドラは走ることができません。
	 <tt>timer</tt> で実行中の I/O 操作をインターラプトするには、ソケットに読み出し準備ができたかどうかをテストするため、<a href="#net-select">net-select</a> を呼び出す次のパターンを使ってください。<br />
	Note that a timer cannot interrupt an 
	ongoing built-in function.
	The timer interrupt gets registered by newLISP,
	but a timer handler cannot run 
	until one expression is evaluated 
	and the next one starts.
	To interrupt an ongoing I/O operation with <tt>timer</tt>,
	use the following pattern, 
	which calls <a href="#net-select">net-select</a> 
	to test if a socket is ready for reading:
</p>

<!-- example -->

<pre>
define (interrupt)
    (set 'timeout true))
        
(set 'listen (net-listen 30001))
(set 'socket (net-accept listen))
        
(timer 'interrupt 10)
;; or specifying the function directly
(timer (fn () (set 'timeout true)) 10)
        
(until (or timeout done)
    (if (net-select socket "read" 100000)
        (begin
            (net-receive socket buffer 1024)
            (set 'done true)))
)
                                                                                
(if timeout
    (println "timeout")
    (println buffer))
                                                                              
(exit)
</pre>


<p>
	この例では、<tt>until</tt> ループは <tt>socket</tt> から何かを読み取るか、10秒が過ぎて <tt>timeout</tt> 変数がセットされるまで走ります。<br />
	In this example,
	the <tt>until</tt> loop will run 
	until something can be read from <tt>socket</tt>, 
	or until ten seconds have passed 
	and the <tt>timeout</tt> variable is set.
</p>

<br/><br/>

<a name="title-case"></a>
<h2><span class="function">title-case</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (title-case <em>str</em> <em>[bool]</em>)</h4>

<p>
	<em>str</em> の文字列の最初の文字を大文字に変換したコピーを返します。
	オプションの <em>bool</em> パラメータが <tt>nil</tt> 以外の値に評価される時は、文字列の残りを小文字に変換します。<br />
	Returns a copy of the string in <em>str</em> 
	with the first character converted to uppercase.
	When the optional <em>bool</em> parameter 
	evaluates to any value other than <tt>nil</tt>,
	the rest of the string is converted to lowercase.
</p>

<!-- example -->

<pre>
(title-case "hello")       <span class='arw'>&rarr;</span> "Hello"
(title-case "hELLO" true)  <span class='arw'>&rarr;</span> "Hello"
(title-case "hELLO")       <span class='arw'>&rarr;</span> "HELLO"
</pre>


<p>
	関数 <a href="#lower-case">lower-case</a> や <a href="#upper-case">upper-case</a> も見てください。<br />
	See also the <a href="#lower-case">lower-case</a> 
	and <a href="#upper-case">upper-case</a> functions.
</p>

<br/><br/>

<a name="trace"></a>
<h2><span class="function">trace</span></h2>

<h4>syntax: (trace <em>int-device</em>)<br/>
syntax: (trace <em>true</em>)<br/>
syntax: (trace <em>nil</em>)<br/>
syntax: (trace)</h4>

<p>第一構文では、パラメータがファイルを開くときのようなデバイスの整数です。
出力をそのデバイスに連続して書き込みます。
<em>int-device</em> が <tt>1</tt> ならば、出力を<i>標準出力</i> に書き込みます。<br />
In the first syntax the parameter is an integer of a device like an opened file.
Output is continuously written to that device. If <em>int-device</em> is 
<tt>1</tt> output is written to <i>stdout</i>. </p> 

<pre>
; write all entries and exits from expressions to trace.txt
(trace (open "trace.txt")) 

; write all entries and exits from expressions to trace.txt
(foo x y)                  
(bar x)              
      
; close the trace.txt file
(trace nil)
</pre>

<p>第二構文では、パラメータが真(true)に評価される時、デバッガ・モードに切り替わります。
デバック・モード中の newLISP は、各エントリ後に止まり、式から抜け出して、ユーザ入力を待ちます。
二つの #（番号記号）文字を使い、式（訳注:直前に実行された式）を囲むことでハイライトを表します。
この文字は <a href="#trace-highlight">trace-highlight</a> を使って、別の文字に変更できます。<br />
In the second syntax debugger mode is switched on when the 
parameter evaluates true. When in debugging mode newLISP will stop
after each entry and exit from an expression and wait for user input.
Highlighting is done by bracketing the expression between two # 
(number sign) characters.  This can be changed to a different character 
using <a href="#trace-highlight">trace-highlight</a>.:</p>

<pre>
[-&gt; 2] s|tep n|ext c|ont q|uit &gt;
</pre>


<p>
プロンプトの <tt>s</tt>, <tt>n</tt>, <tt>c</tt>, <tt>q</tt> は、1ステップ進めるか単に次の式を実行するために入力できます。
評価用に如何なる式も入力できます。
例えば、変数の名前を入れると、その内容が評価されます。
このようにして、デバック中の変数の内容をチェックしたり、別な値にセットしたりできます。<br />
At the prompt, an <tt>s</tt>, <tt>n</tt>, <tt>c</tt>, 
or <tt>q</tt> can be entered to step into or 
merely execute the next expression.  Any expression can be entered 
at the prompt for evaluation.  Entering the name of a variable,
for example, would evaluate to its contents.
In this way, a variable's contents can be checked during debugging
or set to different values.
</p>

<!-- example -->

<pre>
;; switches newLISP into debugging mode
(trace true)  <span class='arw'>&rarr;</span> true 

;; the debugger will show each step
(my-func a b c)

;; switched newLISP out of debugging mode
(trace nil)  <span class='arw'>&rarr;</span> nil 
</pre>

<p>
通常の式をインターラプトし、デバック・モードに入るためのブレイク・ポイントを設定するには、newLISP コード中のデバックに入りたい実行箇所に <tt>(trace true)</tt> 文を置いてください。<br />
To set break points where newLISP should interrupt 
normal execution and go into debugging mode,
put <tt>(trace true)</tt> statements into the newLISP 
code where execution should switch on the debugger.</p>

<p>
上記例のショートカットである関数 <a href="#debug">debug</a> も見てください。
<br />
Use the <a href="#debug">debug</a> function as a shortcut 
for the above example:</p>

<pre>
(debug (my-func a b c))
</pre>


<p>第三構文の <tt>(trace nil)</tt> はデバック・モードを閉じるか、開かれているトレース・ファイルを閉じます。<br />
In the third syntax <tt>(trace nil)</tt> closes debugger mode or 
the trace file opened.</p>

<p>最後の構文  <tt>(trace)</tt> は現在のモードを返します。<br />
In the last syntax <tt>(trace)</tt> returns the current mode.</p>

<br/><br/>

<a name="trace-highlight"></a>
<h2><span class="function">trace-highlight</span></h2>
<h4>syntax: (trace-highlight <em>str-pre</em> <em>str-post</em> [<em>str-header</em> <em>str-footer</em>])</h4>

<p><a href="#trace">trace</a> の間、式を取り囲む文字または文字列を設定します。
デフォルトでは、<a href="#trace">trace</a> モードのハイライト表現の囲みに # (number sign) が使われます。
これは、異なる文字か7文字までの文字列に変更できます。
コンソール・ウィンドウがターミナル制御文字を受け付けるなら、異なる色、太字、反転文字等で式を表現するために使えます。<br />
Sets the characters or string of characters used to enclose expressions 
during <a href="#trace">trace</a>.  By default, 
the # (number sign) is used to enclose the expression highlighted 
in <a href="#trace">trace</a> mode.  This can be changed to different characters 
or strings of up to seven characters.  If the console window accepts terminal 
control characters, this can be used to display the expression in a different 
color, bold, reverse, and so forth.</p>

<p>オプションで、分離とプロンプトを制御する <em>str-header と str-footer</em> に二つ以上の文字列を指定できます。
ヘッダーには最大15文字、フッターには最大31文字が許されます。<br />
Two more strings can optionally be specified for <em>str-header and str-footer</em>,
which control the separator and prompt. A maximum of 15 characters is allowed 
for the header and 31 for the footer.</p>

<!-- example -->

<pre>
;; active expressions are enclosed in &gt;&gt; and &lt;&lt;

(trace-highlight "&gt;&gt;" "&lt;&lt;") 
             
;; 'bright' color on a VT100 or similar terminal window

(trace-highlight "\027[1m" "\027[0m")   
</pre>


<p>
第一の例は、デフォルトの <tt>#</tt> (number sign) を <tt>&gt;&gt;</tt> と <tt>&lt;&lt;</tt> に置き換えています。
二番目の例は、ほとんどの Linux シェルで動作します。
しかしながら、MS Windows や CYGWIN では端末の設定次第で動作しないかもしれません。<br />
The first example replaces the default <tt>#</tt> (number sign) 
with a <tt>&gt;&gt;</tt> and <tt>&lt;&lt;</tt>. The second example works 
on most Linux shells.  It may not, however, work in console windows 
under MS Windows or CYGWIN, depending on the configuration of the terminal.</p>

<br/><br/>

<a name="transpose"></a>
<h2><span class="function">transpose</span></h2>
<h4>syntax: (transpose <em>matrix</em>)</h4>

<p><em>matrix</em> の行と列を入れ替える転置を行います。
いかなるリスト行列も転置されます。
リスト内の行でアトムを充当もしくは展開すべき場所、要素の見つからない所や要素の省略された所には、<tt>nil</tt> を埋めることで、行列は矩形にされます。
置換された行列の次数は、列数は元の行列の行の数を使って、行数は最初の行の要素数を使って算出されます。<br />
Transposes a <em>matrix</em> by reversing the rows and columns.
Any kind of list-matrix can be transposed. Matrices are made rectangular 
by filling in <tt>nil</tt> for missing elements, omitting elements where 
appropriate, or expanding atoms in rows into lists.
Matrix dimensions are calculated using the number of rows in the original 
matrix for columns and the number of elements in the first row 
as number of rows for the transposed matrix.</p>

<p>転置のための行列には、如何なるデータ型も含めることができます。<br />
The matrix to transpose can contain any data-type.</p>

<p>行列の次元は、行数と最初の行の要素数で定義されます。
入れ子のリストと <a href="#array">array</a> のどちらも、行列になれます。<br />
The dimensions of a matrix are defined by the number of rows 
and the number of elements in the first row.  A matrix can either be a 
nested list or an <a href="#array">array</a>.</p>

<!-- example -->

<pre>
(set 'A '((1 2 3) (4 5 6)))
(transpose A)                      <span class='arw'>&rarr;</span> ((1 4) (2 5) (3 6))
(transpose (list (sequence 1 5)))  <span class='arw'>&rarr;</span> ((1) (2) (3) (4) (5))

; any data type is allowed in the matrix
(transpose '((a b) (c d) (e f)))   <span class='arw'>&rarr;</span> ((a c e) (b d f))

; arrays can be transposed too
(set 'A (array 2 3 (sequence 1 6)))
(set 'M (transpose A)) 
M <span class='arw'>&rarr;</span> ((1 4) (2 5) (3 6))
</pre>


<p>行列の列数は、行列の最初の行の要素数で定義されます。
行の要素が少ないなら、<tt>transpose</tt> は見つからなかった要素を <tt>nil</tt> にします。
行中の余計な要素は、無視されます。<br />
The number of columns in a matrix is defined by the number of elements 
in the first row of the matrix.  If other rows have fewer elements, 
<tt>transpose</tt> will assume <tt>nil</tt> for those missing elements.
Superfluous elements in a row will be ignored.</p>


<pre>
(set 'A '((1 2 3) (4 5) (7 8 9)))

(transpose A)  <span class='arw'>&rarr;</span> ((1 4 7) (2 5 8) (3 nil 9))
</pre>


<p>転置の際、行がリスト以外のデータ型である時は、そのデータ型の要素を行の全ての要素として処理します：<br />
If a row is any other data type besides a list,
the transposition treats it like an entire row of elements 
of that data type:</p>


<pre>
(set 'A '((1 2 3) X (7 8 9)))

(transpose A)  <span class='arw'>&rarr;</span> ((1 X 7) (2 X 8) (3 X 9))
</pre>


<p>ここに示したすべてのリスト上の操作は、アレイでも実行されます。<br />
All operations shown here on lists can also be performed on arrays.
</p>

<p>
	他の行列操作
	<a href="#det">det</a>、
	<a href="#invert">invert</a>、
	<a href="#mat">mat</a>、
	<a href="#multiply">multiply</a> も見てください。<br />
	See also the matrix operations 
	<a href="#det">det</a>, <a href="#invert">invert</a>,
    <a href="#mat">mat</a> and <a href="#multiply">multiply</a>.
</p>

<br/><br/>

<a name="trim"></a>
<h2><span class="function">trim</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (trim <em>str</em>)<br/>
syntax: (trim <em>str</em> <em>str-char</em>)<br/>
syntax: (trim <em>str</em> <em>str-left-char</em> <em>str-right-char</em>)</h4>


<p>最初の構文を使えば、<em>str</em> 両端の全ての空白文字が取り除かれます。<br />
Using the first syntax, all white-space characters are trimmed from both
sides of <em>str</em>.</p>

<p>第二構文は <em>str</em> 文字列の両端から <em>str-char</em> で与えられた文字を頭と尻尾から取り除きます。
もし <em>str-char</em> がなければ、空白文字となります（訳注：第一構文と同じ）。
<tt>trim</tt> は新しい文字列を返します。<br />
The second syntax trims the string <em>str</em> from both sides, 
stripping the leading and trailing characters as given 
in <em>str-char</em>. If <em>str-char</em> contains no character,
the space character is assumed. <tt>trim</tt> returns the new string.
</p>

<p>第三構文は両サイドで異なる文字を切り落とします。
空文字列が指定された時は、反対側の文字のみを切り落とします。<br />
The third syntax can either trim different characters from both sides 
or trim only one side if an empty string is specified 
for the other.  </p>

<!-- example -->

<pre>
(trim "   hello \n ")            <span class='arw'>&rarr;</span> "hello"
(trim "   h e l l o   ")         <span class='arw'>&rarr;</span> "h e l l o")
(trim "----hello-----" "-")      <span class='arw'>&rarr;</span> "hello"
(trim "00012340" "0" "")         <span class='arw'>&rarr;</span> "12340"
(trim "1234000" "" "0")          <span class='arw'>&rarr;</span> "1234"
(trim "----hello=====" "-" "=")  <span class='arw'>&rarr;</span> "hello"
</pre>

<p>もっと複雑な場合には、<a href="#replace">replace</a> を使うことができます。
可能でならば、より早い <tt>trim</tt> を推奨します。<br />
For more complex cases <a href="#replace">replace</a> can be used. When
possible, the much faster <tt>trim</tt> is preferred.</p>

<br/><br/>

<a name="truep"></a>
<h2><span class="function">true?</span></h2>
<h4>syntax: (true? <em>exp</em>)</h4>

<p>式 <em>exp</em> が <tt>nil</tt> か 空リスト <tt>()</tt> 以外に評価された時、<tt>true?</tt> は <tt>true</tt> を返し、それ以外は <tt>nil</tt> を返します。<br />
If the expression in <em>exp</em> 
evaluates to anything other than <tt>nil</tt>
or the empty list <tt>()</tt>, 
<tt>true?</tt> returns <tt>true</tt>; 
otherwise, it returns <tt>nil</tt>.</p>

<!-- example -->

<pre>
(map true? '(x 1 "hi" (a b c) nil ()))
<span class='arw'>&rarr;</span> (true true true true nil nil)
(true? nil)  <span class='arw'>&rarr;</span> nil
(true? '())  <span class='arw'>&rarr;</span> nil
</pre>


<p><tt>true?</tt> は <a href="#if">if</a> のように振る舞い、空リスト <tt>()</tt> を却下します（訳注：つまり、<tt>nil</tt> を返す）。<br />
<tt>true?</tt> behaves like <a href="#if">if</a>
and rejects the empty list <tt>()</tt>.</p>

<br/><br/> 


<a name="unicode"></a>
<h2><span class="function">unicode</span></h2>

<h4>syntax: (unicode <em>str-utf8</em>)</h4>

<p><em>str</em> のASCII/UTF-8 文字の文字列を 4 バイトの UCS-4&ndash;エンコード Unicode に変換します。
文字列の終端は 4 バイト整数 <tt>0</tt> です。
この関数は UTF-8 版 newLISP のみで利用できます。<br />
Converts ASCII/UTF-8 character strings in <em>str</em> 
to UCS-4&ndash;encoded Unicode of 4-byte integers per character.
The string is terminated with a 4-byte integer <tt>0</tt>.
This function is only available on UTF-8&ndash;enabled versions 
of newLISP.</p>

<!-- example -->

<pre>
(unicode "new") 
<span class='arw'>&rarr;</span> "n\000\000\000e\000\000\000w\000\000\000\000\000\000\000"

(utf8 (unicode "new"))  <span class='arw'>&rarr;</span> "new"
</pre>


<p><em>ビッグエンディアン</em> の CPU アーキテクチャでは、バイト順が上位からは下位へと逆になります。
関数 <tt>unicode</tt> と <a href="#utf8">utf8</a> は、互いに逆関数です。
UCS-4 Unicode を使用中の時のみ、これらの関数が必要になります。
多くのシステムでは、UTF-8 エンコーディングのみです。<br />
On <em>big endian</em> CPU architectures, the byte order will 
be reversed from high to low. The <tt>unicode</tt> and 
<a href="#utf8">utf8</a> functions are the inverse of each other.
These functions are only necessary if UCS-4 Unicode is in use.
Most systems use UTF-8 encoding only.</p>

<br/><br/>

<a name="unify"></a>
<h2><span class="function">unify</span></h2>
<h4>syntax: (unify <em>exp-1</em> <em>exp-2</em> [<em>list-env</em>])</h4>

<p>
<em>exp-1</em> と <em>exp-2</em> を評価し、つなぎ合わせます（訳注；以下、マッチと表す）。複数の式が等しいか、式の一つが（後で他の式に束縛される）非束縛変数ならば、それらの式もマッチします。
式がリストなら、下位式との比較でマッチされます。
非束縛変数は、シンボルと区別するために大文字で始まります
<tt>unify</tt> は<a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%8B%E3%83%95%E3%82%A3%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3"><ruby>単一化<rp>（</rp><rt>ユニフィケーション</rt><rp>）</rp></ruby></a>処理に失敗すれば <tt>nil</tt> を返し、成功すれば変数連想のリストを返します。
束縛される変数がない時、マッチは成功しますが、<tt>unify</tt> は、空のリストを返します。
newLISP は、<em><a href="http://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%8B%E3%83%95%E3%82%A3%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3#.E5.87.BA.E7.8F.BE.E6.A4.9C.E6.9F.BB">出現検査</a></em> を正しく適用するため、修正 <em>J. Alan Robinson</em> <ruby>単一化<rp>（</rp><rt>ユニフィケーション</rt><rp>）</rp></ruby>アルゴリズムを使っています。
この実装にはない一般的な <a href="http://norvig.com/unify-bug.pdf">unifcation algorithm bug</a> についての <em>Peter Norvig</em> の論文も見てください。<br />
Evaluates and matches <em>exp-1</em> and <em>exp-2</em>.
Expressions match if they are equal or if one of the expressions is 
an unbound variable (which would then be bound to the other expression).
If expressions are lists, they are matched by comparing subexpressions.
Unbound variables start with an uppercase character 
to distinguish them from symbols.  <tt>unify</tt> returns <tt>nil</tt> 
when the unification process fails,
or it returns a list of variable associations on success.
When no variables were bound, but the match is still successful,
<tt>unify</tt> returns an empty list.
newLISP uses a modified <em>J. Alan Robinson</em> unification algorithm
with correctly applied <em>occurs check</em>. 
See also <em>Peter Norvig</em>'s paper about a common 
<a href="http://norvig.com/unify-bug.pdf">unifcation algorithm bug</a>, which 
is not present in this implementation.
</p>

<p>バージョン 10.4.0 から、如何なるアトム、リスト、非束縛変数でも、シンボル <tt>_</tt> (ASCII 95) がマッチし、束縛しません。<br />
Since version 10.4.0 the underscore symbol <tt>_</tt> (ASCII 95) matches any atom,
list or unbound variable and never binds.</p>

<p>
	<a href="#match">match</a>のように、
	<a href="#find">find</a>、
	<a href="#ref">ref</a>、
	<a href="#ref-all">ref-all</a>、
	<a href="#replace">replace</a> で、しばしば、<tt>unify</tt> はファンクタ（関数オブジェクト）のパラメータとして使われます。<br />
    Like <a href="#match">match</a>, <tt>unify</tt> is frequently 
    employed as a parameter functor in <a href="#find">find</a>,
    <a href="#ref">ref</a>,  <a href="#ref-all">ref-all</a> and 
    <a href="#replace">replace</a>.
</p>


<!-- example -->

<pre>
(unify 'A 'A)  <span class='arw'>&rarr;</span> ()  ; tautology

(unify 'A 123)  <span class='arw'>&rarr;</span> ((A 123))  ; A bound to 123

(unify '(A B) '(x y))  <span class='arw'>&rarr;</span> ((A x) (B y))  ; A bound to x, B bound to y

(unify '(A B) '(B abc))  <span class='arw'>&rarr;</span> ((A abc) (B abc))  ; B is alias for A

(unify 'abc 'xyz)  <span class='arw'>&rarr;</span> nil  ; fails because symbols are different

(unify '(A A) '(123 456))  <span class='arw'>&rarr;</span> nil  ; fails because A cannot be bound to different values

(unify '(f A) '(f B))  <span class='arw'>&rarr;</span> ((A B))  ; A and B are aliases

(unify '(f A) '(g B))  <span class='arw'>&rarr;</span> nil  ; fails because heads of terms are different

(unify '(f A) '(f A B))  <span class='arw'>&rarr;</span> nil  ; fails because terms are of different arity

(unify '(f (g A)) '(f B))  <span class='arw'>&rarr;</span> ((B (g A)))  ; B bound to (g A)

(unify '(f (g A) A) '(f B xyz))  <span class='arw'>&rarr;</span> ((B (g xyz)) (A xyz))  ; B bound to (g xyz) A to xyz

(unify '(f A) 'A)  <span class='arw'>&rarr;</span> nil  ; fails because of infinite unification (f(f(f &hellip;)))

(unify '(A xyz A) '(abc X X))  <span class='arw'>&rarr;</span>  nil ; indirect alias A to X doesn't match bound terms

(unify '(p X Y a) '(p Y X X))  <span class='arw'>&rarr;</span> '((Y a) (X a)))  ; X alias Y and binding to 'a

(unify '(q (p X Y) (p Y X)) '(q Z Z))  <span class='arw'>&rarr;</span> ((Y X) (Z (p X X)))  ; indirect alias

(unify '(A b _) '(x G z)) <span class='arw'>&rarr;</span> ((A x) (G b)) ; _ matches atom z 

(unify '(A b c _) '(x G _ z)) <span class='arw'>&rarr;</span> ((A x) (G b)) ; _ never binds, matches c and z

(unify '(A b _) '(x G (x y z))) <span class='arw'>&rarr;</span> ((A x) (G b)) ; _ matches list (x y z)

;; some examples taken from <a href="http://en.wikipedia.org/wiki/Unification_(computer_science)">http://en.wikipedia.org/wiki/Unification_(computer_science)</a>
</pre>


<p>
	<tt>unify</tt> は <em>list-env</em> にオプションの束縛リスト、または、連想リストを取ることができます。
	これは、<tt>unify</tt> 式が続き、前の <tt>unify</tt> の束縛結果を含める必要がある時、役立ちます：<br />
	<tt>unify</tt> can take an optional binding 
	or association list in <em>list-env</em>.
	This is useful when chaining <tt>unify</tt> expressions 
	and the results of previous <tt>unify</tt> bindings 
	must be included:
</p>

<!-- example -->

<pre>
(unify '(f X) '(f 123))  <span class='arw'>&rarr;</span> ((X 123))

(unify '(A B) '(X A) '((X 123)))
<span class='arw'>&rarr;</span> ((X 123) (A 123) (B 123))
</pre>


<p>
	前の例では、先に、<tt>X</tt> は、<tt>123</tt> に束縛され、第二宣言文中の前束縛 <tt>X</tt> として含まれます。 <br />
	In the previous example,
	<tt>X</tt> was bound to <tt>123</tt> earlier 
	and is included in the second statement 
	to pre-bind <tt>X</tt>.
</p> 
<blockquote>（訳例：
<pre>
(unify '(A B) '(X A) (unify '(f X) '(f 123)))
<span class="arw">→</span> ((X 123) (A 123) (B 123))
(let (alist (unify '(f X) '(f 123)))
  (unify '(A B) '(X A) alist))
<span class="arw">→</span> ((X 123) (A 123) (B 123))
</pre>
）</blockquote>

<h3>Use <tt>unify</tt> with <tt>expand</tt>（<tt>unify</tt> を <tt>expand</tt> と使う）</h3>

<p>
	変数は、実際には、newLISP の割り当てとして束縛されないことに注意してください。
	むしろ、論理的束縛を示す連想リストが返ります。
	<a href="#expand">expand</a> の特殊構文が、実際、これらの表現を束縛された変数に置き換えます：<br />
	Note that variables are not actually bound 
	as a newLISP assignment. Rather,
	an association list is returned 
	showing the logical binding.
	A special syntax of <a href="#expand">expand</a> 
	can be used to actually replace bound variables 
	with their terms:
</p>


<pre>
(set 'bindings (unify '(f (g A) A) '(f B xyz)))
<span class='arw'>&rarr;</span> ((B (g xyz)) (A xyz))

(expand '(f (g A) A) bindings)  <span class='arw'>&rarr;</span> (f (g xyz) xyz)

; or in one statement
(expand '(f (g A) A) (unify '(f (g A) A) '(f B xyz)))
<span class='arw'>&rarr;</span> (f (g xyz) xyz)
</pre>

 
<h3>Use <tt>unify</tt> with <tt>bind</tt> for de-structuring（構造体の分解に <tt>unify</tt> を <tt>bind</tt> と使う）</h3>

<p>関数 <a href="#bind">bind</a> は、統合した変数のセットに使われます：<br />
The function <a href="#bind">bind</a> can be used to set unified
variables:</p>

<pre>
(bind (unify '(f (g A) A) '(f B xyz)))

A <span class='arw'>&rarr;</span> xyz 
B <span class='arw'>&rarr;</span> (g xyz)
</pre>

<p>これは、構造体の分解に使うことができます：<br />This can be used for de-structuring:</p>

<pre>
(set 'structure '((one "two") 3 (four (x y z))))
(set 'pattern '((A B) C (D E)))
(bind (unify pattern structure))

A <span class='arw'>&rarr;</span> one
B <span class='arw'>&rarr;</span> "two"
C <span class='arw'>&rarr;</span> 3
D <span class='arw'>&rarr;</span> four
E <span class='arw'>&rarr;</span> (x y z)
</pre>

<p><tt>unify</tt> は連想リストを返し、その連想を <tt>bind</tt> が束縛します。<br />
<tt>unify</tt> returns an association list and <tt>bind</tt> binds the associations.</p>

<h3>Model propositional logic with <tt>unify</tt>（ <tt>unify</tt> で命題論理を構築する）</h3>

<p>
	次の例が示しているのは、<tt>unify</tt> と <a href="#expand">expand</a> を使って、<a href="http://ja.wikipedia.org/wiki/%E5%91%BD%E9%A1%8C%E8%AB%96%E7%90%86">命題論理</a>を構築する方法です：<br />
	The following example shows how propositional logic 
	can be modeled using <tt>unify</tt> 
	and <a href="#expand">expand</a>:
</p>


<pre>
; if somebody is human, he is mortal -&gt; (X human) :- (X mortal)
; socrates is human -&gt; (socrates human)
; is socrates mortal? -&gt; ?  (socrates mortal)

(expand '(X mortal) 
         (unify '(X human) '(socrates human))) 
<span class='arw'>&rarr;</span> (socrates mortal)
</pre>


<p>
	次は、簡易 PROLOG (Programming in Logic) 実装として動作する、より複雑な例です。<br />
	The following is a more complex example 
	showing a small, working PROLOG (Programming in Logic) 
	implementation.
</p>


<pre>
;; a small PROLOG implementation

(set 'facts '(
    (socrates philosopher)
    (socrates greek)
    (socrates human)
    (einstein german)
    (einstein (studied physics))
    (einstein human)
))

(set 'rules '(
    ((X mortal) &lt;- (X human))
    ((X (knows physics)) &lt;- (X physicist))
    ((X physicist) &lt;- (X (studied physics)))
))


(define (query trm)
    (or  (when (find trm facts) true) (catch (prove-rule trm))))

(define (prove-rule trm)
    (dolist (r rules)
        (when (list? (set 'e (unify trm (first r))))
            (when (query (expand (last r) e))
                (throw true))))
    nil
)

; try it

&gt; (query '(socrates human))
<b>true</b>
&gt; (query '(socrates (knows physics)))
<b>nil</b>
&gt; (query '(einstein (knows physics)))
<b>true</b>
</pre>


<p>
	プログラムは、<tt>facts</tt> のデータベースと、単に<em>B が事実なら、A は事実である</em> という <tt>rules</tt> のデータベースを処理します。
	事実は、それが <tt>facts</tt> データベースで見つけられるか、それがルールを使って証明されるかしたら、真だと証明されます。
	ルールは入れ子可能で、例えば、誰かが <tt>(knows physics)</tt> であることを証明するためには、その誰かが <tt>physicist</tt> であることが真であると証明されなければなりません。
	しかし、その人物が <tt>studied physics</tt> なら、誰かは単に物理学者です。
	ルールの左右の項を分けている <tt>&lt;-</tt> シンボル は要求されず、	ルールのデータベースをより読みやすくするために追加されているだけです。<br />
	The program handles a database of <tt>facts</tt> 
	and a database of simple 
	<em>A is a fact if B is a fact</em> <tt>rules</tt>.
	A fact is proven true 
	if it either can be found in the <tt>facts</tt> database 
	or if it can be proven using a rule.
	Rules can be nested:
	for example, to prove that somebody <tt>(knows physics)</tt>, 
	it must be proved true that somebody is a <tt>physicist</tt>.
	But somebody is only a physicist 
	if that person <tt>studied physics</tt>.
	The <tt>&lt;-</tt> symbol 
	separating the left and right terms of the rules 
	is not required 
	and is only added to make the rules database 
	more readable.
</p>

<p>
	この実装は、ルールの右側の前提部分に複数項を扱えませんが、異なるマッチを試すために <tt>rules</tt> データベースのバックトラッキングを扱えます。
	ルールの複数の前提でバックトラッキングを扱うのではありません。
	例えば、次のルール <tt>A if B and C and D</tt> で、前提 <tt>B</tt> と <tt>C</tt> が進み、<tt>D</tt> で失敗したなら、バックトラッキング機構は<tt>D</tt> を成功させるため、戻って <tt>B</tt> または <tt>A</tt> 項を別の事実またはルールと再 unify することが必要になるかもしれません。<br />
	This implementation does not handle multiple terms 
	in the right premise part of the rules,
	but it does handle backtracking of the <tt>rules</tt> database 
	to try out different matches.
	It does not handle backtracking 
	in multiple premises of the rule.
	For example,
	if in the following rule <tt>A if B and C and D</tt>, 
	the premises <tt>B</tt> and <tt>C</tt> succeed 
	and <tt>D</tt> fails,
	a backtracking mechanism might need to go back 
	and reunify the <tt>B</tt> or <tt>A</tt> terms 
	with different facts or rules 
	to make <tt>D</tt> succeed.
</p>

<p>
	上記アルゴリズムは、<tt>prove-rule</tt>の定義から <a href="#expand">expand</a> を省略し、<tt>unify</tt> と <tt>query</tt> 関数の引数用に <tt>e</tt> を外に出すことで、異なる書き方ができます。<br />
	The above algorithm could be written differently 
	by omitting <a href="#expand">expand</a> 
	from the definition of <tt>prove-rule</tt>
	and by passing the environment, <tt>e</tt>,
	as an argument to the <tt>unify</tt> and <tt>query</tt> functions.
</p>

<p>
	証明された事実の <em>学習</em> は、それらが証明される度に、それらを <tt>facts</tt> データベースに付け加えることで実装されます。
	これは、次の質問群を高速化します。<br />
	A <em>learning</em> of proven facts 
	can be implemented by appending them 
	to the <tt>facts</tt> database 
	once they are proven.
	This would speed up subsequent queries.
</p>

<p>
	大規模な PROLOG 実装はルールの項目の評価も許されます。
	これは、ルールの項目を処理している間に他の仕事をするための関数を実装することを可能にします。
	<tt>prove-rule</tt> は、各ルール項目のシンボルの <tt>eval</tt> ためのテストを実行できます。<br />
	Larger PROLOG implementations 
	also allow the evaluation of terms in rules. 
	This makes it possible to implement functions
	for doing other work 
	while processing rule terms.
	<tt>prove-rule</tt> could accomplish this testing 
	for the symbol <tt>eval</tt> in each rule term.
</p>

<br/><br/>

<a name="union"></a>
<h2><span class="function">union</span></h2>
<h4>syntax: (union <em>list-1</em> <em>list-2</em> [<em>list-3</em> ... ])</h4>

<p><tt>union</tt> は、二つ以上のリストで見つかる区別可能な唯一の要素だけの集合リストを返します。<br />
<tt>union</tt> returns a unique collection list of distinct elements found in two 
or more lists.</p>

<pre>
(union '(1 3 1 4 4 3) '(2 1 5 6 4))  <span class='arw'>&rarr;</span>  (1 3 4 2 5 6)
</pre>

<p>他の集合関数<a href="#difference">difference</a>、<a href="#intersect">intersect</a>、<a href="#unique">unique</a>のように、<tt>union</tt> は元のリストの順序を維持します。<br />
Like the other set functions <a href="#difference">difference</a>, 
<a href="#intersect">intersect</a> and <a href="#unique">unique</a>,
<tt>union</tt> maintains the order of elements as found in the original
lists.</p>

<br/><br/>

<a name="unique"></a>
<h2><span class="function">unique</span></h2>
<h4>syntax: (unique <em>list</em>)</h4>

<p>	二重化している全ての要素を削除し、<em>list</em> の中で唯一のものだけを返します。<br />
	Returns a unique version of <em>list</em> 
	with all duplicates removed.
</p>

<!-- example -->

<pre>
(unique '(2 3 4 4 6 7 8 7))  <span class='arw'>&rarr;</span> (2 3 4 6 7 8)
</pre>


<p>
	リストはソートされている必要はありませんが、
	ソートされたリストは <tt>unique</tt> の実行を早くすることに注意してください。<br />
	Note that the list does not need to be sorted,
	but a sorted list makes <tt>unique</tt> perform faster.
</p>

<p>
	他の集合関数には、<a href="#difference">difference</a> と <a href="#intersect">intersect</a>、<a href="#union">union</a>.があります。<br />
	Other <em>set</em> functions are <a href="#difference">difference</a>,
	<a href="#intersect">intersect</a> and <a href="#union">union</a>.
</p>

<br/><br/>

<a name="unless"></a>
<h2><span class="function">unless</span></h2>
<h4>syntax: (unless <em>exp-condition</em> <em>body</em>)</h4>

<p><em>exp-condition</em> が <tt>nil</tt> か空リスト <tt>()</tt> に評価された時のみ、<em>body</em> の宣言文が評価されます。
<em>body</em> の最後の宣言文の結果か、<em>body</em> が実行されなかった時の <em>exp-condition</em> の戻り値が返ります。<br />
The statements in <em>body</em> are only evaluated if <em>exp-condition</em>
evaluates to <tt>nil</tt> or the empty list <tt>()</tt>. The result
of the last expression in <em>body</em> is returned or the return value
of <em>exp-condition</em> if <em>body</em> was not executed.</p>

<p><tt>unless</tt> は <em>else</em> 条件を持たないので、<a href="#if">if</a> <!-- や <a href="#if-not">if-not</a> --> のように、<em>body</em> 中の宣言文を <a href="#begin">begin</a> でグループ化する必要はありません：<br />
Because <tt>unless</tt> does not have an <em>else</em> condition as in
<a href="#if">if</a>, <!-- or <a href="#if-not">if-not</a> -->the statements in <em>body</em> need 
not to be grouped with <a href="#begin">begin</a>:</p>

<pre>
(unless (starts-with (read-line) "quit")
	(process (current-line))
	...
	(finish)
)	
</pre>

<p>関数 <a href="#when">when</a> も見てください。<br />
See also the function <a href="#when">when</a>.</p>

<br/><br/>

<a name="unpack"></a> 

<h2><span class="function">unpack</span>&nbsp;
<a href="#shared-lib"><font size="+2">&#x26A0;</font></a></h2> 

<h4>syntax: (unpack <em>str-format</em> <em>str-addr-packed</em>)<br/>
syntax: (unpack <em>str-format</em> <em>num-addr-packed</em>)<br/><br/>
syntax: (unpack <em>struct</em> <em>num-addr-packed</em>)<br/> 
syntax: (unpack <em>struct</em> <em>str-addr-packed</em>)</h4> 

<p>第一パラメータが文字列の時、<tt>unpack</tt> は <em>str-addr-packed</em> のバイナリ構造か <em>num-addr-packed</em> で指定された変数を <em>str-format</em> のフォーマットを使って newLISP 変数にアンパックします。
<tt>unpack</tt> は <tt>pack</tt> の逆操作です。
<em>num-addr-packed</em> を使えば、導入された共用ライブライ関数から返される構造体のアンパックが容易になります。<br />
When the first parameter is a string, <tt>unpack</tt> unpacks a binary structure 
in <em>str-addr-packed</em> or pointed to by <em>num-addr-packed</em> into newLISP 
variables using the format in <em>str-format</em>. <tt>unpack</tt> is the reverse 
operation of <tt>pack</tt>.  Using <em>num-addr-packed</em> facilitates the unpacking 
of structures returned from imported, shared library functions.</p>

<p><em>num-addr-packed</em> で指定された数値が有効メモリ・アドレスでないと、
システム・バス・エラーやセグメンテーション違反が起こりえ、newLISP がクラッシュしたり、不安定な状態になりかねません。<br />
If the number specified in <em>num-addr-packed</em> is not a valid memory 
address, a system bus error or segfault can occur and crash newLISP or leave 
it in an unstable state.</p>

<p>第一パラメータが <a href="#struct">struct</a> で定義したシンボルの時、
<tt>unpack</tt> は <em>struct</em> で指定されるフォーマットを使います。
<em>str-format</em> を使った <tt>unpack</tt> は指定された文字の通りにアンパックし、<em>struct</em> を使った <tt>unpack</tt> は構造体をスキップします（訳注：おそらく、構造体は変化しないということ。<tt>pack</tt> は <em>struct</em> に書き込むので）。
構造体は、データ型と要素の順序とCPUアーキテクチャにより一直線に詰められたバイト群です。
詳細は関数 <a href="#struct">struct</a> を参照してください。<br />
When the first parameter is the symbol of a <a href="#struct">struct</a> definition, 
<tt>unpack</tt> uses the format as specified in <em>struct</em>. 
While <tt>unpack</tt> with <em>str-format</em> literally unpacks as specified,
<tt>unpack</tt> with <em>struct</em> will skip structure aligning pad-bytes
depending on data type, order of elements and CPU architecture.
Refer to the description of the <a href="#struct">struct</a> function for more detail.</p>

<p><tt>NULL</tt> ポインタを含む構造をアンパックすると、<tt>unpack</tt> はポインタを文字列に変換しようと試み、エラーが出るでしょう。
<tt>NULL</tt> ポインタが予想されるなら、構造体定義に <tt>void*</tt> を使うべきです。<br />
When unpacking structures containing <tt>NULL</tt> pointers, an error will be
thrown when <tt>unpack</tt> tries to convert the pointer to a string. If <tt>NULL</tt>
pointers are to be expected, <tt>void*</tt> should be used in the structure definition.</p>

<p>以下の文字でフォーマットを定義します：<br />
The following characters may define a format:
</p>
 
<table width="98%" summary="format chracters in pack">

<tr align="left" valign="bottom"><th>format</th><th>description</th></tr>

<tr>
<td><tt>c </tt></td>
<td>a signed 8-bit number</td>
</tr>

<tr>
<td><tt>b </tt></td>
<td>an unsigned 8-bit number</td>
</tr>

<tr>
<td><tt>d </tt></td>
<td>a signed 16-bit short number</td>
</tr>

<tr>
<td><tt>u </tt></td>
<td>an unsigned 16-bit short number</td>
</tr>

<tr>
<td><tt>ld</tt></td>
<td>a signed 32-bit long number</td>
</tr>

<tr>
<td><tt>lu</tt></td>
<td>an unsigned 32-bit long number</td>
</tr>

<tr>
<td><tt>Ld</tt></td>
<td>a signed 64-bit long number</td>
</tr>

<tr>
<td><tt>Lu</tt></td>
<td>an unsigned 64-bit long number</td>
</tr>

<tr>
<td><tt>f </tt></td>
<td>a float in 32-bit representation</td>

</tr>

<tr>
<td><tt>lf</tt></td>
<td>a double float in 64-bit representation</td>
</tr>

<tr>
<td><tt>sn</tt></td>
<td>a string of <em>n</em> null padded ASCII characters</td>
</tr>

<tr>

<td><tt>nn</tt></td>
<td><em>n</em> null characters</td>
</tr>

<tr>
<td><tt>&gt;</tt></td>
<td>switches to big endian byte order</td>
</tr>

<tr>
<td><tt>&lt;</tt></td>
<td>switches to little endian byte order</td>
</tr>

</table><br/>

<br/>
<!-- example -->

<pre>
(pack "c c c" 65 66 67)  <span class='arw'>&rarr;</span> "ABC"
(unpack "c c c" "ABC")   <span class='arw'>&rarr;</span> (65 66 67)

(set 's (pack "c d u" 10 12345 56789))
(unpack "c d u" s)  <span class='arw'>&rarr;</span> (10 12345 56789)

(set 's (pack "s10 f" "result" 1.23))
(unpack "s10 f" s)  <span class='arw'>&rarr;</span> ("result\000\000\000\000" 1.230000019)

(set 's (pack "s3 lf" "result" 1.23))
(unpack "s3 f" s)  <span class='arw'>&rarr;</span> ("res" 1.23)

(set 's (pack "c n7 c" 11 22))
(unpack "c n7 c" s)  <span class='arw'>&rarr;</span> (11 22))
</pre>


<p>	<tt>&gt;</tt> と <tt>&lt;</tt> の指定子は、パック及びアンパック時のバイト順、<em>リトルエンディアン</em> と <em>ビックエンディアン</em> を切り替えるために使えます。<br />
	The <tt>&gt;</tt> and <tt>&lt;</tt> specifiers 
	can be used to switch between 
	<em>little endian</em> and <em>big endian</em> byte order 
	when packing or unpacking:
</p>



<pre>
;; on a little endian system (e.g., Intel CPUs)
(set 'buff (pack "d" 1))  <span class='arw'>&rarr;</span> "\001\000" 

(unpack "d" buff)   <span class='arw'>&rarr;</span> (1)
(unpack "&gt;d" buff)  <span class='arw'>&rarr;</span> (256)
</pre>



<p>	バイト順の切り替えは、16、32、64ビット・サイズの数値全てに作用します。<br />
	Switching the byte order 
	will affect all number formats 
	with 16-, 32-, or 64-bit sizes.
</p>


<p>	<tt>pack</tt> と <tt>unpack</tt> のフォーマットは、次の例のように同じである必要はありません：<br />
	The <tt>pack</tt> and <tt>unpack</tt> format 
	need not be the same,
	as in the following example:
</p>


<pre>
(set 's (pack "s3" "ABC"))
(unpack "c c c" s)  <span class='arw'>&rarr;</span> (65 66 67)
</pre>


<p>	この例では、フォーマット指定子間にスペースがあります。
	要求事項ではありませんが、可読性を良くします。<br />
	The examples show spaces between the format specifiers.
	Although not required, they can improve readability.
</p>

<p>メモリ・アドレスのバッファの大きさがフォーマット文字列による指定より小さい時は、いくつかのフォーマット文字は使われないことになります。<br />
If the buffer's size at a memory address 
is smaller than the formatting string specifies, 
some formatting characters may be left unused.</p>

<p>	関数 <a href="#address">address</a>、
	<a href="#get-int">get-int</a>、
	<a href="#get-long">get-long</a>、
	<a href="#get-char">get-char</a>、
	<a href="#get-string">get-string</a>、 
	<a href="#pack">pack</a> も見てください。<br />
	See also the <a href="#address">address</a>,
	<a href="#get-int">get-int</a>,
	<a href="#get-long">get-long</a>,
	<a href="#get-char">get-char</a>,
	<a href="#get-string">get-string</a>, 
	and <a href="#pack">pack</a> functions.
</p>

<br/><br/>

<a name="until"></a>
<h2><span class="function">until</span></h2>
<h4>syntax: (until <em>exp-condition</em> [<em>body</em>])</h4>

<p><em>exp-condition body</em> の条件を評価し、結果が <tt>nil</tt> か空リスト <tt>()</tt> なら、<em>body</em> 中の式が評価されます。
<em>exp-condition</em> の結果が <tt>nil</tt> か空リスト以外になるまで、評価は繰り返されます。
<em>body</em> で最後に評価された結果が、<tt>until</tt> 式の戻り値になります。
<em>body</em> が空なら、最後の <em>exp-condition</em> の結果が返ります。
<tt>until</tt>は、(<a href="#while">while</a> (<a href="#not">not</a> …)) のように動作します。<br />

 Evaluates the condition in <em>exp-condition</em>.
If the result is <tt>nil</tt> or the empty list <tt>()</tt>, 
the expressions in <em>body</em> are evaluated.
Evaluation is repeated until the exp-condition results in a value 
other than <tt>nil</tt> or the empty list.
The result of the last expression evaluated in <em>body</em>
is the return value of the <tt>until</tt> expression. If
<em>body</em> is empty, the result of last <em>exp-condition</em>
is returned. <tt>until</tt> works like 
(<a href="#while">while</a> (<a href="#not">not</a> &hellip;)).
</p>

<p><tt>until</tt> はシステム繰り返しシンボル <tt>$idx</tt> も更新します。<br />
<tt>until</tt> also updates the system iterator symbol <tt>$idx</tt>.</p>

<!-- example -->

<pre>
(device (open "somefile.txt" "read"))
(set 'line-count 0)
(until (not (read-line)) (inc line-count))
(close (device))
(print "the file has " line-count " lines\n")
</pre>


<p> 本体の式群を<em>評価した後</em> に条件の評価を試したい時は、関数 <a href="#do-until">do-until</a> を使ってください。<br />
	Use the <a href="#do-until">do-until</a> function 
	to test the condition <em>after</em> evaluation 
	of the body expressions.
</p>

<br/><br/>

<a name="upper-case"></a>
<h2><span class="function">upper-case</span>&nbsp;<font size="-1"><a href="#utf8_capable">utf8</a></font></h2>
<h4>syntax: (upper-case <em>str</em>)</h4>

<p>大文字に変換した <em>str</em> の文字列のコピーを返します。
国際文字は正しく変換されます。<br />
Returns a copy of the string in <em>str</em> converted to uppercase.
International characters are converted correctly.</p>

<!-- example -->

<pre>
(upper-case "hello world")  <span class='arw'>&rarr;</span> "HELLO WORLD"
</pre>


<p>	関数 <a href="#lower-case">lower-case</a> と <a href="#title-case">title-case</a> も見てください。<br />
	See also the <a href="#lower-case">lower-case</a> 
	and <a href="#title-case">title-case</a> functions.
</p>

<br/><br/>

<a name="utf8"></a>
<h2><span class="function">utf8</span></h2>
<h4>syntax: (utf8 <em>str-unicode</em>)</h4>

<p>UCS-4, 4バイト, Unicode文字列 (<em>str</em>) を UTF-8 に変換します。
この関数は UTF-8 版 newLISP でのみ利用可能です。<br />
Converts a UCS-4, 4-byte, Unicode-encoded string (<em>str</em>)
into UTF-8.  This function is only available on UTF-8&ndash;enabled 
versions of newLISP.</p>

<!-- example -->

<pre>
(unicode "new") 
<span class='arw'>&rarr;</span> "n\000\000\000e\000\000\000w\000\000\000\000\000\000\000"

(utf8 (unicode "new"))  <span class='arw'>&rarr;</span> "new"
</pre>


<p>関数 <tt>utf8</tt> は、UTF-8 版 newLISP かどうかのテストにも使えます：<br />
The <tt>utf8</tt> function can also be used 
to test for the presence of UTF-8&ndash;enabled newLISP:</p>


<pre>
(if utf8 (do-utf8-version-of-code) (do-ascii-version-of-code))
</pre>


<p>
<em>big endian</em> CPU アーキテクチャでは、バイト順が上位から下位へと逆になります。
<tt>utf8</tt> と <a href="#unicode">unicode</a> は、互いに逆関数です。
UCS-4 Unicode を使用中の時のみ、これらの関数が必要になります。
多くのシステムでは、UTF-8 エンコーディングのみです。 <br />
On <em>big endian</em> CPU architectures, the byte order will be reversed 
from highest to lowest. The <tt>utf8</tt> and <a href="#unicode">unicode</a> 
functions are the inverse of each other. These functions are only necessary 
if UCS-4 Unicode is in use. Most systems use UTF-8 Unicode encoding only.
</p>

<br/><br/>

<a name="utf8len"></a>
<h2><span class="function">utf8len</span></h2>
<h4>syntax: (utf8len <em>str</em>)</h4>

<p>UTF-8 文字列の文字数を返します。
UTF-8 文字は 1 バイト／ 8 ビットよりも大きくエンコードされています。
<tt>utf8len</tt> 文字列中の UTF-8 文字数を返します。
この関数は、UTF-8 版 newLISP でのみ利用可能です。<br />
Returns the number of characters in a UTF-8&ndash;encoded string. 
UTF-8 characters can be encoded in more than one 8-bit byte. 
<tt>utf8len</tt> returns the number of UTF-8 characters in a string. 
This function is only available on UTF-8&ndash;enabled versions of newLISP.</p>

<!-- example -->

<pre>
(utf8len "我能吞下玻璃而不伤身体。")    <span class='arw'>&rarr;</span> 12
(length "我能吞下玻璃而不伤身体。")      <span class='arw'>&rarr;</span> 36
</pre>


<p>関数 <a href="#unicode">unicode</a> と <a href="#utf8">utf8</a> も
見てください。
上記、中国語テキストは <a href="http://www.columbia.edu/kermit/utf8.html">UTF-8 Sampler</a> からのものです。<br />
See also the <a href="#unicode">unicode</a> and <a href="#utf8">utf8</a> functions.
Above Chinese text from <a href="http://www.columbia.edu/kermit/utf8.html">UTF-8 Sampler</a>.</p>

<br/><br/>

<a name="uuid"></a>
<h2><span class="function">uuid</span></h2>
<h4>syntax: (uuid [<em>str-node</em>])</h4>

<p>	UUID (Universally Unique IDentifier) を作成し、返します。
	<em>str-node</em> のノード指定なしでは、タイプ 4 の ランダム生成 UUID が返ります。
	オプションの <em>str-node</em> パラメータが使われると、タイプ 1 の（訳注：<a href="http://e-class.center.yuge.ac.jp/jdk_docs/ja/api/java/util/UUID.html">時間ベース</a>） UUID が返ります。
	<em>str-node</em> の文字列には、ネットワーク・アダプタからの有効な MAC (Media Access Code) か、ランダムなノード ID を指定します。
	ランダムなノード ID が指定された時は、実 MAC 指定子との衝突を避けるために、第一ノード・バイトの最小ビットは 1 にセットしなければなりません。
	ノード ID による タイプ 1 の UUID は、タイプスタンプと他のデータから生成されます。
	UUID 生成の詳細は、<a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a> を見てください。<br />
	Constructs and returns
	a UUID (Universally Unique IDentifier).
	Without a node spec in <em>str-node</em>, 
	a type 4 UUID random generated byte number 
	is returned.
	When the optional <em>str-node</em> parameter is used, 
	a type 1 UUID is returned.
	The string in <em>str-node</em> 
	specifies a valid MAC (Media Access Code) 
	from a network adapter installed on the node
	or a random node ID.
	When a random node ID is specified,
	the least significant bit of the first node byte 
	should be set to 1 
	to avoid clashes with real MAC identifiers.
	UUIDs of type 1 with node ID 
	are generated from a timestamp and other data.
	See <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC 4122</a> 
	for details on UUID generation.
</p>

<!-- example -->

<pre>
;; type 4 UUID for any system

(uuid)  <span class='arw'>&rarr;</span> "493AAD61-266F-48A9-B99A-33941BEE3607"

;; type 1 UUID preferred for distributed systems

;; configure node ID for ether 00:14:51:0a:e0:bc
(set 'id (pack "cccccc" 0x00 0x14 0x51 0x0a 0xe0 0xbc))

(uuid  id)  <span class='arw'>&rarr;</span> "0749161C-2EC2-11DB-BBB2-0014510AE0BC"
</pre>


<p>	<tt>uuid</tt> 関数の各実施は新しいユニークな UUID をもたらします。
	UUID は system-wide shared stable store (RFC 4122 参照) 無しで生成されます。
	UUID を生成するシステムがいくつかのノードに配布されるなら、各ノードで異なるノード ID と共にタイプ 1 の生成が使われるべきです。
	同じノード上のいくつかのプロセスにとっては、同時刻に要求されたとしても有効な UUID が保証されます。
	これは、生成するnewLISP プロセスのプロセス ID が乱数生成器の種の一部になるからです。
	タイプ 4 ID が配布システムで使われる時でも、まだ、二つの同一 UUID はありそうもなく、実 MAC アドレスが使われるタイプ 1 の ID ではありえません。
<br/>
	Each invocation of the <tt>uuid</tt> function 
	will yield a new unique UUID.
	The UUIDs are generated without system-wide 
	shared stable store (see RFC 4122).
	If the system generating the UUIDs 
	is distributed over several nodes, 
	then type 1 generation should be used 
	with a different node ID on each node.
	For several processes on the same node, 
	valid UUIDs are guaranteed 
	even if requested at the same time.
	This is because the process ID 
	of the generating newLISP process 
	is part of the seed 
	for the random number generator.
	When type 4 IDs are used on a distributed system, 
	two identical UUID's are still highly unlikely 
	and impossible for type 1 IDs 
	if real MAC addresses are used.
</p>

<br/><br/>

<a name="wait-pid"></a>
<h2><span class="function">wait-pid</span></h2>
<h4>syntax: (wait-pid <em>int-pid</em> [<em>int-options</em> | <tt>nil</tt>])</h4>

<p>
<em>int-pid</em> で指定された子プロセスが終わるまで待ちます。
子プロセスは、前もって <a href="#process">process</a> か <a href="#fork">fork</a> で開始しています。
<em>int-pid</em> で指定された子プロセスが終わると、pid とステータス値のリストが返ります。
ステータス値は、子プロセスが終了した理由を表します。
戻ったステータス値の説明は、Linux と他の Unix では異なります。
より詳しい情報には、Linux/Unix man ページで <tt>waitpid</tt> コマンド（newLISP で使っているハイフンは無し）を調べてください。<br />
Waits for a child process specified in <em>int-pid</em> to end.  The child process was 
previously started with <a href="#process">process</a> or <a href="#fork">fork</a>.
When the child process specified in <em>int-pid</em> ends, a list of pid and status value is 
returned.  The status value describes the reason for termination of the child process.
The interpretation of the returned status value differs between Linux and other flavors 
of Unix.  Consult the Linux/Unix man pages for the <tt>waitpid</tt> command (without the hyphen 
used in newLISP) for further information.
</p>

<p><tt><em>int-pid</em> に-1</tt> が指定されると、親プロセスで開始した任意の子プロセスの pid とステータス情報が返ります。
<tt>0</tt> が指定されると、<tt>wait-pid</tt> は呼び出しプロセスとして同じプロセス・グループの子プロセスのみを監視します。
<em>int-pid</em> の他の負数の値は、同じプロセス・グループで<em>int-pid</em> の負の符号として指定されている子プロセスを報告します。<br />
When <tt>-1</tt> is specified for <em>int-pid</em>, 
pid and  status information of any child process started by the parent are returned.
When <tt>0</tt> is specified, <tt>wait-pid</tt> only watches child processes in the 
same process group as the calling process.  Any other negative value for <em>int-pid</em> 
reports child processes in the same process group as specified with a negative sign 
in <em>int-pid</em>.
</p>

<p><em>int-options</em> にオプションが指定できます。
<em>int-options</em> の整数値の詳細は、Linux/Unix ドキュメントを見てください。
代わりに <tt>nil</tt> が指定できます。
このオプションは、<tt>wait-pid</tt> をノン・ブロッキングにし、戻りリストの pid を <tt>0</tt> にして直ちに戻ります。
このオプションは、 <tt>-1</tt> の <em>int-pid</em> パラメータと一緒に戻ってくる子プロセスの繰り返し実行に使えます。<br />
An option can be specified in <em>int-option</em>.  See Linux/Unix documentation 
for details on integer values for <em>int-options</em>. As an alternative, <tt>nil</tt>
can be specified. This option causes <tt>wait-pid</tt> to be non-blocking, returning 
right away with a <tt>0</tt> in the pid of the list returned. This option used together with
 an <em>int-pid</em> parameter of <tt>-1</tt> can be used to continuously loop and act 
on returned child processes.</p>

<p>この関数は、macOS、Linux、Unixライク・オペレーティング・システムでのみ利用できます。<br />
This function is only available on macOS, Linux and other Unix-like operating systems.
</p>

<!-- example -->
<pre>
(set 'pid (fork (my-process))) <span class='arw'>&rarr;</span> 8596

(set 'ret (wait-pid pid))  <span class='arw'>&rarr;</span> (8596 0) ; child has exited

(println "process: " pid " has finished with status: " (last ret))
</pre>

<p>	プロセス <tt>my-process</tt> が開始し、メイン・プログラムは <tt>my-process</tt> が終わるまで、<tt>wait-pid</tt> 呼び出しで止まります。<br />
	The process <tt>my-process</tt> is started, 
	then the main program blocks 
	in the <tt>wait-pid</tt> call 
	until <tt>my-process</tt> has finished.
</p>

<br/><br/>

<a name="when"></a>
<h2><span class="function">when</span></h2>
<h4>syntax: (when <em>exp-condition</em> <em>body</em>)</h4>

<p><em>exp-condition</em> が <tt>nil</tt> 以外や空リスト <tt>()</tt> 以外に評価された時のみ、<em>body</em> の宣言文が評価されます。
<em>body</em> の最後の式の評価か、<em>body</em> が評価されなかった時の <tt>nil</tt> か空リスト <tt>()</tt> が返ります。<br />
The statements in <em>body</em> are only evaluated if <em>exp-condition</em>
evaluates to anything not <tt>nil</tt> and not the empty list <tt>()</tt>. The result
of the last expression in <em>body</em> is returned or <tt>nil</tt> or the empty
list <tt>()</tt> if <em>body</em> was not executed.</p>

<p><tt>when</tt> は <em>else</em> 条件を持たないので、<a href="#if">if</a>のように <em>body</em> の宣言文は <a href="#begin">begin</a> でグループ化する必要はありません：<br />
Because <tt>when</tt> does not have an <em>else</em> condition as in
<a href="#if">if</a>, the statements in <em>body</em> need not to be grouped with
<a href="#begin">begin</a>:</p>

<!-- example -->
<pre>
(when (read-line)
	(set 'result (analyze (current-line)))
	(report result)
	(finish)
)	
</pre>

<p>関数 <a href="#unless">unless</a> も見てください。<br />
See also the function <a href="#unless">unless</a>.</p>

<br/><br/>

<a name="while"></a>
<h2><span class="function">while</span></h2>
<h4>syntax: (while <em>exp-condition</em> <em>body</em>)</h4>

<p><em>exp-condition</em> の条件を評価し、結果が <tt>nil</tt> か空リスト <tt>()</tt> 以外なら、<em>body</em> 中の式が評価されます。
<em>exp-condition</em> の結果が、<tt>nil</tt> か空リスト <tt>()</tt> になるまで、
評価は繰り返されます。 
body の最後に評価された結果が <tt>while</tt> 式の戻り値になります。<br />
 Evaluates the condition in <em>exp-condition</em>.
If the result is not <tt>nil</tt> or the empty list <tt>()</tt>, 
the expressions in <em>body</em> are evaluated.
Evaluation is repeated until an <em>exp-condition</em> results 
in <tt>nil</tt> or the empty list <tt>()</tt>.
The result of the body's last evaluated expression
is the return value of the <tt>while</tt> expression.
</p>

<p><tt>while</tt> は、システム繰り返しシンボル <tt>$idx</tt> も更新します。<br />
<tt>while</tt> also updates the system iterator symbol <tt>$idx</tt>.</p>

<!-- example -->

<pre>
(device (open "somefile.txt" "read"))
(set 'line-count 0)
(while (read-line) (inc line-count))
(close (device))
(print "the file has " line-count " lines\n")
</pre>


<p>本体の式群を<em>評価した後</em>で条件を評価したい時は、関数 <a href="#do-while">do-while</a> を使ってください。<br />
Use the <a href="#do-while">do-while</a> function to evaluate the condition 
<em>after</em> evaluating the body of expressions.
</p>

<br/><br/>

<a name="write"></a>
<a name="write-buffer"></a>

<h2><span class="function">write</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (write)<br/>
syntax: (write <em>int-file</em> <em>str-buffer</em> [<em>int-size</em>])<br/>
syntax: (write <em>str</em> <em>str-buffer</em> [<em>int-size</em>])</h4>


<p>第二構文の <tt>write</tt> は、前以てファイルの <tt>open</tt> 操作で開いている <em>int-file</em> で指定されたファイルに、<em>str-buffer</em> のバッファから <em>int-size</em> バイト書き込みます。
<em>int-size</em> が指定されない時、<em>sym-buffer</em> または <em>str-buffer</em> の全てのデータが書き込まれます。
<tt>writer</tt> は、書き込まれたバイト数か、失敗した時の <tt>nil</tt> を返します。<br />
In the second syntax <tt>write</tt> writes <em>int-size</em> bytes 
from a buffer in <em>str-buffer</em> to a file specified in <em>int-file</em>, 
previously obtained from a file <tt>open</tt> operation. If <em>int-size</em> 
is not specified, all data in <em>sym-buffer</em> or <em>str-buffer</em> is written.
<tt>write</tt> returns the number of bytes written or <tt>nil</tt> on failure.</p>
<p>全てのパラメータを省略すると、<tt>write</tt> は最後の <a href="#read-line">read-line</a> からの内容を標準出力に書き込みます。<br />
If all parameters are omitted, <tt>write</tt> writes the contents from the
last <a href="#read-line">read-line</a> to standard out (STDOUT).</p>

<p><tt>write</tt> は <tt>write-buffer</tt> の省略形です。
長い形式は今でも動作しますが、新しいコードでは避けてください。<br />
<tt>write</tt> is a shorter writing of <tt>write-buffer</tt>. The longer
form still works but is deprecated and should be avoided in new code.</p>

<!-- example -->

<pre>
(set 'handle (open "myfile.ext" "write"))
(write handle data 100)   
(write handle "a quick message\n")
</pre>

<p>この例のコードは、<tt>myfile.ext</tt> に <tt>data</tt> 内容を 100 バイト書き込みます。<br />
The code in the example writes 100 bytes to the file <tt>myfile.ext</tt> 
from the contents in <tt>data</tt>.</p>

<p>第三構文の <tt>write</tt> は破壊的文字列追加に使えます：<br />
In the third syntax, <tt>write</tt> can be used for destructive
string appending:</p>

<pre>
(set 'str "")
(write str "hello world")

str   <span class='arw'>&rarr;</span> "hello world"
</pre>

<p>関数 <a href="#read">read</a> も見てください。<br />
See also the <a href="#read">read</a> function.</p>

<br/><br/>

<a name="write-char"></a>
<h2><span class="function">write-char</span></h2>
<h4>syntax: (write-char <em>int-file</em> <em>int-byte1</em> [<em>int-byte2</em> ... ])</h4>

<p><em>int-byte</em> で指定された１バイトを <em>int-file</em> で指定されたファイル・ハンドラに書き込みます。
ファイル・ハンドラは、前以て <tt>open</tt> 操作で得て置きます。
各 <tt>write-char</tt> は、ファイル・ポインタを 1 バイト／ 8 ビットずつ進めます。<br />
Writes a byte specified in <em>int-byte</em> to a file specified by the file 
handle in <em>int-file</em>. The file handle is obtained from a previous 
<tt>open</tt> operation. Each <tt>write-char</tt> advances the file pointer 
by one 8-bit byte.</p>

<p><tt>write-char</tt> は書かれたバイトの数を返します。<br />
<tt>write-char</tt> returns the number of bytes written.</p>

<!-- example -->

<pre>
(define (slow-file-copy from-file to-file)
    (set 'in-file (open from-file "read"))
    (set 'out-file (open to-file "write"))
    (while (set 'chr (read-char in-file))
        (write-char out-file chr))
     (close in-file)
    (close out-file)
    "finished")
</pre>


<p>大規模なデータを一度に書き込む際は、関数 <a href="#print">print</a> と <a href="#device">device</a> を使ってください。
より高速なファイル・コピー用組込関数 <a href="#copy-file">copy-file</a> を、newLISP が既に提供していることに注意してください。
（訳注：つまり、例のようなスクリプトを使うことは、まずありません）<br />
Use the <a href="#print">print</a> 
and <a href="#device">device</a> functions 
to write larger portions of data at a time.
Note that newLISP already supplies a faster 
built-in function called 
<a href="#copy-file">copy-file</a>.
</p>

<p>
	関数 <a href="#read-char">read-char</a> も見てください。<br />
	See also the <a href="#read-char">read-char</a> function.
</p>

<br/><br/>

<a name="write-file"></a>
<h2><span class="function">write-file</span></h2>
<h4>syntax: (write-file <em>str-file-name</em> <em>str-buffer</em>)</h4>

<p><em>str-file-name</em> のファイルに、<em>str-buffer</em> の内容を一気に書き込み、書き込んだバイト数を返します。<br />
Writes a file in <em>str-file-name</em> with contents in <em>str-buffer</em> 
in one swoop and returns the number of bytes written.</p>

<p>失敗した時、関数は <tt>nil</tt> を返します。
ファイルに対して使った時のエラー情報には、<a href="#sys-error">sys-error</a> を使います。
URL の場合は、<a href="#net-error">net-error</a> が詳細なエラー情報を与えます。<br />
On failure the function returns <tt>nil</tt>. For error information, 
use <a href="#sys-error">sys-error</a> when used on files. When used
on URLs <a href="#net-error">net-error</a> gives more error
information.</p>
</p>

<!-- example -->

<pre>
(write-file "myfile.enc"
    (encrypt (read-file "/home/lisp/myFile") "secret"))
</pre>


<p>現ディレクトリ下でファイル <tt>myfile</tt> が読み取られ、パスワード <tt>secret</tt> を使って <a href="#encrypt">暗号化され</a>、<tt>myfile.enc</tt> の新ファイルに書き込まれます。 <br />
The file <tt>myfile</tt> is read, <a href="#encrypt">encrypted</a> using the 
password <tt>secret</tt>, and written back into the new file <tt>myfile.enc</tt>
in the current directory.</p>

<p>
<tt>write-file</tt> は、 <tt>http://</tt> または <tt>file://</tt> URL を <em>str-file-name</em> に取ることができます。
<tt>http://</tt> が使われる時、<tt>write-file</tt> は <a href="#put-url">put-url</a> と同様に動作し、同じ追加パラメータを取ることができます：<br />
<tt>write-file</tt> can take an <tt>http://</tt> or <tt>file://</tt> URL 
in <em>str-file-name</em>. When the prefix <tt>http://</tt> is used, 
<tt>write-file</tt> works exactly like <a href="#put-url">put-url</a> 
and can take the same additional parameters:</p>

<!-- example -->

<pre>
(write-file "http://asite.com/message.txt" "This is a message" )
</pre>


<p>ファイル <tt>message.txt</tt> が、リモート・ローケーション <tt>http://asite.com</tt> に作成され、<em>str-buffer</em> の内容が書き込まれます。
このモードでは、<tt>write-file</tt> はリモート newLISP サーバー・ノードへのファイル転送に使われます。<br />
The file <tt>message.txt</tt> is created and written at a remote location, 
<tt>http://asite.com</tt>, with the contents of <em>str-buffer</em>.
In this mode, <tt>write-file</tt> can also be used to transfer files 
to remote newLISP server nodes.</p>

<p>関数 <a href="#append-file">append-file</a> と <a href="#read-file">read-file</a> も見てください。<br />
See also the <a href="#append-file">append-file</a> 
and <a href="#read-file">read-file</a> functions.</p>

<br/><br/>

<a name="write-line"></a>
<h2><span class="function">write-line</span>&nbsp;<a href="#destructive">!</a></h2>
<h4>syntax: (write-line [<em>int-file</em> [<em>str</em>]])<br/>
syntax: (write-line <em>str-out</em> [<em>str</em>]])</h4>

<p><em>str</em> の文字列と行終端文字が、<em>int-file</em> で指定されたデバイスに書き込まれます。
文字列の引数が省略されると、<tt>write-line</tt> は <em>int-file</em> での最後の <a href="#read-line">read-line</a> の内容を書き込みます。
第一引数も省略されたなら、標準出力 (STDOUT) か <a href="#device">device</a> で設定されたデバイスに書き込みます。<br />
The string in <em>str</em> and the line termination character(s) 
are written to the device specified in <em>int-file</em>.
When the string argument is omitted <tt>write-line</tt> writes the 
contents of the last <a href="#read-line">read-line</a> to <em>int-file</em>.
If the first argument is omitted too then it writes to  to standard out 
(STDOUT) or to whatever device is set by <a href="#device">device</a>.</p> 

<p>第二構文では、<em>str-out</em> の文字列に各行が追加されます。<br />
In the second syntax lines are appended to a string in <em>str-out</em>.</p>

<p><tt>write-line</tt> は、書き込んだバイト数を返します。<br />
<tt>write-line</tt> returns the number of bytes written.</p>

<!-- example -->

<pre>
(set 'out-file (open "myfile" "write"))
(write-line out-file "hello there")
(close out-file)

(set 'myFile (open "init.lsp" "read")
(while (read-line myFile) (write-line))

(set 'str "")
(write-line str "hello")
(write-line str "world")

str  <span class='arw'>&rarr;</span>  "hello\nworld\n"
</pre>


<p>一番目の例は、ファイルをオープン／生成し、それに一行書き込み、ファイルを閉じます。
二番目の例は、引数なしの <tt>write-line</tt> の使い方を示しています。
<tt>init.lsp</tt> の内容が端末画面に書き込まれます。<br />
The first example opens/creates a file, writes a line to it, 
and closes the file. The second example shows the usage of <tt>write-line</tt> 
without arguments. The contents of <tt>init.lsp</tt> are written to the console 
screen.</p>

<p>行終端文字無しでデバイスに書き込む関数 <a href="#write">write</a> も見てください。<br />
See also the function <a href="#write">write</a> for writing
to a device without the line-terminating character.</p>

<br/><br/>

<a name="xfer-event"></a>
<h2><span class="function">xfer-event</span></h2>
<h4>syntax: (xfer-event <em>sym-event-handler</em> | <em>func-event-handler</em>)
syntax: (xfer-event nil)</h4>

<p><a href="#get-url">get-url</a>、<a href="#post-url">post-url</a>、<a href="#put-url">put-url</a> で開始する、または、<a href="#load">load</a>、
<a href="#save">save</a>、<a href="#read-file">read-file</a>、<a href="#write-file">write-file</a>、<a href="#append-file">append-file</a> のように URL を取ることができるファイル関数で開始する HTTP バイト転送をモニタするために、シンボル <em>sym-event-handler</em> かラムダ関数 <em>func-event-handler</em> の関数を登録します。<br />
Registers a function in symbol <em>sym-event-handler</em> or in lambda function 
<em>func-event-handler</em>
to monitor HTTP byte transfers initiated by <a href="#get-url">get-url</a>,
<a href="#post-url">post-url</a> or <a href="#put-url">put-url</a> or initiated
by file functions which can take URLs like <a href="#load">load</a>,
<a href="#save">save</a>, <a href="#read-file">read-file</a>,
<a href="#write-file">write-file</a> and <a href="#append-file">append-file</a>.
</p>

<p>例えば、<a href="#get-url">get-url</a> で<ruby>要求<rp>（</rp><rt>リクエスト</rt><rp>）</rp></ruby>されるデータ・ブロックが届いた時はいつも、<em>sym</em> か <em>func</em> の関数が転送されたバイト数を引数にして呼ばれます。
<a href="#post-url">post-url</a> や他のデータ送信関数でデータを送信している時も同様に、転送されたデータの各ブロックで <em>sym</em> か <em>func</em> の関数が転送されたバイト数を引数にして呼ばれます。<br />
E.g. whenever a block of data requested with <a href="#get-url">get-url</a>
arrives, the function in <em>sym</em> or <em>func</em> will be called with
the number of bytes transferred. Likewise when sending data with
<a href="#post-url">post-url</a> or any of the other data sending 
functions, <em>sym</em> or <em>func</em> will be called with the number of
bytes transferred for each block of data transferred.</p>

<p>イベントに <tt>nil</tt> を指定すると、初期のデフォルト状態にリセットされます。<br />
Specifying <tt>nil</tt> for the event will reset it to the initial default state.</p>

<!-- example -->

<pre>
(xfer-event (fn (n) (println "-&gt;" n)))
(length (get-url "http://newlisp.org"))
<b>
-&gt;73
-&gt;799
-&gt;1452
-&gt;351
-&gt;1093
-&gt;352
-&gt;211
-&gt;885
-&gt;564
-&gt;884
-&gt;561
-&gt;75
-&gt;812
-&gt;638
-&gt;1452
-&gt;801
-&gt;5
-&gt;927
11935
</b>
</pre>


<p>コンピュータの出力は、太字で示されます。
データ・ブロックが受信された時はいつも、そのバイト数が出力されます。
ラムダ関数 <em>func</em> に直接ハンドラ関数を定義する代わりに、関数が定義されているシンボルも使えます：<br />
The computer output is shown in bold. Whenever a block of data is received
its byte size is printed. Instead of defining the handler
function directory with a lambda function in <em>func</em>, a symbol
containing a function definition could have been used:</p>


<pre>
(define (report n) (println "-&gt;" n))
(xfer-event 'report)
</pre>


<p>これは、HTTP のアップロードやダウンロードで、継続中のバイト転送の進行をモニタするために使えます。<br />
 This can be used to monitor the progress of longer
lasting byte transfers in HTTP uploads or downloads.</p>

<br/><br/>

<a name="xml-error"></a>
<h2><span class="function">xml-error</span></h2>
<h4>syntax: (xml-error)</h4>

<p>	最後の <a href="#xml-parse">xml-parse</a> 操作からのエラー情報のリストか、エラーが無かった時の <tt>nil</tt> を返します。
	第一要素は、エラーを表すテキストからなり、第二要素はソース XML テキストの最後の走査位置を示す数値で、<tt>0</tt> (zero) から始まります。<br />
	Returns a list of error information 
	from the last <a href="#xml-parse">xml-parse</a> operation; 
	otherwise, returns <tt>nil</tt>
	if no error occurred.
	The first element contains text 
	describing the error, 
	and the second element is a number indicating 
	the last scan position in the source XML text, 
	starting at <tt>0</tt> (zero).
</p>

<!-- example -->

<pre>
(xml-parse "&lt;atag&gt;hello&lt;/atag&gt;&lt;fin")  <span class='arw'>&rarr;</span> nil

(xml-error)  <span class='arw'>&rarr;</span> ("expected closing tag: &gt;" 18)
</pre>

<br/><br/>

<a name="xml-parse"></a>
<h2><span class="function">xml-parse</span></h2>
<h4>syntax: (xml-parse <em>string-xml</em> [<em>int-options</em> [<em>sym-context</em> [<em>func-callback</em>]]])</h4>

<p>XML 1.0 に適応している <em>well-formed</em> な XML の文字列を解析します。
<tt>xml-parse</tt> は、DTD 確認を実行しません。
DTD (Document Type Declarations) と命令の処理は、スキップされます。
タイプ ELEMENT, TEXT, CDATA, COMMENT のノードは解析され、newLISP のリスト構造体が返ります。
要素ノードが属性を持たず、子ノードが無い時は、代わりに空リストになります。
属性は、連想リストで返り、<a href="#assoc">assoc</a> を使ってアクセス可能です。
<tt>xml-parse</tt> が、奇形の XML で失敗した時は、 <tt>nil</tt> が返り、<a href="#xml-error">xml-error</a> がエラー情報のアクセスに使われます。<br />
Parses a string containing XML 1.0 compliant, <em>well-formed</em> XML.
<tt>xml-parse</tt> does not perform DTD validation. 
It skips DTDs (Document Type Declarations) and processing instructions.
Nodes of type ELEMENT, TEXT, CDATA, and COMMENT are parsed, and 
a newLISP list structure is returned.  When an element node does not have 
attributes or child nodes, it instead contains an empty list.
Attributes are returned as association lists, 
which can be accessed using <a href="#assoc">assoc</a>.
When <tt>xml-parse</tt> fails due to malformed XML, <tt>nil</tt> is returned 
and <a href="#xml-error">xml-error</a> can be used to access error information.
</p>

<!-- example -->

<pre>
(set 'xml 
  "&lt;person name='John Doe' tel='555-1212'&gt;nice guy&lt;/person&gt;")

(xml-parse xml) 
<span class='arw'>&rarr;</span> (("ELEMENT" "person" 
    (("name" "John Doe") 
     ("tel" "555-1212"))
    (("TEXT" "nice guy"))))
</pre>


<h3>Modifying the translation process.（翻訳処理を変更する）</h3>
<p>空白や属性無しリストやコメントを隠すために、オプションで <em>int-options</em> パラメータを指定できます。
タグを文字列からシンボルに変換するためにも使えます。
別関数 <a href="#xml-type-tags">xml-type-tags</a> が、XML タグの変換を提供します。
次のオプション番号が使えます：<br />
Optionally, the <em>int-options</em> parameter can be specified 
to suppress whitespace, empty attribute lists, and comments.
It can also be used to transform tags from strings into symbols.
Another function, <a href="#xml-type-tags">xml-type-tags</a>, 
serves for translating the XML tags.
The following option numbers can be used:
</p>

<table  summary="option numbers for xml-parse">
<tr align="left" valign="bottom"><th>option</th><th>description</th></tr>
<tr><td>1</td><td>空白テキスト・タグの隠蔽<br />suppress whitespace text tags</td></tr>
<tr><td>2</td><td>空属性リストの隠蔽<br />suppress empty attribute lists</td></tr>
<tr><td>4</td><td>コメント・タグの隠蔽<br />suppress comment tags</td></tr>
<tr><td>8</td><td>文字列タグをシンボルに変換<br />translate string tags into symbols</td></tr>

<tr><td>16</td><td>SXML（Ｓ式 XML）属性タグの追加 (@ ...)<br />add SXML (S-expression XML) attribute tags (@ ...)</td></tr>
</table><br/>

<p>オプションは、数値の足し算で組み合わせられます
(例えば、<tt>3</tt> は、空白テキストのタグ／情報と空属性リストの隠蔽のオプションの組み合わせです)。<br />
Options can be combined by adding the numbers
(e.g., <tt>3</tt> would combine the options 
for suppressing whitespace text tags/info 
and empty attribute lists).
</p>
 
<p>続く例は、異なるオプションの使われ方を示しています：<br />
The following examples show how the different options can be used:
</p>
<br/>
<b>XML source:</b>


<pre>
&lt;?xml version="1.0" ?&gt;
&lt;DATABASE name="example.xml"&gt;
&lt;!--This is a database of fruits--&gt;
    &lt;FRUIT&gt;
        &lt;NAME&gt;apple&lt;/NAME&gt;
        &lt;COLOR&gt;red&lt;/COLOR&gt;
        &lt;PRICE&gt;0.80&lt;/PRICE&gt;
    &lt;/FRUIT&gt;

    &lt;FRUIT&gt;
        &lt;NAME&gt;orange&lt;/NAME&gt;
        &lt;COLOR&gt;orange&lt;/COLOR&gt;
        &lt;PRICE&gt;1.00&lt;/PRICE&gt;
    &lt;/FRUIT&gt;

    &lt;FRUIT&gt;
       &lt;NAME&gt;banana&lt;/NAME&gt;
       &lt;COLOR&gt;yellow&lt;/COLOR&gt;
       &lt;PRICE&gt;0.60&lt;/PRICE&gt;
    &lt;/FRUIT&gt;
&lt;/DATABASE&gt;
</pre>


<h3>Parsing without any options:（オプション無しの解析）</h3>


<pre>
(xml-parse (read-file "example.xml"))
<span class='arw'>&rarr;</span> (("ELEMENT" "DATABASE" (("name" "example.xml")) (("TEXT" "\r\n\t") 
    ("COMMENT" "This is a database of fruits") 
    ("TEXT" "\r\n\t") 
    ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" () 
       (("TEXT" "apple"))) 
      ("TEXT" "\r\n\t\t") 
      ("ELEMENT" "COLOR" () (("TEXT" "red"))) 
      ("TEXT" "\r\n\t\t") 
      ("ELEMENT" "PRICE" () (("TEXT" "0.80"))) 
      ("TEXT" "\r\n\t"))) 
    ("TEXT" "\r\n\r\n\t") 
    ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" () 
       (("TEXT" "orange"))) 
      ("TEXT" "\r\n\t\t") 
      ("ELEMENT" "COLOR" () (("TEXT" "orange"))) 
      ("TEXT" "\r\n\t\t") 
      ("ELEMENT" "PRICE" () (("TEXT" "1.00"))) 
      ("TEXT" "\r\n\t"))) 
    ("TEXT" "\r\n\r\n\t") 
    ("ELEMENT" "FRUIT" () (("TEXT" "\r\n\t\t") ("ELEMENT" "NAME" () 
       (("TEXT" "banana"))) 
      ("TEXT" "\r\n\t\t") 
      ("ELEMENT" "COLOR" () (("TEXT" "yellow"))) 
      ("TEXT" "\r\n\t\t") 
      ("ELEMENT" "PRICE" () (("TEXT" "0.60"))) 
      ("TEXT" "\r\n\t"))) 
    ("TEXT" "\r\n"))))
</pre>


<p>空白のみからなる <tt>TEXT</tt> 要素 は、出力を分かりにくくします。
<tt>example.xml</tt> のデータベースがデータのみを含んでいるなら、空白文字とコメントをオプション <tt>(+ 1 2 4)</tt> を使って隠蔽できます：<br />
The <tt>TEXT</tt> elements containing only whitespace make the output very confusing.
As the database in <tt>example.xml</tt> only contains data,
we can suppress whitespace, empty attribute lists and comments with 
option <tt>(+ 1 2 4)</tt>:</p>

<h3>Filtering whitespace TEXT, COMMENT tags, and empty attribute lists:（空白 TEXT や COMMENT タグや空の属性リストを振るい落とす）</h3>


<pre>
(xml-parse (read-file "example.xml") (+ 1 2 4))
<span class='arw'>&rarr;</span> (("ELEMENT" "DATABASE" (("name" "example.xml")) ( 
     ("ELEMENT" "FRUIT" (
       ("ELEMENT" "NAME" (("TEXT" "apple"))) 
       ("ELEMENT" "COLOR" (("TEXT" "red"))) 
       ("ELEMENT" "PRICE" (("TEXT" "0.80"))))) 
     ("ELEMENT" "FRUIT" (
       ("ELEMENT" "NAME" (("TEXT" "orange"))) 
       ("ELEMENT" "COLOR" (("TEXT" "orange"))) 
       ("ELEMENT" "PRICE" (("TEXT" "1.00"))))) 
     ("ELEMENT" "FRUIT" (
       ("ELEMENT" "NAME" (("TEXT" "banana"))) 
       ("ELEMENT" "COLOR" (("TEXT" "yellow"))) 
       ("ELEMENT" "PRICE" (("TEXT" "0.60"))))))))
</pre>


<p>出力結果はより読みやすく見えますが、<a href="#xml-type-tags">xml-type-tags</a> 命令を使って XML タイプ・タグ "ELEMENT" と"TEXT" を隠蔽するのはもちろん、タグ "FRUIT", "NAME", "COLOR", "PRICE" の文字列の代わりにシンボルを使うことで、さらに改良されます。<br />
The resulting output looks much more readable, but it can still be improved 
by using symbols instead of strings for the tags "FRUIT", "NAME", "COLOR", and "PRICE",
as well as by suppressing the XML type tags "ELEMENT" and "TEXT" completely 
using the <a href="#xml-type-tags">xml-type-tags</a> directive.
</p>

<h3>Suppressing XML type tags with <a href="#xml-type-tags">xml-type-tags</a> 
and translating string tags into symbol tags:（<a href="#xml-type-tags">xml-type-tags</a> で XML 型タグを抑制し、文字列タグをシンボル・タグに変換する）</h3>


<pre>
;; suppress all XML type tags for TEXT and ELEMENT
;; instead of "CDATA", use cdata and instead of "COMMENT", use !--

(xml-type-tags nil 'cdata '!-- nil) 

;; turn on all options for suppressing whitespace and empty
;; attributes, translate tags to symbols

(xml-parse (read-file "example.xml") (+ 1 2 8))
<span class='arw'>&rarr;</span> ((DATABASE (("name" "example.xml")) 
     (!-- "This is a database of fruits") 
     (FRUIT (NAME "apple") (COLOR "red") (PRICE "0.80")) 
     (FRUIT (NAME "orange") (COLOR "orange") (PRICE "1.00")) 
     (FRUIT (NAME "banana") (COLOR "yellow") (PRICE "0.60"))))
</pre>


<p>オプション <tt>8</tt> を使って、タグがシンボルに変換される時、
<em>sym-context</em> でコンテキストを指定できます。
コンテキストが指定されないと、全てのシンボルは、現コンテキスト内で作成されます。<br />
When tags are translated into symbols by using option <tt>8</tt>, 
a context can be specified in <em>sym-context</em>. 
If no context is specified, all symbols will be created inside the current context.
</p>


<pre>
(xml-type-tags nil nil nil nil)
(xml-parse "&lt;msg&gt;Hello World&lt;/msg&gt;" (+ 1 2 4 8 16) 'CTX)
<span class='arw'>&rarr;</span> ((CTX:msg "Hello World"))
</pre>


<p>XML タイプ・タグ TEXT と ELEMENT に <tt>nil</tt> に指定すると、それらを消すことになります。
同時に、子ノードのリストの括弧が削除され、文字列タグ "FRUIT"、"NAME" などから変換されたタグ・シンボルで始まるリストの要素として、子ノードが現れます。<br />
Specifying <tt>nil</tt> for the XML type tags TEXT and ELEMENT 
makes them disappear.  At the same time, 
parentheses of the child node list are removed so that 
child nodes now appear as members of the list, 
starting with the tag symbol translated from the string tags 
"FRUIT", "NAME", etcetera.
</p>

<h3>Parsing into SXML (S-expressions XML) format:（SXML (S 式 XML) 形式に解析する）</h3>
<p>
<a href="#xml-type-tags">xml-type-tags</a> を使い、オプション番号<tt>1</tt>, <tt>2</tt>, <tt>4</tt>, <tt>8</tt> と <tt>16</tt> に従って全てのXML タイプ・タグを隠蔽すれば、SXML形式出力が生成されます：<br />
Using <a href="#xml-type-tags">xml-type-tags</a> to suppress 
all XML-type tags&mdash;along with the option numbers 
<tt>1</tt>, <tt>2</tt>, <tt>4</tt>, <tt>8</tt>, and <tt>16</tt>&mdash;SXML 
formatted output can be generated:
</p>


<pre>
(xml-type-tags nil nil nil nil)
(xml-parse (read-file "example.xml") (+ 1 2 4 8 16))
<span class='arw'>&rarr;</span> ((DATABASE (@ (name "example.xml")) 
    (FRUIT (NAME "apple") (COLOR "red") (PRICE "0.80")) 
    (FRUIT (NAME "orange") (COLOR "orange") (PRICE "1.00")) 
    (FRUIT (NAME "banana") (COLOR "yellow") (PRICE "0.60"))))
</pre>

<p>元々の XML タグは <tt>:</tt> で区分けされた名前空間部分を持ち、コロンは newLISP シンボルとして生じる <tt>.</tt> ドットに変換されます。<br />
If the original XML tags contain a namespace part separated by a <tt>:</tt>,
that colon will be translated into a <tt>.</tt> dot in the resulting newLISP
symbol.</p>


<p>オプション番号 <tt>16</tt> を使うと、属性リストに <tt>@</tt>（アットマーク）が付加されることに注意してください。<br />
Note that using option number <tt>16</tt> 
causes an <tt>@</tt> (at symbol) to be added to attribute lists.
</p>

<p>XML 解析の詳細情報には、関数 <a href="#xml-type-tags">xml-type-tags</a> も見てください。<br />
See also the <a href="#xml-type-tags">xml-type-tags</a> function 
for further information on XML parsing.
</p>

<h3>Parsing into a specified context</h3>

<p>XML 式を解析する時、オプション 8 が指定されていれば、XML タグは newLISP シンボルに変換されます。
その際、<i>sym-context</i> オプションがシンボル生成用のコンテキストを指定します：<br />
When parsing XML expressions, XML tags are translated into newLISP symbols,
when option 8 is specified.  The <i>sym-context</i> option specifies the target 
context for the symbol creation:</p>

<pre>
(xml-type-tags nil nil nil nil)
(xml-parse (read-file "example.xml") (+ 1 2 4 8 16) 'CTX)
<span class='arw'>&rarr;</span>((CTX:DATABASE (@ (CTX:name "example.xml")) 
    (CTX:FRUIT (CTX:NAME "apple") (CTX:COLOR "red") (CTX:PRICE "0.80")) 
    (CTX:FRUIT (CTX:NAME "orange") (CTX:COLOR "orange") (CTX:PRICE "1.00")) 
    (CTX:FRUIT (CTX:NAME "banana") (CTX:COLOR "yellow") (CTX:PRICE "0.60"))))
</pre>

<p>コンテキストが存在しない時は、生成されます。
存在する場合、クォートは省略でき、コンテキストは変数で参照できます。<br />
If the context does not exist, it will be created. If it exists, the quote can 
be omitted or the context can be referred to by a variable.</p>

<h3>Using a call back function（コールバック関数を使う）</h3>
<p>通常、<tt>xml-parse</tt> は、解析が終了するまで戻りません。
<em>func-callback</em> オプションを使えば、生成されたＳ式で閉じた各タグとソース XML 上での先頭からの位置と長さを引数にして、<tt>xml-parse</tt> はコールバックします：<br />
Normally, <tt>xml-parse</tt> will not return until all parsing has finished.
Using the <em>func-callback</em> option, <tt>xml-parse</tt> will call back after
each tag closing with the generated S-expression and a start position and
length in the source XML:</p>


<pre>
;; demo callback feature
(define (xml-callback s-expr start size)
    (if (or (= (s-expr 0) 'NAME) (= (s-expr 0) 'COLOR) (= (s-expr 0) 'PRICE))
        (begin
            (print "parsed expression:" s-expr)
            (println ", source:" (start size example-xml))
        )
    )
)

(xml-type-tags nil 'cdata '!-- nil)
(xml-parse  (read-file "example.xml") (+ 1 2 8) MAIN xml-callback)
</pre>


<p>コールバック関数 <tt>xml-callback</tt> によって、次の出力が生成されます：<br />
The following output will be generated by the callback function <tt>xml-callback</tt>:</p>

<pre>
parsed expression:(NAME "apple"), source:&lt;NAME&gt;apple&lt;/NAME&gt;
parsed expression:(COLOR "red"), source:&lt;COLOR&gt;red&lt;/COLOR&gt;
parsed expression:(PRICE "0.80"), source:&lt;PRICE&gt;0.80&lt;/PRICE&gt;
parsed expression:(NAME "orange"), source:&lt;NAME&gt;orange&lt;/NAME&gt;
parsed expression:(COLOR "orange"), source:&lt;COLOR&gt;orange&lt;/COLOR&gt;
parsed expression:(PRICE "1.00"), source:&lt;PRICE&gt;1.00&lt;/PRICE&gt;
parsed expression:(NAME "banana"), source:&lt;NAME&gt;banana&lt;/NAME&gt;
parsed expression:(COLOR "yellow"), source:&lt;COLOR&gt;yellow&lt;/COLOR&gt;
parsed expression:(PRICE "0.60"), source:&lt;PRICE&gt;0.60&lt;/PRICE&gt;
</pre>


<p>この例のコールバック関数は、注目すべきタグをフィルタし、それらが出現した時に処理します。
<br/>
The example callback handler function filters the tags of interest and processes
them as they occur.</p>

<br/><br/>

<a name="xml-type-tags"></a>
<h2><span class="function">xml-type-tags</span></h2>

<h4>syntax: (xml-type-tags [<em>exp-text-tag</em> <em>exp-cdata-tag</em> <em>exp-comment-tag</em> <em>exp-element-tags</em>])</h4>

<p>XML のタイプ・タグ "TEXT"、"CDATA"、"COMMENT"、"ELEMENT" を完全に隠蔽するか、パラメータで指定した何かに置き換えることが可能です。<br />
Can suppress completely or replace the XML type tags 
"TEXT", "CDATA", "COMMENT", and "ELEMENT" with something else specified 
in the parameters.
</p>

<p>
<tt>xml-type-tags</tt> は、タグ自身を隠蔽もしくは変換しますが、タグされた情報を隠蔽したり、変更したりはしません。
後者は、<a href="#xml-parse">xml-parse</a> にオプション番号を使ってなされます。<br />
Note that <tt>xml-type-tags</tt> only suppresses or translates the tags themselves 
but does not suppress or modify the tagged information.  The latter would be done 
using option numbers in <a href="#xml-parse">xml-parse</a>.
</p>

<p>引数無しの <tt>xml-type-tags</tt> は、現在のタイプ・タグを返します：<br />
Using <tt>xml-type-tags</tt> without arguments 
returns the current type tags:
</p>

<!-- example -->

<pre>
(xml-type-tags)  <span class='arw'>&rarr;</span> ("TEXT" "CDATA" "COMMENT" "ELEMENT")

(xml-type-tags nil 'cdata '!-- nil)
</pre>


<p>一番目の例は、現在使用しているタイプ・タグを返します。
二番目の例は、"TEXT" と "ELEMENT" を隠し、"CDATA" と "COMMENT" の代わりに <tt>cdata</tt> と <tt>!--</tt> を示します。 <br />
The first example just shows the currently used type tags.
The second example specifies suppression of the "TEXT" and "ELEMENT" tags 
and shows <tt>cdata</tt> and <tt>!--</tt> instead of 
"CDATA" and "COMMENT".
</p>

<br/><br/>

<a name="zerop"></a>
<h2><span class="function">zero?</span>&nbsp;
<a href="#big_int"><font size="-1">bigint</font></a></h2>
<h4>syntax: (zero? <em>exp</em>)</h4>

<p><em>exp</em> の評価が <tt>0</tt>（ゼロ）かどうかをチェックします。<br />
Checks the evaluation of <em>exp</em> to see if it equals <tt>0</tt> (zero).
</p>

<!-- example -->

<pre>
(set 'value 1.2)
(set 'var 0)
(zero? value)  <span class='arw'>&rarr;</span> nil
(zero? var)    <span class='arw'>&rarr;</span> true

(map zero? '(0 0.0 3.4 4))  <span class='arw'>&rarr;</span> (true true nil nil)

(map zero? '(nil true 0 0.0 "" ()))  <span class='arw'>&rarr;</span> (nil nil true true nil nil)
</pre>


<p>数値以外のデータ型において、<tt>zero?</tt> は <tt>nil</tt> を返します。<br />
	<tt>zero?</tt> will return <tt>nil</tt> 
	on data types other than numbers.
</p>

<br/><br/>

<center style="font-size: 150%">
<span class="divider">(&nbsp;<font color="#7ba9d4">&part;</font>&nbsp;)</span>
</center>

<br/><br/>

<hr/>

<br/><br/>

<a name="appendix"></a>
<center><h2>newLISP APPENDIX（付録）</h2></center>

<a name="error_codes"></a>
<h2>Error codes（エラー コード）</h2>


<table summary="Error codes">
<tr align="left"><th>description</th><th>no</th></tr>
<tr><td>not enough memory</td><td>1</td></tr>
<tr><td>environment stack overflow</td><td>2</td></tr>
<tr><td>call stack overflow</td><td>3</td></tr>
<tr><td>problem accessing file</td><td>4</td></tr>
<tr><td>not an expression</td><td>5</td></tr>
<tr><td>missing parenthesis</td><td>6</td></tr>
<tr><td>string token too long</td><td>7</td></tr>
<tr><td>missing argument</td><td>8</td></tr>
<tr><td>number or string expected</td><td>9</td></tr>
<tr><td>value expected</td><td>10</td></tr>
<tr><td>string expected</td><td>11</td></tr>
<tr><td>symbol expected</td><td>12</td></tr>
<tr><td>context expected</td><td>13</td></tr>
<tr><td>symbol or context expected</td><td>14</td></tr>
<tr><td>list expected</td><td>15</td></tr>
<tr><td>list or array expected</td><td>16</td></tr>
<tr><td>list or symbol expected</td><td>17</td></tr>
<tr><td>list or string expected</td><td>18</td></tr>
<tr><td>list or number expected</td><td>19</td></tr>
<tr><td>array expected</td><td>20</td></tr>
<tr><td>array, list or string expected</td><td>21</td></tr>
<tr><td>lambda expected</td><td>22</td></tr>
<tr><td>lambda-macro expected</td><td>23</td></tr>
<tr><td>invalid function</td><td>24</td></tr>
<tr><td>invalid lambda expression</td><td>25</td></tr>
<tr><td>invalid macro expression</td><td>26</td></tr>
<tr><td>invalid let parameter list</td><td>27</td></tr>
<tr><td>problem saving file</td><td>28</td></tr>
<tr><td>division by zero</td><td>29</td></tr>
<tr><td>matrix expected</td><td>30</td></tr>
<tr><td>wrong dimensions</td><td>31</td></tr>
<tr><td>matrix is singular</td><td>32</td></tr>
<tr><td>syntax in regular expression</td><td>33</td></tr>
<tr><td>throw without catch</td><td>34</td></tr>
<tr><td>problem loading library</td><td>35</td></tr>
<tr><td>import function not found</td><td>36</td></tr>
<tr><td>symbol is protected</td><td>37</td></tr>
<tr><td>error number too high</td><td>38</td></tr>
<tr><td>regular expression</td><td>39</td></tr>
<tr><td>missing end of text [/text]</td><td>40</td></tr>
<tr><td>mismatch in number of arguments</td><td>41</td></tr>
<tr><td>problem in format string</td><td>42</td></tr>
<tr><td>data type and format don't match</td><td>43</td></tr>
<tr><td>invalid parameter</td><td>44</td></tr>
<tr><td>invalid parameter: 0.0</td><td>45</td></tr>
<tr><td>invalid parameter: NaN</td><td>46</td></tr>
<tr><td>invalid UTF8 string</td><td>47</td></tr>
<tr><td>illegal parameter type</td><td>48</td></tr>
<tr><td>symbol not in MAIN context</td><td>49</td></tr>
<tr><td>symbol not in current context</td><td>50</td></tr>
<tr><td>target cannot be MAIN</td><td>51</td></tr>
<tr><td>list index out of bounds</td><td>52</td></tr>
<tr><td>array index out of bounds</td><td>53</td></tr>
<tr><td>string index out of bounds</td><td>54</td></tr>
<tr><td>nesting level too deep</td><td>55</td></tr>
<tr><td>list reference changed</td><td>56</td></tr>
<tr><td>invalid syntax</td><td>57</td></tr>
<tr><td>user error</td><td>58</td></tr>
<tr><td>user reset -</td><td>59</td></tr>
<tr><td>received SIGINT -</td><td>60</td></tr>
<tr><td>function is not reentrant</td><td>61</td></tr>
<tr><td>local symbol is protected</td><td>62</td></tr>
<tr><td>no reference found</td><td>63</td></tr>
<tr><td>list is empty</td><td>64</td></tr>
<tr><td>I/O error</td><td>65</td></tr>
<tr><td>working directory not found</td><td>66</td></tr>
<tr><td>invalid PID</td><td>67</td></tr>
<tr><td>cannot open socket pair</td><td>68</td></tr>
<tr><td>cannot fork process</td><td>69</td></tr>
<tr><td>no comm channel found</td><td>70</td></tr>

<tr><td>ffi preparation failed</td><td>71</td></tr>
<tr><td>invalid ffi type</td><td>72</td></tr>
<tr><td>ffi struct expected</td><td>73</td></tr>

<tr><td>bigint type not applicable</td><td>74</td></tr>
<tr><td>not a number or infinite</td><td>75</td></tr>
<tr><td>cannot convert NULL to string</td><td>76</td></tr>
</table><br/>

<br/><br/><br/>

<a name="tcpip_error_codes"></a>
<h2>TCP/IP and UDP Error Codes</h2>

<table summary="tcp/ip error codes">
<tr align="left"><th>no</th><th>description</th></tr>
<tr><td>1</td><td>Cannot open socket</td></tr>
<tr><td>2</td><td>DNS resolution failed</td></tr>
<tr><td>3</td><td>Not a valid service</td></tr>
<tr><td>4</td><td>Connection failed</td></tr>
<tr><td>5</td><td>Accept failed</td></tr>
<tr><td>6</td><td>Connection closed</td></tr>
<tr><td>7</td><td>Connection broken</td></tr>
<tr><td>8</td><td>Socket send() failed</td></tr>
<tr><td>9</td><td>Socket recv() failed</td></tr>
<tr><td>10</td><td>Cannot bind socket</td></tr>
<tr><td>11</td><td>Too many sockets in net-select</td></tr>
<tr><td>12</td><td>Listen failed</td></tr>
<tr><td>13</td><td>Badly formed IP</td></tr>
<tr><td>14</td><td>Select failed</td></tr>
<tr><td>15</td><td>Peek failed</td></tr>
<tr><td>16</td><td>Not a valid socket</td></tr>
<tr><td>17</td><td>Cannot unblock socket</td></tr>
<tr><td>18</td><td>Operation timed out</td></tr>
<tr><td>19</td><td>HTTP bad formed URL</td></tr>
<tr><td>20</td><td>HTTP file operation failed</td></tr>
<tr><td>21</td><td>HTTP transfer failed</td></tr>
<tr><td>22</td><td>HTTP invalid response from server</td></tr>
<tr><td>23</td><td>HTTP no response from server</td></tr>
<tr><td>24</td><td>HTTP document empty</td></tr>
<tr><td>25</td><td>HTTP error in header</td></tr>
<tr><td>26</td><td>HTTP error in chunked format</td></tr>
</table><br/>

<br/><br/><br/>

<a name="system_symbols"></a>
<h2>System Symbols and Constants（システム シンボルと定数）</h2>

<h3>Variables changed by the system（システムが変更する変数）</h3>

<p>newLISP は内部シンボル変数をいくつか持っています。
それらは全てグローバルで、プログラマーの使用が可能です。
ライト・プロテクションのかかっているものも有りますが、それ以外はユーザで設定可能です。
それを使って閉じている式の部分式に使われている時、変化するものも有ります。
その以外は、入れ子になった関数や式で再帰に使っても安全です。<br />
newLISP maintains several internal symbol variables. All of them are global
and can be used by the programmer. Some have write protection, others
are user settable. Some will change when used in a sub-expression of the
enclosing expression using it. Others are safe when using reentrant in nested 
functions or expressions.</p>

<p>関数 <a href="#save">save</a> または <a href="#source">source</a> を使う時、<tt>$</tt> 文字で始まる全てのシンボルは<ruby><rb><a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">直列化</a></rb><rp>（</rp><rt>シリアライズ</rt><rp>）</rp></ruby>されません。<br />
All symbols starting with the <tt>$</tt> character will not be serialized
when using the <a href="#save">save</a> or <a href="#source">source</a> functions.
</p>

<table width="98%" summary="system vars">
<tr><th>&nbsp;variable&nbsp;name</th><th>purpose</th><th>&nbsp;protected&nbsp;</th><th>&nbsp;reentrant&nbsp;</th></tr>
<tr><td><tt>&nbsp;$0 - $15</tt></td><td>主に正規表現で使用されます。<tt>$0</tt> は最後の状態の記録に使われます。また、実行回数の記録に使用する関数も有ります。<br />Used primarily in regular expressions. <tt>$0</tt> is also used to record the last state or count of execution of some functions.</td>
<td>&nbsp;no</td><td>&nbsp;no</td></tr>

<tr><td><tt>&nbsp;$args</tt></td><td>ローカルに束縛されていないパラメータのリストが入っています。この変数の内容の取り出しには、普通、関数 <a href="#args">args</a> を使います。<br />Contains the list parameters not bound to localvariables. Normally the function <a href="#args">args</a> is used to retrieve the contents of this variable.</td>
<td>&nbsp;yes</td><td>&nbsp;yes</td></tr>

<tr><td><tt>&nbsp;$count</tt></td><td><a href="#find-all">find-all</a>、<a href="#replace">replace</a>、<a href="#ref-all">ref-all</a>、<a href="#set-ref-all">set-ref-all</a> で一致した要素数。もしくは <a href="#read-expr">read-expr</a> で処理された文字数。<br />The count of elements matching when using <a href="#find-all">find-all</a>, <a href="#replace">replace</a>,<a href="#ref-all">ref-all</a> and <a href="#set-ref-all">set-ref-all</a> or the count of characters processed by <a href="#read-expr">read-expr</a>.</td>
<td>&nbsp;yes</td><td>&nbsp;no</td></tr>

<tr><td><tt>&nbsp;$idx</tt></td><td>関数 <a href="#dolist">dolist</a> は、リストのインデックスやオプセットとしてこれを使います。関数 <a href="#map">map</a>、<a href="#series">series</a>、<a href="#while">while</a>、<a href="#until">until</a>、<a href="#do-while">do-while</a>、<a href="#do-until">do-until</a> は、最初が 0（ゼロ）から始まる繰り返し回数として、この変数を使います。<br />The function <a href="#dolist">dolist</a>maintains this as a list index or offset. The functions <a href="#map">map</a>, <a href="#series">series</a>, <a href="#while">while</a>, <a href="#until">until</a>, <a href="#do-while">do-while</a> and <a href="#do-until">do-until</a> maintain this variable as an iteration counter starting with 0 (zero) for the first iteration.</td>
<td>&nbsp;yes</td><td>&nbsp;yes</td></tr>

<tr><td><tt>&nbsp;$it</tt></td><td><em>アナフォリック</em> <tt>$it</tt> は、実行中の式内部の結果を参照します。すなわち、自己参照です。<tt>$it</tt> は、それを設定する関数式内部でのみ利用可能で、その式外では <tt>nil</tt> に設定されています。次の関数で利用可能です：<a href="#if">if</a>、<a href="#hash">hashes</a>、<a href="#find-all">find-all</a>、<a href="#replace">replace</a>、<a href="#set-ref">set-ref</a>、<a href="#set-ref-all">set-ref-all</a>、<a href="#setf">setf、setq</a><br />The <em>anaphoric</em> <tt>$it</tt> refers to the result inside an executing expression, i.e. in self referential assignments. <tt>$it</tt> is only available inside the function expression setting it, and is set to <tt>nil</tt> on exit of that expression. The following functions use it:<a href="#if">if</a>,<a href="#hash">hashes</a>, <a href="#find-all">find-all</a>,<a href="#replace">replace</a>, <a href="#set-ref">set-ref</a>, <a href="#set-ref-all">set-ref-all</a> and <a href="#setf">setf setq</a>.</td>
<td>&nbsp;yes</td><td>&nbsp;no</td></tr>

<tr><td><tt>&nbsp;$main-args</tt></td><td>OS によって newLISP に渡されるコマンド・ラインの引数がリストで入っています。内容の取り出しには、通常、関数 <a href="#main-args">main-args</a> を使います。<br />Contains the list of command line arguments passed by the OS to newLISP when it was started. Normally the function <a href="#main-args">main-args</a> is used to retrieve the contents.</td>
<td>&nbsp;yes</td><td>&nbsp;n/a</td></tr>

</table><br/>

<h3>Predefined variables and functions.（予め定義されている変数と関数）</h3>

<p>これらは、予め設定されているシンボル定数です。
そのうち二つは名前空間テンプレートとして使われ、もう一つはプラットフォーム非依存コードを書くために使われます。<br />
These are preset symbol constants. Two of them are used as namespace templates,
one to write platform independent code.</p> 

<table  width="98%" summary="preset vars">
<tr><th>name</th><th>purpose</th><th>&nbsp;protected&nbsp;</th><th>&nbsp;reentrant&nbsp;</th></tr>

<tr><td><tt>&nbsp;Class</tt></td><td>予め定義された一般 FOOP クラス・コンストラクタで、新 FOOP クラスを生成するために <tt>new</tt> と一緒に使われます。例えば、<tt>(new Class 'Rectangle)</tt> はユーザ・クラス <tt>Rectangle</tt> のクラスとオブジェクト・コンストラクタを生成します。詳細は、ユーザ・マニュアルの <a href="#newlisp_classes">FOOP classes and constructors</a> の章で見てください。<br />Is the predefined general FOOP class constructor which can be used together with <tt>new</tt> to create new FOOP classes, e.g:<tt>(new Class 'Rectangle)</tt> would create a class and object constructor for a user class <tt>Rectangle</tt>. See the <a href="#newlisp_classes">FOOP classes and constructors</a> chapter in the users manual for details.</td>
<td>&nbsp;no</td><td>&nbsp;n/a</td></tr>

<tr><td><tt>&nbsp;ostype</tt></td><td>走っている newLISP の版がコンパイルされた OS-プラットフォームを示す文字列が入っています。<a href="#ostype">詳細</a>はリファレンス・セクションで見てください。<br />Contains a string identifying the OS-Platform for which the running newLISP version has been compiled. See the reference section for <a href="#ostype">details</a></td>
<td>&nbsp;yes</td><td>&nbsp;n/a</td></tr>

<tr><td><tt>&nbsp;Tree</tt></td><td>予め定義されている名前空間で、ハッシュ・ライク辞書を提供するものです。<tt>Foo</tt> 辞書を生成するために <tt>(define Foo:Foo)</tt> と書く代わりに、式 <tt>(new Tree 'Foo)</tt> を同じように使えます。詳細は、<a href="#hash">Hash functions and dictionaries</a> の章で見てください。<br />Is a predefined namespace to serve as a hash like dictionary. Instead of writing <tt>(define Foo:Foo)</tt> to create a <tt>Foo</tt> dictionary, the expression <tt>(new Tree 'Foo)</tt> can be used as well. See the chapter <a href="#hash">Hash functions and dictionaries</a> for details.</td>
<td>&nbsp;no</td><td>&nbsp;n/a</td></tr>

<tr><td><tt>&nbsp;module</tt></td><td>予め定義されているロード・モジュール用関数です。<tt>NEWLISPDIR</tt> 環境変数と一緒に <tt>load</tt> を使う代わりに、関数 <tt>module</tt> は自動的に <tt>$NEWLISPDIR/modules/</tt> からロードします。<br />Is a predefined function to load modules. Instead of using <tt>load</tt> together with the <tt>NEWLISPDIR</tt> environment variable, the <tt>module</tt> function loads automatically from <tt>$NEWLISPDIR/modules/</tt>.</td>
<td>&nbsp;no</td><td>&nbsp;n/a</td></tr>

</table><br/>

<p>シンボル <tt>Class</tt>、<tt>Tree</tt>、<tt>module</tt> は、予め次のように定義されています：<br />
The symbols <tt>Class</tt>, <tt>Tree</tt> and <tt>module</tt> are predefined as follows:</p>

<pre>
; built-in template for FOOP constructors
; usage: (new Class 'MyClass)
(define (Class:Class) 
    (cons (context) (args)))

; built-in template for hashes
; usage: (new Tree 'MyHash)
(context 'Tree) 
  (constant 'Tree:Tree) 
(context MAIN)"

; load modules from standard path
; usage (module "mymodule.lsp")
(define (module $x)
  (load (append (env "NEWLISPDIR") "/modules/" $x)))

(global 'module)
</pre>

<p>これらのシンボルは保護されていませんし、ユーザが再定義できます。
変数 <tt>$x</tt> は組み込みで、削除からも保護されています。
この変数 <tt>$x</tt> は <a href="#curry">curry</a> 式でも使えます。<br />
These symbols are not protected and can be redefined by the user.
The <tt>$x</tt> variable is built-in and protected against deletion.
This <tt>$x</tt> variable is also used in <a href="#curry">curry</a> expressions.</p>

<br/><br/>

<center style="font-size: 150%">
<span class="divider">(&nbsp;<font color="#7ba9d4">&part;</font>&nbsp;)</span>
</center>
<br/><br/>

<hr/>


<div class="license">
<a name="GNUFDL"></a>
<center>
<h2><span class="gnu">GNU Free Documentation License</span></h2>
<p>Version 1.2, November 2002</p>

<p>
Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
</p>
</center>

<br/><br/>

<h4>0. PREAMBLE</h4>

<p>The purpose of this License is to make a manual, textbook, or other
functional and useful document "free" in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</p>
<p>This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense. It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</p>
<p>We have designed this License in order to use it for manuals for
free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does. But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book. We recommend this License
principally for works whose purpose is instruction or reference.
</p>
<h4>1. APPLICABILITY AND DEFINITIONS</h4>
<p>This License applies to any manual or other work, in any medium,
that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License. Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein. The "Document", below,
refers to any such manual or work. Any member of the public is a
licensee, and is addressed as "you". You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</p>
<p>A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</p>
<p>A "Secondary Section" is a named appendix or a front-matter section
of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject. (Thus, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.) The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</p>
<p>The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License. If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant. The Document may contain zero
Invariant Sections. If the Document does not identify any Invariant
Sections then there are none.
</p>
<p>The "Cover Texts" are certain short passages of text that are
listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License. A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</p>
<p>A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters. A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text. A copy that is not "Transparent" is called "Opaque".
</p>
<p>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML, PostScript or PDF designed for human modification. Examples of
transparent image formats include PNG, XCF and JPG. Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.
</p>
<p>The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page. For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.
</p>
<p>A section "Entitled XYZ" means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language. (Here XYZ stands for a
specific section name mentioned below, such as "Acknowledgements",
"Dedications", "Endorsements", or "History".) To "Preserve the Title"
of such a section when you modify the Document means that it remains a
section "Entitled XYZ" according to this definition.
</p>
<p>The Document may include Warranty Disclaimers next to the notice
which
states that this License applies to the Document. These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</p>
<h4>2. VERBATIM COPYING</h4>
<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License. You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute. However, you may accept
compensation in exchange for copies. If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</p>
<p>You may also lend copies, under the same conditions stated above,
and
you may publicly display copies.
</p>
<h4>3. COPYING IN QUANTITY</h4>
<p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover. Both covers must also clearly and legibly identify
you as the publisher of these copies. The front cover must present
the full title with all words of the title equally prominent and
visible. You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</p>
<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</p>
<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</p>
<p>It is requested, but not required, that you contact the authors of
the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</p>
<h4>4. MODIFICATIONS</h4>
<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it. In addition, you must do these things in the Modified Version:
</p>
<blockquote>
  <p><b>A.</b> Use in the Title Page (and on the covers, if
any) a title distinct from that of the Document, and from those of
previous versions (which should, if there were any, be listed in the
History section of the Document). You may use the same title as a
previous version if the original publisher of that version gives
permission.</p>
  <p><b>B.</b> List on the Title Page, as authors, one or
more persons or entities responsible for authorship of the
modifications in the Modified Version, together with at least five of
the principal authors of the Document (all of its principal authors, if
it has fewer than five), unless they release you from this requirement.</p>
  <p><b>C.</b> State on the Title page the name of the
publisher of the Modified Version, as the publisher.</p>
  <p><b>D.</b> Preserve all the copyright notices of the
Document.</p>
  <p><b>E.</b> Add an appropriate copyright notice for your
modifications adjacent to the other copyright notices.</p>
  <p><b>F.</b> Include, immediately after the copyright
notices, a license notice giving the public permission to use the
Modified Version under the terms of this License, in the form shown in
the Addendum below.</p>
  <p><b>G.</b> Preserve in that license notice the full
lists of Invariant Sections and required Cover Texts given in the
Document's license notice.</p>
  <p><b>H.</b> Include an unaltered copy of this License.</p>
  <p><b>I.</b> Preserve the section Entitled "History",
Preserve its Title, and add to it an item stating at least the title,
year, new authors, and publisher of the Modified Version as given on
the Title Page. If there is no section Entitled "History" in the
Document, create one stating the title, year, authors, and publisher of
the Document as given on its Title Page, then add an item describing
the Modified Version as stated in the previous sentence.</p>
  <p><b>J.</b> Preserve the network location, if any, given
in the Document for public access to a Transparent copy of the
Document, and likewise the network locations given in the Document for
previous versions it was based on. These may be placed in the "History"
section. You may omit a network location for a work that was published
at least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.</p>
  <p><b>K.</b> For any section Entitled "Acknowledgements"
or "Dedications", Preserve the Title of the section, and preserve in
the section all the substance and tone of each of the contributor
acknowledgements and/or dedications given therein.</p>
  <p><b>L.</b> Preserve all the Invariant Sections of the
Document, unaltered in their text and in their titles. Section numbers
or the equivalent are not considered part of the section titles.</p>
  <p><b>M.</b> Delete any section Entitled "Endorsements".
Such a section may not be included in the Modified Version.</p>
  <p><b>N.</b> Do not retitle any existing section to be
Entitled "Endorsements" or to conflict in title with any Invariant
Section.</p>
  <p><b>O.</b> Preserve any Warranty Disclaimers.</p>
</blockquote>
<p>
If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant. To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.
</p>
<p>You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and
a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version. Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity. If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</p>
<p>The author(s) and publisher(s) of the Document do not by this
License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</p>
<h4>5. COMBINING DOCUMENTS</h4>
<p>You may combine the Document with other documents released under
this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</p>
<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy. If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</p>
<p>In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications". You must delete all sections
Entitled "Endorsements."
</p>
<h4>6. COLLECTIONS OF DOCUMENTS</h4>
<p>You may make a collection consisting of the Document and other
documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</p>
<p>You may extract a single document from such a collection, and
distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</p>
<h4>7. AGGREGATION WITH INDEPENDENT WORKS</h4>
<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</p>
<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</p>
<h4>8. TRANSLATION</h4>
<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections. You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers. In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</p>
<p>If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</p>
<h4>9. TERMINATION</h4>
<p>You may not copy, modify, sublicense, or distribute the Document
except
as expressly provided for under this License. Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License. However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.
</p>
<h4>10. FUTURE REVISIONS OF THIS LICENSE</h4>
<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns. See
http://www.gnu.org/copyleft/.
</p>
<p>Each version of the License is given a distinguishing version
number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation. If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
</p>
<br/><br/>

<hr/>

<br/><br/>

<br/><br/>

<a name="GNUGPL"></a>
<center>
<h2><span class="gnu">GNU GENERAL PUBLIC LICENSE</span></h2>
		      <p>Version 3, 29 June 2007</p>
</center>

<p>
 Copyright (C) 2007 Free Software Foundation, Inc. http://fsf.org/
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
</p>

<center><h4>Preamble</h4></center>

<p>
  The GNU General Public License is a free, copyleft license for
software and other kinds of works.
</p>
<p>
  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.
</p>
<p>
  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.
</p>
<p>
  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.
</p>
<p>
  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.
</p>
<p>
  Developers that use the GNU GPL protect your rights with two steps:
</p>
<p>
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.
</p>
<p>
  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.
</p>
<p>
  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.
</p>
<p>
  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.
</p>
<p>
  The precise terms and conditions for copying, distribution and
modification follow.
</p>
<center><h4>TERMS AND CONDITIONS</h4></center>

<h4>0. Definitions.</h4>
<p>
  "This License" refers to version 3 of the GNU General Public License.
</p>
<p>
  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.
</p>
<p>
  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.
</p>
<p>
  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.
</p>
<p>
  A "covered work" means either the unmodified Program or a work based
on the Program.
</p>
<p>
  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.
</p>
<p>
  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.
</p>
<p>
  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.</p>

<h4>1. Source Code.</h4>

<p>
  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.
</p>
<p>
  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.
</p>
<p>
  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.
</p>
<p>
  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.
</p>
<p>
  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.
</p>
<p>
  The Corresponding Source for a work in source code form is that
same work.
</p>
<h4>2. Basic Permissions.</h4>
<p>
  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.
</p>
<p>
  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.
</p>
<p>
  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.
</p>
<h4>3. Protecting Users' Legal Rights From Anti-Circumvention Law.</h4>
<p>
  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.
</p>
<p>
  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.
</p>
<h4>4. Conveying Verbatim Copies.</h4>
<p>
 You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.
</p>
<p>
  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.
</p>
<h4>5. Conveying Modified Source Versions.</h4>
<p>
  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:
</p>
<blockquote>
    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.
</blockquote>
<blockquote>
    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".
</blockquote>
<blockquote>
    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.
</blockquote>
<blockquote>
    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.
</blockquote>
<p>
  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.
</p>
<h4>6. Conveying Non-Source Forms.</h4>
<p>
  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:
</p>
<blockquote>
    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.
</blockquote>
<blockquote>
    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.
</blockquote>
<blockquote>
    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.
</blockquote>
<blockquote>
    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.
</blockquote>
<blockquote>
    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.
</blockquote>
<p>
  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.
</p>
<p>
  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.
</p>
<p>
  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.
</p>
<p>
  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).
</p>
<p>
  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.
</p>
<p>
  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.
</p>
<h4>7. Additional Terms.</h4>
<p>
  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.
</p>
<p>
  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.
</p>
<p>
  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:
</p>
<blockquote>
    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or
</blockquote>
<blockquote>
    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or
</blockquote>
<blockquote>
    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or
</blockquote>
<blockquote>
    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or
</blockquote>
<blockquote>
    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or
</blockquote>
<blockquote>
    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.
</blockquote>
<p>
  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.
</p>
<p>
  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.
</p>
<p>
  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.
</p>
<h4>8. Termination.</h4>
<p>
  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).
</p>
<p>
  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.
</p>
<p>
  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
</p>
<p>
  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.
</p>
<h4>9. Acceptance Not Required for Having Copies.</h4>
<p>
  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.
</p>
<h4>10. Automatic Licensing of Downstream Recipients.</h4>
<p>
  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.
</p>
<p>
  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.
</p>
<p>
  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.
</p>
<h4>11. Patents.</h4>
<p>
  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".
</p>
<p>
  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.
</p>
<p>
  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.
</p>
<p>
  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.
</p>
<p>
  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.
</p>
<p>
  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.
</p>
<p>
  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.
</p>
<p>
  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.
</p>
<h4>12. No Surrender of Others' Freedom.</h4>
<p>
  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.
</p>
<h4>13. Use with the GNU Affero General Public License.</h4>
<p>
  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.
</p>
<h4>14. Revised Versions of this License.</h4>
<p>
  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
</p>
<p>
  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.
</p>
<p>
  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.
</p>
<p>
  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.
</p>
<h4>15. Disclaimer of Warranty.</h4>
<p>
  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
</p>
<h4>16. Limitation of Liability.</h4>
<p>
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.
</p>
<h4>17. Interpretation of Sections 15 and 16.</h4>
<p>
  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.
</p>
<br/>
<center><h4>END OF TERMS AND CONDITIONS</h4></center>
</div>
<br/><br/>
<center style="font-size: 150%">
<span class="divider">(&nbsp;<font color="#7ba9d4">&part;</font>&nbsp;)</span>
</center>
<br/><br/>

</body>
</html>

