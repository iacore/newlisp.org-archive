<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
   <meta name="author" content="Lutz Mueller"/>
   <meta name="keywords" 
         content="newLISP LISP SCHEME programming language manual reference Artificial Intelligence AI NUEVATEC"/>
   <meta name="description" content="newLISP Code Patterns"/>
   <title>newLISP Code Patterns</title>

<style type="text/css" media="screen">

<!--

.title {
    font-family:Optima, Georgia, Times New Roman, Times, serif; 
    font-size:300%;
    font-weight: 500;
	color: #404040;
    }

body, h4, p {
    font-family: Lucida Sans, Helvetica, sans-serif;
    line-height: 120%;
	color: #404040;
	}

h1, h2, h3 {
	margin-top: 3%;
    font-family: Lucida Sans, Helvetica, sans-serif;
    line-height: 120%;
    font-weight: 300;
	color: #202020;
    }

table {
	margin: 0px;
	margin-left: 10px;
	margin-right: 10px;
	border-style: solid;
	border-width: 0px;
	border-color: #888888;
	padding: 3px;
	background: #f8ffff;
	font-size: 95%;
    }
    
th {
	border-style: solid;
	border-width: 1px;
	border-color: #888888;
	padding: 3px;
	background: #eeeeee;
    font-size: 100%;
    }
    
td {
	border-style: solid;
	border-width: 1px;
	border-color: #888888;
	padding: 3px;
	background: #f8ffff;
    font-size: 100%;
    }
    
pre {
	margin: 0px;
	margin-left: 10px;
	margin-right: 10px;
	border-style: dashed;
	border-width: 1px;
	border-color: #888888;
	padding: 4px;
    font-family: Andale Mono, "Bitstream Vera Sans Mono", Monaco, "Courier New";
    font-size: 90%;
	background: #f8ffff;
    }

tt {
    font-family: Andale Mono, "Bitstream Vera Sans Mono", Monaco, "Courier New";
    font-size: 100%;
    }
    
-->
</style>
</head>
<body style="margin: 20px;" text="#000000" bgcolor="#FFFFFF" link="#376590" vlink="#551A8B" alink="#ffAA28">

<br><br>

<center>
<h1 class="title">newLISP のコード用例<br>Code Patterns in newLISP<font size="-1">&#174;</font>
</h1>Version 2018 July 12<sup>th</sup><br/>
<a href="http://newlisp.org">newLISP</a> v.10.7.4
</center>

<br><br><br>

<center>
<span style="line-height:80%;">
<font size="-2">
Copyright &copy; 2019 Lutz Mueller, <a href="http://www.nuevatec.com">www.nuevatec.com</a>. All rights reserved.<br/>
Japanese translations copyright &copy; 2019 <a href=http://johu02.spaces.live.com/?_c11_BlogPart_Blo gPart=blogview&_c=BlogPart&partqs=cat%3dLISP>short story &#12414;&#12383;&#12399; &#26228;&#32789;&#38632;&#35501;&#12394;&#26085;&#12293;</a>
<br/><br/>
Permission is granted to copy, distribute and/or modify this document under the terms of the <a href="#GFDL">GNU Free Documentation License</a>,<br>
Version 1.2 or any later version published by the Free Software Foundation; with no Invariant Sections, no Front-Cover Texts,<br>
and no Back-Cover Texts. A copy of the license is included in the section entitled GNU Free Documentation License.<br>
<br>
newLISP is a registered trademark of Lutz Mueller.
</font>
</span>
</center>


<ul>
<li><a href="#toc-1">1. Introduction（紹介）</a>
</li>
<li><a href="#toc-2">2. newLISP script files（newLISP スクリプト・ファイル）</a>
  <ul>
  <li>Command line options（コマンド・ライン・オプション）</li>
  <li>Scripts as pipes（パイプとしてのスクリプト）</li>
  <li>File filters（ファイル・フィルタ）</li>
  </ul></li>
<li><a href="#toc-3">3. Writing software in modules（モジュール化ソフトウェアの書き方）</a>
  <ul>
  <li>Structuring an application（アプリケーションの構築）</li>
  <li>More than one context per file（ファイル毎の複数のコンテキスト）</li>
  <li>The default function（デフォルト・ファンクション）</li>
  <li>Packaging data with contexts（コンテキストによるデータの包み込み）</li>
  <li>Passing objects by reference（参照によるオブジェクトの受け渡し）</li>
  </ul></li>
<li><a href="#toc-4">4. Local variables（ローカル変数）</a>
  <ul>
  <li>Locals in looping functions（ループ関数中のローカル変数）</li>
  <li>Locals in <tt>let</tt>, <tt>letn</tt>, <tt>local</tt> and <tt>letex</tt>（<tt>let</tt>, <tt>letn</tt>, <tt>local</tt>, <tt>letex</tt> 宣言文中のローカル）</li>
  <li>Unused parameters as locals（渡されなかったパラメータもローカル）</li>
  <li>Default variable values（変数値のデフォルト）</li>
  <li><tt>args</tt> as local substitute（ローカル代用としての関数 <tt>args</tt>）</li>
  <li><tt>args</tt> and <tt>local</tt> used together for named variables（<tt>args</tt> と <tt>local</tt> 宣言文を一緒に使った名前付き変数）</li>
  </ul></li>
<li><a href="#toc-5">5. Walking through lists and data（リストとデータの扱い方）</a>
  <ul>
  <li>Recursion or iteration?（再帰か繰返しか？）</li>
  <li>Speed up with memoization（記憶化によるスピード・アップ）</li>
  <li>Walking a tree（木の扱い方）</li>
  <li>Walking a directory tree（辞書木の扱い方）</li>
  </ul></li>
<li><a href="#toc-6">6. Modifying and searching lists（リストの変更と検索）</a>
  <ul>
  <li><tt>push</tt> and <tt>pop</tt>（関数 <tt>push</tt> と <tt>pop</tt>）</li>
  <li>Extend using <tt>extend</tt>（関数 <tt>extend</tt> を使ったリストの拡張）</li>
  <li>Accessing lists（リストへのアクセス）</li>
  <li>Selecting more elements（複数要素の選択）</li>
  <li>Filtering and differencing lists（リストのフィルタと差分）</li>
  <li>Changing list elements（リスト要素の変更）</li>
  <li>The anaphoric variable（アナフォリック変数）</li>
  <li>Replace in simple lists（単リストでの置換）</li>
  <li>Replace in nested lists（入れ子リストでの置換）</li>
  <li>Passing lists by reference（参照によるリストの渡し方）</li>
  <li>Variable expansion（変数展開）</li>
  <li>Destructuring nested lists（入れ子リストの変更)</li>
  </ul></li>
<li><a href="#toc-7">7. Program flow（プログラム・フロー）</a>
  <ul>
  <li>Loops（ループ）</li>
  <li>Blocks（ブロック）</li>
  <li>Branching（分岐）</li>
  <li>Fuzzy flow（ファジーなフロー）</li>
  <li>Flow with <tt>catch</tt> and <tt>throw</tt>（関数 <tt>catch</tt> と <tt>throw</tt>によるフロー）</li>
  <li>Leave loops with a break condition（脱出条件でループから離脱する）</li>
  <li>Change flow with <tt>and</tt> or <tt>or</tt>（演算子 <tt>and</tt> や <tt>or</tt> でフローを変える）</li>
  </ul></li>
<li><a href="#toc-8">8. Error handling（エラーの取り扱い方）</a>
  <ul>
  <li>newLISP errors（newLISP のエラー）</li>
  <li>User defined errors（ユーザー定義エラー）</li>
  <li>Error event handlers（エラー・イベント・ハンドラ）</li>
  <li>Catching errors（エラーの補足）</li>
  <li>Operating system errors（オペレーティング・システム・エラー）</li>
  </ul></li>
<li><a href="#toc-9">9. Functions as data（データとしての関数）</a>
  <ul>
  <li>Manipulate after definition（定義後に操作する）</li>
  <li>Mapping and applying（map と apply の仕方）</li>
  <li>Functions making functions（関数を作る関数）</li>
  <li>Functions with memory（メモリを持つ関数）</li>
  <li>Functions using self modifying code（自己改変コードを使った関数）</li>
  </ul></li>
<li><a href="#toc-10">10. Text processing（テキスト処理）</a>
  <ul>
  <li>Regular expressions（正規表現）</li>
  <li>Scanning text（テキストの走査）</li>
  <li>Appending strings（文字列の結合）</li>
  <li>Growing strings in place（文字列の追加）</li>
  <li>Rearranging strings（文字列の再配置）</li>
  <li>Modifying strings（文字列の変更）</li>
  </ul></li>
<li><a href="#toc-11">11. Dictionaries and hashes（辞書とハッシュ）</a>
  <ul>
  <li>Hash-like key → value access（ハッシュ・ライクの キー → 値 アクセス）</li>
  <li>Saving and loading dictionaries（辞書のセーブとロード）</li>
  </ul></li>
<li><a href="#toc-12">12. TCP/IP client server（TCP/IP クライアント・サーバー）</a>
  <ul>
  <li>Open connection（接続オープン）</li>
  <li>Closed transaction（トランザクション切断）</li>
  </ul></li>
<li><a href="#toc-13">13. UDP communications（UDP 通信）</a>
  <ul>
  <li>Open connection（接続オープン）</li>
  <li>Closed transaction（トランザクション切断）</li>
  <li>Multi-cast communications（マルチキャスト通信）</li>
  </ul></li>
<li><a href="#toc-14">14. Non-blocking comm（ノン・ブロッキング通信）</a>
  <ul>
  <li>Using <tt>net-select</tt>（関数<tt>net-select</tt>の使い方）</li>
  <li>Using <tt>net-peek</tt>（関数<tt>net-peek</tt> の使い方）</li>
  </ul></li>
<li><a href="#toc-15">15. Controlling other applications（外部アプリケーション制御）</a>
  <ul>
  <li>Using <tt>exec</tt>（関数<tt>exec</tt>の使い方）</li>
  <li>STD I/O pipes（標準 I/O パイプ）</li>
  <li>Communicate via TCP/IP（TCP/IP 経由で通信する）</li>
  <li>Communicate via named FIFO（名前付き FIFO 経由で通信する）</li>
  <li>Communicate via UDP（UDP 経由で通信する）</li>
  </ul></li>
<li><a href="#toc-16">16. Launching apps blocking（ブロッキングするアプリの起動）</a>
  <ul>
  <li>Shell execution（シェルの実行）</li>
  <li>Capturing std-out（標準出力の獲得）</li>
  <li>Feeding std-in（標準入力への供給）</li>
  </ul></li>
<li><a href="#toc-17">17. Semaphores, shared memory（セマフォ、共有メモリ）</a>
</li>
<li><a href="#toc-18">18. Multiprocessing and Cilk（多重処理と Cilk）</a>
  <ul>
  <li>Starting concurrent processes（並列処理の開始）</li>
  <li>Watching progress（進捗の監視）</li>
  <li>Invoking spawn recursively（spawn の再帰的呼び出し）</li>
  <li>Event driven notification（イベント駆動通知）</li>
  </ul></li>
<li><a href="#toc-19">19. Message exchange（メッセージ交換）</a>
  <ul>
  <li>Blocking message sending and receiving（ブロッキング・メッセージの送受信）</li>
  <li>Blocking message exchange（ブロッキング・メッセージ交換）</li>
  <li>Non blocking message exchange（ノン・ブロッキング・メッセージ交換）</li>
  <li>Message timeouts（メッセージのタイムアウト）</li>
  <li>Evaluating messages（メッセージの評価）</li>
  <li>Acting as a proxy（プロキシ動作）</li>
  </ul></li>
<li><a href="#toc-20">20. Databases and lookup tables（データベースとテーブル探索）</a>
  <ul>
  <li>Association lists（連想リスト）</li>
  <li>Nested associations（入れ子の連想）</li>
  <li>Updating nested associations（入れ子の連想の更新）</li>
  <li>Combining associations and hashes（連想結合とハッシュ）</li>
  </ul></li>
<li><a href="#toc-21">21. Distributed computing（分散処理）</a>
  <ul>
  <li>Setting up in server mode（サーバー・モードの設定）</li>
  <li>Start a state-full server（ステートフル・サーバーを開始する）</li>
  <li>Stateless server with inetd（inetd とステートレス・サーバー）</li>
  <li>Test the server with telnet（telnet でサーバーをテストする）</li>
  <li>Test with netcat on Unix（Unix の netcat でテストする）</li>
  <li>Test from the command line（コマンド・ラインからテストする）</li>
  <li>Test HTTP with a browser（ブラウザで HTTP をテストする）</li>
  <li>Evaluating remotely（リモート評価）</li>
  <li>Setting up the <tt>net-eval</tt> parameter structure（関数<tt>net-eval</tt>のパラメータ構成を設定）</li>
  <li>Transferring files（ファイル転送）</li>
  <li>Loading and saving data（データのロードとセーブ）</li>
  <li>Local domain Unix sockets（ローカル・ドメイン UNIX ソケット）</li>
  </ul></li>
<li><a href="#toc-22">22. HTTPD web server only mode（HTTPD ウェブ・サーバー単一モード）</a>
  <ul>
  <li>Environment variables（環境変数）</li>
  <li>Pre-processing the request（要求（request）のプリ・プロセス）</li>
  <li>CGI processing in HTTP mode（HTTP モードの CGI 処理）</li>
  <li>Media types in HTTP modes（HTTP モードのメディア・タイプ）</li>
  </ul></li>
<li><a href="#toc-23">23. Extending newLISP（newLISP の拡張）</a>
  <ul>
  <li>Simple versus extended FFI interface（単純 及び 拡張 FFI インターフェイスの比較）</li>
  <li>A shared library in C（C の共有ライブラリ）</li>
  <li>Compile on Unix（Unix でコンパイルする）</li>
  <li>Compile a DLL on Win32（Win32 の DLL をコンパイルする）</li>
  <li>Importing data structures（構造体データのインポート）</li>
  <li>Memory management（メモリ・マネージメント）</li>
  <li>Unevenly aligned structures（不均一な構造体割付け）</li>
  <li>Passing parameters（パタメータの受け渡し）</li>
  <li>Extracting return values（戻り値の抽出）</li>
  <li>Writing library wrappers（ライブラリ・ラッパーの書き方）</li>
  <li>Registering callbacks in external libraries（外部ライブラリへのコールバックの登録）</li>
  </ul></li>
<li><a href="#toc-24">24. newLISP as a shared library（共有ライブラリとしての newLISP）</a>
  <ul>
  <li>Evaluating code in the shared library（共有ライブラリでコードを評価）</li>
  <li>Registering callbacks（コールバックの登録）</li>
  </ul></li>
</ul>
<br><br>

<br><center>&sect;</center><br>
<a name="toc-1"></a>
<h2>1. Introduction（紹介）</h2>

<p>newLISP でプログラミングしている時、特定の関数や使い方が繰り返し使われます。問題によっては、最適な解決手段が時につれ進化します。以下の章では、newLISP でのプログラミングにおける特定の問題解決用のコード例と説明があります。<br />When programming in newLISP, certain functions and usage patterns occur repeatedly. For some problems, an optimal way to solve them evolves over time. The following chapters present example code and explanations for the solution of specific problems when programming in newLISP.</p>

<p>内容的には、newLISP ユーザー マニュアルとリファレンスの内容と重複しているものもありますし、違った観点で表されているものもあります。<br />Some content is overlapping with material covered in the newLISP Users Manual and Reference or presented here with a different slant.</p>

<p>ここでは、newLISP の全関数レパートリーの一部が使われているだけです。いくつかの動作例の関数には、追加の呼び出しパターンか、このページで言及されないアプリケーションが含まれています。<br />Only a subset of newLISP's total function repertoire is used here. Some functions demonstrated have additional calling patterns or applications not mentioned on these pages.</p>

<p>この用例と解決例を集めたものは、進化していきます。時につれ、追加されるか既存のものが改良されていきます。<br />This collection of patterns and solutions is a work in progress. Over time, material will be added or existing material improved.</p>

<br><center>&sect;</center><br>
<a name="toc-2"></a>
<h2>2. newLISP script files（newLISP スクリプト・ファイル）</h2>

<h3>Command line options（コマンド・ライン・オプション）</h3>

<p>Linux/Unix では、スクリプト／プログラム・ファイルの第一行に以下を置きます：<br />On Linux/Unix, put the following in the first line of the script/program file:</p>

<pre>
#!/usr/bin/newlisp
</pre>

<p>スタックを大きく指定するなら：<br />specifying a bigger stack:</p>

<pre>
#!/usr/bin/newlisp -s 100000
</pre>

<p>あるいは<br />or</p>

<pre>
#!/usr/bin/newlisp -s100000
</pre>

<p>オペレーティング・システムのシェルは一行目を解析し、取り出したパラメータで異なる振る舞いをします。newLISP は、パラメータをくっ付けても離しても認識します。OS やプラットフォームの元での振る舞いをテストするために、次の短いスクリプトを用意しましょう。このスクリプトはスタックサイズの割り当てを 100,000 にして、newLISP セル・メモリの最大値を 10M バイトに変更します。<br />Operating systems' shells behave differently when parsing the first line and extracting parameters. newLISP takes both attached or detached parameters. Put the following lines in small script to test the behavior of the underlying OS and platform. The script changes the stack size allocated to 100,000 and limits newLISP cell memory to about 10 M bytes.</p>

<pre>
#!/usr/bin/newlisp -s 100000 -m 10
     
(println (main-args))
(println (sys-info))

(exit) ; important
</pre>

<p>システム・シェルからスクリプトを実行した時の出力は、たいてい次のようになります：<br />A typical output executing the script from the system shell would be:</p>

<pre>
./arg-test
     
("/usr/bin/newlisp" "-s" "100000" "-m" "10" "./arg-test")
(308 655360 299 2 0 100000 8410 2)
</pre>

<p>ごくまれに、newLISP のプログラムが大きなスタック構成を必要とすることがありますので、注意してください。たいていのプログラムは、デフォルトの 2048 で走ります。各スタックは、平均で 80 バイト取ります。newLISP の開始時に使えるオプションは、他にもあります。詳しくは、ユーザー・マニュアルを見てください。<br />Note that few programs in newLISP need a bigger stack configured; most programs run on the internal default of 2048. Each stack position takes an average of 80 bytes. Other options are available to start newLISP. See the Users Manual for details.</p>

<h3>Scripts as pipes（パイプとしてのスクリプト）</h3>

<p>次の例では、newLISP スクリプトにファイルをパイプさせる方法を紹介します。<br />The following example shows how a file can be piped into a newLISP script. </p>

<pre>
#!/usr/bin/newlisp
#
# uppercase - demo filter script as pipe
#
# usage:
#          ./uppercase &lt; file-spec
#
# example:
#          ./uppercase &lt; my-text
#
#
     
(while (read-line) (println (upper-case (current-line))))
     
(exit)
</pre>

<p>ファイルは大文字に変換され、<b>標準出力</b> に出力されます。<br />The file will be printed to <tt>std-out</tt> translated to uppercase.</p>

<p>次のプログラムは <tt>0</tt> を含むバイナリの非テキスト情報でも動作します：<br />The following program would also work with binary non-textual information
containing <tt>0</tt>'s :</p>

<pre>
#!/usr/bin/newlisp
;
; inout - demo binary pipe
;
; read from stdin into buffer
; then write to stdout
;
; usage: ./inout < inputfile > outputfile
;

(while (read 0 buffer 1024)
    (write 1 buffer 1024))

(exit)
</pre>

<p>最適なバッファサイズを設定して下さい。<br />Set buffersize to best performance.</p>


<h3>File filters（ファイル・フィルタ）</h3>

<p>次のスクリプトは、Unix の <tt>grep</tt> ユーティリティのように動作し、正規表現パターンを使ってファイルの各行をフィルタする動作を指定されたファイルで繰り返します：<br />The following script works like a Unix <tt>grep</tt> utility iterating through files and filtering each line in a file using a regular expression pattern.</p>

<pre>
#!/usr/bin/newlisp
#
# nlgrep - grep utility on newLISP
#
# usage:
#          ./nlgrep "regex-pattern" file-spec
#
# file spec can contain globbing characters
#
# example:
#          ./nlgrep "this|that" *.c
#
# will print all lines containing 'this' or 'that' in *.c files
#
     
(dolist (fname (3 (main-args)))
    (set 'file (open fname "read"))
    (println "file ---&gt; " fname)
    (while (read-line file)
        (if (find (main-args 2) (current-line) 0)
            (write-line)))
    (close file))
    
(exit)
</pre>

<p>式：<br />The expression:</p>

<pre>
(3 (main-args))
</pre>

<p>は、次の表記の短縮形です：<br />is a short form of writing:</p>

<pre>
(rest (rest (rest (main-args))))
</pre>

<p>これは、全ファイル名のリストを返します。この rest の代わりにインデックスを指定する形式は、暗黙のインデックスと呼ばれます。暗黙のインデックスの他の機能については、ユーザー・マニュアルを見てください。式 <tt>(main-args 2)</tt> は、コマンドラインから正規表現パターンを含む第 3 引数を取り出します。<br />It returns a list of all the filenames. This form of specifying indexes for rest is called implicit indexing. See the Users Manual for implicit indexing with other functions. The expression <tt>(main-args 2)</tt> extracts the 3rd argument from the command line containing the regular expression pattern.</p>

<h3>newLISP as a pipe（パイプで newLISP を使う）</h3>

<p>短い式の評価はパイプを使って直接実行できます：<br />Pipe one-liners directly into the executable for evaluation of short expressions:</p>

<pre>
~&gt; echo '(+ 1 2 3)' | newlisp
6
~&gt; 
</pre>

<br><center>&sect;</center><br>
<a name="toc-3"></a>
<h2>3. Writing software in modules（モジュール化ソフトウェアの書き方）</h2>

<h3>Structuring an application（アプリケーションの構築）</h3>

<p>大規模なアプリケーションを書く時、あるいは、複数のプログラマが同じコード・ベースで作業している時、コード・ベースをモジュールに分割することが求められます。newLISP ではモジュールを名前空間であるコンテキストを使って実装できます。名前空間は、モジュール間をレキシカルに分離します。一モジュール内の変数名が、別のモジュール内の同じ名前の変数と衝突することはありません。<br />When writing bigger applications or when several programmers are working on the same code base, it is necessary to divide the code base into modules. Modules in newLISP are implemented using contexts, which are namespaces. Namespaces allow lexical isolation between modules. Variables of the same name in one module cannot clash with variables of the same name in another module.</p>

<p>通常、モジュールはファイルごとに一コンテキストで編成されます。一ファイル・モジュールに、データベースをアクセスするルーチンを含めます。<br />Typically, modules are organized in one context per file. One file module may contain database access routines.</p>

<pre>
; database.lsp
;
(context 'db)
   
   
(define (update x y z)
...
)
   
(define (erase x y z)
...
)
</pre>

<p>別のモジュールには、様々なユーティリティを置きます。<br />Another module may contain various utilities</p>

<pre>
; auxiliary.lsp
;
(context 'aux)
 
(define (getval a b)
...
)
</pre>

<p>通常、全てのモジュールを一つの MAIN モジュールにロードし、制御します。<br />Typically, there will be one MAIN module that loads and controls all others:</p>

<pre>
; application.lsp
;
   
(load "auxiliary.lsp")
(load "database.lsp")
   
(define (run)
    (db:update ....)
    (aux:putval ...)
    ...
    ...
)
   
(run)
</pre>

<h3>More than one context per file（ファイル毎の複数のコンテキスト）</h3>

<p>ファイル毎に複数のコンテキストを使う時は、各コンテキスト・セクションを <tt>(context MAIN)</tt> 制御文で閉じなければなりません：<br />When using more than one context per file, each context section should be closed with a <tt>(context MAIN)</tt> statement:</p>

<pre>
; myapp.lsp
;
(context 'A)
   
(define (foo ...) ...)
   
(context MAIN)
   
(context 'B)
   
(define (bar ...) ...)
   
(context MAIN)
   
(define (main-func)
    (A:foo ...)
    (B:bar ...)
)
</pre>

<p>コンテキスト <tt>A</tt> と <tt>B</tt> の名前空間制御文においては、コンテキスト名を新しく生成するためにシンボルをクォートしていることに注意して下さい。<tt>MAIN</tt> は、newLISP 開始時に既に存在しているのでクォートなしでも済みます。もちろん、クォートしても問題ありません。<br />Note that in the namespace statements for contexts <tt>A</tt> and <tt>B</tt> that the context names are quoted because they are newly created, but <tt>MAIN</tt> can stay unquoted because it already exists when newLISP starts up. However, quoting it does not present a problem.</p>

<p>コンテキストを閉じる <tt>(context MAIN)</tt> 行は、次のようなテクニックで省略できます：<br />The line <tt>(context MAIN)</tt> that closes a context can be omitted by using the following technique:</p>

<pre>
; myapp.lsp
;
(context 'A)
   
(define (foo ...) ...)
   
(context 'MAIN:B)
   
(define (bar ...) ...)
   
(context 'MAIN)
   
(define (main-func)
    (A:foo ...)
    (B:bar ...)
)
</pre>

<p><tt>(context 'MAIN:B)</tt> は、MAIN に切り替えた後、新規コンテキスト <tt>B</tt> を開きます。<br />The line <tt>(context 'MAIN:B)</tt> switches back to MAIN then opens the new context <tt>B</tt>.</p>

<h3>The default function（デフォルト・ファンクション）</h3>

<p>コンテキスト内の関数は、ホスト・コンテキスト自身と同じ名前を持つことができます。この関数は、特別な特徴を持ちます：<br />A function in a context may have the same name as the host context itself. This function has special characteristics:</p>

<pre>
(context 'foo)
  
(define (foo:foo a b c)
...
)
</pre>

<p>関数 <tt>foo:foo</tt> は <tt>デフォルト・ファンクション</tt> と呼ばれ、コンテキスト名 <tt>foo</tt> を使った時、デフォルトで <tt>foo:foo</tt> になります。<br />The function <tt>foo:foo</tt> is called the <tt>default function</tt>, because when using the context name <tt>foo</tt> like a function, it will default to <tt>foo:foo</tt></p>

<pre>
(foo x y z)
; same as
(foo:foo x y z)
</pre>

<p>デフォルト・ファンクションは、通常の関数のようにみえる関数を書くことができ、さらに、それ自身の名前空間をレキシカルに運用できます。これを使って状態を保持する関数を書くことができます：<br />The default function makes it possible to write functions which look like normal functions but carry their own lexical namespace. We can use this to write functions which keep state:</p>

<pre>
(context 'generator)
   
(define (generator:generator)
    (inc acc)) ; when acc is nil, assumes 0
 
(context MAIN)
   
(generator) → 1
(generator) → 2
(generator) → 3
</pre>

<p>次はフィボナッチ数列を生成する関数ための複雑な例です：<br />The following is a more complex example for a function generating a Fibonacci sequence:</p>

<pre>
(define (fibo:fibo)
    (if (not fibo:mem) (set 'fibo:mem '(0 1)))
    (last (push (+ (fibo:mem -1) (fibo:mem -2)) fibo:mem -1)))
   
(fibo) → 1
(fibo) → 2
(fibo) → 3
(fibo) → 5
(fibo) → 8
...
</pre>

<p>この例は、<tt>context</tt> 制御文を明示することなし、デフォルト・ファンクションを <b>その場で</b> 定義する方法を示しています。一方で、コンテキストを明示的に生成して、関数を書くこともできます：<br />This example also shows how a default function is defined <tt>on-the-fly</tt> without the need of explicit <tt>context</tt> statements. As an alternative, the function could also have been written so that the context is created explicitly:</p>

<pre>
(context 'fibo)
(define (fibo:fibo)
        (if (not mem) (set 'mem '(0 1)))
        (last (push (+ (mem -1) (mem -2)) mem -1)))
(context MAIN)
  
(fibo) → 1
(fibo) → 2
(fibo) → 3
(fibo) → 5
(fibo) → 8
</pre>

<p>最初の形式は短くて済み、二番目の形式は読みやすくなります。<br />Although the first form is shorter, the second form is more readable.</p>

<h3>Packaging data with contexts（コンテキストによるデータの包み込み）</h3>

<p>前の例で、名前空間にデータを包み込む関数を示しました。<tt>generator</tt> の例では、変数 <tt>acc</tt> が状態を保存していました。<tt>fibo</tt> の例では、変数 <tt>mem</tt> が成長するリストを保持していました。どちらの場合も、関数とデータが共に名前空間内にあります。次の例は、名前空間がデフォルト・ファンクタとしてデータのみを保持する方法を示しています：<br />The previous examples already presented functions packaged with data in a namespace. In the <tt>generator</tt> example the <tt>acc</tt> variable kept state. In the <tt>fibo</tt> example the variable <tt>mem</tt> kept a growing list. In both cases, functions and data are living together in a namespace. The following example shows how a namespace holds only data in a default functor:</p>

<pre>
(set 'db:db '(a "b" (c d) 1 2 3 x y z))
</pre>

<p><tt>fibo</tt> や <tt>generator</tt> を参照するのにデフォルト・ファンクションを使ったように、<tt>db</tt> を使って <tt>db:db</tt> のリストに参照できます。これは、リストをインデックスする全ての場合で動作します：<br />Just like we used the default function to refer to <tt>fibo</tt> and <tt>generator</tt> we can refer to the list in <tt>db:db</tt> by only using <tt>db</tt>. This will work in all situations where we do list indexing:</p>

<pre>
(db 0)    → a
(db 1)    → "b"
(db 2 1)  → d
(db -1)   → z
(db -3)   → x
   
(3 db)    → (1 2 3 x y z)
(2 1 db)  → ((c d))
(-6 2 db) → (1 2)
</pre>

<h3>Passing objects by reference（参照によるオブジェクトの受け渡し）</h3>

<p>デフォルト・ファンクタがユーザー定義関数に引数として使われる時、デフォルト・ファンクタは参照として渡されます。これは、リストや文字列のコピーではなく、オリジナルの内容の参照が渡されることを意味します。つまり、大規模なリストや文字列を操作する時に、役立ちます：<br />When the default functor is used as an argument in a user defined function, the default functor is passed by reference. This means that a reference to the original contents is passed, not a copy of the list or string. This is useful when handling large lists or strings:</p>

<pre>
(define (update data idx expr)
    (if (not (or (lambda? expr) (primitive? expr)))
        (setf (data idx) expr)
        (setf (data idx) (expr $it))))
   
(update db 0 99) → a
db:db → (99 "b" (c d) 1 2 3 x y z)
   
(update db 1 upper-case) → "b"
db:db → (99 "B" (c d) 1 2 3 x y z)
   
(update db 4 (fn (x) (mul 1.1 x))) →
db:db → (99 "B" (c d) 1 2.2 3 x y z)
</pre>

<p><tt>db:db</tt> のデータが、関数 <tt>update</tt> のパラメータ <tt>data</tt> に渡されます。渡されたパラメータ <tt>expr</tt> は、組込関数か演算子かユーザー・ラムダ式かをチェックされ、もしそうなら <tt>(data idx)</tt> によって参照された古い（訳注：変更前の意味）内容が入っているアナフォリック変数 <tt>$it</tt> に適用されます。<br />The data in <tt>db:db</tt> is passed via the <tt>update</tt> function parameter <tt>data</tt>, which now holds a reference to the context <tt>db</tt>. The <tt>expr</tt> parameter passed is checked to determine if it is a built-in function, operator or a user defined lambda expression and then works on <tt>$it</tt>, the anaphoric system variable containing the old content referenced by <tt>(data idx)</tt>.</p>

<p>newLISP の関数がパラメータに文字列かリストを要求する時は、デフォルト・ファンクタをそのコンテキスト・シンボルで渡せます。別の例では：<br />Whenever a function in newLISP asks for a string or list in a parameter, a default functor can be passed by its context symbol. Another example:</p>

<pre>
(define (pop-last data)
(pop data -1))
   
(pop-last db) → z
   
db:db         → (99 "B" (c d) 1 2.2 3 x y)
</pre>

<p>関数 <tt>update</tt> は、演算子や関数を関数の引数として渡す方法の良い例でもあります（<tt>$it</tt> に作用する <tt>upper-case</tt> のように）。詳細は、<a href="#toc-9">Functions as data</a> の章を読んで下さい。<br />The function <tt>update</tt> is also a good example of how to pass operators or functions as a function argument (<tt>upper-case</tt> working on <tt>$it</tt>). Read more about this in the chapter <a href="#toc-9">Functions as data</a>.</p>

<br><center>&sect;</center><br>
<a name="toc-4"></a>
<h2>4. Local variables（ローカル変数）</h2>

<h3>Locals in looping functions（ループ関数中のローカル変数）</h3>

<p><tt>doargs</tt>、<tt>dolist</tt>、<tt>dostring</tt>、<tt>dotimes</tt>、<tt>dotree</tt>、<tt>for</tt> 等の全てのループ関数は、ローカル変数を使います。しかし、ループ関数から離れた後で、(訳注:ループ関数を使用する前に定義されていた）変数は古い値を回復します。<tt>let</tt>、<tt>define</tt>、<tt>lambda</tt> は、変数をローカルにする別の方法です：<br />All looping functions like <tt>doargs</tt>, <tt>dolist</tt>, <tt>dostring</tt>, <tt>dotimes</tt>, <tt>dotree</tt> and <tt>for</tt> use local variables. During loop execution, the variable takes different values. But after leaving the looping function, the variable regains its old value. <tt>let</tt>, <tt>define</tt>, and <tt>lambda</tt> expressions are another method for making variables local:</p>

<h3>Locals in <tt>let</tt>, <tt>letn</tt>, <tt>local</tt> and <tt>letex</tt>（<tt>let</tt>, <tt>letn</tt>, <tt>local</tt>, <tt>letex</tt> 宣言文中のローカル）</h3>

<p>newLISP で <tt>let</tt> は、ブロック内のローカルなシンボルを宣言する一般的な方法です。<br /><tt>let</tt> is the usual way in newLISP to declare symbols as local to a block.</p>

<pre>
(define (sum-sq a b)
    (let ((x (* a a)) (y (* b b)))
        (+ x y)))
 
(sum-sq 3 4) → 25
 
; alternative syntax
(define (sum-sq a b)
    (let (x (* a a) y (* b b))
        (+ x y)))
</pre>


<p>変数 x と y が初期化されから、式 (+ x y) が評価されます。<tt>let</tt> 形式は、まさに最適な形で、次のような書き方を提供してくれます：<br />The variables x and y are initialized, then the expression (+ x y) is evaluated. The <tt>let</tt> form is just an optimized version and syntactic convenience for writing:</p>

<pre>
((lambda (sym1 [sym2 ...]) exp-body ) exp-init1 [ exp-init2 ...])
</pre>

<p>いくつかのパラメータを初期化する際、先に初期化した変数を参照して次々と初期化するために <tt>letn</tt>（入れ子になっている <tt>let</tt>）が使えます：<br />When initializing several parameters, a nested <tt>let</tt>, <tt>letn</tt> can be used to reference previously initialized variables in subsequent initializer expressions:</p>

<pre>
(letn ((x 1) (y (+ x 1)))
    (list x y))              → (1 2)
</pre>

<p><tt>local</tt> も同様に動作しますが、変数は <tt>nil</tt> に初期化されます。<br /><tt>local</tt> works the same way but variables are initialized to <tt>nil</tt></p>

<pre>
(local (a b c) 
   ...          ; expressions using the locale variables a b c
)
</pre>

<p><tt>letex</tt> は <tt>let</tt> と同じように動作しますが、本体中の変数に値を展開します。<br /><tt>letex</tt> works similar to <tt>let</tt> but variables are expanded in the body to
values assigned.</p>

<pre>
; assign to local variable and expand in body

(letex ( (x 1) (y '(a b c)) (z "hello") ) '(x y z))
→ (1 (a b c) "hello")

; as in let, parentheses around the initializers can be omitted

(letex (x 1 y 2 z 3) '(x y z))    → (1 2 3)
</pre>

<p><tt>let</tt>, <tt>letn</tt>, <tt>local</tt>, <tt>letex</tt> 式から抜けた後、ローカルで使った変数シンボルには元の値が戻ります。<br />After exiting any of the <tt>let</tt>, <tt>letn</tt>, <tt>local</tt> or <tt>letex</tt>
expressions, the variable symbols used as locals get their old values back.</p> 


<h3>Unused parameters as locals（渡されなかったパラメータもローカル）</h3>

<p>newLISP では、ユーザー定義関数の全てのパラメータはオプションです。使用されない（訳注：渡されなかった）パラメータには <tt>nil</tt> が入り、関数のダイナミック・スコープにローカル・スコープします。必要数より多いパラメータでユーザー関数を定義することは、ローカル変数シンボルを生成する便利な方法です：<br />In newLISP, all parameters in user defined functions are optional. Unused parameters are filled with <tt>nil</tt> and are of local scope to the dynamic scope of the function. Defining a user function with more parameters than required is a convenient method to create local variable symbols:</p>

<pre> 
(define (sum-sq a b , x y)
    (set 'x (* a a))
    (set 'y (* b b))
    (+ x y))
</pre>

<p>カンマは特殊な構文機能ではありませんが、通常のパラメータとローカル変数シンボルとを区別する視覚的補助になります。（技術的には、カンマは x と y と同じように、ローカル変数で nil に設定されます。）<br>The comma is not a special syntax feature but only a visual helper to separate normal parameters from local variable symbols. (Technically, the comma, like x and y, is a local variable and is set to nil.)</p>

<h3>Default variable values（デフォルトの変数値）</h3>

<p>関数定義の際、初期値を指定できます：<br />In the definition of a function default values can be specified:</p>

<pre>
(define (foo (a 1) (b 2))
    (list a b))
  
    (foo)      →  (1 2)
    (foo 3)    →  (3 2)
    (foo 3 4)  →  (3 4)
</pre>

<h3><tt>args</tt> as local substitute（ローカル代用としての関数 <tt>args</tt>）</h3>

<p>関数 <tt>args</tt> を使えば、パラメータ・シンボルを使う必要が無く、渡されたパラメータで宣言されているパラメータに取られなかった全てのパラメータのリストを <tt>args</tt> が返します：<br />Using the <tt>args</tt> function no parameter symbols need to be used at all and <tt>args</tt> returns a list of all parameters passed but not taken by declared parameters:</p>

<pre>
(define (foo)
    (args))
   
(foo 1 2 3)   → (1 2 3)
   
   
(define (foo a b)
    (args))
   
(foo 1 2 3 4 5)   → (3 4 5)
</pre>

<p>二番目の例は、シンボル <tt>a</tt> と <tt>b</tt> に束縛されない引数のリストだけを <tt>args</tt> が得る方法を示しています。<br />The second example shows how <tt>args</tt> only contains the list of arguments not bound by the variable symbols <tt>a</tt> and <tt>b</tt>.</p>

<p><a href="http://www.newlisp.org/newlisp_manual-10208-jp.html#indexing">インデックス機能</a> を <tt>(args)</tt> リストの要素のアクセスに使えます：<br />Indices can be used to access members of the <tt>(args)</tt> list:</p>

<pre>
(define (foo)
      (+ (args 0) (args 1)))
   
(foo 3 4)   → 7
</pre>

<h3><tt>args</tt> and <tt>local</tt> used together for named variables（<tt>args</tt> と <tt>local</tt> を一緒に使った名前付き変数）</h3>

<pre>
(define-macro (foo)
   (local (len width height)
      (bind (args) true)
      (println "len:" len " width:" width " height:" height)
   ))

(foo (width 20) (height 30) (len 10))

<b>len:10 width:20 height:30</b>
</pre>

<p><tt>local</tt> は高次のダイナミック・スコープから <tt>len</tt>、<tt>width</tt>、<tt>height</tt>の変数の値を隠して保護します。<br /><tt>local</tt> will shadow / protect the values of the variables <tt>len</tt>, <tt>width</tt>
and <tt>height</tt> at higher dynamic scoping levels.</p>

<br><center>&sect;</center><br>
<a name="toc-5"></a>
<h2>5. Walking through lists and data（リストとデータの扱い方）</h2>

<h3>Recursion or iteration?（再帰か繰返しか？）</h3>

<p>再帰は、多くのアルゴリズムを読みやすい形式で表現できる強力な機能ですが、場合によっては効率的ではありません。newLISP は多くの繰返し構文や <tt>flat</tt> のような高級関数、あるいは、内部で再帰を使う組込の XML 関数を持っています。このため、多くの場面で再帰アルゴリズムは不要です。<br />Although recursion is a powerful feature to express many algorithms in a readable form, it can also be inefficient in some instances. newLISP has many iterative constructs and high level functions like <tt>flat</tt> or the built-in XML functions, which use recursion internally. In many cases this makes defining a recursive algorithm unnecessary.</p>

<p>いくつかの場面では、非再帰手法の方がより速く、システム・リソースも少なくて済みます。<br />Some times a non-recursive solution can be much faster and lighter on system resources.</p>

<pre>
; classic recursion
; slow and resource hungry
(define (fib n)
    (if (&lt; n 2) 1
        (+  (fib (- n 1))
            (fib (- n 2)))))
</pre>

<p>再帰手法は、頻繁に呼び出されるオーバーヘッドにより遅くなります。また、再帰手法は、中間物や時に余分な結果の保持に多くのメモリを使います。<br />The recursive solution is slow because of the frequent calling overhead. Also, the recursive solution uses a lot of memory for holding intermediate and frequently redundant results.</p>

<pre>
; iteration
; fast and also returns the whole list
(define (fibo n , f)
    (set 'f '(1 0))
    (dotimes (i n)
         (push (+ (f 0) (f 1)) f)) )
</pre>

<p>繰返し手法は、速くて、使うメモリも少なくて済みます。<br />The iterative solution is fast and uses very little memory.</p>

<h3>Speed up with memoization（記憶化によるスピード・アップ）</h3>

<p>記憶化（memoizing）関数は、あるパラメータが再び呼び出された時に素早く回復できるように結果を蓄えておきます。次の関数は、任意の引数を持つ組込かユーザー定義関数から記憶化関数を生成します。データを貯蔵する記憶化関数用の名前空間が作成されます。<br />A memoizing function caches results for faster retrieval when called with the same parameters again. The following function makes a memoizing function from any built-in or user defined function with an arbitrary number of arguments. A namespace is created for the memoizing function as a data cache.</p>

<pre>
; speed up a recursive function using memoization
(define-macro (memoize mem-func func)
    (set (sym mem-func mem-func)
        (letex (f func  c mem-func)
          (lambda ()
              (or (context c (string (args)))
              (context c (string (args)) (apply f (args))))))))
       
(define (fibo n)
    (if (&lt; n 2)  1
        (+  (fibo (- n 1))
            (fibo (- n 2)))))
       
(memoize fibo-m fibo)
       
(time (fibo-m 25)) → 148
(time (fibo-m 25)) → 0
</pre>

<p>関数は、コンテキストと元の関数用の<b>デフォルト</b>・ファンクションを新しい名前で作成して、全ての結果を同じコンテキストのシンボルに保存します。<br />The function creates a context and <tt>default</tt> function for the original function with a new name and stores all results in symbols in the same context.</p>

<p>再帰関数を記憶化（memoizing）する際は、再帰呼び出しが記憶されるように直接ラムダ関数の形で入れて下さい：<br />When memoizing recursive functions, include the raw lambda specification of the function so recursive calls are memoized too:</p>

<pre>
(memoize fibo
    (lambda (n)
        (if(&lt; n 2) 1
            (+  (fibo (- n 1))
                (fibo (- n 2))))))
        
(time (fibo 100)) → 1
(fibo 80)         → 37889062373143906
</pre>

<p>最後の例を記憶化無しの <tt>fibo</tt> 関数で計算するには、何時間もかかります。記憶化したバージョンなら、引数 <tt>100</tt> でも 1 ミリ秒しかかかりません。<br />The <tt>fibo</tt> function in the last example would take hours to calculate without memoization. The memoized version takes only about a milli-second for an argument of <tt>100</tt>.</p>

<h3>Walking a tree（木の扱い方）</h3>

<p><a href="http://ja.wikipedia.org/wiki/%E6%9C%A8%E6%A7%8B%E9%80%A0_%28%E3%83%87%E3%83%BC%E3%82%BF%E6%A7%8B%E9%80%A0%29">(訳注：データ構造としての）木</a>探索は、入れ子リストの探索と同様に伝統的な LISP や newLISP での代表的パターンです。しかし、多くの場合、木探索は存在する木や入れ子リストの全要素で繰り返すためにのみ使われます。この場合、組込関数 <tt>flat</tt> を使えば、再帰を使うよりかなり速くなります：<br />Tree walks are a typical pattern in traditional LISP and in newLISP as well for walking through a nested list. But many times a tree walk is only used to iterate through all elements of an existing tree or nested list. In this case the built-in <tt>flat</tt> function is much faster than using recursion:</p>

<pre>
(set 'L '(a b c (d e (f g) h i) j k))
   
; classic car/cdr and recursion
;
(define (walk-tree tree)
    (cond ((= tree '()) true)
          ((atom? (first tree))
             (println (first tree))
             (walk-tree (rest tree)))
          (true
             (walk-tree (first tree))
             (walk-tree (rest tree)))))
   
; classic recursion
; 3 times faster
;
(define (walk-tree tree)
    (dolist (elmnt tree)
        (if (list? elmnt)
            (walk-tree elmnt)
            (println elmnt))))
   
(walk-tree L) →
     a
     b
     c
     d
     e
     ...
</pre>

<p>newLISP の組込 <tt>flat</tt> を使えば、入れ子リストはフラットなリストに変換されます。これで、リストを <tt>dolist</tt> や <tt>map</tt> で処理できるようになります：<br />Using the built-in <tt>flat</tt> in newLISP a nested list can be transformed into a flat list. Now the list can be processed with a <tt>dolist</tt> or <tt>map</tt>:</p>

<pre>
; fast and short using 'flat'
; 30 times faster with map
;
(map println (flat L))
 
 ; same as
 
(dolist (item (flat L)) (println item)
</pre>

<h3>Walking a directory tree（辞書木の扱い方）</h3>

<p>ディレクトリ木の探索は、再帰動作にぴったりの処理です：<br />Walking a directory tree is a task where recursion works well:</p>

<pre> 
; walks a disk directory and prints all path-file names
;
(define (show-tree dir)
    (when (directory? dir)
        (dolist (nde (directory dir))
            (if (and (directory? (append dir "/" nde))
                     (!= nde ".") (!= nde ".."))
                (show-tree (append dir "/" nde))
                (println (append dir "/" nde))))))
</pre>

<p>この例では、再帰が唯一の方法です。なぜなら、関数が呼び出される時には、ファイルの完全な入れ子リストを入手できず、関数実行中に再帰的に作成されて得られるからです。<br />In this example recursion is the only solution, because the entire nested list of files is not available when the function is called but gets created recursively during function execution.</p>

<br><center>&sect;</center><br>
<a name="toc-6"></a>
<h2>6. Modifying and searching lists（リストの変更と検索）</h2>

<p>newLISP には、入れ子リストを多次元インデックスでアクセスできる機能が用意されています。<tt>push</tt>、<tt>pop</tt>、<tt>setf</tt>、<tt>set-ref</tt>、<tt>set-ref-all</tt>、<tt>sort</tt>、<tt>reverse</tt> のような破壊的関数と <tt>nth</tt>、<tt>ref</tt>、<tt>ref-all</tt>、<tt>first</tt>、<tt>last</tt>、<tt>rest</tt> のような非破壊演算子があります。newLISP のリスト関数のほとんどが、文字列に対しても使えます。<br />newLISP has facilities for multidimensional indexing into nested lists. There are <tt>destructive</tt> functions like <tt>push</tt>, <tt>pop</tt>, <tt>setf</tt>, <tt>set-ref</tt>, <tt>set-ref-all</tt>, <tt>sort</tt> and <tt>reverse</tt> and many others for <tt>non-destructive</tt> operations, like <tt>nth</tt>, <tt>ref</tt>, <tt>ref-all</tt>, <tt>first</tt>, <tt>last</tt> and <tt>rest</tt> etc.. Many of the list functions in newLISP also work on strings.</p>

<p>newLISP では、リストと文字列の右側からに -1 で始まる負のインデックス値が使えることに注目して下さい。<br />Note that any list or string index in newLISP can be negative starting with -1 from the right side of a list:</p>

<pre>
(set 'L '(a b c d))
(L -1)   → d
(L -2)   → c
(-3 2 L) → (b c)
   
(set 'S  "abcd")
   
(S -1)   → d
(S -2)   → c
(-3 2 S) → "bc")
</pre>

<h3><tt>push</tt> and <tt>pop</tt>（関数<tt>push</tt>と<tt>pop</tt>）</h3>

<p><tt>push</tt> を使ってリストに追加したり、<tt>pop</tt> を使ってリストから要素を削除したりすることは、どちらも破壊的でリストの内容を変更します：<br />To add to a list use <tt>push</tt>, to eliminate an element from a list use <tt>pop</tt>. Both functions are destructive, changing the contents of a list:</p>

<pre>
(set 'L '(b c d e f))
   
(push 'a L) → (a b c d e f)
(push 'g L -1) ; push to the end with negative index
(pop L)        ; pop first a
(pop L -1)     ; pop last g
(pop L -2)     ; pop second to last e
(pop L 1)      ; pop second c
   
L → (b d f)
   
; multidimensional push / pop
(set 'L '(a b (c d (e f) g) h i))
   
(push 'x L 2 1) → (a b (c x d (e f) g) h i)
   
L → (a b (c x d (e f) g) h i)
   
(pop L 2 1) → x

; the target list is a place reference
(set 'lst '((a 1) (b 2) (c 3) (d)))

(push 4 (assoc 'd lst) -1) → (d 4)

lst → ((a 1) (b 2) (c 3) (d 4))
</pre>

<p>newLISP は、繰り返しリストの最後に push することに最適化されていて、リストの先頭に push するより早くできます。<br />Pushing to the end of a list repeatedly is optimized in newLISP and as fast as pushing in front of a list.</p>

<p>インデックス・ベクトル V で要素を push した時、同じインデックス・ベクトル V を pop に使えます：<br />When pushing an element with index vector V it can be popped with the same index vector V:</p>

<pre>
(set 'L '(a b (c d (e f) g) h i))
(set 'V '(2 1))
(push 'x L V)
L → (a b (c x d (e f) g) h i))
(ref 'x L) → (2 1) ; search for a nested member
(pop L V) → 'x
</pre>

<h3>Extend using <tt>extend</tt>（関数 <tt>extend</tt> を使ったリストの拡張）</h3>

<p><tt>extend</tt> を使えば、リストを破壊的に追加できます。<tt>push</tt> や <tt>pop</tt> のように、<tt>extend</tt> は、第一引数のリストを変更します。<br />Using <tt>extend</tt> lists can be appended destructively.
Like <tt>push</tt> and <tt>pop</tt>, <tt>extend</tt> modifies the list in the first
argument.</p>

<pre>
(set 'L '(a b c))
(extend L '(d e) '(f g))

L &rarr; '(a b c d e f g)

; extending in a place

(set 'L '(a b "CD" (e f)))
(extend (L 3) '(g))
L → (a b "CD" (e f g))
</pre>

<h3>Accessing lists（リストへのアクセス）</h3>

<p>複数のインデックスを入れ子リスト構造の要素アクセス指定に使えます：<br />Multiple indexes can be specified to access elements in a nested list structure:</p>

<pre>
(set 'L '(a b (c d (e f) g) h i))
   
; old syntax only for one index
(nth 2 L) → (c d (e f) g)
   
; use new syntax for multiple indices
(nth '(2 2 1) L) → f
(nth '(2 2) L) → (e f)
   
; vector indexing
(set 'vec '(2 2))
(nth vec L) → (e f)
   
; implicit indexing
(L 2 2 1) → f
(L 2 2)   → (e f)
   
; implicit indexing with vector
(set 'vec '(2 2 1))
(L vec)   → f
</pre>

<p>最後の例に示した暗黙のインデックス機能は、コードを読み易くします。リストの前のインデックスは、リストの一部を切り出し、リストで返します。<br />Implicit indexing shown in the last example can make code more readable. Indexes before a list select subsections of a list, which in turn are always lists.</p>

<p>暗黙のインデックス機能は、rest や slice のようにも使えます：<br />Implicit indexing is also available for rest and slice:</p>

<pre>
(rest '(a b c d e))      → (b c d e)
(rest (rest '(a b c d e) → (c d e)
; same as
(1 '(a b c d e)) → (b c d e)
(2 '(a b c d e)) → (c d e)
   
; negative indices
(-2 '(a b c d e)) → (d e)
   
; slicing
(2 2 '(a b c d e f g))  → (c d)
(-5 3 '(a b c d e f g)) → (c d e)
</pre>

<h3>Selecting more elements（複数要素の選択）</h3>

<p>リストから一個以上の要素を取り出さねばならない時があります。このような時は、<tt>select</tt> を使います：<br />Sometimes more than one element must be selected from a list. This is done using select:</p>

<pre>
; pick several elements from a list
(set 'L '(a b c d e f g))
(select L 1 2 4 -1) → (b c e g)
   
; indices can be delivered in an index vector:
(set 'vec '(1 2 4 -1))
(select L vec) → (b c e g)
</pre>

<p>select 処理は、同時に、再配置したり、要素を二重化したりできます：<br />The selecting process can re-arrange or double elements at the same time:</p>

<pre>
(select L 2 2 1 1) → (c c b b)
</pre>

<h3>Filtering and differencing lists（リストのフィルタと差分）</h3>

<p>リストにフィルタをかけたり、指定した条件に合致する要素のみを取り出すこともできます：<br />Lists can be filtered, returning only those elements that meet a specific condition:</p>

<pre>
(filter (fn(x) (&lt; 5 x)) '(1 6 3 7 8))    → (6 7 8)
(filter symbol? '(a b 3 c 4 "hello" g)) → (a b c g)
(difference '(1 3 2 5 5 7) '(3 7)) → (1 2 5)
</pre>

<p>最初の例は、次のように簡略して書くこともできます：<br />The first example could be written more concisely, as follows:</p>

<pre>
(filter (curry &lt; 5) '(1 6 3 7 8))
</pre>

<p>関数 <tt>curry</tt> は、二つの引数用関数を一つの引数用関数にします：<br />The <tt>curry</tt> function makes a one argument function out of a two argument function:</p>

<pre>
(curry &lt; 5) → (lambda (_x) (&lt; 5 _x))
</pre>

<p><tt>curry</tt> により、二つの引数を取る関数を簡単に一つの引数を取る述語に変換できます。<br />With <tt>curry</tt>, a function taking two arguments can be quickly converted into a predicate taking one argument.</p>

<h3>Changing list elements（リスト要素の変更）</h3>

<p><tt>setf</tt> は、<tt>nth</tt> や <tt>assoc</tt> 等で参照されるリスト要素を変更するのに使えます：<br /><tt>setf</tt> can be used to change a list element by referencing it with either <tt>nth</tt> or <tt>assoc</tt>:</p>

<pre>
; modify a list at an index
(set 'L '(a b (c d (e f) g) h i))
   
(setf (L 2 2 1) 'x) → x   
L → (a b (c d (e x) g) h i)
(setf (L 2 2) 'z) → z
L → (a b (c d z g) h i)
   
; modify an association list
(set 'A '((a 1) (b 2) (c 3)))
   
; using setf with assoc
(setf (assoc 'b A) '(b 22)) → (b 22)
A → ((a 1) (b 22) (c 3))
; using setf with lookup
(setf (lookup 'c A) 33) → 33
A → ((a 1) (b 22) (c 33))
</pre>

<h3>The anaphoric variable（アナフォリック変数）</h3>

<p>内部 <b>アナフォリック</b> システム変数 <tt>$it</tt> は、古いリスト要素を保持します。これを使って新しい要素を形成できます：<br />The internal <em>anaphoric</em> system variable <tt>$it</tt> holds the old list element. This can be used to configure the new one:</p>

<pre>
(set 'L '(0 0 0))
(setf (L 1) (+ $it 1)) → 1 ; the new value
(setf (L 1) (+ $it 1)) → 2
(setf (L 1) (+ $it 1)) → 4
L → '(0 3 0)
</pre>

<p>次の関数でアナフォリック <tt>$it</tt> が使えます：<tt>find-all</tt>、<tt>if</tt>、<tt>replace</tt>、<tt>set-ref</tt>、<tt>set-ref-all</tt>、<tt>setf setq</tt>。<br />The following functions use the anaphoric <tt>$it</tt>:&nbsp;
<tt>find-all</tt>, <tt>if</tt>, <tt>replace</tt>, <tt>set-ref</tt>, <tt>set-ref-all</tt> and <tt>setf setq</tt>.</p>

<h3>Replace in simple lists（単リストでの置換）</h3>

<p>文字列にも同じように使える <tt>Replace</tt> は、リスト中の要素を検索し、一括して置き換えます。<tt>match</tt> や <tt>unify</tt> と一緒に使って、複雑な検索パターンを指定できます。<tt>setf</tt> のように、置換式にはその置換内容の形成に古い要素内容を使えます。<br />Replace, which can also be used on strings, can search for and replace multiple elements in a list at once. Together with <tt>match</tt> and <tt>unify</tt> complex search patterns can be specified. Like with <tt>setf</tt>, the replacement expression can use the old element contents to form the replacement.</p>

<pre>
(set 'aList '(a b c d e a b c d))
     
(replace 'b aList 'B) → (a B c d e a B c d)
</pre>

<p>関数 <tt>replace</tt> は、リスト要素の抽出に比較関数を使えます：<br />The function <tt>replace</tt> can take a comparison function for picking list elements:</p>

<pre>
; replace all numbers where 10 &lt; number
(set 'L '(1 4 22 5 6 89 2 3 24))
     
(replace 10 L 10 &lt;) → (1 4 10 5 6 10 2 3 10)
</pre>

<p>関数 <tt>match</tt> や <tt>unify</tt>を使えば、より複雑な選択基準を定義できます：<br />Using the built-in functions <tt>match</tt> and <tt>unify</tt> more complex selection criteria can be defined:</p>

<pre>
; replace only sublists starting with 'mary'
    
(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))
   
(replace '(mary *)  AL (list 'mary (apply + (rest $it))) match)
→ ((john 5 6 4) (mary 14) (bob 4 2 7 9) (jane 3))
    
; make sum in all expressions
    
(set 'AL '((john 5 6 4) (mary 3 4 7) (bob 4 2 7 9) (jane 3)))
   
(replace '(*) AL (list ($it 0) (apply + (rest $it))) match)
→ ((john 15) (mary 14) (bob 22) (jane 3))
    
$0 → 4  ; replacements made
    
; change only sublists where both elements are the same
    
(replace '(X X) '((3 10) (2 5) (4 4) (6 7) (8 8)) (list ($it 0) 'double ($it 1)) unify)
→ ((3 10) (2 5) (4 double 4) (6 7) (8 double 8))
    
$0 → 2  ; replacements made
</pre>

<p>置換中、<tt>$0</tt> やアナフォリック・システム変数 <tt>$it</tt> には、現時点で検出された式が入ります。<br />During replacements <tt>$0</tt> and the anaphoric system variable <tt>$it</tt> contain the current found expression.</p>

<p>置換制御文が実行された後、newLISP システム変数 <tt>$0</tt> には、置換された数が入ります。<br />After a replacement statement is executed the newLISP system variable <tt>$0</tt> contains the number of replacements made.</p>

<h3>Replace in nested lists（入れ子リストでの置換）</h3>

<p>XML を解析した産物である SXML のように、リストは時に入れ子になります。関数 <tt>ref-set</tt>、<tt>set-ref</tt>、<tt>set-ref-all</tt> は、入れ子リスト中の要素検出や全要素検出、そして、それらの置換に使えます。<br />Sometimes lists are nested, e.g. the SXML results from parsing XML. The functions <tt>ref-set</tt>, <tt>set-ref</tt> and <tt>set-ref-all</tt> can be used to find a single element or all elements in a nested list, and replace it or all.</p>

<pre>
(set 'data '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))
   
(set-ref 'monday data tuesday)
→ ((tuesday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))) 
</pre>

<p> <tt>set-ref-all</tt> は 見つかった要素をすべて置換するまで <tt>set-ref</tt> します。<br />The function <tt>set-ref-all</tt> does a <tt>set-ref</tt> multiple times, replacing all found occurrences of an element.</p>

<pre>
(set 'data '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))
   
(set-ref-all 'apples data "Apples")
→ ((monday ("Apples" 20 30) (oranges 2 4 9)) (tuesday ("Apples" 5) (oranges 32 1)))
</pre>

<p> <tt>find</tt> のように、<tt>replace</tt>、<tt>ref</tt>、<tt>ref-all</tt> は <tt>match</tt> や <tt>unify</tt> と一緒に使って、より複雑な検索表現が可能です。<br />Like <tt>find</tt>, <tt>replace</tt>, <tt>ref</tt> and <tt>ref-all</tt>, more complex searches can be expressed using <tt>match</tt> or <tt>unify</tt>:</p>

<pre>
(set 'data '((monday (apples 20 30) (oranges 2 4 9)) (tuesday (apples 5) (oranges 32 1))))
   
(set-ref-all '(oranges *) data (list (first $0) (apply + (rest $it))) match)
→ ((monday (apples 20 30) (oranges 15)) (tuesday (apples 5) (oranges 33)))
</pre>

<p>最後の例は、更新する式で <tt>$0</tt> が古い要素にアクセスする様子を示しています。 <tt>$0</tt> の代わりにアナフォリック・システム変数 <tt>$it</tt> を使うこともできます。<br />The last example shows how <tt>$0</tt> can be used to access the old list element in the updating expression. In this case the numbers for <tt>oranges</tt> records have been summed. Instead of <tt>$0</tt> the anaphoric system variable <tt>$it</tt> can also be used.</p>

<h3>Passing lists by reference（参照によるリストの渡し方）</h3>

<p>(数百以上の要素を持つ）大規模なリストを変更するために、ユーザー定義関数に渡さなければならない時があります。通常、newLISP はユーザー定義関数に全てのパラメータを値として渡します。しかし、次のコードでは、大規模なリストや文字列オブジェクトを参照で渡すのに使えるテクニックを紹介しています：<br />Sometimes a larger list (more than a few hundred elements) must be passed to a user-defined function for elements in it to be changed. Normally newLISP passes all parameters to user-defined functions by value. But the following snippet shows a technique that can be used to pass a bigger list or string object by reference:</p>

<pre>
(set 'data:data '(a b c d e f g h))
   
(define (change db i value)
    (setf (db i) value))
   
(change data 3 999) → d
   
data:data → '(a b c 999 d e f g h)
</pre>

<p>この例では、変数 <tt>data</tt> を保持する同名の <tt>data</tt> と名付けられたコンテキストにカプセル化されます。<br />In this example the list is encapsulated in a context named <tt>data</tt> holding a variable <tt>data</tt> with the same name.</p>

<p>newLISP では、関数が文字列やリストのパラメータを待ち受けている時、コンテキストを渡すことができ、その際、デフォルト・ファンクタとして解釈されます。<br />Whenever a function in newLISP looks for a string or list parameter, a context can be passed, which will then be interpreted as the default functor.</p>

<p>シンボルのよって参照されるリストやアレイに属するリストかアレイか要素を返す時、多くの組込関数は、リストのコピーではなく、//参照// を返します。これにより、リストの変更する際、組込関数を入れ子して使えます：<br />When returning a list or array or an element belonging to a list or array referenced by a symbol, many built-in functions return a //reference// to the list – not a copy. This can be used to nest built-in functions when modifying a list:</p>

<pre>
(set 'L '(r w j s r b))
   
(pop (sort L)) → b
   
L → (j r r s w)
</pre>

<h3>Variable expansion（変数展開）</h3>

<p>二つの関数がマクロ展開するのに利用できます：<tt>expand</tt> と <tt>letex</tt>。関数 <tt>expand</tt> には、三つの異なる構文パターンがあります。<br />Two functions are available to do macro-expansion: <tt>expand</tt> and <tt>letex</tt>. The <tt>expand</tt> function has three different syntax patterns.</p>

<p>シンボルに展開された値が入ります：<br />Symbols get expanded to their value:</p>

<pre>
; expand from one or more listed symbols
(set 'x 2 'a '(d e))
(expand '(a x (b c x)) 'x 'a)  → ((d e) 2 (b c 2))
</pre>

<p><tt>expand</tt> は、ラムダ式を構成する際または関数やマクロ（<tt>define-macro</tt> による fexpr）内で変数を展開する時に役立ちます：<br>（訳注： <a href="http://en.wikipedia.org/wiki/Fexpr">fexpr</a> とは、オペランドが評価されずに渡される関数）<br /><tt>expand</tt> is useful when composing lambda expressions or when doing variable expansion inside functions and function macros (fexpr with <tt>define-macro</tt>):</p>

<pre>
; use expansion inside a function
(define (raise-to power)
    (expand (fn (base) (pow base power)) 'power))
(define square (raise-to 2))
(define cube (raise-to 3))
(square 5)  → 25
(cube 5)    → 125
</pre>

<p><tt>expand</tt> は、連想リストを取ることができます：<br /><tt>expand</tt> can take an association list:</p>

<pre>
; expand from an association list
(expand '(a b c) '((a 1) (b 2)))                → (1 2 c)
(expand '(a b c) '((a 1) (b 2) (c (x y z))))    → (1 2 (x y z))
</pre>

<p>そして、連想リストの値部分を最初に評価することができます：<br />and the value part in associations can be evaluated first:</p>

<pre>
; evaluate the value parts in the association list before expansion
(expand '(a b) '((a (+ 1 2)) (b (+ 3 4))))      → ((+ 1 2) (+ 3 4))
(expand '(a b) '((a (+ 1 2)) (b (+ 3 4))) true) → (3 7)
</pre>

<p><tt>expand</tt> は単独であれ連想リストであれ展開式が指定されない時は、大文字で始まる変数に対して動作します。<br /><tt>expand</tt> does its work on variables starting with an uppercase letter when expansion variables have neither been specified stand-alone nor in an association list.</p>

<pre>
; expand from uppercase variables
(set 'A 1 'Bvar 2 'C nil 'd 5 'e 6)
(expand '(A (Bvar) C d e f))  → (1 (2) C d e f)
</pre>

<p>これを使って、前述の関数定義を短くできます。<br />Using this, a previous function definition can be made even shorter.</p>

<pre>
; use expansion from uppercase variables in function factories
(define (raise-to Power) 
    (expand (fn (base) (pow base Power))))
(define cube (raise-to 3)) → (lambda (base) (pow base 3))
(cube 4) → 64
</pre>

<p>関数 <tt>letex</tt> は <tt>expand</tt> のように動作しますが、展開シンボルは <tt>letex</tt> 式内でローカルになります。<br />The <tt>letex</tt> function works like <tt>expand</tt>, but expansion symbols are local to the <tt>letex</tt> expression.</p>

<pre>
; use letex for variable expansion
(letex ( (x 1) (y '(a b c)) (z "hello") ) '(x y z)) → (1 (a b c) "hello")
</pre>

<p>例では、<tt>letex</tt> 内の本体式：<tt>(x y z)</tt> が、評価されないようにクォートされていることに注意して下さい。<br />Note that in the example the body expression in <tt>letex</tt>: <tt>(x y z)</tt> is quoted to prevent evaluation.</p>

<h3>Destructuring nested lists（入れ子リストの変更)</h3>

<p>入れ子リストの内部変数を束縛するのに次の方法が使えます：<br />The following method can be used to bind variables to subparts of a nested list:</p>

<pre>
; uses unify together with bind for destructuring
(set 'structure '((one "two") 3 (four (x y z))))
(set 'pattern '((A B) C (D E))) ; unify needs uppercase for binding
(bind (unify pattern structure))
A → one
B → "two"
C → 3
D → four
E → (x y z)
</pre>

<br><center>&sect;</center><br>
<a name="toc-7"></a>
<h2>7. Program flow（プログラム・フロー）</h2>

<p>newLISP でのプログラムのフローは大部分が関数的ですが、ループや分岐構造を持つこともあり、通常のフローから脱出する <tt>catch</tt> と <tt>throw</tt> もあります。<br />Program flow in newLISP is mostly functional but it also has looping and branching constructs and a <tt>catch</tt> and <tt>throw</tt> to break out of the normal flow.</p>

<p>ループ式は、関数のように完結した動作をするか最後に評価された式を返すブロックになります。<br />Looping expressions as a whole behave like a function or block returning the last expression evaluated.</p>

<h3>Loops（ループ）</h3>

<p>伝統的なループ形式のほとんどが提供されています。ループ変数はループ内のローカル変数で、現在の名前空間またはコンテキスト内でダイナミック・スコープの規則に従って動作します。<br />Most of the traditional looping patterns are supported. Whenever there is a looping variable, it is local in scope to the loop, behaving according the rules of dynamic scoping inside the current name-space or context:</p>

<pre>
; loop a number of times
; i goes from 0 to N - 1
(dotimes (i N)
    ....
)
   
; demonstrate locality of i
(dotimes (i 3)
    (print i ":")
    (dotimes (i 3) (print i))
    (println)
)
   
→ ; will output
 0:012
 1:012
 2:012
   
; loop through a list
; takes the value of each element in aList
(dolist (e aList)
    ...
)
   
; loop through a string
; takes the ASCII or UTF-8 value of each character in aString
(dostring (e aString)
    ...
)
   
; loop through the symbols of a context in
; alphabetical order of the symbol name
(dotree (s CTX)
    ...
)
   
; loop from to with optional step size
; i goes from init to &lt;= N inclusive with step size step
; Note that the sign in step is irrelevant, N can be greater
; or less then init.
(for (i init N step)
    ...
)
   
; loop while a condition is true
; first test condition then perform body
(while condition
    ...
)
   
; loop while a condition is false
; first test condition then perform body
(until condition
    ...
)
   
; loop while a condition is true
; first perform body then test
; body is performed at least once
(do-while condition
    ...
)
   
; loop while a condition is false
; first perform body then test
; body is performed at least once
(do-until condition
    ...
)
</pre>

<p>ループ関数 <tt>dolist</tt>、<tt>dotimes</tt>、<tt>for</tt> は、引数オプションに脱出条件を取れることに着目して下さい。脱出条件が true に評価された時、ループを終了します：<br />Note that the looping functions <tt>dolist</tt>, <tt>dotimes</tt> and <tt>for</tt> can also take a break condition as an additional argument. When the break condition evaluates to true the loop finishes:</p>

<pre>
(dolist (x '(a b c d e f g) (= x 'e))
    (print x))
→ ; will output
 abcd
</pre>

<h3>Blocks（ブロック）</h3>

<p>ブロックは、連続して評価されるｓ式の集合体です。全てのループ構造は、条件式の後に本体としてブロック式を持つことになります。<br />Blocks are collections of s-expressions evaluated sequentially. All looping constructs may have expression blocks after the condition expression as a body.</p>

<p>ブロックは、begin 式で括って構成することもできます：<br />Blocks can also be constructed by enclosing them in a begin expression:</p>

<pre>
(begin
    s-exp1
    s-exp2
     ...
    s-expN)
</pre>

<p>ループ構造ではループ条件の後に begin を明示する必要はありません。<tt>begin</tt> は、たいてい <tt>if</tt> や <tt>cond</tt> 宣言文で式をブロック化するのに使われます。<br />Looping constructs do not need to use an explicit begin after the looping conditions. <tt>begin</tt> is mostly used to block expressions in <tt>if</tt> and <tt>cond</tt> statements.</p>

<p>関数 <tt>and</tt>、<tt>or</tt>、<tt>let</tt>、<tt>letn</tt>、<tt>local</tt> もブロックを形成できるので、ブロック化宣言文 <tt>begin</tt> を必要としません。<br />The functions <tt>and</tt>, <tt>or</tt>, <tt>let</tt>, <tt>letn</tt> and <tt>local</tt> can also be used to form blocks and do not require <tt>begin</tt> for blocking statements.</p>

<h3>Branching（分岐）</h3>

<pre>
(if condition true-expr false-expr)
   
;or when no false clause is present
(if condition true-expr)
   
;or unary if for (filter if '(...))
(if condition)
   
; more than one statement in the true or false
; part must be blocked with (begin ...)
(if (= x y)
    (begin
        (some-func x)
        (some-func y))
    (begin
        (do-this x y)
        (do-that x y))
)
 
; the when form can take several statements without
; using a (begin ...) block
(when condition
    exp-1
    exp-2
    ...
)
   
; unless works like (when (not ...) ...)
(unless condition
    exp-1
    exp-2
    ...
)
</pre>

<p>条件次第で、<tt>exp-true</tt> または <tt>exp-false</tt> の部分が評価され、返されます。<br />Depending on the condition, the <tt>exp-true</tt> or <tt>exp-false</tt> part is evaluated and returned.</p>

<p>if 式では、一個以上の <tt>condition/exp-true</tt> 対 をおいて <tt>cond</tt> のように使えます。<br />More than one <tt>condition/exp-true</tt> pair can occur in an if expression, making it look like a <tt>cond</tt>:</p>

<pre>
(if condition-1 exp-true-1
    condition-2 exp-true-2
    ...
    condition-n exp-true-n
    expr-false
)
</pre>

<p>最初に <tt>nil</tt> でなかった <tt>condition-i</tt> と対の <tt>exp-true-i</tt> が評価されて返されます。どの <tt>condition-i</tt> も <tt>true</tt> にならなかったなら、<tt>exp-false</tt> になります。<br />The first <tt>exp-true-i</tt> for which the <tt>condition-i</tt> is not <tt>nil</tt> is evaluated and returned, or the <tt>exp-false</tt> if none of the <tt>condition-i</tt> is <tt>true</tt>.</p>

<p><tt>cond</tt> は if の複数の条件形式のように動作しますが、各 <tt>condition-i</tt> <tt>exp-true-i</tt> 部分を括弧で囲む必要があります：<br /><tt>cond</tt>works like the multiple condition form of if but each part of <tt>condition-i</tt> <tt>exp-true-i</tt> must be braced in parentheses:</p>

<pre>
(cond
    (condition-1 exp-true-1 )
    (condition-2 exp-true-2 )
                ...
    (condition-n exp-true-n )
    (true exp-true)
)
</pre>

<h3>Fuzzy flow（ファジーなフロー）</h3>

<p> <tt>amb</tt> を使って、プログラム・フローを確率的なやり方で調整できます：<br />Using <tt>amb</tt> the program flow can be regulated in a probabilistic fashion:</p>

<pre>
(amb
    exp-1
    exp-2
    ...
    exp-n
)
</pre>

<p><tt>exp-1</tt> から <tt>exp-n</tt> の選択肢から確率 <tt>p = 1/n</tt> で一つの式が選択され、評価されます。結果は、amb 式から返されます。<br />One of the alternative expressions <tt>exp-1</tt> to <tt>exp-n</tt> is evaluated with a probability of <tt>p = 1/n</tt> and the result is returned from the amb expression.</p>

<h3>Flow with <tt>catch</tt> and <tt>throw</tt>（関数 <tt>catch</tt> と <tt>throw</tt> によるフロー）</h3>

<p>ループやブロック式を catch 式で取り囲めます。throw が評価された時、catch 式全体の戻り値として throw 式の値を返します。<br />Any loop or other expression block can be enclosed in a catch expression. The moment a throw expression is evaluated, the whole catch expression returns the value of the throw expression.</p>

<pre>
(catch
    (dotimes (i 10)
    (if (= i 5) (throw "The End"))
    (print i " "))
)
; will output
0 1 2 3 4
; and the return value of the catch expression will be
→ "The End"
</pre>

<p>複数の <tt>catch</tt> を入れ子できます。関数 <tt>catch</tt> は、エラーも補足可能です。詳細は、 //<a href="#toc-8">エラーの取り扱い方</a>// の章で見て下さい。<br />Several <tt>catch</tt> expressions can be nested. The function <tt>catch</tt> can also catch errors. See the chapter on //Error Handling// below.</p>

<h3>Leave loops with a break condition（脱出条件でループから離脱する）</h3>

<p><tt>dotimes</tt>、<tt>dolist</tt>、<tt>for</tt> を使って構成したループは、ループから早く抜けるための脱出条件を指定できます：<br />Loops built using <tt>dotimes</tt>, <tt>dolist</tt> or <tt>for</tt> can specify a break condition for leaving the loop early:</p>

<pre>
(dotimes (x 10 (&gt; (* x x) 9))
    (println x))
→
 0
 1
 2
 3
   
(dolist (i '(a b c nil d e) (not i))
    (println i))
→
 a
 b
 c
</pre>

<h3>Change flow with <tt>and</tt> or 'or'（演算子 <tt>and</tt> や <tt>or</tt> でフローを変える）</h3>

<p>Prolog 言語のプログラムのように、式の論理接続の結果次第でプログラム・フロー制御するのに論理 <tt>and</tt> と <tt>or</tt> が使えます：<br />Similar to programming in the Prolog language, the logical <tt>and</tt> and <tt>or</tt> can be used to control program flow depending on the outcome of expressions logically connected:</p>

<pre> 
(and
   expr-1
   expr-2
    ...
   expr-n)
</pre>

<p><tt>expr-i</tt> が <tt>nil</tt> または 空リスト <tt>()</tt> に評価されるか、<tt>expr-i</tt> がなくなるまで順に式が評価されていきます。最後に評価された式が <tt>and</tt> 式全体の戻り値になります。<br />Expressions are evaluated sequentially until one <tt>expr-i</tt> evaluates to <tt>nil</tt> or the empty list <tt>()</tt> or until all <tt>expr-i</tt> are exhausted. The last expression evaluated is the return value of the whole <tt>and</tt> expression.</p>

<pre>
(or
   expr-1
   expr-2
    ...
   expr-n)
</pre>

<p><tt>expr-i</tt> が <tt>nil</tt> でもなく、空リスト <tt>()</tt> でもなく評価されるか、<tt>expr-i</tt> がなくなるまで順に式が評価されていきます。最後に評価された式が <tt>or</tt> 式全体の戻り値になります。<br />Expressions are evaluated sequentially until one <tt>expr-i</tt> evaluates to <b>not</b> <tt>nil</tt> and not <tt>()</tt> or until all <tt>expr-i</tt> are exhausted. The last expression evaluated is the return value of the whole <tt>or</tt> expression.</p>

<br><center>&sect;</center><br>
<a name="toc-8"></a>
<h2>8. Error handling（エラーの取り扱い方）</h2>

<p>newLISP 式評価の際、いくつかの条件がエラー例外を起こします。エラーの全リストは、newLISP リファレンス・マニュアルを見て下さい。<br />Several conditions during evaluation of a newLISP expression can cause error exceptions. For a complete list of errors see the Appendix in the newLISP Reference Manual.</p>

<h3>newLISP errors（newLISP のエラー）</h3>

<p>newLISP のエラーは、関数呼び出す際に間違ったパラメータ数を供給したり、間違ったデータ型をパラメータに渡す等の誤った構文を使うプログラマや、存在しない関数を評価したりすることによって引き起こされます。<br />newLISP errors are caused by the programmer using the wrong syntax when invoking functions, supplying the wrong number of parameters or parameters with the wrong data type, or by trying to evaluate nonexistent functions.</p>

<pre>
; examples of newLISP errors
;
(foo foo)   → invalid function : (foo foo)
(+ "hello") → value expected in function + : "hello"
</pre>

<h3>User defined errors（ユーザー定義エラー）</h3>

<p>ユーザー・エラーは、関数 throw-error を使って引き起こされるエラー例外です：<br />User errors are error exceptions thrown using the function throw-error:</p>

<pre>
; user defined error
;
(define (double x)
    (if (= x 99) (throw-error "illegal number"))
    (+ x x)
)
   
(double 8)   → 16
(double 10)  → 20
(double 99)
→
user error : illegal number
called from user defined function double
</pre>

<h3>Error event handlers（エラー・イベント・ハンドラ）</h3>

<p>newLISP エラーとユーザー定義エラーは、イベント・ハンドラを定義する関数 error-event を使って捕捉されます。<br />newLISP and user defined errors can be caught using the function error-event to define an event handler.</p>

<pre>
; define an error event handler
;
(define (MyHandler)
    (println  (last (last-error))  " has occurred"))
   
(error-event 'MyHandler)
   
(foo) → ERR: invalid function : (foo) has occurred 
</pre>

<h3>Catching errors（エラーの補足）</h3>

<p>より細やかで特殊なエラー処理は、関数補足の特殊構文を使って実現されます。<br />A finer grained and more specific error exception handling can be achieved using a special syntax of the function catch.</p>

<pre>
(define (double x)
    (if (= x 99) (throw-error "illegal number"))
    (+ x x))
</pre>

<p>第二パラメータを持つ catch を使って、システム・エラーとユーザー定義エラーの両方を捕捉できます：<br />catch with a second parameter can be used to catch both system and user-defined errors:</p>

<pre>
(catch (double 8) 'result) → true
result → 16
(catch (double 99) 'result) → nil
(print result)
 →
user error : illegal number
called from user defined function double
    
(catch (double "hi") 'result) → nil
(print result)
→
value expected in function + : x
called from user defined function double
</pre>

<p>catch 式はエラー例外が起らなかった時 true を返し、式の結果は第二パラメータに指定されたシンボル <tt>result</tt> に見い出せます。<br />The catch expression returns true when no error exception occurred, and the result of the expression is found in the symbol <tt>result</tt> specified as a second parameter.</p>

<p>エラー例外が起こると捕捉され、catch は nil を返します。この場合、シンボル <tt>result</tt> にはエラー・メッセージが入ります。<br />If an error exception occurs, it is caught and the catch clause returns nil. In this case the symbol <tt>result</tt> contains the error message.</p>

<h3>Operating system errors（オペレーティング・システム・エラー）</h3>

<p>ある種のエラーはオペレーティング・システム・レベルで発生し、newLISP では捕捉できませんが、関数 <tt>sys-error</tt> を使って調べることができます。例えば、ファイル・オープンの失敗は次のような異なる原因を持ちます：<br />Some errors originating at operating system level are not caught by newLISP, but can be inspected using the function <tt>sys-error</tt>. For example the failure to open a file could have different causes:</p>

<pre>
; trying to open a nonexistent file
(open "blahbla" "r")  →  nil
(sys-error)           →  (2 "No such file or directory")
   
   
; to clear errno specify 0
(sys-error 0)         →  (0 "Unknown error: 0")
</pre>

<p>異なる UNIX プラットフォームでは、戻り値の数値が異なります。お使いのプラットフォームの <tt>/usr/include/sys/errno.h</tt> ファイルを調べて見て下さい。<br />Numbers returned may be different on different Unix platforms. Consult the file <tt>/usr/include/sys/errno.h</tt> on your platform.</p>

<br><center>&sect;</center><br>
<a name="toc-9"></a>
<h2>9. Functions as data（データとしての関数）</h2>

<h3>Manipulate after definition（定義後に操作する）</h3>

<pre>
(define (double x) (+ x x))
→ (lambda (x) (+ x x))
    
(first double) → (x)
(last double)  → (+ x x)
    
; make a fuzzy double
(setf (nth 1 double) '(mul (normal x (div x 10)) 2))
    
(double 10) → 20.31445313
(double 10) → 19.60351563
</pre>

<p>newLISP のラムダは、演算子でもシンボルでもなく、どちらかというと、ｓ式やリスト属性の特殊な形態です：<br />lambda in newLISP is not an operator or symbol, but rather a special s-expression or list attribute:</p>

<pre>
(first double) → (x)   ; not lambda
</pre>

<p>ｓ式のラムダ属性は、<tt>append</tt> だと右側連結で：<br />The lambda attribute of an s-expression is right-associative in <tt>append</tt>:</p>

<pre>
(append (lambda) '((x) (+ x x))) → (lambda (x) (+ x x))
; or shorter
(append (fn) '((x) (+ x x))) → (lambda (x) (+ x x))
    
(set 'double (append (lambda) '((x) (+ x x)))
    
(double 10) → 20
</pre>

<p>cons を使えば、左連結です：<br />and left-associative when using cons:</p>

<pre>
(cons '(x) (lambda) → (lambda (x))
</pre>

<p>newLISP のラムダ式は、<a href="http://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88">第一級オブジェクト</a>特性を決して失いません。<br />Lambda expressions in newLISP never lose their first class object property.</p>

<p><tt>lambda</tt> という単語は <tt>fn</tt> に省略でき、式を読みやすく、かつ、短くするので、関数を map や apply する時、便利です。<br />The word <tt>lambda</tt> can be abbreviated as <tt>fn</tt>, which is convenient when mapping or applying functions to make the expression more readable and shorter to type.</p>

<h3>Mapping and applying（map と apply の仕方）</h3>

<p>（訳注：<tt>map</tt> を使えば、）関数や演算子がデータのリストに一括で適用され、結果はリストとして返されます：<br />Functions or operators can be applied to a list of data at once and all results are returned in a list</p>

<pre>
(define (double (x) (+ x x))
     
(map double '(1 2 3 4 5)) → (2 4 6 8 10)
</pre>

<p>（訳注：<tt>apply</tt> を使えば、）関数をリスト中にあるパラメータに適用できます：<br />Functions can be applied to parameters occurring in a list:</p>

<pre>
(apply + (sequence 1 10)) → 55
</pre>

<h3>Functions making functions（関数を作る関数）</h3>

<p>ここでは、式がパラメータとして渡されます：<br />Here an expression is passed as a parameter:</p>

<pre>
; macro expansion using expand
(define (raise-to power)
    (expand (fn (base) (pow base power)) 'power))
     
; or as an alternative using letex
(define (raise-to power)
    (letex (p power) (fn (base) (pow base p))))
     
(define square (raise-to 2))
     
(define cube (raise-to 3))
     
(square 5)   → 25
(cube 5)     → 125
</pre>

<p>二つの引数を取る関数を一つの引数を取る関数するために、組込関数 <tt>curry</tt> が使えます。<br />The built-in function <tt>curry</tt> can be used to make a function taking one argument from a function taking two arguments.</p>

<pre>
(define add-one (curry add 1))  → (lambda () (add 1 ($args 0)))
     
(define by-ten (curry mul 10))  → (lambda () (mul 10 ($args 0)))
   
(add-one 5)    → 6
     
(by-ten 1.23)  → 12.3
</pre>

<p>'curry 化'されるパラメータは、常に元の関数の第一パラメータになることに注意して下さい。<br />Note that the 'curried' parameter is always the first parameter of the original function.</p>

<h3>Functions with memory（メモリを持つ関数）</h3>

<p>newLISP は、名前空間 context を使って、ローカルな状態変数を生成できます：<br />newLISP can create local state variables using a name-space context:</p>

<pre>
; newLISP generator

(define (gen:gen)
    (setq gen:sum 
    (if gen:sum (inc gen:sum) 1)))

; this could be written even shorter, because
; 'inc' treats nil as zero

(define (gen:gen)
    (inc gen:sum))

(gen) &rarr; 1
(gen) &rarr; 2 
(gen) &rarr; 3
</pre>

<p>この例では、デフォルト・ファンクタ&mdash;&mdash;関数名と名前空間の名前が同じ&mdash;&mdash;を使っていて、通常関数のような形になっています。この名前空間内には、他の関数も追加できます。例えば sum の初期化用とか。<br />The example uses a default functor &mdash; functions name equals names-space name &mdash;
to give it the appearance of a normal function. Other functions could be added to the
namespace, e.g. for initializing the sum.</p>

<pre>
(define (gen:init x)
    (setq gen:sum x))

(gen:init 20) &rarr; 20

(gen) &rarr; 21
(gen) &rarr; 22
</pre>

<h3>Functions using self modifying code（自己改変コードを使った関数）</h3>

<p>newLISP において、ラムダ式のファースト・クラスの特筆すべき点は、自己改変コードを書くことができることです：<br />The first class nature of lambda expressions in newLISP makes 
it possible to write self modifying code:</p>

<pre>
;; sum accumulator
(define (sum (x 0)) (inc 0 x))

(sum 1)    &rarr; 1
(sum 2)    &rarr; 3
(sum 100)  &rarr; 103
(sum)      &rarr; 103

sum  &rarr; (lambda ((x 0)) (inc 103 x))
</pre>

<p>次の例は、<tt>expand</tt> を使って、自己改変ストリーム関数を作る関数を示しています：<br />The following example shows a function making a self modifying 
stream function using <tt>expand</tt> :</p>

<pre>
(define (make-stream lst)
    (letex (stream lst) 
        (lambda () (pop 'stream))))

(set 'lst '(a b c d e f g h))
(define mystream (make-stream lst))

(mystream)  &rarr; a
(mystream)  &rarr; b
(mystream)  &rarr; c
</pre>

<p><tt>pop</tt> は、リストと文字列の両方に作用するので、同じ関数生成器が文字列にも使えます：<br />Because <tt>pop</tt> works on both: lists and strings, the same 
function factory can be used for a string stream:</p>

<pre>
(set 'str "abcddefgh")
(define mystream (make-stream str))

(mystream)  &rarr; "a"
(mystream)  &rarr; "c"
</pre>

<br><center>&sect;</center><br>
<a name="toc-10"></a>
<h2>10. Text processing（テキスト処理）</h2>

<h3>Regular expressions（正規表現）</h3>

<p>newLISP では、正規表現を次の関数で使うことができます：<br />Regular expressions in newLISP can be used in a number of functions:</p>

<table  summary='table'>
<tr align='left'><th> function </th><th> function description </th></tr>
<tr><td> <tt>directory</tt></td><td>パターンにマッチした名前のファイルのリストを返す。<br /> Return a list of files whose names match a pattern.</td></tr>
<tr><td> <tt>ends-with</tt></td><td>文字列の最後がキー文字列またはパターンになっているかをテストする。<br /> Test if a string ends with a key string or pattern.</td></tr>
<tr><td> <tt>find</tt></td><td>パターンの位置を検出する。<br /> Find the position of a pattern.</td></tr>
<tr><td> <tt>find-all</tt></td><td>検出された全てのパターンのリストを集める。<br /> Assemble a list of all patterns found.</td></tr>
<tr><td> <tt>parse</tt></td><td>トークン間に検出されるパターンで文字列をトークンに分解する。<br /> Break a string into tokens at patterns found between tokens.</td></tr>
<tr><td> <tt>regex</tt></td><td>パターンを検出し、検出された部分パターンのリストをオフセットと長さと共に返す。<br /> Find patterns and returns a list of all sub patterns found, with offset and length.</td></tr>
<tr><td> <tt>replace</tt></td><td>検出されたパターンをパターン自身を入力するユーザー定義関数を使って置き換える。<br /> Replace found patterns with a user defined function, which can take as input the patterns themselves.</td></tr>
<tr><td> <tt>search</tt></td><td>ファイル中のパターンを検索する。<br /> Search for a pattern in a file.</td></tr>
<tr><td> <tt>starts-with</tt></td><td>文字列の先頭がキー文字列またはパターンになっているかをテストする。<br /> Test if a string starts with a key string or pattern.</td></tr>
</table>
<p>関数 find、regex、replace、search は、パターン・マッチした結果をシステム変数 $0 から $15 に保存します。詳細は、newLISP ユーザー・マニュアルを見て下さい。<br />The functions find, regex, replace and search store pattern matching results in the system variables $0 to $15. See the newLISP Users Manual for details.</p>

<p>次の段落では、テキストの走査やトークン化によく使われるアルゴリズムを紹介しています。<br />The following paragraphs show frequently-used algorithms for scanning and tokenizing text.</p>

<h3>Scanning text（テキストの走査）</h3>

<p>関数 <tt>replace</tt> は、正規表現パターンと一緒に使って、テキストを走査するのに使えます。この場合のパターンは、走査するトークンを表現します。トークンが見つかると、それはリストに push されます。この作業は、<tt>replace</tt> の置き換え式部分でなされます。この例では、ウェブ・ページ上にリンクされていた全ファイルをセーブします。<br />The <tt>replace</tt> function, together with a regular expression pattern, can be used to scan text. The pattern in this case describes the tokens scanned for. As each token is found, it is pushed on a list. The work is done in the replacement expression part of <tt>replace</tt>. This example saves all files linked on a web page:</p>

<pre>
#!/usr/bin/newlisp

; tokenize using replace with regular expressions
; names are of the form &lt;a href="example.lsp"&gt;example.lsp&lt;/a&gt;
   
(set 'page (get-url "http://newlisp.digidep.net/scripts/"))
(replace {&gt;(.*lsp)&lt;} page (first (push $1 links)) 0) ; old technique
;(set 'links (find-all {&gt;(.*lsp)&lt;} page $1)) ; new technique
  
(dolist (fname links)
   (write-file fname (get-url (append "http://newlisp.digidep.net/scripts/" fname)))
   (println "-&gt;" fname))

(exit)
</pre>

<p>クォート (<tt>"</tt>) や正規表現で特別の意味を持つ他の文字をエスケープしなくて済むように、正規表現パターンには波括弧 (<tt>{</tt>,<tt>}</tt>) が使われます。<br />Curly braces (<tt>{</tt>,<tt>}</tt>) are used in the regular expression pattern to avoid having to escape the quotes (<tt>"</tt>) or other characters that have special meanings in regular expressions.</p>

<p>次はより短い別の方法です。関数 <tt>find-all</tt> は、マッチした全ての文字列をリストに入れてくれます：<br />The following alternative technique is even shorter. The <tt>find-all</tt> function puts all matching strings into a list:</p>

<pre>
(set 'links (find-all {&gt;(.*lsp)&lt;} page $1)) ; new technique
</pre>

<p>見つかった部分式を使った作業を追加式として、<tt>find-all</tt> に指示できます：<br />In an additional expression <tt>find-all</tt> can be directed to do additional work with the sub expressions found:</p>

<pre>
(find-all {(new)(lisp)} "newLISPisNEWLISP" (append $2 $1) 1)
→ ("LISPnew" "LISPNEW")<br>
</pre>

<p>最後の例で、<tt>find-all</tt> は結果のリストに、見つかった部分式の順序を逆にしてくっつけています。<br />In the last example <tt>find-all</tt> appends the sub expressions found in reverse order before returning them in the result list.</p>

<p>テキストのトークン化の別の手法としては、<tt>parse</tt> を使います。<tt>replace</tt> と <tt>find-all</tt> ではトークンを定義したのに対して、<tt>parse</tt> ではトークンとトークンの間を正規表現で表現します：<br />Another technique for tokenizing text uses <tt>parse</tt>. Whereas with <tt>replace</tt> and <tt>find-all</tt> the regular expression defined the token, when using <tt>parse</tt>, the regex pattern describes the space between the tokens:</p>

<pre>
; tokenize using parse
(set 'str "1 2,3,4 5, 6 7  8")
(parse str {,\ *|\ +,*} 0)
→ ("1" "2" "3" "4" "5" "6" "7" "8")
</pre>

<p>（訳注：上記例で）parse パターンに波括弧を使わない時は、バックスラッシュを二重化する必要があります。各バックスラッシュの後にスペースがあることに注意して下さい。<br />Without the curly braces in the parse pattern, the backslashes would need to be doubled. Note that there is a space after each backslash.</p>

<h3>Appending strings（文字列の結合）</h3>

<p>文字列を追加したい時、新しい文字列を形成するのに append と join が使えます：<br />When appending strings append and join can be used to form a new string:</p>

<pre>
(set 'lstr (map string (rand 1000 100)))
→ ("976" "329" ... "692" "425")
   
; the wrong slowest way
(set 'bigStr "")
(dolist (s lstr)
    (set 'bigStr (append bigStr s)))
   
; smarter way - 50 times faster
;
(apply append lstr)
</pre>

<p>時には、上記の例のような文字列のリストを利用したい時に用意できません。このような場合、文字列が生成されている間、push を使ってリストに押し込めることができます。リストは join の引数として使え、最も早く、文字列をつなぎ合わせる方法です：<br />Sometimes strings are not readily available in a list like in the above examples. In this case push can be used to push strings on a list while they get produced. The list then can be used as an argument for join, making the fastest method for putting strings together from existing pieces:</p>

<pre>
; smartest way - 300 times faster
; join an existing list of strings
;
(join lstr) → "97632936869242555543 ...."
   
; join can specify a string between the elements
; to be joined
(join lstr "-") → "976-329-368-692-425-555-43 ...."
</pre>

<h3>Growing strings（文字列の追加）</h3>

<p>多くの場合、一つの場所で文字列を大きくしていくことがベストです。文字列の末尾に追加するのに、関数 <tt>extend</tt> が使えます。文字列の任意の場所に挿入するには、関数 <tt>push</tt> が使えます。<br />Often it is best to grow a string in place. The function <tt>extend</tt> can be used to append to a string at the end. The function <tt>push</tt> can be used to insert new content at any place in the string.</p>.

<pre>
; smartest way - much faster on big strings
; grow a string in place

; using extend
(set 'str "")
(extend str "AB" "CD")
str &rarr; "ABCD"

; extending in a place
(set 'L '(a b "CD" (e f)))
(extend (L 2) "E")
L &rarr; (a b "CDE" (e f))

; using push
(set 'str "")
(push "AB" str -1)
(push "CD" str -1)
str &rarr; "ABCD"
</pre>

<h3>Rearranging strings（文字列の再配置）</h3>

<p>文字列の文字の選択と再配置に、リストを使って要素を選択する関数 select が使えます：<br />The function select for selecting elements from lists can also be used to select and re-arrange characters from strings:</p>

<pre>
(set 'str "eilnpsw")
(select str '(3 0 -1 2 1 -2 -3)) → "newlisp"
   
; alternative syntax
(select str 3 0 -1 2 1 -2 -3) → "newlisp"
</pre>

<p>複数のインデックスを定数ではなく、変数で指定したい時、第二構文が役立ちます。<br />The second syntax is useful when indexes are specified not as constants but occur as variables.</p>

<h3>Modifying strings（文字列の変更）</h3>

<p>newLISP には、文字列を破壊的に変更する関数がいくつかあります：<br />newLISP has a variety of functions, which can destructively change a string:</p>

<table  summary='table'>
<tr align='left'><th> function </th><th> description </th></tr>
<tr><td> <tt>extend</tt></td><td>文字列に別の文字列を拡張する。<br /> Extend a string with another string.</td></tr>
<tr><td> <tt>push pop</tt></td><td>指定した位置の一つ以上の文字列を挿入または抜取る。<br /> Insert or extract one or more characters at a specific position.</td></tr>
<tr><td> <tt>replace</tt></td><td>文字列または文字列パターンの出現を全て文字列で置き換える。<br /> Replace all occurrences of a string or string pattern with a string.</td></tr>
<tr><td> <tt>setf</tt></td><td>文字列中の一文字を一つ以上の文字で置き換える。<br /> Replace a character in a string with one or more characters.</td></tr>
</table>
<p><tt>replace</tt> は、置換文字列に空文字列 <tt>""</tt> を指定することで、文字列や文字列パターンの出現を全て削除できます。<br /><tt>replace</tt> can also be used to remove all occurrences of string or string pattern when specifying an empty string <tt>""</tt> as replacement.</p>

<p>UTF-8 版 newLISP において <tt>nth</tt> や暗黙のインデックス機能で文字列を指定する時、文字列は<b>バイト</b>境界ではなく、<b>文字単位</b>でアドレスされます。UTF-8 文字には１バイト以上が含まれます。<br />When indexing strings with either <tt>nth</tt> or implicit indexing, the string is addressed at <em>character</em> rather than <em>byte</em> boundaries to work correctly on UTF-8 enabled versions of newLISP. A UTF-8 character can contain more than one byte.</p>

<br><center>&sect;</center><br>
<a name="toc-11"></a>
<h2>11. Dictionaries and hashes（辞書とハッシュ）</h2>

<h3>Hash-like key → value access（ハッシュ・ライクの　キー → 値　アクセス）</h3>

<p>newLISP は、関数 <tt>sym</tt> と関数 <tt>context</tt> の特殊構文でシンボルを生成し、操作する機能を持っています。newLISP の古い版では、これらの関数はハッシュ・ライク生成をプログラムし、キー・値ペアをアクセスするのに使われました。現在では、名前空間コンテキストの <b>デフォルト・ファンクタ</b> を使う、より簡潔で便利な方法が利用できます：<br />newLISP has functions to create and manipulate symbols using the functions <tt>sym</tt> and a special syntax of the function <tt>context</tt>. In older versions of newLISP, these functions were used to program hash-like creation and access of key-value pairs. Now a shorter and more convenient method is available, using the un-initialized <tt>default functor</tt> of a namespace context:</p>

<pre>
(define Myhash:Myhash) ; establish the namespace and default functor
</pre>

<p>上記方法の代わりに、あらかじめ定義された名前空間であるデフォルト・ファンクタの <tt>Tree</tt> を<a href="http://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9">インスタンス</a>生成に使えます：<br />As an alternative to the above methods, the predefined namespace and default functor <tt>Tree</tt> can be used to instantiate a new one:</p>

<pre>
(new Tree 'Myhash)
</pre>

<p>どちらの方法も、同じ結果を生成しますが、二つ目の方法はデフォルト・ファンクタ <tt>Myhash:Myhash</tt> を変更から保護します。<br />Both methods produce the same result, but the second method also protects the default functor <tt>Myhash:Myhash</tt> from change.</p>

<p><b>デフォルト・ファンクタ</b> は、所属する名前空間（コンテキスト）と同じ名前を持つシンボルです。この デフォルト・ファンクタ・シンボルに <tt>nil</tt> 以外の何も入っていない時、ハッシュ関数のように動作します：<br />A <em>default functor</em> is the symbol with the same name as the namespace (context) it belongs to. If this default functor symbol does not contain anything except <tt>nil</tt>, it works like a hash function:</p>

<pre>
(Myhash "var" 123) ; create and set variable/value pair
 
(Myhash "var") → 123 ; retrieve value
 
(Myhash "foo" "hello")
 
(Myhash "bar" '(q w e r t y))
 
(Myhash "!*@$" '(a b c))

; numbers can be used too and will be converted to strings internally

(Myhash 555 42)

(Myhash 555) → 42
</pre>

<p>ハッシュ・シンボルに <tt>nil</tt> をセットすることは、消去に相当します：<br />Setting a hash symbol to <tt>nil</tt> will effectively erase it:</p>

<pre>
(Myhash "bar" nil)
</pre>

<p>キーにはどんな文字列も使え、内部的には全てのキー文字列にアンダースコア文字を先付することで（訳注：シンボルに変換されて、かつ）、newLISP組込シンボルとの衝突を避けています。値には、どんな文字列、数値、newLISP のｓ式でも可能です。<br />The key can be any string; newLISP prevents symbol clashes with built-in newLISP symbols by prepending an underscore character (_) to all key strings internally. The value can be any string, number or any other newLISP s-expression.</p>

<p><tt>Myhash</tt> の名前空間を連想リストに変換できます：<br />The <tt>Myhash</tt> namespace can be transformed in an association list:</p>

<pre>
(Myhash) → (("!*@$" (a b c)) ("foo" "hello") ("var" 123))
</pre>

<p>また、<tt>Myhash</tt> の生の内容は、関数 <tt>symbols</tt> を使って見ることができます：<br />Or the raw contents of <tt>Myhash</tt> can be shown using the <tt>symbols</tt> function:</p>

<pre>
(symbols Myhash) → (Myhash:Myhash Myhash:_!*@$ Myhash:_foo Myhash:_var)
</pre>

<p>辞書は、既にある連想リストからの変換で生成可能です：<br />Dictionaries can be built by converting an existing association list:</p>

<pre>
(set 'aList '(("one" 1) ("two" 2) ("three")))
 
(Myhash aList)
 
(Myhash) → (("!*@$" (a b c)) ("foo" "hello") ("one" 1) ("three" nil) ("two" 2) ("var" 123))
</pre>

<h3>Saving and loading dictionaries（辞書のセーブとロード）</h3>

<p>辞書は、名前空間 <tt>Myhash</tt> の<a href="http://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%AA%E3%82%A2%E3%83%A9%E3%82%A4%E3%82%BA">シリアライズ</a>で簡単に保存できます：<br />The dictionary can be easily saved to a file by serializing the namespace <tt>Myhash</tt>:</p>

<pre>
(save "Myhash.lsp" 'Myhash)
</pre>

<p>名前空間の全てが <tt>Myhash.lsp</tt> ファイルに保存され、後で、newLISP に再読み込みできます：<br />The whole namespace is saved to the file <tt>Myhash.lsp</tt> and can be reloaded into newLISP at a later time:</p>

<pre>
(load "Myhash")
</pre>

<p>ハッシュは、関数 <tt>bayes-train</tt> と同様にコンテキストを生成することに注意して下さい。全てに文字列キーは、アンダースコアを先付されて、シンボルに変換されます。 <tt>bayes-train</tt> を使って生成された名前空間が、単語や統計を取り出すためにハッシュのように使えることを意味します。詳細は、マニュアルで関数 <tt>bayes-train</tt> を見て下さい。<br />Note that hashes create contexts similar to the <tt>bayes-train</tt> function. All string keys are prepended with an underscore and then transformed into a symbol. This means that namespaces created using <tt>bayes-train</tt> can be used like hashes to retrieve words and their statistics. See the <tt>bayes-train</tt> function in the manual for more detail.</p>

<br><center>&sect;</center><br>
<a name="toc-12"></a>
<h2>12. TCP/IP client server（TCP/IP クライアント・サーバー）</h2>

<h3>Open connection（接続オープン）</h3>

<p>この形式では、サーバーはクライアントが接続と切るまで、接続オープンを保ちます。その後、サーバー・ループは新しい <tt>net-accept</tt> に入ります：<br />In this pattern the server keeps the connection open until the client closes the connection, then the server loops into a new <tt>net-accept</tt>:</p>

<pre>
; sender listens
(constant 'max-bytes 1024)
(if (not (set 'listen (net-listen 123)))
    (print (net-error)))
(while (not (net-error))
    (set 'connection (net-accept listen)) ; blocking here
    (while (not (net-error))
         (net-receive connection message-from-client max-bytes)
         .... process message from client ...
         .... configure message to client ...
         (net-send connection message-to-client)) 
)
</pre>

<p>そして、クライアント側は：<br />and the client:</p>

<pre>
; client connects to sender
(if (not (set 'connection (net-connect "host.com" 123)))
    (println (net-error)))
; maximum bytes to receive
(constant 'max-bytes 1024)
; message send-receive loop
(while (not (net-error))
     .... configure message to server ...
     (net-send connection message-to-server)
     (net-receive connection message-from-server max-bytes)
     .... process message-from-server ...
)
</pre>

<h3>Closed transaction（トランザクション切断）</h3>

<p>この形式では、サーバーはメッセージ交換の各処理毎に接続を切ります：<br />In this pattern the server closes the connection after each transaction exchange of messages.</p>

<pre>
; sender
(while (not (net-error))
    (set 'connection (net-accept listen)) ; blocking here
    (net-receive connection message-from-client max-bytes)
        .... process message from client ...
        .... configure message to client ...
    (net-send connection message-to-client)
    (close connection)
)
</pre>

<p>そして、クライアントは送信側への再接続を試みます：<br />and the client again tries to connect to the sender:</p>

<pre> 
; client
(unless (set 'connection (net-connect "host.com" 123))
    (println (net-error))
    (exit))
; maximum bytes to receive
(constant 'max-bytes 1024)
  .... configure message to server ...
(net-send connection message-to-server)
(net-receive connection message-from-server max-bytes)
  .... process message-from-server ...
</pre>

<p>クライアント／サーバーのセット・アップ方法には異なる方法が数多くありますので、newLISP マニュアルの例も見て下さい。<br />There are many different ways to set up a client/server connection, see also the examples in the newLISP manual.</p>

<br><center>&sect;</center><br>
<a name="toc-13"></a>
<h2>13. UDP communications（UDP 通信）</h2>

<p>高速で TCP/IP の設定を必要としない<b>マルチ・キャスティング</b>を提供します。UDP は、プロトコルがパケット・シーケンスの整合性や全パケットの受信確認等をチェックをしないので、信頼性は劣ります。通常インターネット上で動作しなければ問題ありませんが、上手に管理されているローカル・ネットワーク上や機械制御を行う時には、問題になるかもしれません。メッセージ部分には簡潔でより明解なプロトコルが用いられています。<br />They are fast and need less setup than TCP/IP and offer <tt>multi casting</tt>. UDP is also less reliable because the protocol does less checking, i.e. of correct packet sequence or if all packets are received. This is normally no problem when not working on the Internet but in a well controlled local network or when doing machine control. A simple more specific protocol could be made part of the message.</p>

<h3>Open connection（接続オープン）</h3>

<p>この例では、サーバーは接続オープンを保持します。net-listen、net-receive-from、net-send-to での UDP 通信は受信中、ブロックできます。<br />In this example the server keeps the connection open. UDP communications with net-listen, net-receive-from and net-send-to can block on receiving.</p>

<p>クライアントとサーバーはどちらも、<tt>net-listen</tt> を <tt>"udp"</tt> オプションで使うことに注意して下さい。この場合、<tt>net-listen</tt> はアドレスをソケットに束縛するためにのみ使われ、接続の待ち受けには使われません。サーバーは複数のクライアントからのメッセージを受け取ります。関数 <tt>net-send-to</tt> は、送信アドレスを受信したメッセージから取り出しています。<br />Note that both, the client and server use <tt>net-listen</tt> with the <tt>"udp"</tt> option. In this case <tt>net-listen</tt> is used only for binding the socket to the address, it is not used for listening for a connection. The server could receive messages from several clients. The <tt>net-send-to</tt> function extracts the target address from the message received.</p>

<p>送信側は：<br />The sender:</p>

<pre>
; sender
(set 'socket (net-listen 10001 "localhost" "udp"))
(if socket (println "server listening on port " 10001)
   (println (net-error)))
(while (not (net-error))
    (set 'msg (net-receive-from socket 255))
    (println "-&gt; " msg)
    (net-send-to (first (parse (nth 1 msg) ":"))
                 (nth 2 msg) (upper-case (first msg)) socket))
(exit)
</pre>

<p>そして、受信側は：<br />and the client:</p>

<pre>
(set 'socket (net-listen 10002 "" "udp"))
(if (not socket) (println (net-error)))
(while (not (net-error))
    (print "enter something -&gt; ")
    (net-send-to  "127.0.0.1" 10001 (read-line) socket)
    (net-receive socket buff 255)
    (println "=&gt; " buff))
(exit)
</pre>

<h3>Closed transaction（トランザクション切断）</h3>

<p>この形式は、時々、ハードウェアや機器の制御に使われます。セット・アップは必要なく、送信用に一つの関数、受信用に別の一つがあるだけです。<br />This form is sometimes used for controlling hardware or equipment. No setup is required, just one function for sending, another one for receiving.</p>

<pre>
; wait for data gram with maximum 20 bytes
(net-receive-udp 1001 20)
; or
(net-receive-udp 1001 20 5000000)  ; wait for max 5 seconds
; the sender
(net-send-udp "host.com" 1001 "Hello")
</pre>

<p>受信端で指定されたバイトより多くまたは少なく送信された時、Win32 と Unix は異なる振る舞いを示します。<br />Win32 and Unix's show different behavior when sending less or more bytes than specified on the receiving end.</p>

<h3>Multi-cast communications（マルチキャスト通信）</h3>

<p>この構成でサーバーは、関数 net-listen を使っているマルチキャスト・アドレス範囲の一つに入ります。<br />In this scheme the server subscribes to one of a range of multi cast addresses using the net-listen function.</p>

<pre>
; example server
(net-listen 4096 "226.0.0.1" "multi") → 5
(net-receive-from 5 20)
 
; example client I
(net-connect "226.0.0.1" 4096 "multi") → 3
(net-send 3 "hello")
; example client II
(net-connect "" 4096 "multi") → 3
(net-send-to "226.0.0.1" 4096 "hello" 3)
</pre>

<p>この例の接続は <tt>net-receive</tt> 上でブロックしますが、<tt>net-select</tt> や <tt>net-peek</tt> と使えば、ブロックされずに済みます。<br />The connection in the example is blocking on <tt>net-receive</tt> but could be de-blocked using <tt>net-select</tt> or <tt>net-peek</tt></p>

<br><center>&sect;</center><br>
<a name="toc-14"></a>
<h2>14. Non-blocking communications（ノン・ブロッキング通信）</h2>

<h3>Using <tt>net-select</tt>（関数<tt>net-select</tt>の使い方）</h3>

<p>前述の全ての形式で、クライアントは受信時にブロックします。ブロックしない通信には net-select 呼び出しを使うことができます。<br />In all previous patterns the client blocks when in receive. The net-select call can be used to unblock communications:</p>

<pre> 
; optionally poll for arriving data with 100ms timeout
(while (not (net-select connection "r" 100000))
    (do-something-while-waiting ...))
 
(net-receive...)
</pre>

<p><tt>connection</tt> は接続ソケット用の一つの数か様々なソケット上で待ち状態にある数のリストです。<br /><tt>connection</tt> can be a single number for a connection socket or a list of numbers to wait on various sockets.</p>

<h3>Using 'net-peek'（関数net-peek の使い方）</h3>

<p><tt>net-peek</tt> は未読み取りの文字数を返します。<br /><tt>net-peek</tt> returns the number of characters pending to read.</p>

<pre>
(while ( = (net-peek aSock) 0)
    (do-something-while-waiting ...))
(net-receive...)
</pre>

<br><center>&sect;</center><br>
<a name="toc-15"></a>
<h2>15. Controlling other applications（外部アプリケーション制御）</h2>

<h3>Using <tt>exec</tt>（関数<tt>exec</tt>の使い方）</h3>

<p>これは、一コマンドを実行して結果を受け取る、短いやりとりに適した方法です。<br />This method is only suited for short exchanges, executing one command and receiving the output.</p>

<pre>
> (exec "ls *.c")
("newlisp.c" "nl-debug.c" "nl-filesys.c" "nl-import.c" "nl-list.c" "nl-liststr.c" 
 "nl-math.c" "nl-matrix.c" "nl-sock.c" "nl-string.c" "nl-symbol.c" "nl-utf8.c" "nl-web.c" 
 "nl-xml-json.c" "pcre-chartables.c" "pcre.c" "unix-lib.c" "win-dll.c" "win-path.c" 
 "win-util.c")
> 
</pre>

<p>関数 <tt>exec</tt> は、Unix コマンド・ラインのユーティリティ <tt>ls</tt> にパイプ・プロセスを開き、標準出力（STDOUT）の各行を文字列のリストに集めます。<br />The <tt>exec</tt> function opens a process pipe for the Unix command-line utility <tt>ls</tt> and collects each line of STDOUT into a list of strings.</p>

<p>以下の例のほとんどが、アプリケーションを実行するのに <tt>process</tt> を使っています。この関数は、他のアプリケーションを実行した後、ブロックせず、すぐに戻ってきます。<br />Most following examples use <tt>process</tt> to launch an application. This function returns immediately after launching the other application and does not block.</p>

<p>以下のパターンに全てにおいてサーバーは自律的でなく、サーバーを起動して行単位の手順で通信するクライアントによって制御されています：<br />In all of the following patterns the server is not independent but controlled by the client, which launches the server and then communicates via a line oriented protocol:</p>

<pre>
     → launch server
     → talk to server
     ← wait for response from server
     → talk to server
     ← wait for response from server
          ...
</pre>

<p>時には、サーバーが準備できるまで待つために、クライアント側でスリープ時間が必要です。最初の例を除いて、これらのほとんどが、GTK-server [http://www.gtk-server.org www.gtk-server.org] からのエッセンスです。基本的なプログラム・ロジックは、他のアプリケーションでも同じでしょう。<br />Sometimes a sleep time is necessary on the client side to wait for the server to be ready loading. Except for the first example, most of these are condensed snippets from GTK-Server from [http://www.gtk-server.org www.gtk-server.org]. The basic program logic will be the same for any other application.</p>

<h3>STD I/O pipes（標準 I/O パイプ）</h3>

<p>関数 <tt>process</tt> には、実行するアプリケーションとの通信用に 2つのパイプを指定します。<br />The <tt>process</tt> function allows specifying 2 pipes for communications with the launched application.</p>

<pre>
; setup communications
(map set '(myin tcout) (pipe))
(map set '(tcin myout) (pipe))
(process "/usr/bin/wish" tcin tcout)
 
; make GUI
(write myout
[text]
wm geometry . 250x90
wm title . "Tcl/Tk and newLISP"
bind . &lt;Destroy&gt; {puts {(exit)}}
[/text])
 
; run event loop
(while (read-line myin)
    (eval-string (current-line))
)
</pre>

<p>これは、Unix コマンド・ライン・ユーティリティや言語との双方向通信時に時間のかかるセットアップに都合のよい方法です。一つのコマンドのやり取りには、関数 <tt>exec</tt> の方が簡潔に役目を果たします。<br />This is the preferred way to set up longer lasting, bidirectional communications with Unix command line utilities and languages. For one-command exchanges the <tt>exec</tt> function does the job shorter.</p>

<p>手の込んだ Tcl/Tk の例は、配布ソース中の <tt>examples/tcltk.lsp</tt> アプリケーションで見て下さい。<br />For a more elaborate Tcl/Tk example see the application <tt>examples/tcltk.lsp</tt> in the source distribution.</p>

<h3>Communicate via TCP/IP（TCP/IP 経由で通信する）</h3>

<pre>
; Define communication function
(define (gtk str , tmp)
    (net-send connection str)
    (net-receive connection tmp 64)
    tmp)
 
; Start the gtk-server
(process "gtk-server tcp localhost:50000")
(sleep 1000)
 
; Connect to the GTK-server
(set 'connection (net-connect "localhost" 50000))
(set 'result (gtk "gtk_init NULL NULL"))
(set 'result (gtk "gtk_window_new 0"))
               .....
</pre>

<h3>Communicate via named FIFO （名前付き FIFO 経由で通信する）</h3>

<p>最初に（特定のファイル・ノードのように見える） FIFO を用意して下さい：<br />Make a FIFO first (looks like a special file node):</p>

<pre>
(exec "mkfifo myfifo")
 
; or alternatively
 
(import "/lib/libc.so.6" "mkfifo")
(mkfifo "/tmp/myfifo" 0777)
 
; Define communication function
(define (gtk str)
	(set 'handle (open "myfifo" "write"))
	(write handle str)
	(close handle)
	(set 'handle (open "myfifo" "read"))
	(read handle tmp 20)
	(close handle)
tmp)
</pre>

<h3>Communicate via UDP（UDP 経由で通信する）</h3>

<p> "udp" オプション付待ち受け関数はソケットを物理アドレスに束縛しますが、実際には、TCP/IP を待ち受けないことに注意して下さい。<br />Note that the listen function with "udp" option just binds the sockets to a address/hardware but not actually listens as in TCP/IP.</p>

<pre>
; Define communication function
(define (gtk str , tmp)
(net-send-to "localhost" 50000 str socket)
(net-receive socket 'tmp net-buffer)
tmp)
 
; Start the gtk-server
(define (start)
	(process "gtk-server udp localhost:50000")
	(sleep 500)
	(set 'socket (net-listen 50001 "localhost" "udp")) )
 
(set 'result (gtk "gtk_init NULL NULL"))
 
(set 'result (gtk "gtk_window_new 0"))
.....
</pre>

<br><center>&sect;</center><br>
<a name="toc-16"></a>
<h2>16. Launching apps blocking（ブロッキングするアプリの起動）</h2>

<h3>Shell execution（シェルの実行）</h3>

<p>これは、newLISP のインターラクティブ・コマンド・ラインからシェルを走らせる必要があるプロセスをブロッキング状態で実行するためによく使われます：<br />This is frequently used from newLISP's interactive command line to execute processes in a blocking fashion, which need a shell to run:</p>

<pre>
(! "ls -ltr")
</pre>

<p>newLISP の式内ではなく、コマンド・ラインでのみ動作する別の形式もあります：<br />There is an interesting variant of this form working not inside a newLISP expression, but only on the command line:</p>

<pre>
!ls -ltr
</pre>

<p>コマンド・ラインでは、<tt>!</tt> は先頭でなければなりません。この形式は、VI エディタのシェル・エスケープのように動作します。newLISP コンソールから離れることなしに、エディタを呼び出したり、素早くシェルを起動したりするのに役立ちます。<br />The <tt>!</tt> should be the first character on the command line. This form works like a shell escape in the VI editor. It is useful for invoking an editor or doing quick shell work without completely leaving the newLISP console.</p>

<h3>Capturing std-out（標準出力の獲得）</h3>

<pre>
(exec "ls /") → ("bin" "etc" "home" "lib")
</pre>

<h3>Feeding std-in（標準入力への供給）</h3>

<pre>
(exec "script.cgi" cgi-input)
</pre>

<p>この例で <tt>cgi-input</tt> には、通常、ウェブ・サーバーからくるクエリ入力の文字列が入っています。この場合、出力はスクリーンに直接書かれ、newLISP には戻ってこないことに注意して下さい。他のアプリケーションとの双方向標準 I/O 通信には、プロセスとパイプを使って下さい。<br />In this example <tt>cgi-input</tt> could contain a string feeding a query input, normally coming from a web server. Note that output in this case is written directly to the screen, and cannot be returned to newLISP. Use process and pipe for two way std i/o communications with other applications.</p>

<br><center>&sect;</center><br>
<a name="toc-17"></a>
<h2>17. Semaphores, shared memory（セマフォ、共有メモリ）</h2>

<p>共有メモリ、セマフォ、プロセスは、たいてい一緒に動作します。セマフォは異なるプロセス・スレッドのタスクを同期させることができ、共有メモリはそれらの間の通信に使われます。<br />Shared memory, semaphores and processes work frequently together. Semaphores can synchronize tasks in different process threads and shared memory can be used to communicate between them.</p>

<p>次に、三つの手順が同時に動作するちょっと複雑な例を紹介します。<br />The following is a more complex example showing the working of all three mechanisms at the same time.</p>

<p>producer は、i = 0 から n - 1 までループし、各値を共有メモリに置きます。そして、それは consumer スレッドに取り出されます。セマフォは、データが準備できたかどうかの信号として使われます。<br />The producer loops through all n values from i = 0 to n - 1 and puts each value into shared memory where it is picked up by the consumer thread. Semaphores are used to signal that a data value is ready for reading.</p>

<p>セマフォと共有メモリを使ったプロセスの制御は速いですが、二つより多いプロセスを伴なう時は、エラーを起こしがちです。Cilk API を使って、プロセス間通信すれば、複数プロセスの制御が簡単になります。この件については、18 章と 19 章を見て下さい。<br />Although controlling processes with semaphores and shared memory is fast, it is also error prone, specially when more the two processes are involved. It is easier to control multiple processes using the Cilk API and messaging between processes. See chapters 18. and 19. for these topics.</p>

<pre>
#!/usr/bin/newlisp
# prodcons.lsp -  Producer/consumer
#
# usage of 'fork', 'wait-pid', 'semaphore' and 'share'
 
(when (= ostype "Windows")
    (println "this will not run on Windows OS")
    (exit))
 
(constant 'wait -1 'sig 1 'release 0)
 
(define (consumer n)
    (set 'i 0)
    (while (&lt; i n)
        (semaphore cons-sem wait)
        (println (set 'i (share data)) " &lt;-")
        (semaphore prod-sem sig))
    (exit))
 
(define (producer n)
    (for (i 1 n)
        (semaphore prod-sem wait)
        (println "-&gt; " (share data i))
        semaphore cons-sem sig))
    (exit))
 
(define (run n)
    (set 'data (share))
    (share data 0)
    (set 'prod-sem (semaphore)) ; get semaphores
    (set 'cons-sem (semaphore))
    (set 'prod-pid (fork (producer n))) ; start processes
    (set 'cons-pid (fork (consumer n)))
    (semaphore prod-sem sig) ; get producer started
    (wait-pid prod-pid) ; wait for processes to finish
    (wait-pid cons-pid) ;
    (semaphore cons-sem release) ; release semaphores
    (semaphore prod-sem release))
 
(run 10)
 
(exit)
</pre>

<br><center>&sect;</center><br>
<a name="toc-18"></a>
<h2>18. Multiprocessing and Cilk（多重処理と Cilk）</h2>

<p>マルチプロセッサ CPU 上では、オペレーティング・システムは、生成されたプロセスや子プロセスを最適な状態で異なるプロセッサ・コアに分配しています。newLISP は、プロセス起動の全作業と評価結果の同期された収集をおこなうシンプルな API を提供します。<a href="http://supertech.csail.mit.edu/cilk/">Cilk</a> API は、newLISP で <tt>spawn</tt>、<tt>sync</tt>、<tt>abort</tt> として実装されているたった 3 つの関数呼び出しからなります。<br />On multiprocessor CPUs the operating system will distribute processes and child processes created on different processor cores in an optimized fashion. newLISP offers a simple API which does all the work of launching processes and does the synchronized collection of evaluation results. The <a href="http://supertech.csail.mit.edu/cilk/">Cilk</a> API consists of only 3 function calls, implemented in newLISP as <tt>spawn</tt>, <tt>sync</tt> and <tt>abort</tt></p>

<p>v.10.1 以来、newLISP の<tt>message</tt> 関数は、親子プロセス間の通信が可能です。これについての詳細は、次の章  <b><a href="#toc-19">19. メッセージ交換</a></b> を見て下さい。<br />Since v.10.1 newLISP's <tt>message</tt> function enables communications between parent and child processes. For more details about this, see the next chapter <b>19. Message exchange</b>.</p>

<h3>Starting concurrent processes（並列処理の開始）</h3>

<pre>
; calculate primes in a range
(define (primes from to)
    (let (plist '())
    (for (i from to)
        (if (= 1 (length (factor i)))
        (push i plist -1)))
plist))
 
; start child processes
(set 'start (time-of-day))
 
(spawn 'p1 (primes 1 1000000))
(spawn 'p2 (primes 1000001 2000000))
(spawn 'p3 (primes 2000001 3000000))
(spawn 'p4 (primes 3000001 4000000))
 
; wait for a maximum of 60 seconds for all tasks to finish
(sync 60000) ; returns true if all finished in time
; p1, p2, p3 and p4 now each contain a lists of primes
</pre>

<p>この例は、素数を生成するタスクが小分けされ、並行処理される方法を示しています。全ての <tt>spawn</tt> 呼び出しはすぐに戻りますが、子プロセスが終了し、結果のリストが4つの変数 <tt>p1</tt> ～ <tt>p4</tt> として利用できるようになるまで、<tt>sync</tt> がブロックします。<br />The example shows how the task of generating a range of prime numbers can be organized for parallel processing by splitting the range into sub-ranges. All <tt>spawn</tt> calls will return immediately, but <tt>sync</tt> will block until all child processes have finished and the result lists are available in the four variables <tt>p1</tt> to <tt>p4</tt>.</p>

<h3>Watching progress（進捗の監視）</h3>

<p>指定されたタイムアウト値が全プロセス終了より短い時、<tt>sync</tt> は <tt>nil</tt> を返します。これは、進捗状況の監視に使えます：<br />When the timeout value specified is too short for all processes to finish, <tt>sync</tt> will return <tt>nil</tt>. This can be used to watch progress:</p>

<pre>
; print a dot after each 2 seconds of waiting
(until (sync 2000) (println "."))
</pre>

<p><tt>sync</tt> がパラメータ無しで呼ばれた時は、まだ実行中のプロセスの ID がリストで返ります。<br />When <tt>sync</tt> is called without parameters, it returns a list of still active process ids:</p>

<pre>
; show a list of pending process ids after
;each three-tenths of a second
(until (sync 300) (println (sync)))
</pre>

<h3>Invoking spawn recursively（spawn の再帰的呼び出し）</h3>

<pre>
(define (fibo n)
    (let (f1 nil f2 nil)
        (if (&lt; n 2) 1
            (begin
                (spawn 'f1 (fibo (- n 1)))
                (spawn 'f2 (fibo (- n 2)))
                (sync 10000)
                (+ f1 f2)))))
 
(fibo 7)  → 21
</pre>
（訳注：<tt>spawn</tt> の引数のシンボルが <tt>local</tt>（または <tt>let</tt>）で定義されていることに要注意かも）
<h3>Event driven notification（イベント駆動通知）</h3>

<p><tt>spawn</tt> で起動されたプロセスが終了する時、<tt>sync</tt> 宣言文で指定された <tt>inlet</tt> 関数が呼び出されます。<br />When processes launched with <tt>spawn</tt> finish, an <tt>inlet</tt> function specified in the <tt>sync</tt> statement can be called.</p>

<pre>
(define (report pid)
    (println "process: " pid " has returned"))
 
; call the report function, when a child returns
(sync 10000 report)
</pre>

<br><center>&sect;</center><br>
<a name="toc-19"></a>
<h2>19. Message exchange（メッセージ交換）</h2>

<p>親プロセスと <tt>spawn</tt> で開始した子プロセスはメッセージを交換できます。メッセージは、親から子プロセス、子プロセスから親のどちらの方向にも渡せます。親プロセスでメッセージを評価することを用いて、子プロセス同士間のメッセージ経路を制御するプロキシとして親プロセスを使えます。<br />Parent and child processes started with <tt>spawn</tt> can exchange messages. Messages flow either from the parent to child processes or from child processes to the parent. By means of evaluating messages in the parent process, the parent process can be used as a proxy routing messages between child peers.</p>

<p>newLISP の内部では親と子のプロセス間の二重メッセージ・キューとして UNIX ローカル・ドメイン・ソケットを使っています。キューの受信側が空の時、<tt>receive</tt> 呼び出しは <tt>nil</tt> を返します。同様にキューが満杯の時の <tt>send</tt> 呼び出しも <tt>nil</tt> を返します。ブロッキング動作に <tt>send</tt> と <tt>receive</tt> 宣言文を使うのにループ関数 <tt>until</tt> が使えます。<br />Internally newLISP uses UNIX local domain sockets for dual message queues between parent and child processes. When the receiving side of a queue is empty a <tt>receive</tt> call will return <tt>nil</tt>. Likewise when a queue is full, a <tt>send</tt> call will return <tt>nil</tt>. The looping function <tt>until</tt> can be used to make <tt>send</tt> and <tt>receive</tt> statements blocking.</p>

<h3>Blocking message sending and receiving（ブロッキングメッセージの送受信）</h3>

<pre>
     ; blocking sender
     (until (send pid msg))     ; true when a msg queued up
 
     ; blocking receiver
     (until (receive pid msg))  ; true after a msg is read
</pre>

<h3>Blocking message exchange（ブロッキング・メッセージ交換）</h3>

<p>親プロセスは、子プロセスの全ID でループし、<tt>(until (receive cpid msg))</tt> を使い、<tt>receive</tt> から未決のメッセージを待ちます。<tt>(sync)</tt> は<tt>spawn</tt> で開始した子プロセスの全IDを返します。
通知メッセージを探します。次の例では、メッセージ呼び出しはブロックされ、同期します。<br />The parent process loops through all child process IDs and uses the <tt>(until (receive cpid msg))</tt> form of <tt>receive</tt> to wait for pending messages. <tt>(sync)</tt> returns a list of all child PIDs from processes launched by <tt>spawn</tt>.</p>

<pre>
#!/usr/bin/newlisp 

; child process transmits random numbers
(define (child-process)
    (set 'ppid (sys-info -4)) ; get parent pid
    (while true
        (until (send ppid (rand 100))))
)

; parent starts 5  child processes, listens and displays
; the true flag enables usage of send and receive 

(dotimes (i 5) (spawn 'result (child-process) true))

(for (i 1 3)
    (dolist (cpid (sync)) ; iterate thru pending child PIDs
        (until (receive cpid msg))
        (print "pid:" cpid "-&gt;>" (format "%-2d  " msg)))
    (println)
)

(abort) ; cancel child-processes
(exit)
</pre>

<p>このような出力を生成します：<br />generates this output:</p>

<pre>
pid:53181-&gt;47  pid:53180-&gt;61  pid:53179-&gt;75  pid:53178-&gt;39  pid:53177-&gt;3
pid:53181-&gt;59  pid:53180-&gt;12  pid:53179-&gt;20  pid:53178-&gt;77  pid:53177-&gt;47
pid:53181-&gt;6   pid:53180-&gt;56  pid:53179-&gt;96  pid:53178-&gt;78  pid:53177-&gt;18
</pre>

<h3>Non Blocking message exchange（ノン・ブロッキング・メッセージ交換）</h3>

<p>子プロセスの送信も親プロセスの受信もどちらもブロックされません。可能な限り早いメッセージの送受信が行われます。全てのメッセージが配送されるという保証はありません。送信キューの大きさと親プロセスのメッセージ取り出し速度次第です。子プロセスの送信キューが満杯なら、<tt>(send ppid (rand 100))</tt> は失敗し、<tt>nil</tt> を返します。<br />Neither the sending child process nor the receiving parent process block. Each sends and receives messages as fast as possible. There is no guarantee that all messages will be delivered. It depends on the size of the sending queue and the speed of pick-up of messages by the parent process. If the sending queue for a child process is full, the <tt>(send ppid (rand 100))</tt> call will fail and return <tt>nil</tt>.</p>

<pre>
#!/usr/bin/newlisp

; child process transmits random numbers non-blocking
; not all calls succeed
(set 'start (time-of-day))
 
(define (child-process)
    (set 'ppid (sys-info -4)) ; get parent pid
    (while true
        (send ppid (rand 100)))
)
 
; parent starts 5  child processes, listens and displays
(dotimes (i 5) (spawn 'result (child-process) true))
 
(set 'N 1000)
 
(until finished
    (if (= (inc counter) N) (set 'finished true))
    (dolist (cpid (receive)) ; iterate thru ready child pids
        (receive cpid msg)
    (if msg (print "pid:" cpid "-&gt;" (format "%-2d  \r" msg))))
)
 
(abort) ; cancel child-processes
(sleep 300)
 
(exit)
</pre>

<h3>Message timeouts（メッセージのタイムアウト）</h3>

<p>メッセージ宣言文は、一定時間ブロックされます：<br />A messaging statement can be made to block for a certain time:</p>

<pre>
(define (receive-timeout pid msec)
    (let ( (start (time-of-day)) (msg nil))
        (until (receive pid msg)
            (if (&gt; (- (time-of-day) start) 1000) (throw-error "timeout")))
    msg)
)
; use it
    
(receive-timeout pid 1000)  ; return message or throw error after 1 second
</pre>

<p>この例では、ブロッキングは 1000ms 起こります。タイムアウトの実装には、多くの方法があります。<br />In this example blocking will occur for 1000 ms. Many methods exist to implement timeout behavior.</p>

<h3>Evaluating messages（メッセージの評価）</h3>

<p>メッセージは受信環境で評価される式を持つことができます。この方法で変数を評価環境に設定でき、メッセージを他のプロセスに送ることができます。次の例は、メッセージ・ルーターを実装しています：<br />Messages sent can contain expressions which can be evaluated in the recipient's environment. This way variables can be set in the evaluator's environment, and messages can be routed to other processes. The following example implements a message router:</p>

<pre>
#!/usr/bin/newlisp

; sender child process of the message
(set 'A (spawn 'result 
    (begin
        (dotimes (i 3)
            (set 'ppid (sys-info -4))
            /* the following statement in msg will be evaluated in the proxy */
            (set 'msg '(until (send B (string "greetings from " A))))
            (until (send ppid msg)))
        (until (send ppid '(begin 
            (sleep 200) ; make sure all else is printed
            (println "parent exiting ...\n")
            (set 'finished true))))) true)) 

; receiver child process of the message
(set 'B (spawn 'result 
    (begin
        (set 'ppid (sys-info -4))
        (while true
            (until (receive ppid msg))
            (println msg)
            (unless (= msg (string "greetings from " A))
                (println "ERROR in proxy message: " msg)))) true))

(until finished (if (receive A msg) (eval msg))) ; proxy loop

(abort)
(exit)
</pre>

<h3>Acting as a proxy（プロキシ動作）</h3>

<p>最後の例のプログラム式：<br />In the last example program the expression:</p>

<pre>
; content of message to be evaluated by proxy
(until (send B (string "greetings from " A)))
</pre>

<p>プログラム宣言文が子プロセスID A から親に送られ、そこで評価されて、子プロセス B に送るメッセージが生じます。親プロセスは子プロセスのとって、プロキシ代行者のように振舞います。<br />A programming statement sent from child process ID A to the parent, where it is evaluated, causing a message to be sent to child process B. The parent process acts as a proxy agent for the child process A.</p>

<pre>
; the set statement is evaluated in the proxy
(until (send ppid '(set 'finished true)))
</pre>

<p>式 <tt>(set 'finished true)</tt> が親に送られ、そこで評価されると、親の <tt>until</tt> ループは終了します。<br />The expression <tt>(set 'finished true)</tt> is sent to the parent where it gets evaluated and causes the parent's <tt>until</tt> loop to finish.</p>

<p>A プロセスの <tt>sleep</tt> 宣言文は、全ての受信メッセージが B で識別されるプロセスによって報告される前に、メッセージ <tt>"parent exiting ..."</tt> が現れないことを確実にします。<br />The <tt>sleep</tt> statement in the A process ensures that the <tt>"parent exiting ..."</tt> message does not appear before all received messages are reported by process identified with B.</p>

<br><center>&sect;</center><br>
<a name="toc-20"></a>
<h2>20. Databases and lookup tables（データベースとテーブル探索）</h2>

<p>数百に満たないエントリーの小さいテープルでは、連想リストが使えます。大規模なデータベースでは、11章で記述されている辞書とハッシュを使います。<br />For smaller tables of not more than a few hundred entries association lists can be used. For larger databases use dictionaries and hashes as described in <a href="#toc-11">chapter 11.</a></p>

<h3>Association lists（連想リスト）</h3>

<p>連想リストは、連想検索用に情報を保存する古典的な LISP のデータ構造です：<br />The association list is a classic LISP data structure for storing information for associative retrieval:</p>

<pre>
; creating association lists
; pushing at the end with -1 is optimized and
; as fast as pushing in front
 
(push '("John Doe" "123-5555" 1200.00) Persons -1)
(push '("Jane Doe" "456-7777" 2000.00) Persons -1)
.....
 
Persons →  (
("John Doe" "123-5555" 1200.00)
("Jane Doe" "456-7777" 2000.00) ...)
 
; access/lookup data records
(assoc "John Doe" Persons)
 
→ ("John Doe" "123-5555" 1200.00 male)
 
(assoc "Jane Doe" Persons)
 
→ ("Jane Doe" "456-7777" 2000.00 female)
</pre>

<p>newLISP は、表計算ソフトで使われるような lookup 関数を持っています。<tt>assoc</tt> と <tt>nth</tt> の組み合わせのように動作するこの関数は、連想を見つけ、同時に、データ・レコードの特定された要素を取り出します：<br />newLISP has a lookup function similar to what is used in spreadsheet software. This function which works like a combination of <tt>assoc</tt> and <tt>nth</tt> can find the association and pick a specific member of the data record at the same time:</p>

<pre>
(lookup "John Doe" Persons 0)   → "123-555"
(lookup "John Doe" Persons -1)  → male
(lookup "Jane Doe" Persons 1)   → 2000.00
(lookup "Jane Doe" Persons -2)  → 2000.00
 
; update data records
(setf (assoc "John Doe" Persons)
    '("John Doe" "123-5555" 900.00 male))
 
; replace as a function of existing/replaced data
(setf (assoc "John Doe" Persons) (update-person $it))
 
; delete data records
(replace (assoc "John Doe" Persons) Persons)
</pre>

<h3>Nested associations（入れ子の連想）</h3>

<p>連想のデータ部分が連想リストなら、入れ子の連想リストであって：<br />If the data part of an association is itself an association list, we have a nested association:</p>

<pre>
(set 'persons '(
    ("Anne" (address (country "USA") (city "New York")))
    ("Jean" (address (country "France") (city "Paris")))
))
</pre>

<p>関数 <tt>assoc</tt> の別の構文を使います：<br />A different syntax of the <tt>assoc</tt> function can be used to specify multiple keys:</p>

<pre>
; one key
(assoc "Anne" persons) → ("Anne" (address (country "USA") (city "New York")))
 
; two keys
(assoc '("Anne" address) persons) → (address (country "USA") (city "New York"))
 
; three keys
(assoc '("Anne" address city) persons) → (city "New York")
 
; three keys in a vector
(set 'anne-city '("Anne" address city))
(assoc anne-city persons) → (city "New York")
</pre>

<p>newLISP の <tt>FOOP</tt> (Functional Object Oriented Programming) オブジェクトでは、全てのキーが、例えば <tt>address</tt>, <tt>country</tt>, <tt>city</tt> のようなシンボルの時、単純な連想リストと入れ子の連想リストは同じフォーマットを持ちます。詳細は、ユーザー・マニュアルの "18. Functional-object oriented programming（関数的オブジェクト指向プログラミング）" の章を見て下さい。<br />When all keys are symbols, as is in <tt>address</tt>, <tt>country</tt> 
and <tt>city</tt>, simple and nested associations in newLISP have the same 
format as newLISP <tt>FOOP</tt> (Functional Object Oriented Programming) objects. 
See the users manual chapter "18. Functional object-oriented programming" for details.</p>

<h3>Updating nested associations（入れ子の連想の更新）</h3>

<p>単純及び入れ子連想リストの更新に関数 <tt>assoc</tt> と <tt>setf</tt> を使うことができます：<br />The functions <tt>assoc</tt> and <tt>setf</tt> can be used to update simple or nested associations:</p>

<pre>
(setf (assoc '("Anne" address city) persons) '(city "Boston")) → (city "New York")
</pre>

<p><tt>setf</tt> は、常に新たにセットされた要素を返します。<br /><tt>setf</tt> always returns the newly set element.</p>

<h3>Combining associations and hashes（連想結合とハッシュ）</h3>

<p>キーでアクセスするメモリ内データベースを形成するために、ハッシュと FOOP オブジェクトを組み合わせて使うことができます。<br />Hashes and FOOP objects can be combined to form an in-memory database with keyed access.</p>

<p>次の例は、データ・レコードがハッシュの名前空間に保存され、キーとして個人名を使いアクセスします。<br />In the following example, data records are stored in a hash namespace and access is with the name of the person as a key.</p>

<p><tt>setf</tt> と <tt>lookup</tt> を FOOP オブジェクトの更新に使います：<br /><tt>setf</tt> and <tt>lookup</tt> are used to update nested FOOP objects:</p>

<pre>
(new Tree 'Person)
(new Class 'Address)
(new Class 'City)
(new Class 'Telephone)
 
 
(Person "John Doe" (Address (City "Small Town") (Telephone 5551234)))
 
(lookup 'Telephone (Person "John Doe"))
(setf (lookup 'Telephone (Person "John Doe")) 1234567)
(setf (lookup 'City (Person "John Doe")) (lower-case $it))
 
(Person "John Doe") → (Address (City "small town") (Telephone 1234567))
</pre>

<br><center>&sect;</center><br>
<a name="toc-21"></a>
<h2>21. Distributed computing（分散処理）</h2>

<p>現在では多くのアプリケーションが、ネットワークを通していくつかのコンピュータで分散処理されているか、同一 CPU 上の数個のプロセッサで分散処理されています。あるいは、アプリケーションを分散処理する両方の方法が同時に使われています。<br />Many of todays applications are distributed on to several computers on the network or distributed on to several processes on one CPU. Often both methods of distributing an application are used at the same time.</p>

<p>newLISP は、多くの式を newLISP が走っている異なるネットワーク・ノードやプロセッサで並列評価する便宜をはかります。関数 <tt>net-eval</tt> は、評価する式を配布し、ブロッキングまたはイベント駆動のどちらの状況下でも結果を集めるという、他のノードと通信に必要な全ての作業を行ないます。<br />newLISP has facilities to evaluate many expressions in parallel on different network nodes or processes running newLISP. The <tt>net-eval</tt> function does all the work necessary to communicate to other nodes, distribute expressions for evaluation and collect results in either a blocking or event driven fashion.</p>

<p>関数 <tt>read-file</tt>, <tt>write-file</tt>, <tt>append-file</tt>, <tt>delete-file</tt> では、ファイル指定に URL を使えば、リモート・ノードのファイルのアクセスに使うこともできます。同様な方法で、関数 <tt>load</tt> と <tt>save</tt> は、リモート・ノードからのローダやリモート・ノードへのセーブに使えます。<br />The functions <tt>read-file</tt>, <tt>write-file</tt>, <tt>append-file</tt> and <tt>delete-file</tt> can also be used to access with files on remote nodes when using URLs in file specifications. In a similar way the functions <tt>load</tt> and <tt>save</tt> can be used to load and save code from and to remote nodes.</p>

<p>この機能を実装するために、newLISP は既存の HTTP プロトコルと newLISP コマンド・ライン動作を使います。これは、terminal、telnet あるいはウェブ・ブラウザのような標準 UNIX アプリケーションを使ってプログラムをデバックしたり、テストしたりできることを意味します。 また、newLISP で構築した分散アプリケーションを他のツールやプログラムに簡単に統合することを可能にします。例えば、Unix ユーティリティの <tt>netcat</tt> (<tt>nc</tt>) はリモートで式を評価するのに使え、ウェブ・ブラウザは newLISP サーバーの走っているノードからウェブページを取り出すのに使えます。<br />newLISP uses existing HTTP protocols and newLISP command line behavior to implement this functionality. This means that programs can be debugged and tested using standard UNIX applications like terminal, telnet or a web browser. This also enables easy integration of other tools and programs into distributed applications built with newLISP. For example the Unix utility <tt>netcat</tt> (<tt>nc</tt>) could be used to evaluate expressions remotely or a web browser could be used to retrieve webpages from nodes running a newLISP server.</p>

<h3>Setting up in server mode（サーバー・モードの設定）</h3>

<p>newLISP サーバー・ノードは、本質的には一つのネットワーク・ポートを待ち受ける newLISP のプロセスで、newLISP コマンド・ラインのように動作する HTTP の <tt>GET</tt>, <tt>PUT</tt>, <tt>POST</tt>, <tt>DELETE</tt> 要求のための HTTP サーバーです。バージョウン 9.1 以来、newLISP のサーバー・モードは、<tt>GET</tt> か <tt>POST</tt> 要求のどちらかで受け取った <tt>CGI</tt> クエリにも応答します。<br />A newLISP server node is essentially a newLISP process listening to a network port and behaving like a newLISP command-line console and HTTP server for HTTP <tt>GET</tt>, <tt>PUT</tt>, <tt>POST</tt> and <tt>DELETE</tt> requests. Since version 9.1 newLISP server mode also answers <tt>CGI</tt> queries received by either <tt>GET</tt> or <tt>POST</tt> request.</p>

<p>newLISP のサーバー・ノードを開始するには、二つの方法があります。一方はクライアントが違っても状態を持続するステートフル・サーバー・ノードになり、他方は新しいクライアント接続ごとにリロードするステートレス・サーバーです。<br />Two methods are used to start a newLISP server node. One results in a state full server, maintaining state in between communications with different clients, the other method a server with no state, reloading for every new client connection.</p>
（訳注：ステートレスとステートフルについては、<a href="http://yohei-y.blogspot.com/2007/10/blog-post.html">こちら<a/>も参考になります。）<br>

<h3>Start a state-full server（ステートフル・サーバーを開始する）</h3>

<pre>
newlisp -c -d 4711 &amp;
 
newlisp myprog.lsp -c -d 4711 &amp;
 
newlisp myprog.lsp -c -w /home/node25 -d 4711 &amp;
</pre>

<p>これで、newLISP はポート 4711 を待ち受けます。（Unix でのみ）&amp; (ampersand) の付加が newLISP にバックグラウンドで走っていることを知らせます。<tt>-c</tt> スイッチがコマンド・ライン・プロンプトを抑制します。そのため、newLISP は、コマンドラインからの入力のようにポート 4711 を待ち受けるプロンプト無しの newLISP コンソールのように振る舞います。もちろん、他のポートを選択することもできます。Unix では、1024 以下のポートには、管理者権限が必要なことに注意して下さい。<br />newLISP is now listening on port 4711, the &amp; (ampersand) sign tells newLISP to run in the background (Unix only). The <tt>-c</tt> switch suppresses command line prompts. newLISP now behaves like a newLISP console without prompts listening on port 4711 for command line like input. Any other available port could have been chosen. Note that on Unix, ports below 1024 need administrator access rights.</p>

<p>二行目は、コードを予めロードする例でもあります。三行目では、<tt>-w</tt> オプションを使って作業ディレクトリも指定しています。 <tt>-w</tt> による指定がなければ、開始ディレクトリが作業ディレクトリになります。<br />The second example also pre-loads code. The third example also specifies a working directory using the <tt>-w</tt> option. If no working directory is specified using <tt>-w</tt>, the startup directory is assumed to be the working directory.</p>

<p>各処理後に接続を絶った時、newLISP はプロセスをリセットし、スタックとシグナルを再初期化し、コンテキストを <tt>MAIN</tt> に戻します。プログラムやシンボル変数の内容だけが保存されます。<br />After each transaction, when a connection closes, newLISP will go through a reset process, reinitialize stack and signals and go to the <tt>MAIN</tt> context. Only the contents of program and variable symbols will be preserved.</p>

<h3>Stateless server with inetd（inetd とステートレス）</h3>
<p>Unix 上で、<tt>inetd</tt> または <tt>xindetd</tt> の存在は、ステートレス・サーバーの開始に使われます。この場合、TCP/IP ネット接続は、同時に複数の要求（request）を操作できる能力を持つ専用の Unix ユーティリティで管理されます。<tt>inetd</tt> または <tt>xindetd</tt> ユーティリティは、クライアントによって作られた各接続において、新規の newLISP プロセスを開始します。接続が閉じた後、newLISP プロセスは終了します。<br />On Unix the <tt>inetd</tt> or <tt>xindetd</tt> facility can be used to start a stateless server. In this case the TCP/IP net connections are managed by a special Unix utility with the ability to handle multiple requests at the same time. For each connection made by a client the <tt>inetd</tt> or <tt>xinetd</tt> utility will start a fresh newLISP process. After the connection is closed the newLISP process will shut down.</p>

<p>ノードが状態を保持することを要求されないことは、newLISP サーバー・ノードにとっても、同時に複数の接続を扱うためにも望ましいことです。<br />When nodes are not required to keep state, this is the preferred method for a newLISP server node, for handling multiple connections at the same time.</p>

<p><tt>inetd</tt> または <tt>xindetd</tt> プロセス・ノードは、ほとんどの UNIX にある <tt>/etc</tt> ディレクトリで見つかる設定ファイルを使って設定されることを必要とします。<br />The <tt>inetd</tt> or <tt>xinetd</tt> process needs to be configured using configuration files found in the <tt>/etc</tt> directory of most UNIX installations.</p>

<p><tt>inetd</tt> と <tt>xinetd</tt> のどちらでも、ファイル <tt>/etc/services</tt> に次の行を設定します：<br />For both the <tt>inetd</tt> and <tt>xinetd</tt> configurations add the following line to the <tt>/etc/services</tt> file:</p>

<pre>
net-eval        4711/tcp     # newLISP net-eval requests
</pre>

<p><tt>4711</tt> 以外のポートも与えられることに注意して下さい。<br />Note that any other port than <tt>4711</tt> could be supplied.</p>

<p><tt>inetd</tt> の設定には、ファイル <tt>/etc/inetd.conf</tt> に次の行も追加します：<br />When configuring <tt>inetd</tt> add also the following lines to the <tt>/etc/inetd.conf</tt> file:</p>

<pre>
net-eval  stream  tcp  nowait  root  /usr/bin/newlisp -c
 
# as an alternative, a program can also be preloaded
 
net-eval  stream  tcp  nowait  root  /usr/bin/newlisp myprog.lsp -c
 
# a working directory can also be specified
 
net-eval  stream  tcp  nowait  newlisp  /usr/bin/newlisp -c -w /usr/home/newlisp
</pre>

<p>最後の行は、作業ディレクトリと<tt>root</tt> の代わりにユーザー の <tt>newlisp</tt> も指定しています。newLISP サーバー・ノードのアクセスを指定ユーザーアカウントに制限するよりセキュアなモードになります。<br />The last line also specified a working directory and a user <tt>newlisp</tt> instead of the <tt>root</tt> user. This is a more secure mode limiting newLISP server node access to a specific user account with restricted permissions.</p>

<p>ある種の Unix では、<tt>inetd</tt> の現代的な変種である <tt>xinetd</tt> が使え、次のような設定をファイル <tt>/etc/xinet.d/net-eval</tt> に追加します。<br />On some Unix system a modern flavor of <tt>inetd</tt>: the <tt>xinetd</tt> facility can be used. Add the following configuration to a file <tt>/etc/xinet.d/net-eval</tt>:</p>

<pre>
service net-eval
    {
    socket_type = stream
    wait = no
    user = root
    server = /usr/bin/newlisp
    port = 4711
    server_args = -c -w /home/node
    }
</pre>

<p>他の場所からのアクセス制限や特定ユーザーへの限定アクセスのために、様々なパラメータの組み合わせが可能であることに注意して下さい。詳細は、<tt>inetd</tt> と <tt>xinetd</tt> のマニュアル・ページを調べて下さい。<br />Note that a variety of parameter combinations are possible to restrict access from different places or limit access to certain users. Consult the man-pages for <tt>inetd</tt> and <tt>xinetd</tt> for details.</p>

<p><tt>inetd</tt> または <tt>xinetd</tt> の設定後、プロセスは設定ファイル再読み込みのために再スタートが必要です。これは、Unix <tt>kill</tt> または Unix <tt>nohup</tt> ユーティリティを使って、Unix <tt>HUP</tt> シグナルを<tt>inetd</tt> か <tt>xinetd</tt> プロセスに送ることで達成できます。<br />After configuring <tt>inetd</tt> or <tt>xinetd</tt> either process must be restarted to re-read the configuration files. This can be accomplished by sending the Unix <tt>HUP</tt> signal to either the <tt>inetd</tt> or <tt>xinetd</tt> process using the Unix <tt>kill</tt> or Unix <tt>nohup</tt> utility.</p>

<p>macOS では <tt>launchd</tt> 機能が同じように使えます。newLISP 配布ソースのディレクトリ <tt>util/</tt> に <tt>org.newlisp.newlisp.plist</tt> ファイルがあります。このファイルは OS 起動中に newLISP サーバーを起動するために使うことができます。<br />On macOS the <tt>launchd</tt> facility can be used in a similar fashion. The newLISP source distribution contains the file <tt>org.newlisp.newlisp.plist</tt> in the <tt>util/</tt> directory. This file can be used to launch newlisp server during OS boot time as a persistent server.</p>

<h3>Test the server with telnet（telnet でサーバーをテストする）</h3>

<p>Unix ユーティリティ <tt>telnet</tt> を使って、newLISP サーバー・ノードをテストできます：<br />A newLISP server node can be tested using the Unix <tt>telnet</tt> utility:</p>

<pre>
telnet localhost 4711
 
; or when running on a different computer i.e. ip 192.168.1.100
 
telnet 192.168.1.100 4711
</pre>

<p>複数行の式をタグ <tt>[cmd]</tt>, <tt>[/cmd]</tt> で囲んで入力できます。この時、タグは開始も終了も、独立した一行でなければなりません。newLISP は、バージョン10.3.0 からインターラクティブ・シェル用の新マルチ・ライン・モードという第二の方法を持っていますが、<tt>netcat</tt> や他の Unix ユーティリティを使う時は、まだ複数行の式を <tt>[cmd]</tt>, <tt>[/cmd]</tt> タグで囲む必要があります。<br />Multi-line expressions can be entered by enclosing them in <tt>[cmd]</tt>, 
<tt>[/cmd]</tt> tags, each tag on a separate line. Both the opening and closing 
tags should be on separate lines. Although newLISP has a second, new
multi-line mode for the interactive shell since version 10.3.0 without tags, 
when using <tt>netcat</tt> or other Unix utilities, multi-line expressions still have 
to be enclosed in <tt>[cmd]</tt>, <tt>[/cmd]</tt> tags.</p>

<h3>Test with netcat on Unix（Unix の netcat でテストする）</h3>

<pre>
echo '(symbols) (exit)' | nc localhost 4711
</pre>

<p>あるいは、リモート・ノードと対話します：<br />Or talking to a remote node:</p>

<pre>
echo '(symbols) (exit)' | nc 192.168.1.100 4711
</pre>

<p>どちらの例でも、 <tt>netcat</tt> が <tt>(symbols)</tt> 式の評価結果をエコー・バックします。<br />In both examples <tt>netcat</tt> will echo back the result of evaluating the <tt>(symbols)</tt> expression.</p>

<p>複数行の式をタグ <tt>[cmd]</tt>, <tt>[/cmd]</tt> で囲んで入力できます。この時、タグは開始も終了も、独立した一行でなければなりません。<br />Multi-line expressions can be entered by enclosing them in <tt>[cmd]</tt>, <tt>[/cmd]</tt> tags, each tag on a separate line.</p>

<h3>Test from the command line（コマンド・ラインからテストする）</h3>

<p>構文としての <tt>net-eval</tt> は一つのリモート・サーバー・ノードのみへの接続を形成します。このモードは、newLISP コマンド・ラインから素早くテストするのに役立ちます：<br />The <tt>net-eval</tt> function as a syntax form for connecting to only one remote server node. This mode is practical for quick testing from the newLISP command line:</p>

<pre>
(net-eval "localhost" 4711 "(+ 3 4)" 1000) → 7
 
; to a remote node
 
(net-eval "192.168.1.100" 4711 {(upper-case "newlisp")} 1000) → "NEWLISP"
</pre>

<p>二番目の例では、評価するプログラム文字列を囲むのに波括弧 <tt>{,}</tt> を使っています。この方法で、式内の文字列を囲むのにクォートを使えるようになります。<br />In the second example curly braces <tt>{,}</tt> are used to limit the program string for evaluation. This way quotes can be used to limit a string inside the expression.</p>

<p>複数行の式を送る際、<tt>[cmd]</tt>, <tt>[/cmd]</tt> タグは必要ありません。<tt>net-eval</tt> が自動的に挿入します。<br />No <tt>[cmd]</tt>, <tt>[/cmd]</tt> tags are required when sending multi-line expressions. <tt>net-eval</tt> supplies these tags automatically.</p>

<h3>Test HTTP with a browser（ブラウザで HTTP をテストする）</h3>

<p>newLISP は簡単な HTTP の <tt>GET</tt> と <tt>PUT</tt> 要求も受け付けます。ブラウザのアドレス・バーに次のファイルのフル・パスを入力してみて下さい：<br />A newLISP server also understands simple HTTP <tt>GET</tt> and <tt>PUT</tt> requests. Enter the full path of a file in the address-bar of the browser:</p>

<pre>
http://localhost:4711//usr/share/newlisp/doc/newlisp_manual.html
</pre>

<p>マニュアル・ファイルの大きさはおよそ 800K バイトで、ブラウザにロードされるには、数秒かかります。ホスト名またはホスト IP にコロンをつけて、ポート番号を指定して下さい。ファイルのアドレスをルート・ディレクトリから相対的に指定するために、二重のスラッシュの指定が必要なことに注意して下さい。<br />The manual file is almost 800 Kbyte in size and will take a few seconds to load into the browser. Specify the port-number with a colon separated from the host-name or host IP. Note the double slash necessary to specify a file address relative to the root directory.</p>

<h3>Evaluating remotely（リモート評価）</h3>

<p>newLISP サーバー・モードが正常にインストールされたかのテストの際、評価用にリモート・ノードに式を送っていました。異なるノードでリモート評価するために長いタスクを短いサブタスクに分割して多数のリモート評価を使います。<br />When testing the correct installation of newLISP server nodes, we were already sending expressions to remote node for evaluation. Many times remote evaluation is used to split up a lengthy task into shorter subtasks for remote evaluation on different nodes.</p>

<p>単純な複数の式をリモートに評価している最初の例はつまらないものですが、使用原理をわかりやすく示しています：<br />The first example is trivial, because it only evaluates several very simple expressions remotely, but it demonstrates the principles involved easily:</p>

<pre>
#!/usr/bin/newlisp
 
(set 'result (net-eval '(
    ("192.168.1.100" 4711 {(+ 3 4)})
    ("192.168.1.101" 4711 {(+ 5 6)})
    ("192.168.1.102" 4711 {(+ 7 8)})
    ("192.168.1.103" 4711 {(+ 9 10)})
    ("192.168.1.104" 4711 {(+ 11 12)})
) 1000))
 
 
(println "result: " result)
 
(exit)
</pre>

<p>このプログラムを走らせると、次のような出力を得ます：<br />Running this program will produce the following output:</p>

<pre>
result: (7 11 15 19 23)
</pre>

<p>Unix を走らせ、newLISP サーバーで構成された <tt>inetd</tt> または <tt>xinetd</tt> を使っている時、全ての IP 番号を <tt>"localhost"</tt> か同じローカル IP 番号に置き換えることで、サーバーとプログラムを一つの CPU 上でのみ走らせることができます。<tt>indetd</tt> または <tt>xinetd</tt> デーモンは、5個の独立した newLISP プロセスを開始します。Win32 では同じ実行に、5個のステートフル newLISP サーバーを異なるポートで開始します。<br />When running Unix and using an <tt>inetd</tt> or <tt>xinetd</tt> configured newLISP server, the servers and programs can be run on just one CPU, replacing all IP numbers with <tt>"localhost"</tt> or the same local IP number. The <tt>indetd</tt> or <tt>xinetd</tt> daemon will then start 5 independent newLISP processes. On Win32 5 state-full newLISP servers could be started on different port numbers to accomplish the same.</p>

<p><tt>net-eval</tt> の戻り値を一度に全部集める代わりに、結果が利用できるようなった時、受け取り処理するコールバック関数が使えます：<br />Instead of collecting all results at once on the return of <tt>net-eval</tt>, a callback function can be used to receive and process results as they become available:</p>

<pre>
#!/usr/bin/newlisp
 
(define (idle-loop p)
    (if p (println p)))
 
(set 'result (net-eval '(
    ("192.168.1.100" 4711 {(+ 3 4)})
    ("192.168.1.101" 4711 {(+ 5 6)})
    ("192.168.1.102" 4711 {(+ 7 8)})
    ("192.168.1.103" 4711 {(+ 9 10)})
    ("192.168.1.104" 4711 {(+ 11 12)})
) 1000 idle-loop))
 
(exit)
</pre>

<p><tt>net-eval</tt> が結果を待っている間、関数 <tt>idle-loop</tt> はパラメータ <tt>p</tt> を伴って繰り返し呼び出されます。パラメータ <tt>p</tt> は 1000ミリ秒間中、結果がない時の <tt>nil</tt> か、リモート・ノードから送り返されたリストが入ります。リストには、リモート・アドレスとポートと評価結果が入っています。上記例は、次のような出力を生成します：<br />While <tt>net-eval</tt> is waiting for results, it calls the function <tt>idle-loop</tt> repeatedly with parameter <tt>p</tt>. The parameter <tt>p</tt> is <tt>nil</tt> when no result was received during the last 1000 milli seconds, or <tt>p</tt> contains a list sent back from the remote node. The list contains the remote address and port and the evaluation result. The example shown would generate the following output:</p>

<pre>
("192.168.1.100" 4711 7)
("192.168.1.101" 4711 11)
("192.168.1.102" 4711 15)
("192.168.1.103" 4711 19)
("192.168.1.104" 4711 23)
</pre>

<p>一つの CPU でのみテストする際は、全アドレスを <tt>"localhost"</tt> に置き換えます。Unix の <tt>inetd</tt> または <tt>xinetd</tt> デーモンは各接続に対して全てポート <tt>4711</tt> の待ち受けで個別のプロセスを開始します。同じ Win32 でステートフル・サーバーを使った時は、CPU は各サーバーに異なるポート番号を指定します。<br />For testing on just one CPU, replace addresses with <tt>"localhost"</tt>; the Unix <tt>inetd</tt> or <tt>xinetd</tt> daemon will start a separate process for each connection made and all listening on port <tt>4711</tt>. When using a state-full server on the same Win32 CPU specify a different port number for each server.</p>

<h3>Setting up the 'net-eval' parameter structure（関数net-eval パラメータ構成の設定）</h3>

<p>アプリケーションが絶えず移動している、または、IP番号が切り替わるサーバー・ノードが使われているネットワーク環境では、<tt>net-eval</tt> パラメータ・リスト中のノード・パラメータの設定が変数として必要です。以下の込み入った例でその様子が示されます。また、この例では、大規模なプログラム・テキストがリモート・ノードに転送され、このプログラム部品が異なる各ノード用にカスタマイズされていく様子が示されます：<br />In a networked environment where an application gets moved around, or server nodes with changing IP numbers are used, it is necessary to set up the node parameters in the <tt>net-eval</tt> parameter list as variables. The following more complex example shows how this can be done. The example also shows how a bigger piece of program text can be transferred to a remote node for evaluation and how this program piece can be customized for each node differently:</p>

<pre>
#!/usr/bin/newlisp
 
; node parameters
(set 'nodes '(
    ("192.168.1.100" 4711)
    ("192.168.1.101" 4711)
    ("192.168.1.102" 4711)
    ("192.168.1.103" 4711)
    ("192.168.1.104" 4711)
))
 
; program template for nodes
(set 'program [text]
    (begin
        (map set '(from to node) '(%d %d %d))
        (for (x from to)
		(if (= 1 (length (factor x)))
        (push x primes -1)))
    primes)
[/text])
 
; call back routine for net-eval
(define (idle-loop p)
    (when p
        (println (p 0) ":" (p 1))
        (push (p 2) primes))
)
 
(println "Sending request to nodes, and waiting ...")
 
; machines could be on different IP addresses.
; For this test 5 nodes are started on localhost
(set 'result (net-eval (list
    (list (nodes 0 0) (nodes 0 1) (format program 0 99999 1))
    (list (nodes 1 0) (nodes 1 1) (format program 100000 199999 2))
    (list (nodes 2 0) (nodes 2 1) (format program 200000 299999 3))
    (list (nodes 3 0) (nodes 3 1) (format program 300000 399999 4))
    (list (nodes 4 0) (nodes 4 1) (format program 400000 499999 5))
) 20000 idle-loop))
 
(set 'primes (sort (flat primes)))
(save "primes" 'primes)
 
(exit)
</pre>

<p>プログラムの先頭で <tt>nodes</tt> リストの構造は、ホスト名とポートの関連するノード情報が全て得ています。<br />At the beginning of the program a <tt>nodes</tt> list structure contains all the relevant node information for hostname and port.</p>

<p><tt>program</tt> は与えられた範囲にある素数を算出します。変数 <tt>from</tt>、<tt>to</tt>、<tt>node</tt> は <tt>format</tt> を使ってプログラム・テキスト中に設定されます。全ての命令は <tt>begin</tt> 式ブロック内に置かれ、結果が一つの式のみでリモートノードから送り返されます。<br />The <tt>program</tt> calculates all prime numbers in a given range. The <tt>from</tt>, <tt>to</tt> and <tt>node</tt> variables are configured into the program text using <tt>format</tt>. All instructions are placed into a <tt>begin</tt> expression block, so only one expression result will be send back from the remote node.</p>

<p><tt>net-eval</tt> パラメータの設定には、その他多くの構成が可能です。次の構成は <tt>idle-loop</tt> 無しで同様の結果を与えます：<br />Many other schemes to configure a <tt>net-eval</tt> parameter list are possible. The following scheme without <tt>idle-loop</tt> would give the same results:</p>

<pre>
(set 'node-eval-list (list
    (list (nodes 0 0) (nodes 0 1) (format program 0 99999 1))
    (list (nodes 1 0) (nodes 1 1) (format program 100000 199999 2))
    (list (nodes 2 0) (nodes 2 1) (format program 200000 299999 3))
    (list (nodes 3 0) (nodes 3 1) (format program 300000 399999 4))
    (list (nodes 4 0) (nodes 4 1) (format program 400000 499999 5))
))
 
(set 'result (net-eval node-eval-list  20000))
</pre>

<p>関数 <tt>idle-loop</tt> は受け取った素数リストを全ての集め、次の出力を生成します：<br />The function <tt>idle-loop</tt> aggregates all lists of primes received and generates the following output:</p>

<pre>
192.168.1.100:4711
192.168.1.101:4711
192.168.1.102:4711
192.168.1.103:4711
192.168.1.104:4711
</pre>

<p>多数のネットワーク・ホストの配布環境に展開する前に配布アプリケーションを単一ホスト上でテストするために、前述の例のように全 IP 番号を <tt>"localhost"</tt> や他のホスト名や IP 番号に置き換えることができます。<br />As with the previous examples all IP numbers could be replaced with <tt>"localhost"</tt> or any other host-name or IP number to test a distributed application on a single host before deployment in a distributed environment with many networked hosts.</p>

<h3>Transferring files（ファイル転送）</h3>

<p>ローカル・ファイル・システムのファイルの読み書きに使える関数群で、リモート・ノードのファイルの読み書きが可能です。この機能は、現在のところ、newLISP サーバーと通信中のUnix システムでのみ利用可能です。これらの関数は <tt>GET</tt> と <tt>PUT</tt> という標準の HTTP プロトコルに基づいているので、ウェブ・サーバーへの通信にも使えます。デフォルトで <tt>PUT</tt> プロトコルを利用可能にしている Apache ウェブ・サーバーは少ないことに注意して下さい。<br />Files can be read from or written to remote nodes with the same functions used to read and write files to a local file system. This functionality is currently only available on Unix systems when talking to newLISP servers. As functions are based on standard <tt>GET</tt> and <tt>PUT</tt> HTTP protocols they can also be used communicating with web servers. Note that few Apache web-server installations have enabled the <tt>PUT</tt> protocol by default.</p>

<p>関数 <tt>read-file</tt>、<tt>write-file</tt>、<tt>append-file</tt> は、newLISP サーバーやウェブ・サーバーの走っているリモート・ノードに読み書きする際、ファイル名指定に URL を取ることができます：<br />The functions <tt>read-file</tt>, <tt>write-file</tt> and <tt>append-file</tt> can all take URLs in their filename specifications for reading from and writing to remote nodes running a newLISP server or a web-server:</p>

<pre>
(write-file "http://127.0.0.1:4711//Users/newlisp/afile.txt" "The message - ")
→ "14 bytes transferred for /Users/newlisp/afile.txt\r\n"
 
(append-file "http://127.0.0.1:4711//Users/newlisp/afile.txt" "more text")
→ "9 bytes transferred for /Users/newlisp/afile.txt\r\n"
 
(read-file "http://127.0.0.1:4711//Users/newlisp/afile.txt")
→ "The message - more text"
</pre>

<p>最初の二つの関数は転送したバイト数から始まるメッセージを返します。関数 <tt>read-file</tt> は受け取った内容を返します。<br />The first two function return a message starting with the numbers of bytes transferred and the name of the remote file affected. The <tt>read-file</tt> function returns the contents received.</p>

<p>エラーが起こった時は、文字列 <tt>ERR:</tt> で始まるエラー・メッセージが返されます：<br />Under all error conditions an error message starting with the characters <tt>ERR:</tt> would be returned:</p>

<pre>
(read-file "http://127.0.0.1:4711//Users/newlisp/somefile.txt")
→ "ERR:404 File not found: /Users/newlisp/somefile.txt\r\n"
</pre>

<p>サーバー・ノード上の root からファイルを相対的に参照する際は、二重のバックスラッシュが必要なことに注意して下さい。<br />Note the double backslash necessary to reference files relative to root on the server node.</p>

<p>全てに関数は、セロ文字を含む非アスキーのバイナリ情報を転送するのに使えます。newLISP は内部で <tt>read-file</tt>、<tt>write-file</tt>、<tt>append-file</tt>の代わりに <tt>get-url</tt> と <tt>put-url</tt> を使っています。<tt>get-url</tt> と <tt>put-url</tt> で使われる付加オプションが、<tt>read-file</tt>、<tt>write-file</tt>、<tt>append-file</tt> でも使えます。詳細は、newLISP 関数リファレンスでこれらの関数を見て下さい。<br />All functions can be used to transfer binary non-ascii contents containing zero characters. Internally newLISP uses the functions <tt>get-url</tt> and <tt>put-url</tt>, which could be used instead of the functions <tt>read-file</tt>, <tt>write-file</tt> and <tt>append-file</tt>. Additional options like used with <tt>get-url</tt> and <tt>put-url</tt> could be used with the functions <tt>read-file</tt>, <tt>write-file</tt> and <tt>append-file</tt> as well. For more detail see the newLISP function reference for these functions.</p>

<h3>Loading and saving data（データのロードとセーブ）</h3>

<p>リモート・ノードへのロードやセーブに、ローカル・ファイル・システムからプログラムや LISP データをロードするのに使うのと同じ関数 <tt>load</tt> と <tt>save</tt> が使えます。<br />The same <tt>load</tt> and <tt>save</tt> functions used to load program or LISP data from a local file system can be used to load or save programs and LISP data from or to remote nodes.</p>

<p>ファイル指定に URL を使うことで、<tt>load</tt> や <tt>save</tt> はnewLISP サーバー・ノードとのネットワーク通信上で動作します：<br />By using URLs in the file specifications of <tt>load</tt> and <tt>save</tt> these functions can work over the network communicating with a newLISP server node.:</p>

<pre>
(load "http://192.168.1.2:4711//usr/share/newlisp/mysql5.lsp")
 
(save "http://192.168.1.2:4711//home/newlisp/data.lsp" 'db-data)
</pre>

<p>ファイル・パスの代わりに URL を使っても、関数 <tt>load</tt> と <tt>save</tt> は内部動作で <tt>get-url</tt> と <tt>put-url</tt> を使っているので、ローカル・ファイル・システムで使う時と同様に確実に動作します。両関数とも接続が確立しなかった場合、60秒後にタイムアウトします。きめ細かい操作が必要な時は、関数 <tt>get-url</tt> や <tt>put-url</tt> を HTTP モードでの <tt>load</tt> や <tt>save</tt> と同等の機能を実現する <tt>eval-string</tt> や <tt>source</tt> と一緒に使って下さい。<br />Although the <tt>load</tt> and <tt>save</tt> functions internally use <tt>get-url</tt> and <tt>put-url</tt> to perform its works they behave exactly as when used on a local file system, but instead of a file path URLs are specified. Both function will timeout after 60 seconds if a connection could not be established. When finer control is necessary use the functions <tt>get-url</tt> and <tt>put-url</tt> together with <tt>eval-string</tt> and <tt>source</tt> to realize a similar result as when using the <tt>load</tt> and <tt>save</tt> in HTTP mode.</p>

<h3>Local domain Unix sockets（ローカル・ドメイン Unix ソケット）</h3>

<p>newLISP は、newLISP サーバー・モードで組込関数 <tt>net-eval</tt>、<tt>net-listen</tt>、<tt>net-connect</tt> と <tt>net-accept</tt>、<tt>net-receive</tt>、<tt>net-select</tt>、<tt>net-send</tt> を一緒に使って、名前付きローカル・ドメイン・ソケットを提供します。<br />newLISP supports named local domain sockets in newLISP server mode and using the built-in functions <tt>net-eval</tt>, <tt>net-listen</tt>, <tt>net-connect</tt> together with the functions <tt>net-accept</tt>, <tt>net-receive</tt>, <tt>net-select</tt> and <tt>net-send</tt>.</p>

<p>ローカル・ドメイン・ソケットを使えば、同じファイル・システム上のプロセスとnewLISP サーバー間の高速な通信が可能になります。詳細は、マニュアルで見て下さい。<br />Using local domain sockets fast communications between processes on the same file system and with newLISP servers is possible. See the Users Manual for more details.</p>

<br><center>&sect;</center><br>
<a name="toc-22"></a>
<h2>22. HTTPD web server only mode（HTTPD ウェブ・サーバー単一モード）</h2>

<p>ここまで章では、<tt>-c</tt> サーバー・モードを使ってきました。このモードは <tt>net-eval</tt> サーバーとして実行でき、同時に ウェブ・ページの提供やファイルとプログラムの転送などの <tt>HTTP</tt> 要求に応答します。<tt>-c</tt> サーバーはファイヤオール下のセキュア操作用の優先モードです。newLISP は、制限された <tt>-c</tt> モードのように動作する <tt>-http</tt> モードも持っています。<tt>-http</tt> モードでは、<tt>HTTP</tt> 要求のみが提供され整形された要求（request）のようなコマンド・ラインや <tt>net-eval</tt> 要求には応答しません。このモードでは、newLISP は <tt>CGI</tt> 要求と同様に HTTP の <tt>GET</tt>、<tt>PUT</tt>、<tt>POST</tt>、<tt>DELETE</tt> 要求に応答するウェブ・サーバーのように動作しますが、インターネット上でのセキュアな動作確保するために権限のないファイルやディレクトリのアクセスを制限します。 <br>In all previous chapters the <tt>-c</tt> server mode was used. This mode can act as a <tt>net-eval</tt> server and at the same time answer <tt>HTTP</tt> requests for serving web pages or transfer of files and programs. The <tt>-c</tt> mode is the preferred mode for secure operation behind a firewall. newLISP also has a <tt>-http</tt> mode which works like a restricted <tt>-c</tt> mode. In <tt>-http</tt> mode only <tt>HTTP</tt> requests are served and command-line like formatted requests and <tt>net-eval</tt> requests are not answered. In this mode newLISP can act like a web server answering HTTP <tt>GET</tt>, <tt>PUT</tt>, <tt>POST</tt> and <tt>DELETE</tt> requests as well as <tt>CGI</tt> requests, but additional efforts should be made to restrict the access to unauthorized files and directories to secure the server when exposed to the internet.</p>

<h3>Environment variables（環境変数）</h3>
<p><tt>-c</tt> と <tt>-http</tt> のサーバー・モードのどちらでも、環境変数 DOCUMENT_ROOT, REQUEST_METHOD, SERVER_SOFTWARE, QUERY_STRING が設定されます。変数 CONTENT_TYPE, HTTP_HOST, HTTP_USER_AGENT, HTTP_COOKIE はクライアントから送られてくる HTTP ヘッダに存在する時、設定されます。<br />In both server modes <tt>-c</tt> and <tt>-http</tt> the environment variables 
DOCUMENT_ROOT, REQUEST_METHOD, SERVER_SOFTWARE and QUERY_STRING are set. 
The variables CONTENT_TYPE, HTTP_HOST, HTTP_USER_AGENT and HTTP_COOKIE are set too if present 
in the HTTP header sent by the client.</p>

<h3>Pre-processing the request（要求（request）のプリ・プロセス）</h3>

<p>newLISP サーバーが（<tt>HTTP</tt> とコマンド・ラインの）いかなる要求（request）に答える際も、newLISP 関数 <tt>command-event</tt> を要求（request）のプリ・プロセスに使えます。サーバー開始時に次のようにして、ファイル <tt>httpd-conf.lsp</tt> からプリ・プロセス関数をロードできます：<br />When the newLISP server answers any kind of requests (<tt>HTTP</tt> and command line), the newLISP function <tt>command-event</tt> can be used to pre-process the request. The pre-processing function can be loaded from a file <tt>httpd-conf.lsp</tt> when starting the server:</p>

<pre>
server_args = httpd-conf.lsp -http -w /home/node
</pre>

<p>上記は <tt>xinetd</tt> 設定の一部を示しています。スタートアップ・プログラム <tt>httpd-conf.lsp</tt> は newLISP の起動時にロードされます。<tt>-c</tt> オプションは <tt>-http</tt> オプションで置き換えられます。<tt>net-eval</tt> とコマンド・ラインどちらの要求（request）も応答されず、HTTP 要求のみ応答されます。<br />The above snippet shows part of a <tt>xinetd</tt> configuration file. A startup program <tt>httpd-conf.lsp</tt> has been added which will be loaded upon invocation of newLISP. The <tt>-c</tt> options has been replaced with the <tt>-http</tt> option. Now neither <tt>net-eval</tt> nor command-line requests will be answered but only HTTP requests.</p>

<p>スタートアップ・ファイルは、次の方法でも追加されます。コマンド・シェルからバックグランドでサーバーを開始する時、この時、<tt>httpd-conf.lsp</tt> はカレント・ディレクトリに置いておきます：<br />The startup file could also have been added the following way when starting the server in the background from a command shell, and <tt>httpd-conf.lsp</tt> is in the current directory:</p>

<pre>
newlisp httpd-conf.lsp -http -d 80 -w /home/www &amp;
</pre>

<p>全ての要求（request）は <tt>command-event</tt> を使って指定された <tt>httpd-conf.lsp</tt> の関数でプリ・プロセスされます：<br />All requests will be pre-processed with a function specified using <tt>command-event</tt> in <tt>httpd-conf.lsp</tt>:</p>

<pre>
; httpd-conf.lsp
;
; filter and translate HTTP request for newLISP
; -c or -http server modes
; reject query commands using CGI with .exe files
 
(command-event (fn (s)
    (let (request nil)
    (if (find "?" s) ; is this a query
        (begin
            (set 'request (first (parse s "?")))
            ; discover illegal extension in queries
            (if (ends-with request ".exe")
                (set 'request "GET /errorpage.html")
                (set 'request s)))
        (set 'request s))
    request)
))
 ; eof
</pre>

<p><tt>.exe</tt> で終わるファイルの CGI要求は排除され、エラー・ページの要求（request）に変換されます。<br />All CGI requests files ending with <tt>.exe</tt> would be rejected and the request translated into the request of an error page.</p>

<h3>CGI processing in HTTP mode（HTTP モードの CGI 処理）</h3>

<p>http://www.newlisp.org には、様々な CGI サンプルがあります。http://www.newlisp.org/downloads のダウンロード・ディレクトリには、二つの複雑なアプリケーション、ウェブ・ベースの IDE である <tt>newlisp-ide</tt> とウェブ・サイト [http://www.newlisp.org www.newlisp.org] で使っている情報処理システム <tt>newlisp-wiki</tt> があります。<br />On http://www.newlisp.org various CGI examples can be found. In the download directory at http://www.newlisp.org/downloads two more complex applications can be found: <tt>newlisp-ide</tt> is a web based IDE and <tt>newlisp-wiki</tt> is a content management system which also runs the [http://www.newlisp.org www.newlisp.org] website.</p>

<p>CGI プログラム・ファイルは拡張子 <tt>.cgi</tt> でなければならず、Unix では実行可能のパーミッションが必要です。<br />CGI program files must have the extension <tt>.cgi</tt> and have executable permission on Unix. </p>

<p>次の例は、最低限の CGI プログラムです：<br />The following is a minimum CGI program:</p>

<pre>
#!/usr/bin/newlisp
 
(print "Content-type: text/html\r\n\r\n")
(println "&lt;h2&gt;Hello World&lt;/h2&gt;")
(exit)
</pre>

<p>newLISP は通常、標準の<tt>HTTP/1.0 200 OK\r\n</tt>の応答ヘッダに <tt>Server: newLISP v. ...\r\n</tt> ヘッダ・ラインを追加して出力します。CGI プログラム出力の一行目が "Status:" で始まっているなら、newLISP の標準ヘッダ出力を止めますので、CGI プログラム自身で全てのステータス・ヘッダを供給しなければなりません。次の例は、要求（request）を新しいロケーションにリダイレクトします：<br />newLISP normally puts out a standard <tt>HTTP/1.0 200 OK\r\n</tt> response header plus a <tt>Server: newLISP v. ...\r\n</tt> header line. If the first line of CGI program output starts with "Status:" then newLISP's standard header output is suppressed, and the CGI program must supply the full status header by itself. The following example redirects a request to a new location:</p>

<pre>
#!/usr/bin/newlisp
(print "Status: 301 Moved Permanently\r\n")
(print "Location: http://www.newlisp.org/index.cgi\r\n\r\n")
(exit)
</pre>

<p>インストールした newLISP には、<tt>cgi.lsp</tt> モジュール・ファイルがあります。このモジュールには、HTTP の GET や POST 要求を抽出するためのサブルーチンや抽出、クッキー（cookie）の設定等の CGI ファイルを書く時に役に立つルーチンが入っています。http://www.newlisp.org/modules/ のモジュール・セクションを見て下さい。<br />A newLISP installation contains a module file <tt>cgi.lsp</tt>. 
This module contains subroutines for extracting parameters from 
HTTP GET and POST requests, extract or set cookies and other useful 
routines when writing CGI files. See the modules section 
at: http://www.newlisp.org/modules/.</p>

<h3>Media types in HTTP modes（HTTP モードのメディア・タイプ）</h3>

<p><tt>-c</tt> と <tt>-http</tt> のどちらの HTTP モードでも、以下のファイル・タイプが認識され、正しく定型化された <tt>Content-Type:</tt> ヘッダーが送り返されます：<br />In both the <tt>-c</tt> and <tt>-http</tt> HTTP modes the following file types are recognized and a correctly formatted <tt>Content-Type:</tt> header is sent back:</p>

<table  summary="media types">
<tr align="left"><th>file extension</th><th>media type</th></tr>
<tr><td>.avi</td><td>video/x-msvideo</td></tr>
<tr><td>.css</td><td>text/css</td></tr>
<tr><td>.gif</td><td>image/gif</td></tr>
<tr><td>.htm</td><td>text/htm</td></tr>
<tr><td>.html</td><td>text/html</td></tr>
<tr><td>.jpg</td><td>image/jpg</td></tr>
<tr><td>.js</td><td>application/javascript</td></tr>
<tr><td>.mov</td><td>video/quicktime</td></tr>
<tr><td>.mp3</td><td>audio/mpeg</td></tr>
<tr><td>.mpg</td><td>video/mpeg</td></tr>
<tr><td>.pdf</td><td>application/pdf</td></tr>
<tr><td>.png</td><td>image/png</td></tr>
<tr><td>.wav</td><td>audio/x-wav</td></tr>
<tr><td>.zip</td><td>application/zip</td></tr>
<tr><td><em>any other</em></td><td>text/plain</td></tr>
</table>


<br><center>&sect;</center><br>
<a name="toc-23"></a>
<h2>23. Extending newLISP（newLISP の拡張）</h2>

<p>newLISPはインポート関数を持っており、Win32 の DLL（Dynamic Link Libraries）や Linux/Unix の共有ライブラリ（拡張子が .so、macOS では .dylib）から関数を導入できます。<br />newLISP has an Win32 function, which allows importing function from DLLs (Dynamic Link Libraries) on Win32 or shared libraries on Linux/Unix (ending in .so, ending in .dylib on macOS).</p>

<h3>Simple versus extended FFI interface（単純 及び 拡張 FFI インターフェイスの比較）</h3>

<p>バージョン 10.4.0 で newLISP は、関数 <tt>import</tt>、<tt>callback</tt>、<tt>struct</tt> の拡張構文および、<tt>pack</tt> and <tt>unpack</tt> の補助関数の拡張構文を導入しました。この拡張構文は、<a href="http://sourceware.org/libffi/">libffi</a>を使って構築された newLISP でのみ、利用可能です。www.newlisp.org で配布されている全ての標準バイナリ版では単純 API に加えて新しい拡張機能を使えます。単純 API は、<tt>gsl.lsp</tt> を除く、標準拡張モジュール全てに使われています。<br />In version 10.4.0 newLISP introduced an extended syntax for the <tt>import</tt>, <tt>callback</tt> and <tt>struct</tt> functions and for the <tt>pack</tt> and <tt>unpack</tt> support functions. This extended syntax is only available on newLISP versions built with <a href="http://sourceware.org/libffi/">libffi</a>. All standard binary versions distributed on www.newlisp.org are enabled to use the new extensions additionally to the simpler API. The simpler API is used by all standard extension modules part of the distribution except for the module <tt>gsl.lsp</tt>.</p>

<p>拡張構文を使えば、導入関数やコールバックに登録された関数のパラメータや戻り値に対して C 言語の型指定を行なえます。また、拡張構文は、パラメータや戻り値に対する浮動小数点数値や C の構造体の使用を可能にします。単純 API を使った浮動小数点型の取り扱いはできないか信頼できるものではありません。それは、純粋に <em>cdecl</em> 呼び出し規約に頼っていたためです。この規約は全てのプラットフォームで利用できるものではありません。また、拡張構文は異なる CPU アーキテクチャの C の型の自動アライメントで、C 構造体のパックとアンパックを処理できます。関数 <tt>pack</tt> と <tt>unpack</tt> の拡張構文は <a href=http://www.newlisp.org/newlisp_manual-jp.html">newLISP ユーザー マニュアルとリファレンス</a>と <a href="http://www.newlisp.org/syntax.cgi?code/opengl-demo-ffi-lsp.txt">OpenGL demo</a> で見て下さい。<br />The extended syntax allows specifying C-language types for parameter and return values of imported functions and for functions registered as callbacks. The extended syntax also allows handling of floating point values and C-structures in parameters and returns. Handling of floating point types was either impossible or unreliable using the simple API that depended on pure <em>cdecl</em> calling conventions. These are not available on all platforms. The extended API also handles packing and unpacking of C-structures with automatic alignment of C-types on different CPU architectures. See the extended syntax of the <tt>pack</tt> and <tt>unpack</tt> functions in the <a href="http://www.newlisp.org/newlisp_manual.html">User Manual and Reference</a> and <a href="http://www.newlisp.org/syntax.cgi?code/opengl-demo-ffi-lsp.txt">OpenGL demo</a>.</p>

<p>以下の章には旧式の単純 API が記載されています。その多くは拡張 API でも同じように適用できます。新 API の詳細は<a href=http://www.newlisp.org/newlisp_manual-jp.html">newLISP ユーザー マニュアルとリファレンス</a>で関数<tt>import</tt>、<tt>callback</tt>、<tt>struct</tt>、<tt>pack</tt>、<tt>unpack</tt>を調べて下さい。<br />The following chapters describe the older simple API. Much of it is applicable to the extended API as well. For details on the new API, consult the <a href="http://www.newlisp.org/newlisp_manual.html">User Manual and Reference</a> for the functions <tt>import</tt>, <tt>callback</tt>, <tt>struct</tt>, <tt>pack</tt> and <tt>unpack</tt>.</p>

<h3>A shared library in C（C の共有ライブラリ）</h3>

<p>この章では、Win32 と Linux/Unix プラットフォームの両方での、コンパイルの仕方とライブラリの使い方の両方を紹介します。まず、次の'C' プログラムを使って DLL と Linux/Unix の共有ライブラリにコンパイルしてみましょう。<br />This chapter shows how to compile and use libraries on both, Win32 and Linux/Unix platforms. We will compile a DLL and a Linux/Unix shared library from the following 'C' program.</p>


<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
 
int foo1(char * ptr, int number)
     {
     printf("the string: %s the number: %d\n", ptr, number);
     return(10 * number);
     }
 
char * foo2(char * ptr, int number)
     {
     char * upper;
     printf("the string: %s the number: %d\n", ptr, number);
     upper = ptr;
     while(*ptr) { *ptr = toupper(*ptr); ptr++; }
     return(upper);
     }
 
/* eof */
</pre>

<p>関数 foo1 と foo2 は、どちらもそれらの引数を出力しますが、foo1 は数字を10倍して返し、foo2 は'C' 関数から文字列を返す方法を示すために、文字列を大文字にして返します。 <br>Both functions foo1 and foo2 print their arguments, but while foo1 returns the number multiplied 10 times, foo2 returns the uppercase of a string to show how to return strings from 'C' functions.</p>

<h3>Compile on Unix（Unix 上でコンパイルする）</h3>

<p>macOS と Linux/Unix では、ワン・ステップで <tt>testlib.so</tt> にコンパイルとリンクできます。<br />On macOS and Linux/Unix we can compile and link <tt>testlib.so</tt> in one step:</p>

<pre>
gcc testlib.c -shared -o testlib.so
</pre>

<p>Mac OSX/darwin では、こうします：<br />Or On Mac OSX/darwin do:</p>

<pre>
gcc testlib.c -bundle -o testlib.dylib
</pre>

<p><tt>testlib.so</tt> は、Linux/Unix デフォルトの <tt>cdecl</tt> 規約で構築されます。ライブラリのインポート自体は、Linux と Win32 のプラットフォームのどちらでもよく似ていますが、Win32 ではライブラリをカレント・ディレクトリに置くことができます。フルパスを指定するか、OS のライブラリ・パスにライブラリを置いておく必要があります。<br />The library <tt>testlib.so</tt> will be built with Linux/Unix default <tt>cdecl</tt> conventions. Importing the library is very similar on both Linux and Win32 platforms, but on Win32 the library can be found in the current directory. You may have to specify the full path or put the library in the library path of the os:</p>

<pre>
&gt; (import "/home/newlisp/testlib.so" "foo1")
foo1 &lt;6710118F&gt;
 
&gt; (import "/home/newlisp/testlib.so" "foo2")
foo2 &lt;671011B9&gt;
 
&gt; (foo1 "hello" 123)
the string: hello the number: 123
1230
 
&gt; (foo2 "hello" 123)
the string: hello the number: 123
4054088
 
&gt; (get-string (foo2 "hello" 123))
the string: hello the number: 123
"HELLO"
&gt;
</pre>

<p>さて、<tt>foo2</tt> の戻り値は文字列のアドレス・ポインタですので、文字列へのアクセスには get-string を使います。get-string を使うとバイト 0 までの文字が返ります。バイナリ・バッファのアドレスを返す時は、別のテクニック unpack を使って情報にアクセスします。<br />Again, the number returned from <tt>foo2</tt> is the string address pointer and get-string can be used to access the string. When using get-string only character up to a zero byte are returned. When returning the addresses to binary buffers different techniques using unpack are used to access the information.</p>

<h3>Compile a DLL on Win32（Win32 の DLL をコンパイルする）</h3>

<p>Win32 の DLL は、MinGW、Borland、CYGWIN 等を使って作成できます。ここでは、MinGW コンパイラを使った例を紹介します：<br />DLLs on Win32 can be made using the MinGW, Borland or CYGWIN compilers. This example shows, how to do it using the MinGW compiler.</p>

<p>コンパイルします：<br />Compile it:</p>

<pre>
gcc -c testlib.c -o testlib.o
</pre>

<p><tt>testlib.o</tt> を DLL に変換する前に、エキスポートする関数を宣言する <tt>testlib.def</tt> が必要です。<br />Before we can transform <tt>testlib.o</tt> into a DLL we need a <tt>testlib.def</tt> declaring the exported functions:</p>

<pre>
LIBRARY  testlib.dll
EXPORTS
         foo1
         foo2
</pre>

<p>では、DLL を作ります：<br />Now wrap the DLL:</p>

<pre>
dllwrap testlib.o --def testlib.def -o testlib.dll -lws2_32
</pre>

<p>ライブラリ <tt>testlib.dll</tt> は、Win32 のデフォルト <tt>stdcall</tt> 規約で構築されます。次は、ライブラリをインポートし、関数を使うインターラクティブ・セッションです：<br />The library <tt>testlib.dll</tt> will be built with default Win32 <tt>stdcall</tt> conventions. The following shows an interactive session, importing the library and using the functions:</p>

<pre>
&gt; (import "testlib.dll" "foo1")
foo1 &lt;6710118F&gt;
 
&gt; (import "testlib.dll" "foo2")
foo2 &lt;671011B9&gt;
 
&gt; (foo1 "hello" 123)
the string: hello the number: 123
1230
 
&gt; (foo2 "hello" 123)
the string: hello the number: 123
4054088
 
&gt; (get-string (foo2 "hello" 123))
the string: hello the number: 123
"HELLO"
 
&gt;
; import a library compiled for cdecl
; calling conventions
&gt; (import "foo.dll" "func" "cdecl")
</pre>

<p>最初に <tt>foo2</tt> を使った時の戻り値 4054088 は返された文字列のメモリ・アドレスであることに注意して下さい。get-string を使えば、そのアドレスある文字列にアクセスできます。ライブラリが<tt>cdecl</tt> 呼出規約を使ってコンパイルされたいるなら、<tt>cdecl</tt> キーワードを import 式中に使う必要があります。<br />Note that the first time using <tt>foo2</tt> the return value 4054088 is the memory address of the string returned. Using get-string the string belonging to it can be accessed. If the library is compiled using <tt>cdecl</tt> calling conventions, the <tt>cdecl</tt> keyword must be used in the import expression.</p>

<h3>Importing data structures（構造体データのインポート）</h3>

<p>'C' の文字列が文字列ポインタを使って返されるように、'C' の構造体を構造体ポインタを使って返すことができ、そのアクセスに <tt>get-string</tt>、<tt>get-int</tt>、<tt>get-char</tt> らの関数を使えます。次の例でそれを紹介します：<br />Just like 'C' strings are returned using string pointers, 'C' structures can be returned using structure pointers and functions like <tt>get-string</tt>, <tt>get-int</tt> or <tt>get-char</tt> can be used to access the members. The following example illustrates this:</p>

<pre>
typedef struct mystruc
   {
   int number;
   char * ptr;
   } MYSTRUC;
 
MYSTRUC * foo3(char * ptr, int num )
   {
   MYSTRUC * astruc;
   astruc = malloc(sizeof(MYSTRUC));
   astruc-&gt;ptr = malloc(strlen(ptr) + 1);
   strcpy(astruc-&gt;ptr, ptr);
   astruc-&gt;number = num;
   return(astruc);
   }
</pre>

<p>newLISP プログラムは次のようにして、構造体のメンバーにアクセスします：<br />The newLISP program would access the structure members as follows:</p>

<pre>
&gt; (set 'astruc (foo3 "hello world" 123))
4054280
 
&gt; (get-string (get-integer (+ astruc 4)))
"hello world"
 
&gt; (get-integer astruc)
123
&gt;
</pre>

<p><tt>foo3</tt> からの戻り値は、<tt>astruc</tt> 構造体のアドレスです。文字列のポインタにアクセスするには、'C' プログラミング言語の整数型のサイズ 4 を追加します。これで文字列ポインタにある文字列を get-string でアクセスできます。<br />The return value from <tt>foo3</tt> is the address to the structure <tt>astruc</tt>. To access the string pointer, 4 must be added as the size of an integer type in the 'C' programming language. The string in the string pointer then gets accessed using get-string.</p>

<h3>Memory management（メモリ・マネージメント）</h3>

<p>導入した外部関数により実行された割り当ては、導入したAPIにその呼び出し（機能）がないなら、マニュアルで解除しなければなりません。<tt>libc</tt> の関数 <tt>free</tt> は導入することができ、導入関数内部で割り当てられたメモリを解放するために使われます。<br />Any allocation performed by imported foreign functions has to be 
deallocated manually if there's no call in the imported API to do so.
The <tt>libc</tt> function <tt>free</tt> can be imported and used 
to free memory allocated inside imported functions:</p>

<pre>
(import "/usr/lib/libc.so" "free")

(free astruc) ; astruc contains memory address of allocated structure
</pre>

<p>参照渡しで外部関数を呼び出す場合、変数用のメモリを newLISP 側で予め割り当てておく必要がありますが、それゆえ、メモリはマニュアルで解放する必要はありません。<br />In case of calling foreign functions with passing by reference, 
memory for variables needs to be allocated beforehand by newLISP,
and hence, memory needs not be deallocated manually.</p>

<h3>Unevenly aligned structures（不均一な構造体割付け）</h3>

<p>時には、データ構造は一般の CPU レジスタ・ワードと異なる長さのデータ型を持つことがあります：<br />Sometimes data structures contain data types of different length than the normal CPU register word:</p>

<pre>
struct mystruct
    {
    short int x;
    int z;
    short int y;
    } data;
 
struct mystruct * foo(void)
    {
    data.x = 123;
    data.y = 456;
    data.z = sizeof(data);
    return(&amp;data);
    }
</pre>

<p>変数 <tt>x</tt> と <tt>y</tt> は 16 ビット幅で z のみが 32 ビットを取っています。32 ビット CPU パック上のコンパイラがこの構造体をパックする時、変数 x と y は 16 ビットの代わりに 32 ビットに拡張されます。これは、32 ビット変数 z が適正に配置されるのに必要なことです。次のコードが、この構造体のメンバーのアクセスに必要です：<br />The <tt>x</tt> and <tt>y</tt> variables are 16 bit wide and only z takes 32 bit. When a compiler on a 32-bit CPU packs this structure the variables x and y will each fill up 32 bits instead of the 16 bit each. This is necessary so the 32-bit variable z can be aligned properly. The following code would be necessary to access the structure members:</p>

<pre>
&gt; (import "/usr/home/nuevatec/test.so" "foo")
foo &lt;281A1588&gt;
 
&gt; (unpack "lu lu lu" (foo))
(123 12 456)
</pre>

<p>構造体全体では、全てのメンバーがメモリ中の 32 ビット境界に配置されるので、3 × 4 ＝ 12 バイト消費します。<br />The whole structure consumes 3 by 4 = 12 bytes, because all members have to be aligned to 32 bit borders in memory.</p>

<p>次のデータ構造体はショート 16 ビット変数が互いに隣同士になるようにパックしてあります。この場合、<tt>x</tt> と <tt>y</tt> 用に各々 2、 <tt>z</tt> 用に 4 と、8 バイトだけが要求されます。<tt>x</tt> と <tt>y</tt> が一緒に 32 ビット・ワードに入るので、変数が32 ビット境界にまたがることにならないからです：<br />The following data structure packs the short 16 bit variables next to each other. This time only 8 bytes are required: 2 each for <tt>x</tt> and <tt>y</tt> and 4 bytes for <tt>z</tt>. Because <tt>x</tt> and <tt>y</tt> are together in one 32-bit word, none of the variables needs to cross a 32-bit boundary:</p>

<pre>
struct mystruct
     {
     short int x;
     short int y;
     int z;
     } data;
 
 struct mystruct * foo(void)
    {
    data.x = 123;
    data.y = 456;
    data.z = sizeof(data);
    return(&amp;data);
    }
</pre>

<p>この時の構造体メンバーに反映させた newLISP のアクセス・コードは：<br />This time the access code in newLISP reflects the size of the structure members:</p>

<pre>
&gt; (import "/usr/home/nuevatec/test.so" "foo")
foo &lt;281A1588&gt;
 
&gt; (unpack "u u lu" (foo))
(123 456 8)
</pre>

<h3>Passing parameters（パタメータの受け渡し）</h3>

<table  summary='table'>
<tr align='left'><th> data Type </th><th> newLISP call </th><th> C function call </th></tr>
<tr><td> <tt>integer</tt></td><td> <tt>(foo 123)</tt></td><td> <tt>foo(int number)</tt></td></tr>
<tr><td> <tt>double float</tt></td><td> <tt>(foo 1.234)</tt></td><td> <tt>foo(double number)</tt></td></tr>
<tr><td> <tt>float</tt></td><td> <tt>(foo (flt 1.234))</tt></td><td> <tt>foo(float number)</tt></td></tr>
<tr><td> <tt>string</tt></td><td> <tt>(foo "Hello World!")</tt></td><td> <tt>foo(char * string)</tt></td></tr>
<tr><td> <tt>integer array</tt></td><td> <tt>(foo (pack "d d d" 123 456 789))</tt></td><td> <tt>foo(int numbers[])</tt></td></tr>
<tr><td> <tt>float array</tt></td><td> <tt>(foo (pack "f f f" 1.23 4.56 7.89))</tt></td><td> <tt>foo(float[])</tt></td></tr>
<tr><td> <tt>double array</tt></td><td> <tt>(foo (pack "lf lf lf) 1.23 4.56 7.89)</tt></td><td> <tt>foo(double[])</tt></td></tr>
<tr><td> <tt>string array</tt></td><td> <tt>(foo (pack "lu lu lu" "one" "two" "three")))</tt></td><td> <tt>foo(char * string[])</tt></td></tr>
</table>
<p> <tt>floats</tt> と <tt>double floats</tt> は、x86 プラットフォームで<tt>cdecl</tt> 呼出規約を使った時か <tt>printf()</tt> のような可変引数関数のポインタ参照によって渡された時のみ正しく受け渡されることに注意して下さい。<a href=http://www.newlisp.org/newlisp_manual-jp.html">newLISP ユーザー マニュアルとリファレンス</a><br>Note that <tt>floats</tt> and <tt>double floats</tt> are only passed correctly on x86 platforms with <em>cdecl</em> calling conventions or when passed by pointer reference as in variable argument functions, i.e: <tt>printf()</tt>. For reliable handling of single and double precision floating point types and for advanced usage of <tt>pack</tt> and <tt>unpack</tt> for handling C-structures, see the descriptions of the <tt>import</tt>, <tt>callback</tt> and <tt>struct</tt> functions in the <a href="http://www.newlisp.org/newlisp_manual.html">newLISP User Manual and Reference</a>.</p>

<p><tt>pack</tt> はフォーマット指定子の後に複数の引数をリストでも受け取ります：<br /><tt>pack</tt> can receive multiple arguments after the format specifier in a list too:</p>

<pre> 
(pack "lu lu lu" '("one" "two" "three"))
</pre>

<h3>Extracting return values（戻り値の抽出）</h3>

<table  summary='table'>
<tr align='left'><th> data Type </th><th> newLISP to extract return value </th><th> C return </th></tr>
<tr><td> <tt>integer</tt></td><td> <tt>(set 'number (foo x y z))</tt></td><td> <tt>return(int number)</tt></td></tr>
<tr><td> <tt>double float</tt></td><td> n/a - only 32bit returns, use double float pointer instead </td><td> not available</td></tr>
<tr><td> <tt>double float ptr</tt></td><td> <tt>(set 'number (get-float (foo x y z)))</tt></td><td> <tt>return(double * numPtr)</tt></td></tr>
<tr><td> <tt>float</tt></td><td> not available</td><td> not available</td></tr>
<tr><td> <tt>string</tt></td><td> <tt>(set 'string (get-string (foo x y z)</tt></td><td> <tt>return(char * string)</tt></td></tr>
<tr><td> <tt>integer array</tt></td><td> <tt>(set 'numList (unpack "ld ld ld" (foo x y z)))</tt></td><td> <tt>return(int numList[])</tt></td></tr>
<tr><td> <tt>float array</tt></td><td> <tt>(set 'numList (unpack "f f f" (foo x y z)))</tt></td><td> <tt>return(float numList[])</tt></td></tr>
<tr><td> <tt>double array</tt></td><td> <tt>(set 'numList (unpack "lf lf lf") (foo x y z)))</tt></td><td> <tt>return(double numList[])</tt></td></tr>
<tr><td> <tt>string array</tt></td><td> <tt>(set 'stringList (map get-string (unpack "ld ld ld" (foo x y z))))</tt></td><td><tt>return(char * string[])</tt></td></tr>
</table>
<p><tt>Floats</tt> と <tt>doubles</tt> は、アドレス・ポインタ参照を介してのみ返されます。<br /><tt>Floats</tt> and <tt>doubles</tt> can only be returned via address pointer references.</p>

<p>アレイ型の戻り時は、アレイの要素数が既知でなければなりません。上記例では、3 要素の場合を示しています。<br />When returning array types the number of elements in the array must be known. The examples always assume 3 elements.</p>

<p>全ての pack と unpack はスペースの区切りを必要としませんが、例では読みやすくするためにスペースを入れています。<br />All pack and unpack and formats can also be given without spaces, but are spaced in the examples for better readability.</p>

<p><tt>"ld"</tt> と <tt>"lu"</tt> のフォーマットは交換可能ですが、符号無し16ビットからnewLISP の内部整数フォーマットの符号付き32ビットまたは64ビットへ符号拡張する時の符号拡張のために、16 ビット・フォーマットの <tt>"u"</tt> と <tt>"d"</tt> は異なる結果になるかもしれません。<br />The formats <tt>"ld"</tt> and <tt>"lu"</tt> are interchangeable, but the 16-bit formats <tt>"u"</tt> and <tt>"d"</tt> may produce different results, because of sign extension when going from unsigned 16 bits to signed 32 or 64-bits bits of newLISP's internal integer format.</p>

<blockquote>（訳例：例えば、0xFFFF を <tt>"d"</tt> で受け取ると -1、すなわち 0xFFFFFFFF になります。
<pre>
> (setq x "\xff\xff")
"\255\255"
> (unpack "d" x)
(-1)
> (format "%X" ((unpack "d" x) 0))
"FFFFFFFF"
> (unpack "u" x)
(65535)
> (format "%X" ((unpack "u" x) 0))
"FFFF"</pre>）</blockquote>

<p><tt>pack</tt> と <tt>unpack</tt> 間のバイト順（訳注：リトル・エンディアンとビック・エンディアン）を変更するのにフラグが使えます。<br />Flags are available for changing endian byte order during <tt>pack</tt> and <tt>unpack</tt>.</p>

<h3>Writing library wrappers（ライブラリ・ラッパーの書き方）</h3>

<p>newLISP 組込インポートの単純版では、たまにライブラリに使えないことがあります。これは、パラメータをスタック上で渡すことを想定している <tt>cdecl</tt> 呼出規約にライブラリが厳密に則していないこと起因します。例えば、インテルの CPU の代わりに 旧式の PPC CPU 上で動いている Mac OS X とか、Mac OS X 上でデフォルトで使えない OpenGL ライブラリとかがあります。<br />Sometimes the simple version of newLISP's built-in import facility cannot be used with a library. This happens whenever a library does not strictly adhere to <tt>cdecl</tt> calling conventions expecting all parameters passed on the stack. E.g. when running Mac OS X on older PPC CPUs instead of Intel CPUs, the OpenGL libraries installed by default on Mac OS X cannot be used.</p>

<p>10.4.0 版からの newLISP では、<tt>import</tt> の新しく追加した拡張構文を使うことで、この問題を簡単に解決できます。プラットフォームやアーキテクチャの違いを自動的に解決するからです。とても小さいシステムや必須の <tt>libffi</tt> システムが存在しないプラットフォームでは、newLISP が要求している <tt>cdecl</tt> 規約を目的のライブラリで要求されている呼出規約に翻訳する特殊なラッパー・ライブライを構築できます。<br />Since newLISP version 10.4.0, the problem can be solved easiest using the newer extended syntax of <tt>import</tt>, which automatically resolves platform and architectural differences. On very small systems or whenever the needed <tt>libffi</tt> system library is not present on a platform, a special wrapper library can be built to translate <tt>cdecl</tt> conventions expected by newLISP into the calling conventions expected by the target library.</p>

<pre>
/* wrapper.c - demo for wrapping library function
 
compile:
    gcc -m32 -shared wrapper.c -o wrapper.so
or:
    gcc -m32 -bundle wrapper.c -o wrapper.dylib
 
usage from newLISP:
 
    (import "./wrapper.dylib" "wrapperFoo")
 
    (define (glFoo x y z)
        (get-float (wrapperFoo 5 (float x) (int y) (float z))) )
 
 (glFoo 1.2 3 1.4) =&gt; 7.8
 
*/
 
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
 
 
/* the glFoo() function would normally live in the library to be
   wrapped, e.g. libopengl.so or libopengl.dylib, and this
   program would link to it.
   For demo and test purpose the function has been included in this
   file
*/
 
double glFoo(double x, int y, double z)
    {
    double result;
 
    result = (x + z) * y;
 
    return(result);
    }
 
/* this is the wrapper for glFoo which gets imported by newLISP
   declaring it as a va-arg function guarantees 'cdecl'
   calling conventions on most architectures
*/
 
double * wrapperFoo(int argc, ...)
    {
    va_list ap;
    double x, z;
    static double result;
    int y;
 
    va_start(ap, argc);
 
    x = va_arg(ap, double);
    y = va_arg(ap, int);
    z = va_arg(ap, double);
 
    va_end(ap);
 
    result = glFoo(x, y, z);
    return(&amp;result);
    }
 
/* eof */
</pre>

<h3>Registering callbacks in external libraries（外部ライブラリへのコールバックの登録）</h3>

<p>多くの共有ライブラリは、制御しているプロクラムにコールバックするコールバック関数の登録を許しています。newLISP では、ユーザ定義関数から関数アドレスを取り出し、外部ライブラリに登録関数として渡すために関数 <tt>callback</tt> を使います：<br />Many shared libraries allow registering callback functions to
call back into the controlling program. The function <tt>callback</tt>
is used in newLISP to extract the function address from a user-defined
newLISP function and pass it to the external library via a registering
function:</p>

<pre>
(define (keyboard key x y)
    (if (= (&amp; key 0xFF) 27) (exit)) ; exit program with ESC
    (println "key:" (&amp; key 0xFF) " x:" x  " y:" y))

(glutKeyboardFunc (callback 1 'keyboard))
</pre>

<p>例は、配布ソースの <tt>newlisp-x.x.x/examples/</tt> ディレクトリにある <tt>opengl-demo.lsp</tt> ファイルの一部です。Windows プラットフォームでのコールバックをデモする <tt>win32demo.lsp</tt> ファイルは同じディレクトリで見つけられます。<br />The example is a snippet from the file <tt>opengl-demo.lsp</tt> in
the <tt>newlisp-x.x.x/examples/</tt> directory of the source distribution.
A file <tt>win32demo.lsp</tt> can be found in the same directory demonstrating callbacks on the Windows platform.</p>

<p>C の型指定子を使った <tt>callback</tt> の先進的な構文は<a href=http://www.newlisp.org/newlisp_manual-jp.html">newLISP ユーザー マニュアルとリファレンス</a>を見て下さい。<br />For an advanced syntax of <tt>callback</tt> using C-type specifiers see <a href="http://www.newlisp.org/newlisp_manual.html">newLISP User Manual and Reference</a>.
</p>

<br/><center>&sect;</center><br/>

<a name="toc-24"></a>
<h2>24. newLISP as a shared library（共有ライブラリとしての newLISP）</h2>

<p>全てのプラットフォームで newLISP を共有ライブラリとしてコンパイル可能です。Win32 のライブラリは <tt>newlisp.dll</tt> と呼ばれ、macOS では <tt>newlisp.dylib</tt>、Linux や BSD では <tt>newlisp.so</tt> となります。ほとんどのプラットフォームの Makefile が配布ソースに含まれています。Win32 だけは、インストーラに予めコンパイルされている <tt>newlisp.dll</tt> が入っており、<tt>Program Files/newlisp/</tt>（訳注：デフォルトのインストール先、インストール時に変更すれば、変更先）にインストールされます。<br />On all platforms, newLISP can be compiled as a shared library. On Win32, the library
is called <tt>newlisp.dll</tt>, on macOS <tt>newlisp.dylib</tt> and on Linux and
BSDs, the library is called <tt>newlisp.so</tt>. Makefiles are included in the source 
distribution for most platforms. Only on Win32, the installer comes with a precompiled 
<tt>newlisp.dll</tt> and will install it in the <tt>Program Files/newlisp/</tt> directory.</p>

<h3>Evaluating code in the shared library（共有ライブラリでコードを評価）</h3>

<p>最初の例で、newLISP から <tt>newlispEvalStr</tt> を導入するやり方を示します：<br />The first example shows how to import <tt>newlispEvalStr</tt> from newLISP 
itself as the caller:</p>

<pre>
(import "/usr/lib/newlisp.so" "newlispEvalStr")
(get-string (newlispEvalStr "(+ 3 4)")) &rarr;  "7\n"
</pre>

<p>ライブラリ関数 <tt>newlispEvalStr</tt> を呼び出すと、通常コンソールに直接出力され、文字列の整数ポインタの形式で返されます。このポインタを関数<tt>get-string</tt> に渡すことで出力にアクセスできるようになります。戻り値の出力を黙らせるには、関数<tt>silent</tt> を使います。全ての結果は、数値であっても、インターラクティブ・コンソール・モード上でラインフィードを付加した文字列として返されます。文字列から他のデータ型に変換するには、関数<tt>int</tt> または <tt>float</tt> を使います。<br />When calling the library function <tt>newlispEvalStr</tt>, output normally 
directed to the console (e.g. return values or print statements) is returned 
in the form of an integer string pointer. The output can be accessed by passing 
this pointer to the <tt>get-string</tt> function. To silence the output from 
return values, use the <tt>silent</tt> function. All Results, even if they are 
numbers, are always returned as strings and a trailing linefeed as in interactive 
console mode. Use the <tt>int</tt> or <tt>float</tt> functions to convert the
strings to other data types.</p>

<p><tt>newlispEvalStr</tt>に複数行を渡す時は、ソースを <tt>[cmd]</tt>, <tt>[/cmd]</tt> タグで囲って下さい。その際、<tt>[cmd]</tt>, <tt>[/cmd]</tt>タグは、それぞれ別々の行にします：<br />When passing multi-line source to <tt>newlispEvalStr</tt>, that source should be 
bracketed by <tt>[cmd]</tt>, <tt>[/cmd]</tt> tags, each on a different line:</p>

<pre>
(set 'code [text][cmd]
...
...
...
[/cmd][/text])
</pre>

<p>二番目の例は、C のプログラムに <tt>newlispEvalStr</tt> を導入するやり方です：<br />The second example shows how to import <tt>newlispEvalStr</tt> into a
C-program:</p>

<pre>
/* libdemo.c - demo for importing newlisp.so
 * 
 * compile using: 
 *    gcc -ldl libdemo.c -o libdemo
 *
 * use:
 *
 *    ./libdemo '(+ 3 4)'
 *    ./libdemo '(symbols)'
 *
 */
#include &lt;stdio.h&gt;
#include &lt;dlfcn.h&gt;
 
int main(int argc, char * argv[])
{
void * hLibrary;
char * result;
char * (*func)(char *);
char * error;
 
if((hLibrary = dlopen("/usr/lib/newlisp.so",
                       RTLD_GLOBAL | RTLD_LAZY)) == 0)
    {
    printf("cannot import library\n");
    exit(-1);
    }
 
func = dlsym(hLibrary, "newlispEvalStr");
if((error = dlerror()) != NULL)
    {
    printf("error: %s\n", error);
    exit(-1);
    }
 
printf("%s\n", (*func)(argv[1]));
 
return(0);
}

/* eof */
</pre>

<p>このプログラムは引用された newLISP の式を受け付け、評価結果を出力します。<br />This program will accept quoted newLISP expressions and print the evaluated results.</p>

<h3>Registering callbacks（コールバックの登録）</h3>

<p>他の共有ライブラリ同様、コールバックを newLISP ライブラリに登録可能です。関数<tt>newlispCallback</tt> を導入すれば、関数のコールバック登録に使えます。
例では、newLISP に newLISP ライブラリを導入して、コールバック <tt>callme</tt> を登録しています：<br />Like many other share libraries, callbacks can be registered in newLISP library.
The function <tt>newlispCallback</tt> must be imported and is used for registering
callback functions. The example shows newLISP importing newLISP as a library and
registering a callback <tt>callme</tt>:</p>

<pre>
#!/usr/bin/newlisp

; path-name of the library depending on platform
(set 'LIBRARY (if (= ostype "Windows") "newlisp.dll" "newlisp.dylib"))

; import functions from the newLISP shared library
(import LIBRARY "newlispEvalStr")
(import LIBRARY "newlispCallback")

; set calltype platform specific
(set 'CALLTYPE (if (= ostype "Windows") "stdcall" "cdecl"))

; the callback function
(define (callme p1 p2 p3 result)
    (println "p1 =&gt; " p1 " p2 =&gt; " p2 " p3 =&gt; " p3)
    result)

; register the callback with newLISP library
(newlispCallback "callme" (callback 0 'callme) CALLTYPE)

; the callback returns a string
(println (get-string (newlispEvalStr
    {(get-string (callme 123 456 789 "hello world"))})))

; the callback returns a number
(println (get-string (newlispEvalStr
    {(callme 123 456 789 99999)})))
</pre>

<p>戻り値の型によって、コードを変えています。このプログラムは、次のように出力します：<br />Depending on the type of the return value, different code is used. The program shows the following output:</p>

<pre>
p1 =&gt; 123 p2 =&gt; 456 p3 =&gt; 789
"hello world"

p1 =&gt; 123 p2 =&gt; 456 p3 =&gt; 789
99999
</pre>

<p>Win32 や 多くの Unix は <tt>newlisp.dll</tt>（訳注：Unix では、<tt>newlisp.so</tt>）をシステム・ライブラリ・パスで探しますが、macOS はフル・パスが指定されていないと、<tt>newlisp.dylib</tt> を最初に現行ディレクトリで探すことに注意してください。これ以外のプログラムは、配布ソースの<tt>newlisp-x.x.x/examples</tt> ディレクトリで <tt>callback</tt> として見つかります。<br />Note that Win32 and many Unix flavors will look for <tt>newlisp.dll</tt> in the system library path, but macOS will look for <tt>newlisp.dylib</tt> first in the current directory, if the full file path is not specified. The program above can also be found as <tt>callback</tt> in the source distribution in the <tt>newlisp-x.x.x/examples</tt> directory.</p>


<br><center>&sect;</center><br><hr/><br>

<a NAME="appendix"></a>
<a NAME="GFDL"></a>
<center>
<h2><font color="#EE0000">GNU Free Documentation License</font></h2>
<p>Version 1.2, November 2002</p>

<p>
Copyright (C) 2000,2001,2002  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.</p>
</center>

<br><br>

<b>0. PREAMBLE</b>

<p>The purpose of this License is to make a manual, textbook, or other
functional and useful document "free" in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.
</p>
<p>This License is a kind of "copyleft", which means that derivative
works of the document must themselves be free in the same sense. It
complements the GNU General Public License, which is a copyleft
license designed for free software.
</p>
<p>We have designed this License in order to use it for manuals for
free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does. But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book. We recommend this License
principally for works whose purpose is instruction or reference.
</p>
<p><b>1. APPLICABILITY AND DEFINITIONS</b>
</p>
<p>This License applies to any manual or other work, in any medium,
that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License. Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein. The "Document", below,
refers to any such manual or work. Any member of the public is a
licensee, and is addressed as "you". You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.
</p>
<p>A "Modified Version" of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.
</p>
<p>A "Secondary Section" is a named appendix or a front-matter section
of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject. (Thus, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.) The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.
</p>
<p>The "Invariant Sections" are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License. If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant. The Document may contain zero
Invariant Sections. If the Document does not identify any Invariant
Sections then there are none.
</p>
<p>The "Cover Texts" are certain short passages of text that are
listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License. A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.
</p>
<p>A "Transparent" copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters. A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text. A copy that is not "Transparent" is called "Opaque".
</p>
<p>Examples of suitable formats for Transparent copies include plain
ASCII without markup, Texinfo input format, LaTeX input format, SGML
or XML using a publicly available DTD, and standard-conforming simple
HTML, PostScript or PDF designed for human modification. Examples of
transparent image formats include PNG, XCF and JPG. Opaque formats
include proprietary formats that can be read and edited only by
proprietary word processors, SGML or XML for which the DTD and/or
processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.
</p>
<p>The "Title Page" means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page. For works in
formats which do not have any title page as such, "Title Page" means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.
</p>
<p>A section "Entitled XYZ" means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language. (Here XYZ stands for a
specific section name mentioned below, such as "Acknowledgements",
"Dedications", "Endorsements", or "History".) To "Preserve the Title"
of such a section when you modify the Document means that it remains a
section "Entitled XYZ" according to this definition.
</p>
<p>The Document may include Warranty Disclaimers next to the notice
which
states that this License applies to the Document. These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.
</p>
<p><b>2. VERBATIM COPYING</b>
</p>
<p>You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License. You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute. However, you may accept
compensation in exchange for copies. If you distribute a large enough
number of copies you must also follow the conditions in section 3.
</p>
<p>You may also lend copies, under the same conditions stated above,
and
you may publicly display copies.
</p>
<p><b>3. COPYING IN QUANTITY</b>
</p>
<p>If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover. Both covers must also clearly and legibly identify
you as the publisher of these copies. The front cover must present
the full title with all words of the title equally prominent and
visible. You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.
</p>
<p>If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.
</p>
<p>If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.
</p>
<p>It is requested, but not required, that you contact the authors of
the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.
</p>
<p><b>4. MODIFICATIONS</b>
</p>
<p>You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it. In addition, you must do these things in the Modified Version:
</p>
<ul>
  <li><b>A.</b> Use in the Title Page (and on the covers, if
any) a title distinct from that of the Document, and from those of
previous versions (which should, if there were any, be listed in the
History section of the Document). You may use the same title as a
previous version if the original publisher of that version gives
permission.
  </li>
  <li><b>B.</b> List on the Title Page, as authors, one or
more persons or entities responsible for authorship of the
modifications in the Modified Version, together with at least five of
the principal authors of the Document (all of its principal authors, if
it has fewer than five), unless they release you from this requirement.
  </li>
  <li><b>C.</b> State on the Title page the name of the
publisher of the Modified Version, as the publisher.
  </li>
  <li><b>D.</b> Preserve all the copyright notices of the
Document.
  </li>
  <li><b>E.</b> Add an appropriate copyright notice for your
modifications adjacent to the other copyright notices.
  </li>
  <li><b>F.</b> Include, immediately after the copyright
notices, a license notice giving the public permission to use the
Modified Version under the terms of this License, in the form shown in
the Addendum below.
  </li>
  <li><b>G.</b> Preserve in that license notice the full
lists of Invariant Sections and required Cover Texts given in the
Document's license notice.
  </li>
  <li><b>H.</b> Include an unaltered copy of this License.
  </li>
  <li><b>I.</b> Preserve the section Entitled "History",
Preserve its Title, and add to it an item stating at least the title,
year, new authors, and publisher of the Modified Version as given on
the Title Page. If there is no section Entitled "History" in the
Document, create one stating the title, year, authors, and publisher of
the Document as given on its Title Page, then add an item describing
the Modified Version as stated in the previous sentence.
  </li>
  <li><b>J.</b> Preserve the network location, if any, given
in the Document for public access to a Transparent copy of the
Document, and likewise the network locations given in the Document for
previous versions it was based on. These may be placed in the "History"
section. You may omit a network location for a work that was published
at least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.
  </li>
  <li><b>K.</b> For any section Entitled "Acknowledgements"
or "Dedications", Preserve the Title of the section, and preserve in
the section all the substance and tone of each of the contributor
acknowledgements and/or dedications given therein.
  </li>
  <li><b>L.</b> Preserve all the Invariant Sections of the
Document, unaltered in their text and in their titles. Section numbers
or the equivalent are not considered part of the section titles.
  </li>
  <li><b>M.</b> Delete any section Entitled "Endorsements".
Such a section may not be included in the Modified Version.
  </li>
  <li><b>N.</b> Do not retitle any existing section to be
Entitled "Endorsements" or to conflict in title with any Invariant
Section.
  </li>
  <li><b>O.</b> Preserve any Warranty Disclaimers.
  </li>
</ul>
<p>
If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant. To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.
</p>
<p>You may add a section Entitled "Endorsements", provided it contains
nothing but endorsements of your Modified Version by various
parties--for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.
</p>
<p>You may add a passage of up to five words as a Front-Cover Text, and
a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version. Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity. If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.
</p>
<p>The author(s) and publisher(s) of the Document do not by this
License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.
</p>
<p><b>5. COMBINING DOCUMENTS</b>
</p>
<p>You may combine the Document with other documents released under
this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.
</p>
<p>The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy. If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.
</p>
<p>In the combination, you must combine any sections Entitled "History"
in the various original documents, forming one section Entitled
"History"; likewise combine any sections Entitled "Acknowledgements",
and any sections Entitled "Dedications". You must delete all sections
Entitled "Endorsements."
</p>
<p><b>6. COLLECTIONS OF DOCUMENTS</b>
</p>
<p>You may make a collection consisting of the Document and other
documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.
</p>
<p>You may extract a single document from such a collection, and
distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.
</p>
<p><b>7. AGGREGATION WITH INDEPENDENT WORKS</b>
</p>
<p>A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an "aggregate" if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.
</p>
<p>If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.
</p>
<p><b>8. TRANSLATION</b>
</p>
<p>Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections. You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers. In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.
</p>
<p>If a section in the Document is Entitled "Acknowledgements",
"Dedications", or "History", the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.
</p>
<p><b>9. TERMINATION</b>
</p>
<p>You may not copy, modify, sublicense, or distribute the Document
except
as expressly provided for under this License. Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License. However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.
</p>
<p><b>10. FUTURE REVISIONS OF THIS LICENSE</b>
</p>
<p>The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns. See
http://www.gnu.org/copyleft/.
</p>
<p>Each version of the License is given a distinguishing version
number.
If the Document specifies that a particular numbered version of this
License "or any later version" applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation. If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
</p>

<center>&part;</center>

</body>
</html>

